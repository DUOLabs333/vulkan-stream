
#include <debug.hpp>
#include <boost/json.hpp>
#include <ThreadStruct.hpp>
#include <stdexcept>
#include <shared_mutex>
#include <future>
#include "vk_enum_string_helper.h"

#include <vulkan/vulkan.h>

#include <Serialization.hpp>
#include <Server.hpp>
#include <Synchronization.hpp>

#ifdef CLIENT
    #include <Surface.hpp>
    
    std::map<uintptr_t, VkDeviceSize> devicememory_to_size;
    void registerDeviceMemory(VkDeviceMemory memory, VkDeviceSize size){
        devicememory_to_size[(uintptr_t)memory]=size;
    }
#endif

typedef std::shared_mutex Lock;

Lock MemoryMapLock;
Lock MemoryOperationLock; //This is not needed (but may be preferred, at the expense of unneccessary locking)

#ifndef CLIENT

#ifdef __APPLE__
    std::string vulkan_library_name="libvulkan.dylib";
#endif
#include <dlfcn.h>
auto vulkan_library=dlopen(vulkan_library_name.c_str(), RTLD_LAZY | RTLD_GLOBAL);
auto get_instance_proc_addr=(PFN_vkGetInstanceProcAddr)dlsym(vulkan_library,"vkGetInstanceProcAddr");
auto get_device_proc_addr=(PFN_vkGetDeviceProcAddr)dlsym(vulkan_library,"vkGetDeviceProcAddr");


    void handle_vkCreateInstance(boost::json::object& json){
    //Will only be called by the server
    
VkInstanceCreateInfo* pCreateInfo;
[&](){ VkInstanceCreateInfo* temp_abtPaMc[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_abtPaMc=NULL;
            return; }temp_abtPaMc=(VkInstanceCreateInfo*)malloc(1*sizeof(VkInstanceCreateInfo));
        auto& arr_KMjnDnU=json["pCreateInfo"].as_array();
        for(int tBToPhv=0; tBToPhv < 1; tBToPhv++){
            [&](){
            auto& temp=arr_KMjnDnU[tBToPhv].as_object();
            deserialize_struct(temp,temp_abtPaMc[tBToPhv]);
            }();
        }
        }();pCreateInfo=temp_abtPaMc;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkInstance* pInstance;
[&](){
            if (json["pInstance"].as_array().size()==0){
                pInstance=NULL;
            return; }pInstance=(VkInstance*)malloc(1*sizeof(VkInstance));
        auto& arr_GanofFb=json["pInstance"].as_array();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){deserialize_VkInstance(arr_GanofFb[ErvKwSS], pInstance[ErvKwSS]);}();
        }
        }();

    PFN_vkCreateInstance call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateInstance)get_instance_proc_addr(parent,"vkCreateInstance");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateInstance)get_device_proc_addr(parent,"vkCreateInstance");
    }  
    
{


        VkInstanceCreateInfo* temp_info=pCreateInfo;

        VkInstanceCreateInfo* pCreateInfo=temp_info;

        //Instead, copy to a set, do modification, then copy it back
        
        std::set<std::string> extensions_set;
        
        for(int i=0; i< pCreateInfo->enabledExtensionCount; i++){
            extensions_set.insert(std::string(pCreateInfo->ppEnabledExtensionNames[i]));
        }
        #ifdef VK_USE_PLATFORM_METAL_EXT
            extensions_set.erase(std::string("VK_KHR_xcb_surface"));
            extensions_set.erase(std::string("VK_KHR_xlib_surface"));
        #endif
        
        extensions_set.insert(std::string(VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME));
        //extensions_set.insert(std::string(VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME));
        extensions_set.insert(std::string(VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME));
        extensions_set.insert(std::string(VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME));
        
        auto extensions_length=extensions_set.size();
        auto extensions_list=(char **)malloc(extensions_length*sizeof(char*));
        
        int i=0;
        for (auto& elem: extensions_set){
            extensions_list[i]=strdup(elem.c_str());
            i++;
        }
        
        for (int i=0; i< extensions_length; i++){
            debug_printf("Final extension: %s\n",extensions_list[i]);
        }

        pCreateInfo->ppEnabledExtensionNames=extensions_list;
        pCreateInfo->enabledExtensionCount=extensions_length;            
        
auto result=call_function(pCreateInfo, pAllocator, pInstance);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_yCteunD=json["pCreateInfo"].emplace_array();
        for(int pSiEPar=0; pSiEPar < 1; pSiEPar++){
            [&](){
            auto& temp=arr_yCteunD[pSiEPar].emplace_object();
            return serialize_struct(temp, pCreateInfo[pSiEPar]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pInstance==NULL){
                json["pInstance"]=boost::json::array();
            return; }
        auto& arr_GanofFb=json["pInstance"].emplace_array();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){serialize_VkInstance(arr_GanofFb[ErvKwSS],pInstance[ErvKwSS]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyInstance(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyInstance call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyInstance)get_instance_proc_addr(parent,"vkDestroyInstance");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyInstance)get_device_proc_addr(parent,"vkDestroyInstance");
    }  
    
{
call_function(instance, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkEnumeratePhysicalDevices(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
uint32_t* pPhysicalDeviceCount;
[&](){
            if (json["pPhysicalDeviceCount"].as_array().size()==0){
                pPhysicalDeviceCount=NULL;
            return; }pPhysicalDeviceCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].as_array();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(value_to<int>(arr_ngpFKeB[TRqNryD]));}();
        }
        }();
VkPhysicalDevice* pPhysicalDevices;
[&](){
            if (json["pPhysicalDevices"].as_array().size()==0){
                pPhysicalDevices=NULL;
            return; }pPhysicalDevices=(VkPhysicalDevice*)malloc(*pPhysicalDeviceCount*sizeof(VkPhysicalDevice));
        auto& arr_ZSQNUNc=json["pPhysicalDevices"].as_array();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){deserialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY], pPhysicalDevices[ChMMltY]);}();
        }
        }();

    PFN_vkEnumeratePhysicalDevices call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumeratePhysicalDevices)get_instance_proc_addr(parent,"vkEnumeratePhysicalDevices");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumeratePhysicalDevices)get_device_proc_addr(parent,"vkEnumeratePhysicalDevices");
    }  
    
{
auto result=call_function(instance, pPhysicalDeviceCount, pPhysicalDevices);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceCount==NULL){
                json["pPhysicalDeviceCount"]=boost::json::array();
            return; }
        auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].emplace_array();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){arr_ngpFKeB[TRqNryD]=pPhysicalDeviceCount[TRqNryD];}();
        }
        }();
[&](){
            if (pPhysicalDevices==NULL){
                json["pPhysicalDevices"]=boost::json::array();
            return; }
        auto& arr_ZSQNUNc=json["pPhysicalDevices"].emplace_array();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){serialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY],pPhysicalDevices[ChMMltY]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceProcAddr(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
char* pName;
[&](){ char* temp_sjnYeTb[&](){
            if (json["pName"].as_array().size()==0){
                temp_sjnYeTb=NULL;
            return; }temp_sjnYeTb=(char*)malloc(json["pName"].as_array().size()*sizeof(char));
        auto& arr_OBaQazs=json["pName"].as_array();
        for(int eoosrrl=0; eoosrrl < json["pName"].as_array().size(); eoosrrl++){
            [&](){temp_sjnYeTb[eoosrrl]=static_cast<char>(value_to<int>(arr_OBaQazs[eoosrrl]));}();
        }
        }();pName=temp_sjnYeTb;}();

    PFN_vkGetDeviceProcAddr call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceProcAddr)get_instance_proc_addr(parent,"vkGetDeviceProcAddr");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceProcAddr)get_device_proc_addr(parent,"vkGetDeviceProcAddr");
    }  
    
{
auto result=call_function(device, pName);
}
json.clear();
json["result"]=(uintptr_t)result;
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pName==NULL){
                json["pName"]=boost::json::array();
            return; }
        auto& arr_XCtfitt=json["pName"].emplace_array();
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=pName[EZmXTUp];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetInstanceProcAddr(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
char* pName;
[&](){ char* temp_sjnYeTb[&](){
            if (json["pName"].as_array().size()==0){
                temp_sjnYeTb=NULL;
            return; }temp_sjnYeTb=(char*)malloc(json["pName"].as_array().size()*sizeof(char));
        auto& arr_OBaQazs=json["pName"].as_array();
        for(int eoosrrl=0; eoosrrl < json["pName"].as_array().size(); eoosrrl++){
            [&](){temp_sjnYeTb[eoosrrl]=static_cast<char>(value_to<int>(arr_OBaQazs[eoosrrl]));}();
        }
        }();pName=temp_sjnYeTb;}();

    PFN_vkGetInstanceProcAddr call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetInstanceProcAddr)get_instance_proc_addr(parent,"vkGetInstanceProcAddr");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetInstanceProcAddr)get_device_proc_addr(parent,"vkGetInstanceProcAddr");
    }  
    
{
auto result=call_function(instance, pName);
}
debug_printf("Getting %s\n",pName);
json.clear();
json["result"]=(uintptr_t)result;
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pName==NULL){
                json["pName"]=boost::json::array();
            return; }
        auto& arr_XCtfitt=json["pName"].emplace_array();
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=pName[EZmXTUp];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceProperties* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkPhysicalDeviceProperties*)malloc(1*sizeof(VkPhysicalDeviceProperties));
        auto& arr_rSttUuQ=json["pProperties"].as_array();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto& temp=arr_rSttUuQ[RBAofpr].as_object();
            deserialize_struct(temp,pProperties[RBAofpr]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceProperties");
    }  
    
{
call_function(physicalDevice, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_rSttUuQ=json["pProperties"].emplace_array();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto& temp=arr_rSttUuQ[RBAofpr].emplace_object();
            return serialize_struct(temp, pProperties[RBAofpr]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceQueueFamilyProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pQueueFamilyPropertyCount;
[&](){
            if (json["pQueueFamilyPropertyCount"].as_array().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }pQueueFamilyPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].as_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(value_to<int>(arr_tzRlmPf[cPKCUxv]));}();
        }
        }();
VkQueueFamilyProperties* pQueueFamilyProperties;
[&](){
            if (json["pQueueFamilyProperties"].as_array().size()==0){
                pQueueFamilyProperties=NULL;
            return; }pQueueFamilyProperties=(VkQueueFamilyProperties*)malloc(*pQueueFamilyPropertyCount*sizeof(VkQueueFamilyProperties));
        auto& arr_ixxluvk=json["pQueueFamilyProperties"].as_array();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto& temp=arr_ixxluvk[WYdxXmB].as_object();
            deserialize_struct(temp,pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceQueueFamilyProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties");
    }  
    
{
call_function(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=boost::json::array();
            return; }
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].emplace_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=pQueueFamilyPropertyCount[cPKCUxv];}();
        }
        }();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=boost::json::array();
            return; }
        auto& arr_ixxluvk=json["pQueueFamilyProperties"].emplace_array();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto& temp=arr_ixxluvk[WYdxXmB].emplace_object();
            return serialize_struct(temp, pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceMemoryProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceMemoryProperties* pMemoryProperties;
[&](){
            if (json["pMemoryProperties"].as_array().size()==0){
                pMemoryProperties=NULL;
            return; }pMemoryProperties=(VkPhysicalDeviceMemoryProperties*)malloc(1*sizeof(VkPhysicalDeviceMemoryProperties));
        auto& arr_cVJWqPt=json["pMemoryProperties"].as_array();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto& temp=arr_cVJWqPt[iqfYjRc].as_object();
            deserialize_struct(temp,pMemoryProperties[iqfYjRc]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceMemoryProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties");
    }  
    
{
call_function(physicalDevice, pMemoryProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=boost::json::array();
            return; }
        auto& arr_cVJWqPt=json["pMemoryProperties"].emplace_array();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto& temp=arr_cVJWqPt[iqfYjRc].emplace_object();
            return serialize_struct(temp, pMemoryProperties[iqfYjRc]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFeatures(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceFeatures* pFeatures;
[&](){
            if (json["pFeatures"].as_array().size()==0){
                pFeatures=NULL;
            return; }pFeatures=(VkPhysicalDeviceFeatures*)malloc(1*sizeof(VkPhysicalDeviceFeatures));
        auto& arr_MNJcbZO=json["pFeatures"].as_array();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto& temp=arr_MNJcbZO[IqPoadP].as_object();
            deserialize_struct(temp,pFeatures[IqPoadP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFeatures call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFeatures)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFeatures");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFeatures)get_device_proc_addr(parent,"vkGetPhysicalDeviceFeatures");
    }  
    
{
call_function(physicalDevice, pFeatures);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=boost::json::array();
            return; }
        auto& arr_MNJcbZO=json["pFeatures"].emplace_array();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto& temp=arr_MNJcbZO[IqPoadP].emplace_object();
            return serialize_struct(temp, pFeatures[IqPoadP]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFormatProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
VkFormatProperties* pFormatProperties;
[&](){
            if (json["pFormatProperties"].as_array().size()==0){
                pFormatProperties=NULL;
            return; }pFormatProperties=(VkFormatProperties*)malloc(1*sizeof(VkFormatProperties));
        auto& arr_ktGodop=json["pFormatProperties"].as_array();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto& temp=arr_ktGodop[CLkwuSw].as_object();
            deserialize_struct(temp,pFormatProperties[CLkwuSw]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFormatProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties");
    }  
    
{
call_function(physicalDevice, format, pFormatProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=boost::json::array();
            return; }
        auto& arr_ktGodop=json["pFormatProperties"].emplace_array();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto& temp=arr_ktGodop[CLkwuSw].emplace_object();
            return serialize_struct(temp, pFormatProperties[CLkwuSw]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceImageFormatProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
VkImageType type;
[&](){[&](){int temp_bMZuPlo;[&](){temp_bMZuPlo=static_cast<int>(value_to<int>(json["type"]));}();type=(VkImageType)temp_bMZuPlo;}();}();
VkImageTiling tiling;
[&](){[&](){int temp_PtqdPDE;[&](){temp_PtqdPDE=static_cast<int>(value_to<int>(json["tiling"]));}();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
VkImageUsageFlags usage;
[&](){[&](){int temp_sXuQFYv;[&](){temp_sXuQFYv=static_cast<int>(value_to<int>(json["usage"]));}();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
VkImageCreateFlags flags;
[&](){[&](){int temp_LpOHWxp;[&](){temp_LpOHWxp=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
VkImageFormatProperties* pImageFormatProperties;
[&](){
            if (json["pImageFormatProperties"].as_array().size()==0){
                pImageFormatProperties=NULL;
            return; }pImageFormatProperties=(VkImageFormatProperties*)malloc(1*sizeof(VkImageFormatProperties));
        auto& arr_sBgMBXU=json["pImageFormatProperties"].as_array();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto& temp=arr_sBgMBXU[hhYjZOs].as_object();
            deserialize_struct(temp,pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceImageFormatProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties");
    }  
    
{
auto result=call_function(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }
        auto& arr_sBgMBXU=json["pImageFormatProperties"].emplace_array();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto& temp=arr_sBgMBXU[hhYjZOs].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateDevice(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDeviceCreateInfo* pCreateInfo;
[&](){ VkDeviceCreateInfo* temp_BaoTgZc[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_BaoTgZc=NULL;
            return; }temp_BaoTgZc=(VkDeviceCreateInfo*)malloc(1*sizeof(VkDeviceCreateInfo));
        auto& arr_weWBoax=json["pCreateInfo"].as_array();
        for(int JAVPgPK=0; JAVPgPK < 1; JAVPgPK++){
            [&](){
            auto& temp=arr_weWBoax[JAVPgPK].as_object();
            deserialize_struct(temp,temp_BaoTgZc[JAVPgPK]);
            }();
        }
        }();pCreateInfo=temp_BaoTgZc;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkDevice* pDevice;
[&](){
            if (json["pDevice"].as_array().size()==0){
                pDevice=NULL;
            return; }pDevice=(VkDevice*)malloc(1*sizeof(VkDevice));
        auto& arr_WTIobJE=json["pDevice"].as_array();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){deserialize_VkDevice(arr_WTIobJE[okBORdn], pDevice[okBORdn]);}();
        }
        }();

    PFN_vkCreateDevice call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDevice)get_instance_proc_addr(parent,"vkCreateDevice");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDevice)get_device_proc_addr(parent,"vkCreateDevice");
    }  
    
{

        VkDeviceCreateInfo* temp_info=pCreateInfo;

        VkDeviceCreateInfo* pCreateInfo=temp_info;

        //Instead, copy to a set, do modification, then copy it back
        
        std::set<std::string> extensions_set;
        
        for(int i=0; i< pCreateInfo->enabledExtensionCount; i++){
            extensions_set.insert(std::string(pCreateInfo->ppEnabledExtensionNames[i]));
        }
        
        extensions_set.insert(std::string(VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME));
        
        auto extensions_length=extensions_set.size();
        auto extensions_list=(char **)malloc(extensions_length*sizeof(char*));
        
        int i=0;
        for (auto& elem: extensions_set){
            extensions_list[i]=strdup(elem.c_str());
            i++;
        }
        
        for (int i=0; i< extensions_length; i++){
            debug_printf("Final extension: %s\n",extensions_list[i]);
        }

        pCreateInfo->ppEnabledExtensionNames=extensions_list;
        pCreateInfo->enabledExtensionCount=extensions_length;            
        
auto result=call_function(physicalDevice, pCreateInfo, pAllocator, pDevice);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_TuuJAwt=json["pCreateInfo"].emplace_array();
        for(int Ktbkccz=0; Ktbkccz < 1; Ktbkccz++){
            [&](){
            auto& temp=arr_TuuJAwt[Ktbkccz].emplace_object();
            return serialize_struct(temp, pCreateInfo[Ktbkccz]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDevice==NULL){
                json["pDevice"]=boost::json::array();
            return; }
        auto& arr_WTIobJE=json["pDevice"].emplace_array();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){serialize_VkDevice(arr_WTIobJE[okBORdn],pDevice[okBORdn]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyDevice(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyDevice call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDevice)get_instance_proc_addr(parent,"vkDestroyDevice");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDevice)get_device_proc_addr(parent,"vkDestroyDevice");
    }  
    
{
call_function(device, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkEnumerateInstanceVersion(boost::json::object& json){
    //Will only be called by the server
    
uint32_t* pApiVersion;
[&](){
            if (json["pApiVersion"].as_array().size()==0){
                pApiVersion=NULL;
            return; }pApiVersion=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_qBCKjKo=json["pApiVersion"].as_array();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){pApiVersion[KJjQFCs]=static_cast<uint32_t>(value_to<int>(arr_qBCKjKo[KJjQFCs]));}();
        }
        }();

    PFN_vkEnumerateInstanceVersion call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateInstanceVersion)get_instance_proc_addr(parent,"vkEnumerateInstanceVersion");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateInstanceVersion)get_device_proc_addr(parent,"vkEnumerateInstanceVersion");
    }  
    
{
auto result=call_function(pApiVersion);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){
            if (pApiVersion==NULL){
                json["pApiVersion"]=boost::json::array();
            return; }
        auto& arr_qBCKjKo=json["pApiVersion"].emplace_array();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){arr_qBCKjKo[KJjQFCs]=pApiVersion[KJjQFCs];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkEnumerateInstanceLayerProperties(boost::json::object& json){
    //Will only be called by the server
    
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkLayerProperties* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkLayerProperties*)malloc(*pPropertyCount*sizeof(VkLayerProperties));
        auto& arr_AKGITwD=json["pProperties"].as_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].as_object();
            deserialize_struct(temp,pProperties[AVcpYdO]);
            }();
        }
        }();

    PFN_vkEnumerateInstanceLayerProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateInstanceLayerProperties)get_instance_proc_addr(parent,"vkEnumerateInstanceLayerProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateInstanceLayerProperties)get_device_proc_addr(parent,"vkEnumerateInstanceLayerProperties");
    }  
    
{
auto result=call_function(pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_AKGITwD=json["pProperties"].emplace_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].emplace_object();
            return serialize_struct(temp, pProperties[AVcpYdO]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkEnumerateInstanceExtensionProperties(boost::json::object& json){
    //Will only be called by the server
    
char* pLayerName;
[&](){ char* temp_qzFPgHh[&](){
            if (json["pLayerName"].as_array().size()==0){
                temp_qzFPgHh=NULL;
            return; }temp_qzFPgHh=(char*)malloc(json["pLayerName"].as_array().size()*sizeof(char));
        auto& arr_pwIbPmt=json["pLayerName"].as_array();
        for(int ybQeduD=0; ybQeduD < json["pLayerName"].as_array().size(); ybQeduD++){
            [&](){temp_qzFPgHh[ybQeduD]=static_cast<char>(value_to<int>(arr_pwIbPmt[ybQeduD]));}();
        }
        }();pLayerName=temp_qzFPgHh;}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkExtensionProperties* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkExtensionProperties*)malloc(*pPropertyCount*sizeof(VkExtensionProperties));
        auto& arr_yJzeHZb=json["pProperties"].as_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].as_object();
            deserialize_struct(temp,pProperties[oiKhvHw]);
            }();
        }
        }();

    PFN_vkEnumerateInstanceExtensionProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateInstanceExtensionProperties)get_instance_proc_addr(parent,"vkEnumerateInstanceExtensionProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateInstanceExtensionProperties)get_device_proc_addr(parent,"vkEnumerateInstanceExtensionProperties");
    }  
    
{
auto result=call_function(pLayerName, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=boost::json::array();
            return; }
        auto& arr_xWfwWBl=json["pLayerName"].emplace_array();
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=pLayerName[EYxuOlw];}();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_yJzeHZb=json["pProperties"].emplace_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].emplace_object();
            return serialize_struct(temp, pProperties[oiKhvHw]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkEnumerateDeviceLayerProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkLayerProperties* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkLayerProperties*)malloc(*pPropertyCount*sizeof(VkLayerProperties));
        auto& arr_AKGITwD=json["pProperties"].as_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].as_object();
            deserialize_struct(temp,pProperties[AVcpYdO]);
            }();
        }
        }();

    PFN_vkEnumerateDeviceLayerProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateDeviceLayerProperties)get_instance_proc_addr(parent,"vkEnumerateDeviceLayerProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateDeviceLayerProperties)get_device_proc_addr(parent,"vkEnumerateDeviceLayerProperties");
    }  
    
{
auto result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_AKGITwD=json["pProperties"].emplace_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].emplace_object();
            return serialize_struct(temp, pProperties[AVcpYdO]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkEnumerateDeviceExtensionProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
char* pLayerName;
[&](){ char* temp_qzFPgHh[&](){
            if (json["pLayerName"].as_array().size()==0){
                temp_qzFPgHh=NULL;
            return; }temp_qzFPgHh=(char*)malloc(json["pLayerName"].as_array().size()*sizeof(char));
        auto& arr_pwIbPmt=json["pLayerName"].as_array();
        for(int ybQeduD=0; ybQeduD < json["pLayerName"].as_array().size(); ybQeduD++){
            [&](){temp_qzFPgHh[ybQeduD]=static_cast<char>(value_to<int>(arr_pwIbPmt[ybQeduD]));}();
        }
        }();pLayerName=temp_qzFPgHh;}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkExtensionProperties* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkExtensionProperties*)malloc(*pPropertyCount*sizeof(VkExtensionProperties));
        auto& arr_yJzeHZb=json["pProperties"].as_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].as_object();
            deserialize_struct(temp,pProperties[oiKhvHw]);
            }();
        }
        }();

    PFN_vkEnumerateDeviceExtensionProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateDeviceExtensionProperties)get_instance_proc_addr(parent,"vkEnumerateDeviceExtensionProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateDeviceExtensionProperties)get_device_proc_addr(parent,"vkEnumerateDeviceExtensionProperties");
    }  
    
{
auto result=call_function(physicalDevice, pLayerName, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=boost::json::array();
            return; }
        auto& arr_xWfwWBl=json["pLayerName"].emplace_array();
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=pLayerName[EYxuOlw];}();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_yJzeHZb=json["pProperties"].emplace_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].emplace_object();
            return serialize_struct(temp, pProperties[oiKhvHw]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceQueue(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t queueFamilyIndex;
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
uint32_t queueIndex;
[&](){queueIndex=static_cast<uint32_t>(value_to<int>(json["queueIndex"]));}();
VkQueue* pQueue;
[&](){
            if (json["pQueue"].as_array().size()==0){
                pQueue=NULL;
            return; }pQueue=(VkQueue*)malloc(1*sizeof(VkQueue));
        auto& arr_rYZbcEA=json["pQueue"].as_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

    PFN_vkGetDeviceQueue call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceQueue)get_instance_proc_addr(parent,"vkGetDeviceQueue");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceQueue)get_device_proc_addr(parent,"vkGetDeviceQueue");
    }  
    
{
call_function(device, queueFamilyIndex, queueIndex, pQueue);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){json["queueIndex"]=queueIndex;}();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=boost::json::array();
            return; }
        auto& arr_rYZbcEA=json["pQueue"].emplace_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkQueueSubmit(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t submitCount;
[&](){submitCount=static_cast<uint32_t>(value_to<int>(json["submitCount"]));}();
VkSubmitInfo* pSubmits;
[&](){ VkSubmitInfo* temp_xTlWHqk[&](){
            if (json["pSubmits"].as_array().size()==0){
                temp_xTlWHqk=NULL;
            return; }temp_xTlWHqk=(VkSubmitInfo*)malloc(submitCount*sizeof(VkSubmitInfo));
        auto& arr_TcbTpKH=json["pSubmits"].as_array();
        for(int XjgvzRX=0; XjgvzRX < submitCount; XjgvzRX++){
            [&](){
            auto& temp=arr_TcbTpKH[XjgvzRX].as_object();
            deserialize_struct(temp,temp_xTlWHqk[XjgvzRX]);
            }();
        }
        }();pSubmits=temp_xTlWHqk;}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkQueueSubmit call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueSubmit)get_instance_proc_addr(parent,"vkQueueSubmit");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueSubmit)get_device_proc_addr(parent,"vkQueueSubmit");
    }  
    
{
auto result=call_function(queue, submitCount, pSubmits, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=submitCount;}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=boost::json::array();
            return; }
        auto& arr_kYcwgKD=json["pSubmits"].emplace_array();
        for(int FrUhwZA=0; FrUhwZA < submitCount; FrUhwZA++){
            [&](){
            auto& temp=arr_kYcwgKD[FrUhwZA].emplace_object();
            return serialize_struct(temp, pSubmits[FrUhwZA]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();


        writeToConn(json);
    }

    void handle_vkQueueWaitIdle(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();

    PFN_vkQueueWaitIdle call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueWaitIdle)get_instance_proc_addr(parent,"vkQueueWaitIdle");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueWaitIdle)get_device_proc_addr(parent,"vkQueueWaitIdle");
    }  
    
{
auto result=call_function(queue);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();


        writeToConn(json);
    }

    void handle_vkDeviceWaitIdle(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();

    PFN_vkDeviceWaitIdle call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDeviceWaitIdle)get_instance_proc_addr(parent,"vkDeviceWaitIdle");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDeviceWaitIdle)get_device_proc_addr(parent,"vkDeviceWaitIdle");
    }  
    
{
auto result=call_function(device);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();


        writeToConn(json);
    }

    void handle_vkAllocateMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMemoryAllocateInfo* pAllocateInfo;
[&](){ VkMemoryAllocateInfo* temp_mqYZmru[&](){
            if (json["pAllocateInfo"].as_array().size()==0){
                temp_mqYZmru=NULL;
            return; }temp_mqYZmru=(VkMemoryAllocateInfo*)malloc(1*sizeof(VkMemoryAllocateInfo));
        auto& arr_deRkgom=json["pAllocateInfo"].as_array();
        for(int ujZsXLJ=0; ujZsXLJ < 1; ujZsXLJ++){
            [&](){
            auto& temp=arr_deRkgom[ujZsXLJ].as_object();
            deserialize_struct(temp,temp_mqYZmru[ujZsXLJ]);
            }();
        }
        }();pAllocateInfo=temp_mqYZmru;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkDeviceMemory* pMemory;
[&](){
            if (json["pMemory"].as_array().size()==0){
                pMemory=NULL;
            return; }pMemory=(VkDeviceMemory*)malloc(1*sizeof(VkDeviceMemory));
        auto& arr_JqUSUSb=json["pMemory"].as_array();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){deserialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV], pMemory[iFmVAsV]);}();
        }
        }();

    PFN_vkAllocateMemory call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAllocateMemory)get_instance_proc_addr(parent,"vkAllocateMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAllocateMemory)get_device_proc_addr(parent,"vkAllocateMemory");
    }  
    
{
auto result=call_function(device, pAllocateInfo, pAllocator, pMemory);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }
        auto& arr_NGCHnPz=json["pAllocateInfo"].emplace_array();
        for(int MAXIAGO=0; MAXIAGO < 1; MAXIAGO++){
            [&](){
            auto& temp=arr_NGCHnPz[MAXIAGO].emplace_object();
            return serialize_struct(temp, pAllocateInfo[MAXIAGO]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMemory==NULL){
                json["pMemory"]=boost::json::array();
            return; }
        auto& arr_JqUSUSb=json["pMemory"].emplace_array();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){serialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV],pMemory[iFmVAsV]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkFreeMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkFreeMemory call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkFreeMemory)get_instance_proc_addr(parent,"vkFreeMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkFreeMemory)get_device_proc_addr(parent,"vkFreeMemory");
    }  
    
{
call_function(device, memory, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkMapMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
VkDeviceSize size;
[&](){uint64_t temp_PlNcOBd;[&](){temp_PlNcOBd=static_cast<uint64_t>(value_to<int>(json["size"]));}();size=(VkDeviceSize)temp_PlNcOBd;}();
VkMemoryMapFlags flags;
[&](){[&](){int temp_UEEqVUK;[&](){temp_UEEqVUK=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkMemoryMapFlags)temp_UEEqVUK;}();}();
void** ppData;
[&](){
            if (json["ppData"].as_array().size()==0){
                ppData=NULL;
            return; }ppData=(void**)malloc(1*sizeof(void*));
        auto& arr_syvZTtN=json["ppData"].as_array();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (arr_syvZTtN[weOJAdg].as_array().size()==0){
                ppData[weOJAdg]=NULL;
            return; }char* temp_syvZTtN;[&](){
            if (arr_syvZTtN[weOJAdg].as_array().size()==0){
                temp_syvZTtN=NULL;
            return; }temp_syvZTtN=(char*)malloc(size*sizeof(char));
        auto& arr_yHvgdEb=arr_syvZTtN[weOJAdg].as_array();
        for(int vgxltbA=0; vgxltbA < size; vgxltbA++){
            [&](){temp_syvZTtN[vgxltbA]=static_cast<char>(value_to<int>(arr_yHvgdEb[vgxltbA]));}();
        }
        }();ppData[weOJAdg]=temp_syvZTtN;}();
        }
        }();

    PFN_vkMapMemory call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkMapMemory)get_instance_proc_addr(parent,"vkMapMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkMapMemory)get_device_proc_addr(parent,"vkMapMemory");
    }  
    
{
auto result=call_function(device, memory, offset, size, flags, ppData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }
        auto& arr_syvZTtN=json["ppData"].emplace_array();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (ppData[weOJAdg]==NULL){
                arr_syvZTtN[weOJAdg]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[weOJAdg]))==NULL){
                arr_syvZTtN[weOJAdg]=boost::json::array();
            return; }
        auto& arr_yHvgdEb=arr_syvZTtN[weOJAdg].emplace_array();
        for(int vgxltbA=0; vgxltbA < size; vgxltbA++){
            [&](){arr_yHvgdEb[vgxltbA]=((char*)(ppData[weOJAdg]))[vgxltbA];}();
        }
        }();}();
        }
        }();

        boost::json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, memory);
        
        auto server_memory=value_to<uintptr_t>(server_memory_json); 
        
        *ppData=registerDeviceMemoryMap(server_memory, memory,size,*ppData,(uintptr_t)(*ppData));
        
        #ifndef CLIENT
            json["mem"]=(uintptr_t)(*ppData);
        #endif
        

        writeToConn(json);
    }

    void handle_vkUnmapMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();

    PFN_vkUnmapMemory call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUnmapMemory)get_instance_proc_addr(parent,"vkUnmapMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUnmapMemory)get_device_proc_addr(parent,"vkUnmapMemory");
    }  
    
{
call_function(device, memory);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();


        writeToConn(json);
    }

    void handle_vkFlushMappedMemoryRanges(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t memoryRangeCount;
[&](){memoryRangeCount=static_cast<uint32_t>(value_to<int>(json["memoryRangeCount"]));}();
VkMappedMemoryRange* pMemoryRanges;
[&](){ VkMappedMemoryRange* temp_clUIhVC[&](){
            if (json["pMemoryRanges"].as_array().size()==0){
                temp_clUIhVC=NULL;
            return; }temp_clUIhVC=(VkMappedMemoryRange*)malloc(memoryRangeCount*sizeof(VkMappedMemoryRange));
        auto& arr_nFHDtPn=json["pMemoryRanges"].as_array();
        for(int oXMPKll=0; oXMPKll < memoryRangeCount; oXMPKll++){
            [&](){
            auto& temp=arr_nFHDtPn[oXMPKll].as_object();
            deserialize_struct(temp,temp_clUIhVC[oXMPKll]);
            }();
        }
        }();pMemoryRanges=temp_clUIhVC;}();

    PFN_vkFlushMappedMemoryRanges call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkFlushMappedMemoryRanges)get_instance_proc_addr(parent,"vkFlushMappedMemoryRanges");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkFlushMappedMemoryRanges)get_device_proc_addr(parent,"vkFlushMappedMemoryRanges");
    }  
    
{
auto result=call_function(device, memoryRangeCount, pMemoryRanges);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=memoryRangeCount;}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=boost::json::array();
            return; }
        auto& arr_sKDZFVw=json["pMemoryRanges"].emplace_array();
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto& temp=arr_sKDZFVw[GdhGpVL].emplace_object();
            return serialize_struct(temp, pMemoryRanges[GdhGpVL]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkInvalidateMappedMemoryRanges(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t memoryRangeCount;
[&](){memoryRangeCount=static_cast<uint32_t>(value_to<int>(json["memoryRangeCount"]));}();
VkMappedMemoryRange* pMemoryRanges;
[&](){ VkMappedMemoryRange* temp_clUIhVC[&](){
            if (json["pMemoryRanges"].as_array().size()==0){
                temp_clUIhVC=NULL;
            return; }temp_clUIhVC=(VkMappedMemoryRange*)malloc(memoryRangeCount*sizeof(VkMappedMemoryRange));
        auto& arr_nFHDtPn=json["pMemoryRanges"].as_array();
        for(int oXMPKll=0; oXMPKll < memoryRangeCount; oXMPKll++){
            [&](){
            auto& temp=arr_nFHDtPn[oXMPKll].as_object();
            deserialize_struct(temp,temp_clUIhVC[oXMPKll]);
            }();
        }
        }();pMemoryRanges=temp_clUIhVC;}();

    PFN_vkInvalidateMappedMemoryRanges call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkInvalidateMappedMemoryRanges)get_instance_proc_addr(parent,"vkInvalidateMappedMemoryRanges");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkInvalidateMappedMemoryRanges)get_device_proc_addr(parent,"vkInvalidateMappedMemoryRanges");
    }  
    
{
auto result=call_function(device, memoryRangeCount, pMemoryRanges);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=memoryRangeCount;}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=boost::json::array();
            return; }
        auto& arr_sKDZFVw=json["pMemoryRanges"].emplace_array();
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto& temp=arr_sKDZFVw[GdhGpVL].emplace_object();
            return serialize_struct(temp, pMemoryRanges[GdhGpVL]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceMemoryCommitment(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize* pCommittedMemoryInBytes;
[&](){
            if (json["pCommittedMemoryInBytes"].as_array().size()==0){
                pCommittedMemoryInBytes=NULL;
            return; }pCommittedMemoryInBytes=(VkDeviceSize*)malloc(1*sizeof(VkDeviceSize));
        auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].as_array();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){uint64_t temp_BkHcKeY;[&](){temp_BkHcKeY=static_cast<uint64_t>(value_to<int>(arr_BkHcKeY[iEYXrVv]));}();pCommittedMemoryInBytes[iEYXrVv]=(VkDeviceSize)temp_BkHcKeY;}();
        }
        }();

    PFN_vkGetDeviceMemoryCommitment call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceMemoryCommitment)get_instance_proc_addr(parent,"vkGetDeviceMemoryCommitment");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceMemoryCommitment)get_device_proc_addr(parent,"vkGetDeviceMemoryCommitment");
    }  
    
{
call_function(device, memory, pCommittedMemoryInBytes);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pCommittedMemoryInBytes==NULL){
                json["pCommittedMemoryInBytes"]=boost::json::array();
            return; }
        auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].emplace_array();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){[&](){arr_BkHcKeY[iEYXrVv]=pCommittedMemoryInBytes[iEYXrVv];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetBufferMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkMemoryRequirements* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements*)malloc(1*sizeof(VkMemoryRequirements));
        auto& arr_qQjUyYD=json["pMemoryRequirements"].as_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].as_object();
            deserialize_struct(temp,pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

    PFN_vkGetBufferMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferMemoryRequirements)get_instance_proc_addr(parent,"vkGetBufferMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferMemoryRequirements)get_device_proc_addr(parent,"vkGetBufferMemoryRequirements");
    }  
    
{
call_function(device, buffer, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_qQjUyYD=json["pMemoryRequirements"].emplace_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[VeirrNu]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBindBufferMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize memoryOffset;
[&](){uint64_t temp_yVqWYJm;[&](){temp_yVqWYJm=static_cast<uint64_t>(value_to<int>(json["memoryOffset"]));}();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();

    PFN_vkBindBufferMemory call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindBufferMemory)get_instance_proc_addr(parent,"vkBindBufferMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindBufferMemory)get_device_proc_addr(parent,"vkBindBufferMemory");
    }  
    
{
auto result=call_function(device, buffer, memory, memoryOffset);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=memoryOffset;}();}();


        writeToConn(json);
    }

    void handle_vkGetImageMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkMemoryRequirements* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements*)malloc(1*sizeof(VkMemoryRequirements));
        auto& arr_qQjUyYD=json["pMemoryRequirements"].as_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].as_object();
            deserialize_struct(temp,pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

    PFN_vkGetImageMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageMemoryRequirements)get_instance_proc_addr(parent,"vkGetImageMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageMemoryRequirements)get_device_proc_addr(parent,"vkGetImageMemoryRequirements");
    }  
    
{
call_function(device, image, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_qQjUyYD=json["pMemoryRequirements"].emplace_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[VeirrNu]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBindImageMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize memoryOffset;
[&](){uint64_t temp_yVqWYJm;[&](){temp_yVqWYJm=static_cast<uint64_t>(value_to<int>(json["memoryOffset"]));}();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();

    PFN_vkBindImageMemory call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindImageMemory)get_instance_proc_addr(parent,"vkBindImageMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindImageMemory)get_device_proc_addr(parent,"vkBindImageMemory");
    }  
    
{
auto result=call_function(device, image, memory, memoryOffset);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=memoryOffset;}();}();


        writeToConn(json);
    }

    void handle_vkGetImageSparseMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
uint32_t* pSparseMemoryRequirementCount;
[&](){
            if (json["pSparseMemoryRequirementCount"].as_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }pSparseMemoryRequirementCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(value_to<int>(arr_QpqRnvg[pFgmjla]));}();
        }
        }();
VkSparseImageMemoryRequirements* pSparseMemoryRequirements;
[&](){
            if (json["pSparseMemoryRequirements"].as_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }pSparseMemoryRequirements=(VkSparseImageMemoryRequirements*)malloc(*pSparseMemoryRequirementCount*sizeof(VkSparseImageMemoryRequirements));
        auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].as_array();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto& temp=arr_gCgbiZM[HKRWUBR].as_object();
            deserialize_struct(temp,pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();

    PFN_vkGetImageSparseMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageSparseMemoryRequirements)get_instance_proc_addr(parent,"vkGetImageSparseMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageSparseMemoryRequirements)get_device_proc_addr(parent,"vkGetImageSparseMemoryRequirements");
    }  
    
{
call_function(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].emplace_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].emplace_array();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto& temp=arr_gCgbiZM[HKRWUBR].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSparseImageFormatProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
VkImageType type;
[&](){[&](){int temp_bMZuPlo;[&](){temp_bMZuPlo=static_cast<int>(value_to<int>(json["type"]));}();type=(VkImageType)temp_bMZuPlo;}();}();
VkSampleCountFlagBits samples;
[&](){[&](){int temp_lbKgbKj;[&](){temp_lbKgbKj=static_cast<int>(value_to<int>(json["samples"]));}();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
VkImageUsageFlags usage;
[&](){[&](){int temp_sXuQFYv;[&](){temp_sXuQFYv=static_cast<int>(value_to<int>(json["usage"]));}();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
VkImageTiling tiling;
[&](){[&](){int temp_PtqdPDE;[&](){temp_PtqdPDE=static_cast<int>(value_to<int>(json["tiling"]));}();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkSparseImageFormatProperties* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkSparseImageFormatProperties*)malloc(*pPropertyCount*sizeof(VkSparseImageFormatProperties));
        auto& arr_jINYdYP=json["pProperties"].as_array();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto& temp=arr_jINYdYP[BOLcXca].as_object();
            deserialize_struct(temp,pProperties[BOLcXca]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSparseImageFormatProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties");
    }  
    
{
call_function(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_jINYdYP=json["pProperties"].emplace_array();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto& temp=arr_jINYdYP[BOLcXca].emplace_object();
            return serialize_struct(temp, pProperties[BOLcXca]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkQueueBindSparse(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t bindInfoCount;
[&](){bindInfoCount=static_cast<uint32_t>(value_to<int>(json["bindInfoCount"]));}();
VkBindSparseInfo* pBindInfo;
[&](){ VkBindSparseInfo* temp_FhLonTg[&](){
            if (json["pBindInfo"].as_array().size()==0){
                temp_FhLonTg=NULL;
            return; }temp_FhLonTg=(VkBindSparseInfo*)malloc(bindInfoCount*sizeof(VkBindSparseInfo));
        auto& arr_yoxMwfS=json["pBindInfo"].as_array();
        for(int dbkPgzh=0; dbkPgzh < bindInfoCount; dbkPgzh++){
            [&](){
            auto& temp=arr_yoxMwfS[dbkPgzh].as_object();
            deserialize_struct(temp,temp_FhLonTg[dbkPgzh]);
            }();
        }
        }();pBindInfo=temp_FhLonTg;}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkQueueBindSparse call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueBindSparse)get_instance_proc_addr(parent,"vkQueueBindSparse");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueBindSparse)get_device_proc_addr(parent,"vkQueueBindSparse");
    }  
    
{
auto result=call_function(queue, bindInfoCount, pBindInfo, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfo==NULL){
                json["pBindInfo"]=boost::json::array();
            return; }
        auto& arr_eUGJCxJ=json["pBindInfo"].emplace_array();
        for(int ujBkVap=0; ujBkVap < bindInfoCount; ujBkVap++){
            [&](){
            auto& temp=arr_eUGJCxJ[ujBkVap].emplace_object();
            return serialize_struct(temp, pBindInfo[ujBkVap]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();


        writeToConn(json);
    }

    void handle_vkCreateFence(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFenceCreateInfo* pCreateInfo;
[&](){ VkFenceCreateInfo* temp_SvAOcpg[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_SvAOcpg=NULL;
            return; }temp_SvAOcpg=(VkFenceCreateInfo*)malloc(1*sizeof(VkFenceCreateInfo));
        auto& arr_cSMNytM=json["pCreateInfo"].as_array();
        for(int JOkcmyM=0; JOkcmyM < 1; JOkcmyM++){
            [&](){
            auto& temp=arr_cSMNytM[JOkcmyM].as_object();
            deserialize_struct(temp,temp_SvAOcpg[JOkcmyM]);
            }();
        }
        }();pCreateInfo=temp_SvAOcpg;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkFence* pFence;
[&](){
            if (json["pFence"].as_array().size()==0){
                pFence=NULL;
            return; }pFence=(VkFence*)malloc(1*sizeof(VkFence));
        auto& arr_SJohVKr=json["pFence"].as_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();

    PFN_vkCreateFence call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateFence)get_instance_proc_addr(parent,"vkCreateFence");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateFence)get_device_proc_addr(parent,"vkCreateFence");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pFence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_qbBwXza=json["pCreateInfo"].emplace_array();
        for(int kPSKeJY=0; kPSKeJY < 1; kPSKeJY++){
            [&](){
            auto& temp=arr_qbBwXza[kPSKeJY].emplace_object();
            return serialize_struct(temp, pCreateInfo[kPSKeJY]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }
        auto& arr_SJohVKr=json["pFence"].emplace_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyFence(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyFence call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyFence)get_instance_proc_addr(parent,"vkDestroyFence");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyFence)get_device_proc_addr(parent,"vkDestroyFence");
    }  
    
{
call_function(device, fence, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkResetFences(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t fenceCount;
[&](){fenceCount=static_cast<uint32_t>(value_to<int>(json["fenceCount"]));}();
VkFence* pFences;
[&](){ VkFence* temp_AqhVhJs[&](){
            if (json["pFences"].as_array().size()==0){
                temp_AqhVhJs=NULL;
            return; }temp_AqhVhJs=(VkFence*)malloc(fenceCount*sizeof(VkFence));
        auto& arr_nntmqqP=json["pFences"].as_array();
        for(int hksYnfK=0; hksYnfK < fenceCount; hksYnfK++){
            [&](){deserialize_VkFence(arr_nntmqqP[hksYnfK], temp_AqhVhJs[hksYnfK]);}();
        }
        }();pFences=temp_AqhVhJs;}();

    PFN_vkResetFences call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetFences)get_instance_proc_addr(parent,"vkResetFences");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetFences)get_device_proc_addr(parent,"vkResetFences");
    }  
    
{
auto result=call_function(device, fenceCount, pFences);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=fenceCount;}();
[&](){
            if (pFences==NULL){
                json["pFences"]=boost::json::array();
            return; }
        auto& arr_UUllwqV=json["pFences"].emplace_array();
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetFenceStatus(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkGetFenceStatus call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetFenceStatus)get_instance_proc_addr(parent,"vkGetFenceStatus");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetFenceStatus)get_device_proc_addr(parent,"vkGetFenceStatus");
    }  
    
{
auto result=call_function(device, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();


        writeToConn(json);
    }

    void handle_vkWaitForFences(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t fenceCount;
[&](){fenceCount=static_cast<uint32_t>(value_to<int>(json["fenceCount"]));}();
VkFence* pFences;
[&](){ VkFence* temp_AqhVhJs[&](){
            if (json["pFences"].as_array().size()==0){
                temp_AqhVhJs=NULL;
            return; }temp_AqhVhJs=(VkFence*)malloc(fenceCount*sizeof(VkFence));
        auto& arr_nntmqqP=json["pFences"].as_array();
        for(int hksYnfK=0; hksYnfK < fenceCount; hksYnfK++){
            [&](){deserialize_VkFence(arr_nntmqqP[hksYnfK], temp_AqhVhJs[hksYnfK]);}();
        }
        }();pFences=temp_AqhVhJs;}();
VkBool32 waitAll;
[&](){uint32_t temp_pqKsrTL;[&](){temp_pqKsrTL=static_cast<uint32_t>(value_to<int>(json["waitAll"]));}();waitAll=(VkBool32)temp_pqKsrTL;}();
uint64_t timeout;
[&](){timeout=static_cast<uint64_t>(value_to<int>(json["timeout"]));}();

    PFN_vkWaitForFences call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWaitForFences)get_instance_proc_addr(parent,"vkWaitForFences");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWaitForFences)get_device_proc_addr(parent,"vkWaitForFences");
    }  
    
{
auto result=call_function(device, fenceCount, pFences, waitAll, timeout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=fenceCount;}();
[&](){
            if (pFences==NULL){
                json["pFences"]=boost::json::array();
            return; }
        auto& arr_UUllwqV=json["pFences"].emplace_array();
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        }();
[&](){[&](){json["waitAll"]=waitAll;}();}();
[&](){json["timeout"]=timeout;}();

            if (result!=VK_TIMEOUT){
                SyncAll();
            }
            


        writeToConn(json);
    }

    void handle_vkCreateSemaphore(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphoreCreateInfo* pCreateInfo;
[&](){ VkSemaphoreCreateInfo* temp_vcypzvq[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_vcypzvq=NULL;
            return; }temp_vcypzvq=(VkSemaphoreCreateInfo*)malloc(1*sizeof(VkSemaphoreCreateInfo));
        auto& arr_FJDFSKM=json["pCreateInfo"].as_array();
        for(int aGXpPVQ=0; aGXpPVQ < 1; aGXpPVQ++){
            [&](){
            auto& temp=arr_FJDFSKM[aGXpPVQ].as_object();
            deserialize_struct(temp,temp_vcypzvq[aGXpPVQ]);
            }();
        }
        }();pCreateInfo=temp_vcypzvq;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkSemaphore* pSemaphore;
[&](){
            if (json["pSemaphore"].as_array().size()==0){
                pSemaphore=NULL;
            return; }pSemaphore=(VkSemaphore*)malloc(1*sizeof(VkSemaphore));
        auto& arr_rvNHvxY=json["pSemaphore"].as_array();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){deserialize_VkSemaphore(arr_rvNHvxY[lrrAvof], pSemaphore[lrrAvof]);}();
        }
        }();

    PFN_vkCreateSemaphore call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSemaphore)get_instance_proc_addr(parent,"vkCreateSemaphore");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSemaphore)get_device_proc_addr(parent,"vkCreateSemaphore");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pSemaphore);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_hQVwpIP=json["pCreateInfo"].emplace_array();
        for(int TzTYDbe=0; TzTYDbe < 1; TzTYDbe++){
            [&](){
            auto& temp=arr_hQVwpIP[TzTYDbe].emplace_object();
            return serialize_struct(temp, pCreateInfo[TzTYDbe]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSemaphore==NULL){
                json["pSemaphore"]=boost::json::array();
            return; }
        auto& arr_rvNHvxY=json["pSemaphore"].emplace_array();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){serialize_VkSemaphore(arr_rvNHvxY[lrrAvof],pSemaphore[lrrAvof]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroySemaphore(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphore semaphore;
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroySemaphore call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySemaphore)get_instance_proc_addr(parent,"vkDestroySemaphore");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySemaphore)get_device_proc_addr(parent,"vkDestroySemaphore");
    }  
    
{
call_function(device, semaphore, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateEvent(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEventCreateInfo* pCreateInfo;
[&](){ VkEventCreateInfo* temp_hcihAHF[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_hcihAHF=NULL;
            return; }temp_hcihAHF=(VkEventCreateInfo*)malloc(1*sizeof(VkEventCreateInfo));
        auto& arr_cHgRyNm=json["pCreateInfo"].as_array();
        for(int gikyLcY=0; gikyLcY < 1; gikyLcY++){
            [&](){
            auto& temp=arr_cHgRyNm[gikyLcY].as_object();
            deserialize_struct(temp,temp_hcihAHF[gikyLcY]);
            }();
        }
        }();pCreateInfo=temp_hcihAHF;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkEvent* pEvent;
[&](){
            if (json["pEvent"].as_array().size()==0){
                pEvent=NULL;
            return; }pEvent=(VkEvent*)malloc(1*sizeof(VkEvent));
        auto& arr_edObbrc=json["pEvent"].as_array();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){deserialize_VkEvent(arr_edObbrc[vdhtBcH], pEvent[vdhtBcH]);}();
        }
        }();

    PFN_vkCreateEvent call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateEvent)get_instance_proc_addr(parent,"vkCreateEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateEvent)get_device_proc_addr(parent,"vkCreateEvent");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pEvent);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_wqWioqo=json["pCreateInfo"].emplace_array();
        for(int ThfQKZW=0; ThfQKZW < 1; ThfQKZW++){
            [&](){
            auto& temp=arr_wqWioqo[ThfQKZW].emplace_object();
            return serialize_struct(temp, pCreateInfo[ThfQKZW]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pEvent==NULL){
                json["pEvent"]=boost::json::array();
            return; }
        auto& arr_edObbrc=json["pEvent"].emplace_array();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){serialize_VkEvent(arr_edObbrc[vdhtBcH],pEvent[vdhtBcH]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyEvent(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyEvent call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyEvent)get_instance_proc_addr(parent,"vkDestroyEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyEvent)get_device_proc_addr(parent,"vkDestroyEvent");
    }  
    
{
call_function(device, event, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetEventStatus(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();

    PFN_vkGetEventStatus call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetEventStatus)get_instance_proc_addr(parent,"vkGetEventStatus");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetEventStatus)get_device_proc_addr(parent,"vkGetEventStatus");
    }  
    
{
auto result=call_function(device, event);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();


        writeToConn(json);
    }

    void handle_vkSetEvent(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();

    PFN_vkSetEvent call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetEvent)get_instance_proc_addr(parent,"vkSetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetEvent)get_device_proc_addr(parent,"vkSetEvent");
    }  
    
{
auto result=call_function(device, event);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();


        writeToConn(json);
    }

    void handle_vkResetEvent(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();

    PFN_vkResetEvent call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetEvent)get_instance_proc_addr(parent,"vkResetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetEvent)get_device_proc_addr(parent,"vkResetEvent");
    }  
    
{
auto result=call_function(device, event);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();


        writeToConn(json);
    }

    void handle_vkCreateQueryPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPoolCreateInfo* pCreateInfo;
[&](){ VkQueryPoolCreateInfo* temp_SDSXpYj[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_SDSXpYj=NULL;
            return; }temp_SDSXpYj=(VkQueryPoolCreateInfo*)malloc(1*sizeof(VkQueryPoolCreateInfo));
        auto& arr_OFyRSSf=json["pCreateInfo"].as_array();
        for(int HxljsQx=0; HxljsQx < 1; HxljsQx++){
            [&](){
            auto& temp=arr_OFyRSSf[HxljsQx].as_object();
            deserialize_struct(temp,temp_SDSXpYj[HxljsQx]);
            }();
        }
        }();pCreateInfo=temp_SDSXpYj;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkQueryPool* pQueryPool;
[&](){
            if (json["pQueryPool"].as_array().size()==0){
                pQueryPool=NULL;
            return; }pQueryPool=(VkQueryPool*)malloc(1*sizeof(VkQueryPool));
        auto& arr_uEjfPmz=json["pQueryPool"].as_array();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){deserialize_VkQueryPool(arr_uEjfPmz[HoCFbNC], pQueryPool[HoCFbNC]);}();
        }
        }();

    PFN_vkCreateQueryPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateQueryPool)get_instance_proc_addr(parent,"vkCreateQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateQueryPool)get_device_proc_addr(parent,"vkCreateQueryPool");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pQueryPool);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_AOuTZQo=json["pCreateInfo"].emplace_array();
        for(int SvYxRUl=0; SvYxRUl < 1; SvYxRUl++){
            [&](){
            auto& temp=arr_AOuTZQo[SvYxRUl].emplace_object();
            return serialize_struct(temp, pCreateInfo[SvYxRUl]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pQueryPool==NULL){
                json["pQueryPool"]=boost::json::array();
            return; }
        auto& arr_uEjfPmz=json["pQueryPool"].emplace_array();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){serialize_VkQueryPool(arr_uEjfPmz[HoCFbNC],pQueryPool[HoCFbNC]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyQueryPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyQueryPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyQueryPool)get_instance_proc_addr(parent,"vkDestroyQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyQueryPool)get_device_proc_addr(parent,"vkDestroyQueryPool");
    }  
    
{
call_function(device, queryPool, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetQueryPoolResults(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();
uint32_t queryCount;
[&](){queryCount=static_cast<uint32_t>(value_to<int>(json["queryCount"]));}();
size_t dataSize;
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();
VkDeviceSize stride;
[&](){uint64_t temp_fLSTSIg;[&](){temp_fLSTSIg=static_cast<uint64_t>(value_to<int>(json["stride"]));}();stride=(VkDeviceSize)temp_fLSTSIg;}();
VkQueryResultFlags flags;
[&](){[&](){int temp_jzLjdpj;[&](){temp_jzLjdpj=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();

    PFN_vkGetQueryPoolResults call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetQueryPoolResults)get_instance_proc_addr(parent,"vkGetQueryPoolResults");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetQueryPoolResults)get_device_proc_addr(parent,"vkGetQueryPoolResults");
    }  
    
{
auto result=call_function(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
[&](){[&](){json["stride"]=stride;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        writeToConn(json);
    }

    void handle_vkResetQueryPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();
uint32_t queryCount;
[&](){queryCount=static_cast<uint32_t>(value_to<int>(json["queryCount"]));}();

    PFN_vkResetQueryPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetQueryPool)get_instance_proc_addr(parent,"vkResetQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetQueryPool)get_device_proc_addr(parent,"vkResetQueryPool");
    }  
    
{
call_function(device, queryPool, firstQuery, queryCount);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();


        writeToConn(json);
    }

    void handle_vkCreateBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBufferCreateInfo* pCreateInfo;
[&](){ VkBufferCreateInfo* temp_gfIPKwm[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_gfIPKwm=NULL;
            return; }temp_gfIPKwm=(VkBufferCreateInfo*)malloc(1*sizeof(VkBufferCreateInfo));
        auto& arr_vAtICCQ=json["pCreateInfo"].as_array();
        for(int kBYZDCM=0; kBYZDCM < 1; kBYZDCM++){
            [&](){
            auto& temp=arr_vAtICCQ[kBYZDCM].as_object();
            deserialize_struct(temp,temp_gfIPKwm[kBYZDCM]);
            }();
        }
        }();pCreateInfo=temp_gfIPKwm;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkBuffer* pBuffer;
[&](){
            if (json["pBuffer"].as_array().size()==0){
                pBuffer=NULL;
            return; }pBuffer=(VkBuffer*)malloc(1*sizeof(VkBuffer));
        auto& arr_cIWQmjJ=json["pBuffer"].as_array();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){deserialize_VkBuffer(arr_cIWQmjJ[XGujqfM], pBuffer[XGujqfM]);}();
        }
        }();

    PFN_vkCreateBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateBuffer)get_instance_proc_addr(parent,"vkCreateBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateBuffer)get_device_proc_addr(parent,"vkCreateBuffer");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pBuffer);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_YapwvbL=json["pCreateInfo"].emplace_array();
        for(int XkzMxbI=0; XkzMxbI < 1; XkzMxbI++){
            [&](){
            auto& temp=arr_YapwvbL[XkzMxbI].emplace_object();
            return serialize_struct(temp, pCreateInfo[XkzMxbI]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pBuffer==NULL){
                json["pBuffer"]=boost::json::array();
            return; }
        auto& arr_cIWQmjJ=json["pBuffer"].emplace_array();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){serialize_VkBuffer(arr_cIWQmjJ[XGujqfM],pBuffer[XGujqfM]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyBuffer)get_instance_proc_addr(parent,"vkDestroyBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyBuffer)get_device_proc_addr(parent,"vkDestroyBuffer");
    }  
    
{
call_function(device, buffer, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateBufferView(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBufferViewCreateInfo* pCreateInfo;
[&](){ VkBufferViewCreateInfo* temp_AokAAPK[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_AokAAPK=NULL;
            return; }temp_AokAAPK=(VkBufferViewCreateInfo*)malloc(1*sizeof(VkBufferViewCreateInfo));
        auto& arr_MSlizKJ=json["pCreateInfo"].as_array();
        for(int bEIfqcJ=0; bEIfqcJ < 1; bEIfqcJ++){
            [&](){
            auto& temp=arr_MSlizKJ[bEIfqcJ].as_object();
            deserialize_struct(temp,temp_AokAAPK[bEIfqcJ]);
            }();
        }
        }();pCreateInfo=temp_AokAAPK;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkBufferView* pView;
[&](){
            if (json["pView"].as_array().size()==0){
                pView=NULL;
            return; }pView=(VkBufferView*)malloc(1*sizeof(VkBufferView));
        auto& arr_FoBLnTF=json["pView"].as_array();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){deserialize_VkBufferView(arr_FoBLnTF[jjvyrOh], pView[jjvyrOh]);}();
        }
        }();

    PFN_vkCreateBufferView call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateBufferView)get_instance_proc_addr(parent,"vkCreateBufferView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateBufferView)get_device_proc_addr(parent,"vkCreateBufferView");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pView);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_SvrkcZl=json["pCreateInfo"].emplace_array();
        for(int cSdiRJj=0; cSdiRJj < 1; cSdiRJj++){
            [&](){
            auto& temp=arr_SvrkcZl[cSdiRJj].emplace_object();
            return serialize_struct(temp, pCreateInfo[cSdiRJj]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pView==NULL){
                json["pView"]=boost::json::array();
            return; }
        auto& arr_FoBLnTF=json["pView"].emplace_array();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){serialize_VkBufferView(arr_FoBLnTF[jjvyrOh],pView[jjvyrOh]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyBufferView(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBufferView bufferView;
[&](){deserialize_VkBufferView(json["bufferView"], bufferView);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyBufferView call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyBufferView)get_instance_proc_addr(parent,"vkDestroyBufferView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyBufferView)get_device_proc_addr(parent,"vkDestroyBufferView");
    }  
    
{
call_function(device, bufferView, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBufferView(json["bufferView"],bufferView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateImage(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageCreateInfo* pCreateInfo;
[&](){ VkImageCreateInfo* temp_uEOPMPT[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_uEOPMPT=NULL;
            return; }temp_uEOPMPT=(VkImageCreateInfo*)malloc(1*sizeof(VkImageCreateInfo));
        auto& arr_yCiQzQk=json["pCreateInfo"].as_array();
        for(int QiYISUj=0; QiYISUj < 1; QiYISUj++){
            [&](){
            auto& temp=arr_yCiQzQk[QiYISUj].as_object();
            deserialize_struct(temp,temp_uEOPMPT[QiYISUj]);
            }();
        }
        }();pCreateInfo=temp_uEOPMPT;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkImage* pImage;
[&](){
            if (json["pImage"].as_array().size()==0){
                pImage=NULL;
            return; }pImage=(VkImage*)malloc(1*sizeof(VkImage));
        auto& arr_YGmHGGw=json["pImage"].as_array();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){deserialize_VkImage(arr_YGmHGGw[Lmwohhp], pImage[Lmwohhp]);}();
        }
        }();

    PFN_vkCreateImage call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateImage)get_instance_proc_addr(parent,"vkCreateImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateImage)get_device_proc_addr(parent,"vkCreateImage");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pImage);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_TpPCnAy=json["pCreateInfo"].emplace_array();
        for(int pRwmwcF=0; pRwmwcF < 1; pRwmwcF++){
            [&](){
            auto& temp=arr_TpPCnAy[pRwmwcF].emplace_object();
            return serialize_struct(temp, pCreateInfo[pRwmwcF]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pImage==NULL){
                json["pImage"]=boost::json::array();
            return; }
        auto& arr_YGmHGGw=json["pImage"].emplace_array();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){serialize_VkImage(arr_YGmHGGw[Lmwohhp],pImage[Lmwohhp]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyImage(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyImage call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyImage)get_instance_proc_addr(parent,"vkDestroyImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyImage)get_device_proc_addr(parent,"vkDestroyImage");
    }  
    
{
call_function(device, image, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetImageSubresourceLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageSubresource* pSubresource;
[&](){ VkImageSubresource* temp_nosABzE[&](){
            if (json["pSubresource"].as_array().size()==0){
                temp_nosABzE=NULL;
            return; }temp_nosABzE=(VkImageSubresource*)malloc(1*sizeof(VkImageSubresource));
        auto& arr_zbWgqCd=json["pSubresource"].as_array();
        for(int ioHtFIy=0; ioHtFIy < 1; ioHtFIy++){
            [&](){
            auto& temp=arr_zbWgqCd[ioHtFIy].as_object();
            deserialize_struct(temp,temp_nosABzE[ioHtFIy]);
            }();
        }
        }();pSubresource=temp_nosABzE;}();
VkSubresourceLayout* pLayout;
[&](){
            if (json["pLayout"].as_array().size()==0){
                pLayout=NULL;
            return; }pLayout=(VkSubresourceLayout*)malloc(1*sizeof(VkSubresourceLayout));
        auto& arr_JAFsVvP=json["pLayout"].as_array();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto& temp=arr_JAFsVvP[jGHmbXh].as_object();
            deserialize_struct(temp,pLayout[jGHmbXh]);
            }();
        }
        }();

    PFN_vkGetImageSubresourceLayout call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageSubresourceLayout)get_instance_proc_addr(parent,"vkGetImageSubresourceLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageSubresourceLayout)get_device_proc_addr(parent,"vkGetImageSubresourceLayout");
    }  
    
{
call_function(device, image, pSubresource, pLayout);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=boost::json::array();
            return; }
        auto& arr_bNRLlpX=json["pSubresource"].emplace_array();
        for(int trrMzRH=0; trrMzRH < 1; trrMzRH++){
            [&](){
            auto& temp=arr_bNRLlpX[trrMzRH].emplace_object();
            return serialize_struct(temp, pSubresource[trrMzRH]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }
        auto& arr_JAFsVvP=json["pLayout"].emplace_array();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto& temp=arr_JAFsVvP[jGHmbXh].emplace_object();
            return serialize_struct(temp, pLayout[jGHmbXh]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateImageView(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageViewCreateInfo* pCreateInfo;
[&](){ VkImageViewCreateInfo* temp_wrOeeAb[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_wrOeeAb=NULL;
            return; }temp_wrOeeAb=(VkImageViewCreateInfo*)malloc(1*sizeof(VkImageViewCreateInfo));
        auto& arr_JenFyWd=json["pCreateInfo"].as_array();
        for(int RiehwsS=0; RiehwsS < 1; RiehwsS++){
            [&](){
            auto& temp=arr_JenFyWd[RiehwsS].as_object();
            deserialize_struct(temp,temp_wrOeeAb[RiehwsS]);
            }();
        }
        }();pCreateInfo=temp_wrOeeAb;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkImageView* pView;
[&](){
            if (json["pView"].as_array().size()==0){
                pView=NULL;
            return; }pView=(VkImageView*)malloc(1*sizeof(VkImageView));
        auto& arr_GCwrdnq=json["pView"].as_array();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){deserialize_VkImageView(arr_GCwrdnq[frngisT], pView[frngisT]);}();
        }
        }();

    PFN_vkCreateImageView call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateImageView)get_instance_proc_addr(parent,"vkCreateImageView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateImageView)get_device_proc_addr(parent,"vkCreateImageView");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pView);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_TYfFrkP=json["pCreateInfo"].emplace_array();
        for(int HNOogbj=0; HNOogbj < 1; HNOogbj++){
            [&](){
            auto& temp=arr_TYfFrkP[HNOogbj].emplace_object();
            return serialize_struct(temp, pCreateInfo[HNOogbj]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pView==NULL){
                json["pView"]=boost::json::array();
            return; }
        auto& arr_GCwrdnq=json["pView"].emplace_array();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){serialize_VkImageView(arr_GCwrdnq[frngisT],pView[frngisT]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyImageView(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyImageView call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyImageView)get_instance_proc_addr(parent,"vkDestroyImageView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyImageView)get_device_proc_addr(parent,"vkDestroyImageView");
    }  
    
{
call_function(device, imageView, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateShaderModule(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderModuleCreateInfo* pCreateInfo;
[&](){ VkShaderModuleCreateInfo* temp_VfXsFIV[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_VfXsFIV=NULL;
            return; }temp_VfXsFIV=(VkShaderModuleCreateInfo*)malloc(1*sizeof(VkShaderModuleCreateInfo));
        auto& arr_GtIQgds=json["pCreateInfo"].as_array();
        for(int PbmosKP=0; PbmosKP < 1; PbmosKP++){
            [&](){
            auto& temp=arr_GtIQgds[PbmosKP].as_object();
            deserialize_struct(temp,temp_VfXsFIV[PbmosKP]);
            }();
        }
        }();pCreateInfo=temp_VfXsFIV;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkShaderModule* pShaderModule;
[&](){
            if (json["pShaderModule"].as_array().size()==0){
                pShaderModule=NULL;
            return; }pShaderModule=(VkShaderModule*)malloc(1*sizeof(VkShaderModule));
        auto& arr_FaKUyxw=json["pShaderModule"].as_array();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){deserialize_VkShaderModule(arr_FaKUyxw[EDcqjpD], pShaderModule[EDcqjpD]);}();
        }
        }();

    PFN_vkCreateShaderModule call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateShaderModule)get_instance_proc_addr(parent,"vkCreateShaderModule");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateShaderModule)get_device_proc_addr(parent,"vkCreateShaderModule");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pShaderModule);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_iSZUILM=json["pCreateInfo"].emplace_array();
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto& temp=arr_iSZUILM[dKxemXH].emplace_object();
            return serialize_struct(temp, pCreateInfo[dKxemXH]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pShaderModule==NULL){
                json["pShaderModule"]=boost::json::array();
            return; }
        auto& arr_FaKUyxw=json["pShaderModule"].emplace_array();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){serialize_VkShaderModule(arr_FaKUyxw[EDcqjpD],pShaderModule[EDcqjpD]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyShaderModule(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderModule shaderModule;
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyShaderModule call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyShaderModule)get_instance_proc_addr(parent,"vkDestroyShaderModule");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyShaderModule)get_device_proc_addr(parent,"vkDestroyShaderModule");
    }  
    
{
call_function(device, shaderModule, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreatePipelineCache(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCacheCreateInfo* pCreateInfo;
[&](){ VkPipelineCacheCreateInfo* temp_ZqKWOLK[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_ZqKWOLK=NULL;
            return; }temp_ZqKWOLK=(VkPipelineCacheCreateInfo*)malloc(1*sizeof(VkPipelineCacheCreateInfo));
        auto& arr_tPFcwyz=json["pCreateInfo"].as_array();
        for(int ccOebrR=0; ccOebrR < 1; ccOebrR++){
            [&](){
            auto& temp=arr_tPFcwyz[ccOebrR].as_object();
            deserialize_struct(temp,temp_ZqKWOLK[ccOebrR]);
            }();
        }
        }();pCreateInfo=temp_ZqKWOLK;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkPipelineCache* pPipelineCache;
[&](){
            if (json["pPipelineCache"].as_array().size()==0){
                pPipelineCache=NULL;
            return; }pPipelineCache=(VkPipelineCache*)malloc(1*sizeof(VkPipelineCache));
        auto& arr_mogHiwV=json["pPipelineCache"].as_array();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){deserialize_VkPipelineCache(arr_mogHiwV[ndOADAA], pPipelineCache[ndOADAA]);}();
        }
        }();

    PFN_vkCreatePipelineCache call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreatePipelineCache)get_instance_proc_addr(parent,"vkCreatePipelineCache");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreatePipelineCache)get_device_proc_addr(parent,"vkCreatePipelineCache");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pPipelineCache);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_wTXOYfz=json["pCreateInfo"].emplace_array();
        for(int iWdFkeP=0; iWdFkeP < 1; iWdFkeP++){
            [&](){
            auto& temp=arr_wTXOYfz[iWdFkeP].emplace_object();
            return serialize_struct(temp, pCreateInfo[iWdFkeP]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelineCache==NULL){
                json["pPipelineCache"]=boost::json::array();
            return; }
        auto& arr_mogHiwV=json["pPipelineCache"].emplace_array();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){serialize_VkPipelineCache(arr_mogHiwV[ndOADAA],pPipelineCache[ndOADAA]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyPipelineCache(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyPipelineCache call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyPipelineCache)get_instance_proc_addr(parent,"vkDestroyPipelineCache");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyPipelineCache)get_device_proc_addr(parent,"vkDestroyPipelineCache");
    }  
    
{
call_function(device, pipelineCache, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPipelineCacheData(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
size_t* pDataSize;
[&](){
            if (json["pDataSize"].as_array().size()==0){
                pDataSize=NULL;
            return; }pDataSize=(size_t*)malloc(1*sizeof(size_t));
        auto& arr_Zcusyfw=json["pDataSize"].as_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){pDataSize[HCzJfGC]=static_cast<size_t>(value_to<int>(arr_Zcusyfw[HCzJfGC]));}();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){temp_ZtBEjVJ[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_ZtBEjVJ;}();

    PFN_vkGetPipelineCacheData call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineCacheData)get_instance_proc_addr(parent,"vkGetPipelineCacheData");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineCacheData)get_device_proc_addr(parent,"vkGetPipelineCacheData");
    }  
    
{
auto result=call_function(device, pipelineCache, pDataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].emplace_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkMergePipelineCaches(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache dstCache;
[&](){deserialize_VkPipelineCache(json["dstCache"], dstCache);}();
uint32_t srcCacheCount;
[&](){srcCacheCount=static_cast<uint32_t>(value_to<int>(json["srcCacheCount"]));}();
VkPipelineCache* pSrcCaches;
[&](){ VkPipelineCache* temp_VrNnHBc[&](){
            if (json["pSrcCaches"].as_array().size()==0){
                temp_VrNnHBc=NULL;
            return; }temp_VrNnHBc=(VkPipelineCache*)malloc(srcCacheCount*sizeof(VkPipelineCache));
        auto& arr_criceHb=json["pSrcCaches"].as_array();
        for(int TBfRFpH=0; TBfRFpH < srcCacheCount; TBfRFpH++){
            [&](){deserialize_VkPipelineCache(arr_criceHb[TBfRFpH], temp_VrNnHBc[TBfRFpH]);}();
        }
        }();pSrcCaches=temp_VrNnHBc;}();

    PFN_vkMergePipelineCaches call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkMergePipelineCaches)get_instance_proc_addr(parent,"vkMergePipelineCaches");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkMergePipelineCaches)get_device_proc_addr(parent,"vkMergePipelineCaches");
    }  
    
{
auto result=call_function(device, dstCache, srcCacheCount, pSrcCaches);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=srcCacheCount;}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=boost::json::array();
            return; }
        auto& arr_DmqfOOL=json["pSrcCaches"].emplace_array();
        for(int MmYiSON=0; MmYiSON < srcCacheCount; MmYiSON++){
            [&](){serialize_VkPipelineCache(arr_DmqfOOL[MmYiSON],pSrcCaches[MmYiSON]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateGraphicsPipelines(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();
VkGraphicsPipelineCreateInfo* pCreateInfos;
[&](){ VkGraphicsPipelineCreateInfo* temp_nnqGnqi[&](){
            if (json["pCreateInfos"].as_array().size()==0){
                temp_nnqGnqi=NULL;
            return; }temp_nnqGnqi=(VkGraphicsPipelineCreateInfo*)malloc(createInfoCount*sizeof(VkGraphicsPipelineCreateInfo));
        auto& arr_bKkRMWv=json["pCreateInfos"].as_array();
        for(int kSHyOYR=0; kSHyOYR < createInfoCount; kSHyOYR++){
            [&](){
            auto& temp=arr_bKkRMWv[kSHyOYR].as_object();
            deserialize_struct(temp,temp_nnqGnqi[kSHyOYR]);
            }();
        }
        }();pCreateInfos=temp_nnqGnqi;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].as_array().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));
        auto& arr_wuOYMDC=json["pPipelines"].as_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateGraphicsPipelines call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateGraphicsPipelines)get_instance_proc_addr(parent,"vkCreateGraphicsPipelines");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateGraphicsPipelines)get_device_proc_addr(parent,"vkCreateGraphicsPipelines");
    }  
    
{
auto result=call_function(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_juQDvLY=json["pCreateInfos"].emplace_array();
        for(int wqGiARr=0; wqGiARr < createInfoCount; wqGiARr++){
            [&](){
            auto& temp=arr_juQDvLY[wqGiARr].emplace_object();
            return serialize_struct(temp, pCreateInfos[wqGiARr]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].emplace_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateComputePipelines(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();
VkComputePipelineCreateInfo* pCreateInfos;
[&](){ VkComputePipelineCreateInfo* temp_VtfWSvy[&](){
            if (json["pCreateInfos"].as_array().size()==0){
                temp_VtfWSvy=NULL;
            return; }temp_VtfWSvy=(VkComputePipelineCreateInfo*)malloc(createInfoCount*sizeof(VkComputePipelineCreateInfo));
        auto& arr_THdSKsK=json["pCreateInfos"].as_array();
        for(int qnUOnCC=0; qnUOnCC < createInfoCount; qnUOnCC++){
            [&](){
            auto& temp=arr_THdSKsK[qnUOnCC].as_object();
            deserialize_struct(temp,temp_VtfWSvy[qnUOnCC]);
            }();
        }
        }();pCreateInfos=temp_VtfWSvy;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].as_array().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));
        auto& arr_wuOYMDC=json["pPipelines"].as_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateComputePipelines call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateComputePipelines)get_instance_proc_addr(parent,"vkCreateComputePipelines");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateComputePipelines)get_device_proc_addr(parent,"vkCreateComputePipelines");
    }  
    
{
auto result=call_function(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_eqiaDas=json["pCreateInfos"].emplace_array();
        for(int NsFJrJk=0; NsFJrJk < createInfoCount; NsFJrJk++){
            [&](){
            auto& temp=arr_eqiaDas[NsFJrJk].emplace_object();
            return serialize_struct(temp, pCreateInfos[NsFJrJk]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].emplace_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPass renderpass;
[&](){deserialize_VkRenderPass(json["renderpass"], renderpass);}();
VkExtent2D* pMaxWorkgroupSize;
[&](){
            if (json["pMaxWorkgroupSize"].as_array().size()==0){
                pMaxWorkgroupSize=NULL;
            return; }pMaxWorkgroupSize=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));
        auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].as_array();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto& temp=arr_QJRQgTX[WdbibPk].as_object();
            deserialize_struct(temp,pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();

    PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)get_instance_proc_addr(parent,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)get_device_proc_addr(parent,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
    }  
    
{
auto result=call_function(device, renderpass, pMaxWorkgroupSize);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderpass"],renderpass);}();
[&](){
            if (pMaxWorkgroupSize==NULL){
                json["pMaxWorkgroupSize"]=boost::json::array();
            return; }
        auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].emplace_array();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto& temp=arr_QJRQgTX[WdbibPk].emplace_object();
            return serialize_struct(temp, pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyPipeline(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyPipeline call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyPipeline)get_instance_proc_addr(parent,"vkDestroyPipeline");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyPipeline)get_device_proc_addr(parent,"vkDestroyPipeline");
    }  
    
{
call_function(device, pipeline, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreatePipelineLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineLayoutCreateInfo* pCreateInfo;
[&](){ VkPipelineLayoutCreateInfo* temp_UXlQaAm[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_UXlQaAm=NULL;
            return; }temp_UXlQaAm=(VkPipelineLayoutCreateInfo*)malloc(1*sizeof(VkPipelineLayoutCreateInfo));
        auto& arr_oLPmvyU=json["pCreateInfo"].as_array();
        for(int wpAzccn=0; wpAzccn < 1; wpAzccn++){
            [&](){
            auto& temp=arr_oLPmvyU[wpAzccn].as_object();
            deserialize_struct(temp,temp_UXlQaAm[wpAzccn]);
            }();
        }
        }();pCreateInfo=temp_UXlQaAm;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkPipelineLayout* pPipelineLayout;
[&](){
            if (json["pPipelineLayout"].as_array().size()==0){
                pPipelineLayout=NULL;
            return; }pPipelineLayout=(VkPipelineLayout*)malloc(1*sizeof(VkPipelineLayout));
        auto& arr_NheDZho=json["pPipelineLayout"].as_array();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){deserialize_VkPipelineLayout(arr_NheDZho[QNJuRwu], pPipelineLayout[QNJuRwu]);}();
        }
        }();

    PFN_vkCreatePipelineLayout call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreatePipelineLayout)get_instance_proc_addr(parent,"vkCreatePipelineLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreatePipelineLayout)get_device_proc_addr(parent,"vkCreatePipelineLayout");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pPipelineLayout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_iyZpkhm=json["pCreateInfo"].emplace_array();
        for(int AdWYCmn=0; AdWYCmn < 1; AdWYCmn++){
            [&](){
            auto& temp=arr_iyZpkhm[AdWYCmn].emplace_object();
            return serialize_struct(temp, pCreateInfo[AdWYCmn]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelineLayout==NULL){
                json["pPipelineLayout"]=boost::json::array();
            return; }
        auto& arr_NheDZho=json["pPipelineLayout"].emplace_array();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){serialize_VkPipelineLayout(arr_NheDZho[QNJuRwu],pPipelineLayout[QNJuRwu]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyPipelineLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineLayout pipelineLayout;
[&](){deserialize_VkPipelineLayout(json["pipelineLayout"], pipelineLayout);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyPipelineLayout call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyPipelineLayout)get_instance_proc_addr(parent,"vkDestroyPipelineLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyPipelineLayout)get_device_proc_addr(parent,"vkDestroyPipelineLayout");
    }  
    
{
call_function(device, pipelineLayout, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineLayout(json["pipelineLayout"],pipelineLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateSampler(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSamplerCreateInfo* pCreateInfo;
[&](){ VkSamplerCreateInfo* temp_elQKknk[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_elQKknk=NULL;
            return; }temp_elQKknk=(VkSamplerCreateInfo*)malloc(1*sizeof(VkSamplerCreateInfo));
        auto& arr_tMhVauC=json["pCreateInfo"].as_array();
        for(int yZfhKUj=0; yZfhKUj < 1; yZfhKUj++){
            [&](){
            auto& temp=arr_tMhVauC[yZfhKUj].as_object();
            deserialize_struct(temp,temp_elQKknk[yZfhKUj]);
            }();
        }
        }();pCreateInfo=temp_elQKknk;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkSampler* pSampler;
[&](){
            if (json["pSampler"].as_array().size()==0){
                pSampler=NULL;
            return; }pSampler=(VkSampler*)malloc(1*sizeof(VkSampler));
        auto& arr_nEROYrx=json["pSampler"].as_array();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){deserialize_VkSampler(arr_nEROYrx[iCIaKrl], pSampler[iCIaKrl]);}();
        }
        }();

    PFN_vkCreateSampler call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSampler)get_instance_proc_addr(parent,"vkCreateSampler");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSampler)get_device_proc_addr(parent,"vkCreateSampler");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pSampler);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_xWlqrLm=json["pCreateInfo"].emplace_array();
        for(int yMsdBPh=0; yMsdBPh < 1; yMsdBPh++){
            [&](){
            auto& temp=arr_xWlqrLm[yMsdBPh].emplace_object();
            return serialize_struct(temp, pCreateInfo[yMsdBPh]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSampler==NULL){
                json["pSampler"]=boost::json::array();
            return; }
        auto& arr_nEROYrx=json["pSampler"].emplace_array();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){serialize_VkSampler(arr_nEROYrx[iCIaKrl],pSampler[iCIaKrl]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroySampler(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSampler sampler;
[&](){deserialize_VkSampler(json["sampler"], sampler);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroySampler call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySampler)get_instance_proc_addr(parent,"vkDestroySampler");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySampler)get_device_proc_addr(parent,"vkDestroySampler");
    }  
    
{
call_function(device, sampler, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSampler(json["sampler"],sampler);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateDescriptorSetLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayoutCreateInfo* pCreateInfo;
[&](){ VkDescriptorSetLayoutCreateInfo* temp_JRXOWVB[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_JRXOWVB=NULL;
            return; }temp_JRXOWVB=(VkDescriptorSetLayoutCreateInfo*)malloc(1*sizeof(VkDescriptorSetLayoutCreateInfo));
        auto& arr_oELBvJU=json["pCreateInfo"].as_array();
        for(int RmYFXzA=0; RmYFXzA < 1; RmYFXzA++){
            [&](){
            auto& temp=arr_oELBvJU[RmYFXzA].as_object();
            deserialize_struct(temp,temp_JRXOWVB[RmYFXzA]);
            }();
        }
        }();pCreateInfo=temp_JRXOWVB;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkDescriptorSetLayout* pSetLayout;
[&](){
            if (json["pSetLayout"].as_array().size()==0){
                pSetLayout=NULL;
            return; }pSetLayout=(VkDescriptorSetLayout*)malloc(1*sizeof(VkDescriptorSetLayout));
        auto& arr_iCAhOCt=json["pSetLayout"].as_array();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){deserialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl], pSetLayout[RWEcihl]);}();
        }
        }();

    PFN_vkCreateDescriptorSetLayout call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDescriptorSetLayout)get_instance_proc_addr(parent,"vkCreateDescriptorSetLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDescriptorSetLayout)get_device_proc_addr(parent,"vkCreateDescriptorSetLayout");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pSetLayout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_dFRsqIW=json["pCreateInfo"].emplace_array();
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto& temp=arr_dFRsqIW[tUGauKK].emplace_object();
            return serialize_struct(temp, pCreateInfo[tUGauKK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSetLayout==NULL){
                json["pSetLayout"]=boost::json::array();
            return; }
        auto& arr_iCAhOCt=json["pSetLayout"].emplace_array();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){serialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl],pSetLayout[RWEcihl]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyDescriptorSetLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayout descriptorSetLayout;
[&](){deserialize_VkDescriptorSetLayout(json["descriptorSetLayout"], descriptorSetLayout);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyDescriptorSetLayout call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDescriptorSetLayout)get_instance_proc_addr(parent,"vkDestroyDescriptorSetLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDescriptorSetLayout)get_device_proc_addr(parent,"vkDestroyDescriptorSetLayout");
    }  
    
{
call_function(device, descriptorSetLayout, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["descriptorSetLayout"],descriptorSetLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateDescriptorPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPoolCreateInfo* pCreateInfo;
[&](){ VkDescriptorPoolCreateInfo* temp_musTBgd[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_musTBgd=NULL;
            return; }temp_musTBgd=(VkDescriptorPoolCreateInfo*)malloc(1*sizeof(VkDescriptorPoolCreateInfo));
        auto& arr_aaNyAKF=json["pCreateInfo"].as_array();
        for(int zIfzhBg=0; zIfzhBg < 1; zIfzhBg++){
            [&](){
            auto& temp=arr_aaNyAKF[zIfzhBg].as_object();
            deserialize_struct(temp,temp_musTBgd[zIfzhBg]);
            }();
        }
        }();pCreateInfo=temp_musTBgd;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkDescriptorPool* pDescriptorPool;
[&](){
            if (json["pDescriptorPool"].as_array().size()==0){
                pDescriptorPool=NULL;
            return; }pDescriptorPool=(VkDescriptorPool*)malloc(1*sizeof(VkDescriptorPool));
        auto& arr_zvYCksx=json["pDescriptorPool"].as_array();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){deserialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo], pDescriptorPool[UuMLZWo]);}();
        }
        }();

    PFN_vkCreateDescriptorPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDescriptorPool)get_instance_proc_addr(parent,"vkCreateDescriptorPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDescriptorPool)get_device_proc_addr(parent,"vkCreateDescriptorPool");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pDescriptorPool);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_fChMCRL=json["pCreateInfo"].emplace_array();
        for(int XgrRVVh=0; XgrRVVh < 1; XgrRVVh++){
            [&](){
            auto& temp=arr_fChMCRL[XgrRVVh].emplace_object();
            return serialize_struct(temp, pCreateInfo[XgrRVVh]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDescriptorPool==NULL){
                json["pDescriptorPool"]=boost::json::array();
            return; }
        auto& arr_zvYCksx=json["pDescriptorPool"].emplace_array();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){serialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo],pDescriptorPool[UuMLZWo]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyDescriptorPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPool descriptorPool;
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyDescriptorPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDescriptorPool)get_instance_proc_addr(parent,"vkDestroyDescriptorPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDescriptorPool)get_device_proc_addr(parent,"vkDestroyDescriptorPool");
    }  
    
{
call_function(device, descriptorPool, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkResetDescriptorPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPool descriptorPool;
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
VkDescriptorPoolResetFlags flags;
[&](){[&](){int temp_zAsidUJ;[&](){temp_zAsidUJ=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkDescriptorPoolResetFlags)temp_zAsidUJ;}();}();

    PFN_vkResetDescriptorPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetDescriptorPool)get_instance_proc_addr(parent,"vkResetDescriptorPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetDescriptorPool)get_device_proc_addr(parent,"vkResetDescriptorPool");
    }  
    
{
auto result=call_function(device, descriptorPool, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        writeToConn(json);
    }

    void handle_vkAllocateDescriptorSets(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetAllocateInfo* pAllocateInfo;
[&](){ VkDescriptorSetAllocateInfo* temp_phatNqO[&](){
            if (json["pAllocateInfo"].as_array().size()==0){
                temp_phatNqO=NULL;
            return; }temp_phatNqO=(VkDescriptorSetAllocateInfo*)malloc(1*sizeof(VkDescriptorSetAllocateInfo));
        auto& arr_scxnpgA=json["pAllocateInfo"].as_array();
        for(int LkJrMgh=0; LkJrMgh < 1; LkJrMgh++){
            [&](){
            auto& temp=arr_scxnpgA[LkJrMgh].as_object();
            deserialize_struct(temp,temp_phatNqO[LkJrMgh]);
            }();
        }
        }();pAllocateInfo=temp_phatNqO;}();
VkDescriptorSet* pDescriptorSets;
[&](){
            if (json["pDescriptorSets"].as_array().size()==0){
                pDescriptorSets=NULL;
            return; }pDescriptorSets=(VkDescriptorSet*)malloc(pAllocateInfo->descriptorSetCount*sizeof(VkDescriptorSet));
        auto& arr_hwQSDBT=json["pDescriptorSets"].as_array();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){deserialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY], pDescriptorSets[spXEqJY]);}();
        }
        }();

    PFN_vkAllocateDescriptorSets call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAllocateDescriptorSets)get_instance_proc_addr(parent,"vkAllocateDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAllocateDescriptorSets)get_device_proc_addr(parent,"vkAllocateDescriptorSets");
    }  
    
{
auto result=call_function(device, pAllocateInfo, pDescriptorSets);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }
        auto& arr_yVqYJHW=json["pAllocateInfo"].emplace_array();
        for(int jTINpTr=0; jTINpTr < 1; jTINpTr++){
            [&](){
            auto& temp=arr_yVqYJHW[jTINpTr].emplace_object();
            return serialize_struct(temp, pAllocateInfo[jTINpTr]);
            }();
        }
        }();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }
        auto& arr_hwQSDBT=json["pDescriptorSets"].emplace_array();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){serialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY],pDescriptorSets[spXEqJY]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkFreeDescriptorSets(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPool descriptorPool;
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
uint32_t descriptorSetCount;
[&](){descriptorSetCount=static_cast<uint32_t>(value_to<int>(json["descriptorSetCount"]));}();
VkDescriptorSet* pDescriptorSets;
[&](){ VkDescriptorSet* temp_ypxprPw[&](){
            if (json["pDescriptorSets"].as_array().size()==0){
                temp_ypxprPw=NULL;
            return; }temp_ypxprPw=(VkDescriptorSet*)malloc(descriptorSetCount*sizeof(VkDescriptorSet));
        auto& arr_EoTJzqV=json["pDescriptorSets"].as_array();
        for(int ignhEiw=0; ignhEiw < descriptorSetCount; ignhEiw++){
            [&](){deserialize_VkDescriptorSet(arr_EoTJzqV[ignhEiw], temp_ypxprPw[ignhEiw]);}();
        }
        }();pDescriptorSets=temp_ypxprPw;}();

    PFN_vkFreeDescriptorSets call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkFreeDescriptorSets)get_instance_proc_addr(parent,"vkFreeDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkFreeDescriptorSets)get_device_proc_addr(parent,"vkFreeDescriptorSets");
    }  
    
{
auto result=call_function(device, descriptorPool, descriptorSetCount, pDescriptorSets);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){json["descriptorSetCount"]=descriptorSetCount;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }
        auto& arr_JZNsxgK=json["pDescriptorSets"].emplace_array();
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkUpdateDescriptorSets(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t descriptorWriteCount;
[&](){descriptorWriteCount=static_cast<uint32_t>(value_to<int>(json["descriptorWriteCount"]));}();
VkWriteDescriptorSet* pDescriptorWrites;
[&](){ VkWriteDescriptorSet* temp_RotfizJ[&](){
            if (json["pDescriptorWrites"].as_array().size()==0){
                temp_RotfizJ=NULL;
            return; }temp_RotfizJ=(VkWriteDescriptorSet*)malloc(descriptorWriteCount*sizeof(VkWriteDescriptorSet));
        auto& arr_YJcGFpk=json["pDescriptorWrites"].as_array();
        for(int PyFuMgH=0; PyFuMgH < descriptorWriteCount; PyFuMgH++){
            [&](){
            auto& temp=arr_YJcGFpk[PyFuMgH].as_object();
            deserialize_struct(temp,temp_RotfizJ[PyFuMgH]);
            }();
        }
        }();pDescriptorWrites=temp_RotfizJ;}();
uint32_t descriptorCopyCount;
[&](){descriptorCopyCount=static_cast<uint32_t>(value_to<int>(json["descriptorCopyCount"]));}();
VkCopyDescriptorSet* pDescriptorCopies;
[&](){ VkCopyDescriptorSet* temp_yaFNCDe[&](){
            if (json["pDescriptorCopies"].as_array().size()==0){
                temp_yaFNCDe=NULL;
            return; }temp_yaFNCDe=(VkCopyDescriptorSet*)malloc(descriptorCopyCount*sizeof(VkCopyDescriptorSet));
        auto& arr_kgDeqJO=json["pDescriptorCopies"].as_array();
        for(int ygJPsJJ=0; ygJPsJJ < descriptorCopyCount; ygJPsJJ++){
            [&](){
            auto& temp=arr_kgDeqJO[ygJPsJJ].as_object();
            deserialize_struct(temp,temp_yaFNCDe[ygJPsJJ]);
            }();
        }
        }();pDescriptorCopies=temp_yaFNCDe;}();

    PFN_vkUpdateDescriptorSets call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUpdateDescriptorSets)get_instance_proc_addr(parent,"vkUpdateDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUpdateDescriptorSets)get_device_proc_addr(parent,"vkUpdateDescriptorSets");
    }  
    
{
call_function(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["descriptorWriteCount"]=descriptorWriteCount;}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=boost::json::array();
            return; }
        auto& arr_AuOrFWk=json["pDescriptorWrites"].emplace_array();
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto& temp=arr_AuOrFWk[qJACxKx].emplace_object();
            return serialize_struct(temp, pDescriptorWrites[qJACxKx]);
            }();
        }
        }();
[&](){json["descriptorCopyCount"]=descriptorCopyCount;}();
[&](){
            if (pDescriptorCopies==NULL){
                json["pDescriptorCopies"]=boost::json::array();
            return; }
        auto& arr_WWZDhqd=json["pDescriptorCopies"].emplace_array();
        for(int ryeXdkw=0; ryeXdkw < descriptorCopyCount; ryeXdkw++){
            [&](){
            auto& temp=arr_WWZDhqd[ryeXdkw].emplace_object();
            return serialize_struct(temp, pDescriptorCopies[ryeXdkw]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateFramebuffer(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFramebufferCreateInfo* pCreateInfo;
[&](){ VkFramebufferCreateInfo* temp_yBfXASx[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_yBfXASx=NULL;
            return; }temp_yBfXASx=(VkFramebufferCreateInfo*)malloc(1*sizeof(VkFramebufferCreateInfo));
        auto& arr_JrEGPNB=json["pCreateInfo"].as_array();
        for(int NUUgVax=0; NUUgVax < 1; NUUgVax++){
            [&](){
            auto& temp=arr_JrEGPNB[NUUgVax].as_object();
            deserialize_struct(temp,temp_yBfXASx[NUUgVax]);
            }();
        }
        }();pCreateInfo=temp_yBfXASx;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkFramebuffer* pFramebuffer;
[&](){
            if (json["pFramebuffer"].as_array().size()==0){
                pFramebuffer=NULL;
            return; }pFramebuffer=(VkFramebuffer*)malloc(1*sizeof(VkFramebuffer));
        auto& arr_xECXRAK=json["pFramebuffer"].as_array();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){deserialize_VkFramebuffer(arr_xECXRAK[zDUSKRl], pFramebuffer[zDUSKRl]);}();
        }
        }();

    PFN_vkCreateFramebuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateFramebuffer)get_instance_proc_addr(parent,"vkCreateFramebuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateFramebuffer)get_device_proc_addr(parent,"vkCreateFramebuffer");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pFramebuffer);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_LBIrWmz=json["pCreateInfo"].emplace_array();
        for(int jMLqpUb=0; jMLqpUb < 1; jMLqpUb++){
            [&](){
            auto& temp=arr_LBIrWmz[jMLqpUb].emplace_object();
            return serialize_struct(temp, pCreateInfo[jMLqpUb]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFramebuffer==NULL){
                json["pFramebuffer"]=boost::json::array();
            return; }
        auto& arr_xECXRAK=json["pFramebuffer"].emplace_array();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){serialize_VkFramebuffer(arr_xECXRAK[zDUSKRl],pFramebuffer[zDUSKRl]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyFramebuffer(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFramebuffer framebuffer;
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyFramebuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyFramebuffer)get_instance_proc_addr(parent,"vkDestroyFramebuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyFramebuffer)get_device_proc_addr(parent,"vkDestroyFramebuffer");
    }  
    
{
call_function(device, framebuffer, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateRenderPass(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPassCreateInfo* pCreateInfo;
[&](){ VkRenderPassCreateInfo* temp_nZEGjxk[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_nZEGjxk=NULL;
            return; }temp_nZEGjxk=(VkRenderPassCreateInfo*)malloc(1*sizeof(VkRenderPassCreateInfo));
        auto& arr_aQkDqwy=json["pCreateInfo"].as_array();
        for(int RbeQDgp=0; RbeQDgp < 1; RbeQDgp++){
            [&](){
            auto& temp=arr_aQkDqwy[RbeQDgp].as_object();
            deserialize_struct(temp,temp_nZEGjxk[RbeQDgp]);
            }();
        }
        }();pCreateInfo=temp_nZEGjxk;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkRenderPass* pRenderPass;
[&](){
            if (json["pRenderPass"].as_array().size()==0){
                pRenderPass=NULL;
            return; }pRenderPass=(VkRenderPass*)malloc(1*sizeof(VkRenderPass));
        auto& arr_ZwdXTfx=json["pRenderPass"].as_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();

    PFN_vkCreateRenderPass call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateRenderPass)get_instance_proc_addr(parent,"vkCreateRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateRenderPass)get_device_proc_addr(parent,"vkCreateRenderPass");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pRenderPass);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_upxhtZe=json["pCreateInfo"].emplace_array();
        for(int oHJSJzU=0; oHJSJzU < 1; oHJSJzU++){
            [&](){
            auto& temp=arr_upxhtZe[oHJSJzU].emplace_object();
            return serialize_struct(temp, pCreateInfo[oHJSJzU]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=boost::json::array();
            return; }
        auto& arr_ZwdXTfx=json["pRenderPass"].emplace_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyRenderPass(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPass renderPass;
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyRenderPass call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyRenderPass)get_instance_proc_addr(parent,"vkDestroyRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyRenderPass)get_device_proc_addr(parent,"vkDestroyRenderPass");
    }  
    
{
call_function(device, renderPass, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetRenderAreaGranularity(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPass renderPass;
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();
VkExtent2D* pGranularity;
[&](){
            if (json["pGranularity"].as_array().size()==0){
                pGranularity=NULL;
            return; }pGranularity=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));
        auto& arr_VvmWHYL=json["pGranularity"].as_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].as_object();
            deserialize_struct(temp,pGranularity[tgiNLQL]);
            }();
        }
        }();

    PFN_vkGetRenderAreaGranularity call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRenderAreaGranularity)get_instance_proc_addr(parent,"vkGetRenderAreaGranularity");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRenderAreaGranularity)get_device_proc_addr(parent,"vkGetRenderAreaGranularity");
    }  
    
{
call_function(device, renderPass, pGranularity);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=boost::json::array();
            return; }
        auto& arr_VvmWHYL=json["pGranularity"].emplace_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].emplace_object();
            return serialize_struct(temp, pGranularity[tgiNLQL]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetRenderingAreaGranularityKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderingAreaInfoKHR* pRenderingAreaInfo;
[&](){ VkRenderingAreaInfoKHR* temp_jpMwmxR[&](){
            if (json["pRenderingAreaInfo"].as_array().size()==0){
                temp_jpMwmxR=NULL;
            return; }temp_jpMwmxR=(VkRenderingAreaInfoKHR*)malloc(1*sizeof(VkRenderingAreaInfoKHR));
        auto& arr_WDJFhzk=json["pRenderingAreaInfo"].as_array();
        for(int Eyzmwzy=0; Eyzmwzy < 1; Eyzmwzy++){
            [&](){
            auto& temp=arr_WDJFhzk[Eyzmwzy].as_object();
            deserialize_struct(temp,temp_jpMwmxR[Eyzmwzy]);
            }();
        }
        }();pRenderingAreaInfo=temp_jpMwmxR;}();
VkExtent2D* pGranularity;
[&](){
            if (json["pGranularity"].as_array().size()==0){
                pGranularity=NULL;
            return; }pGranularity=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));
        auto& arr_VvmWHYL=json["pGranularity"].as_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].as_object();
            deserialize_struct(temp,pGranularity[tgiNLQL]);
            }();
        }
        }();

    PFN_vkGetRenderingAreaGranularityKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRenderingAreaGranularityKHR)get_instance_proc_addr(parent,"vkGetRenderingAreaGranularityKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRenderingAreaGranularityKHR)get_device_proc_addr(parent,"vkGetRenderingAreaGranularityKHR");
    }  
    
{
call_function(device, pRenderingAreaInfo, pGranularity);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingAreaInfo==NULL){
                json["pRenderingAreaInfo"]=boost::json::array();
            return; }
        auto& arr_QFvDqfG=json["pRenderingAreaInfo"].emplace_array();
        for(int WRYBJDa=0; WRYBJDa < 1; WRYBJDa++){
            [&](){
            auto& temp=arr_QFvDqfG[WRYBJDa].emplace_object();
            return serialize_struct(temp, pRenderingAreaInfo[WRYBJDa]);
            }();
        }
        }();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=boost::json::array();
            return; }
        auto& arr_VvmWHYL=json["pGranularity"].emplace_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].emplace_object();
            return serialize_struct(temp, pGranularity[tgiNLQL]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateCommandPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPoolCreateInfo* pCreateInfo;
[&](){ VkCommandPoolCreateInfo* temp_TXLADqx[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_TXLADqx=NULL;
            return; }temp_TXLADqx=(VkCommandPoolCreateInfo*)malloc(1*sizeof(VkCommandPoolCreateInfo));
        auto& arr_gbWnDrT=json["pCreateInfo"].as_array();
        for(int kFYaAKf=0; kFYaAKf < 1; kFYaAKf++){
            [&](){
            auto& temp=arr_gbWnDrT[kFYaAKf].as_object();
            deserialize_struct(temp,temp_TXLADqx[kFYaAKf]);
            }();
        }
        }();pCreateInfo=temp_TXLADqx;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkCommandPool* pCommandPool;
[&](){
            if (json["pCommandPool"].as_array().size()==0){
                pCommandPool=NULL;
            return; }pCommandPool=(VkCommandPool*)malloc(1*sizeof(VkCommandPool));
        auto& arr_ohCGecZ=json["pCommandPool"].as_array();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){deserialize_VkCommandPool(arr_ohCGecZ[oHETrgL], pCommandPool[oHETrgL]);}();
        }
        }();

    PFN_vkCreateCommandPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateCommandPool)get_instance_proc_addr(parent,"vkCreateCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateCommandPool)get_device_proc_addr(parent,"vkCreateCommandPool");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pCommandPool);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_ISnaSOj=json["pCreateInfo"].emplace_array();
        for(int ubLLexW=0; ubLLexW < 1; ubLLexW++){
            [&](){
            auto& temp=arr_ISnaSOj[ubLLexW].emplace_object();
            return serialize_struct(temp, pCreateInfo[ubLLexW]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pCommandPool==NULL){
                json["pCommandPool"]=boost::json::array();
            return; }
        auto& arr_ohCGecZ=json["pCommandPool"].emplace_array();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){serialize_VkCommandPool(arr_ohCGecZ[oHETrgL],pCommandPool[oHETrgL]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyCommandPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyCommandPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyCommandPool)get_instance_proc_addr(parent,"vkDestroyCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyCommandPool)get_device_proc_addr(parent,"vkDestroyCommandPool");
    }  
    
{
call_function(device, commandPool, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkResetCommandPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
VkCommandPoolResetFlags flags;
[&](){[&](){int temp_ZfbLqrp;[&](){temp_ZfbLqrp=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkCommandPoolResetFlags)temp_ZfbLqrp;}();}();

    PFN_vkResetCommandPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetCommandPool)get_instance_proc_addr(parent,"vkResetCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetCommandPool)get_device_proc_addr(parent,"vkResetCommandPool");
    }  
    
{
auto result=call_function(device, commandPool, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        writeToConn(json);
    }

    void handle_vkAllocateCommandBuffers(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandBufferAllocateInfo* pAllocateInfo;
[&](){ VkCommandBufferAllocateInfo* temp_XuIPIXe[&](){
            if (json["pAllocateInfo"].as_array().size()==0){
                temp_XuIPIXe=NULL;
            return; }temp_XuIPIXe=(VkCommandBufferAllocateInfo*)malloc(1*sizeof(VkCommandBufferAllocateInfo));
        auto& arr_IZSSdEC=json["pAllocateInfo"].as_array();
        for(int VNokfaI=0; VNokfaI < 1; VNokfaI++){
            [&](){
            auto& temp=arr_IZSSdEC[VNokfaI].as_object();
            deserialize_struct(temp,temp_XuIPIXe[VNokfaI]);
            }();
        }
        }();pAllocateInfo=temp_XuIPIXe;}();
VkCommandBuffer* pCommandBuffers;
[&](){
            if (json["pCommandBuffers"].as_array().size()==0){
                pCommandBuffers=NULL;
            return; }pCommandBuffers=(VkCommandBuffer*)malloc(pAllocateInfo->commandBufferCount*sizeof(VkCommandBuffer));
        auto& arr_WZYlBGU=json["pCommandBuffers"].as_array();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){deserialize_VkCommandBuffer(arr_WZYlBGU[RztseIK], pCommandBuffers[RztseIK]);}();
        }
        }();

    PFN_vkAllocateCommandBuffers call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAllocateCommandBuffers)get_instance_proc_addr(parent,"vkAllocateCommandBuffers");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAllocateCommandBuffers)get_device_proc_addr(parent,"vkAllocateCommandBuffers");
    }  
    
{
auto result=call_function(device, pAllocateInfo, pCommandBuffers);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }
        auto& arr_ZURucFE=json["pAllocateInfo"].emplace_array();
        for(int VMrKYrr=0; VMrKYrr < 1; VMrKYrr++){
            [&](){
            auto& temp=arr_ZURucFE[VMrKYrr].emplace_object();
            return serialize_struct(temp, pAllocateInfo[VMrKYrr]);
            }();
        }
        }();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }
        auto& arr_WZYlBGU=json["pCommandBuffers"].emplace_array();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){serialize_VkCommandBuffer(arr_WZYlBGU[RztseIK],pCommandBuffers[RztseIK]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkFreeCommandBuffers(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
uint32_t commandBufferCount;
[&](){commandBufferCount=static_cast<uint32_t>(value_to<int>(json["commandBufferCount"]));}();
VkCommandBuffer* pCommandBuffers;
[&](){ VkCommandBuffer* temp_zutnffS[&](){
            if (json["pCommandBuffers"].as_array().size()==0){
                temp_zutnffS=NULL;
            return; }temp_zutnffS=(VkCommandBuffer*)malloc(commandBufferCount*sizeof(VkCommandBuffer));
        auto& arr_aIQpbyi=json["pCommandBuffers"].as_array();
        for(int Neoyndt=0; Neoyndt < commandBufferCount; Neoyndt++){
            [&](){deserialize_VkCommandBuffer(arr_aIQpbyi[Neoyndt], temp_zutnffS[Neoyndt]);}();
        }
        }();pCommandBuffers=temp_zutnffS;}();

    PFN_vkFreeCommandBuffers call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkFreeCommandBuffers)get_instance_proc_addr(parent,"vkFreeCommandBuffers");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkFreeCommandBuffers)get_device_proc_addr(parent,"vkFreeCommandBuffers");
    }  
    
{
call_function(device, commandPool, commandBufferCount, pCommandBuffers);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){json["commandBufferCount"]=commandBufferCount;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }
        auto& arr_PdRlpEO=json["pCommandBuffers"].emplace_array();
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBeginCommandBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCommandBufferBeginInfo* pBeginInfo;
[&](){ VkCommandBufferBeginInfo* temp_UBfumFg[&](){
            if (json["pBeginInfo"].as_array().size()==0){
                temp_UBfumFg=NULL;
            return; }temp_UBfumFg=(VkCommandBufferBeginInfo*)malloc(1*sizeof(VkCommandBufferBeginInfo));
        auto& arr_IMPwIrn=json["pBeginInfo"].as_array();
        for(int yjPwvUw=0; yjPwvUw < 1; yjPwvUw++){
            [&](){
            auto& temp=arr_IMPwIrn[yjPwvUw].as_object();
            deserialize_struct(temp,temp_UBfumFg[yjPwvUw]);
            }();
        }
        }();pBeginInfo=temp_UBfumFg;}();

    PFN_vkBeginCommandBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBeginCommandBuffer)get_instance_proc_addr(parent,"vkBeginCommandBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBeginCommandBuffer)get_device_proc_addr(parent,"vkBeginCommandBuffer");
    }  
    
{
auto result=call_function(commandBuffer, pBeginInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=boost::json::array();
            return; }
        auto& arr_cULABHU=json["pBeginInfo"].emplace_array();
        for(int MlslWJM=0; MlslWJM < 1; MlslWJM++){
            [&](){
            auto& temp=arr_cULABHU[MlslWJM].emplace_object();
            return serialize_struct(temp, pBeginInfo[MlslWJM]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkEndCommandBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkEndCommandBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEndCommandBuffer)get_instance_proc_addr(parent,"vkEndCommandBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEndCommandBuffer)get_device_proc_addr(parent,"vkEndCommandBuffer");
    }  
    
{
auto result=call_function(commandBuffer);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        writeToConn(json);
    }

    void handle_vkResetCommandBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCommandBufferResetFlags flags;
[&](){[&](){int temp_lxCkbVG;[&](){temp_lxCkbVG=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkCommandBufferResetFlags)temp_lxCkbVG;}();}();

    PFN_vkResetCommandBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetCommandBuffer)get_instance_proc_addr(parent,"vkResetCommandBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetCommandBuffer)get_device_proc_addr(parent,"vkResetCommandBuffer");
    }  
    
{
auto result=call_function(commandBuffer, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdBindPipeline(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

    PFN_vkCmdBindPipeline call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindPipeline)get_instance_proc_addr(parent,"vkCmdBindPipeline");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindPipeline)get_device_proc_addr(parent,"vkCmdBindPipeline");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, pipeline);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();


        writeToConn(json);
    }

    void handle_vkCmdSetAttachmentFeedbackLoopEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImageAspectFlags aspectMask;
[&](){[&](){int temp_LWxAVsj;[&](){temp_LWxAVsj=static_cast<int>(value_to<int>(json["aspectMask"]));}();aspectMask=(VkImageAspectFlags)temp_LWxAVsj;}();}();

    PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)get_instance_proc_addr(parent,"vkCmdSetAttachmentFeedbackLoopEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)get_device_proc_addr(parent,"vkCmdSetAttachmentFeedbackLoopEnableEXT");
    }  
    
{
call_function(commandBuffer, aspectMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["aspectMask"]=aspectMask;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetViewport(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){firstViewport=static_cast<uint32_t>(value_to<int>(json["firstViewport"]));}();
uint32_t viewportCount;
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();
VkViewport* pViewports;
[&](){ VkViewport* temp_NINOLjT[&](){
            if (json["pViewports"].as_array().size()==0){
                temp_NINOLjT=NULL;
            return; }temp_NINOLjT=(VkViewport*)malloc(viewportCount*sizeof(VkViewport));
        auto& arr_NYoDqxX=json["pViewports"].as_array();
        for(int SjlAQpy=0; SjlAQpy < viewportCount; SjlAQpy++){
            [&](){
            auto& temp=arr_NYoDqxX[SjlAQpy].as_object();
            deserialize_struct(temp,temp_NINOLjT[SjlAQpy]);
            }();
        }
        }();pViewports=temp_NINOLjT;}();

    PFN_vkCmdSetViewport call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewport)get_instance_proc_addr(parent,"vkCmdSetViewport");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewport)get_device_proc_addr(parent,"vkCmdSetViewport");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pViewports);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=boost::json::array();
            return; }
        auto& arr_SyYryUE=json["pViewports"].emplace_array();
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto& temp=arr_SyYryUE[HAuJlzw].emplace_object();
            return serialize_struct(temp, pViewports[HAuJlzw]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetScissor(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstScissor;
[&](){firstScissor=static_cast<uint32_t>(value_to<int>(json["firstScissor"]));}();
uint32_t scissorCount;
[&](){scissorCount=static_cast<uint32_t>(value_to<int>(json["scissorCount"]));}();
VkRect2D* pScissors;
[&](){ VkRect2D* temp_FCRcmyF[&](){
            if (json["pScissors"].as_array().size()==0){
                temp_FCRcmyF=NULL;
            return; }temp_FCRcmyF=(VkRect2D*)malloc(scissorCount*sizeof(VkRect2D));
        auto& arr_bIRAuhj=json["pScissors"].as_array();
        for(int QukNmCZ=0; QukNmCZ < scissorCount; QukNmCZ++){
            [&](){
            auto& temp=arr_bIRAuhj[QukNmCZ].as_object();
            deserialize_struct(temp,temp_FCRcmyF[QukNmCZ]);
            }();
        }
        }();pScissors=temp_FCRcmyF;}();

    PFN_vkCmdSetScissor call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetScissor)get_instance_proc_addr(parent,"vkCmdSetScissor");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetScissor)get_device_proc_addr(parent,"vkCmdSetScissor");
    }  
    
{
call_function(commandBuffer, firstScissor, scissorCount, pScissors);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstScissor"]=firstScissor;}();
[&](){json["scissorCount"]=scissorCount;}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=boost::json::array();
            return; }
        auto& arr_RpUaBcS=json["pScissors"].emplace_array();
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto& temp=arr_RpUaBcS[XBYGvVT].emplace_object();
            return serialize_struct(temp, pScissors[XBYGvVT]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetLineWidth(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float lineWidth;
[&](){lineWidth=static_cast<float>(value_to<int>(json["lineWidth"]));}();

    PFN_vkCmdSetLineWidth call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLineWidth)get_instance_proc_addr(parent,"vkCmdSetLineWidth");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLineWidth)get_device_proc_addr(parent,"vkCmdSetLineWidth");
    }  
    
{
call_function(commandBuffer, lineWidth);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineWidth"]=lineWidth;}();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthBias(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float depthBiasConstantFactor;
[&](){depthBiasConstantFactor=static_cast<float>(value_to<int>(json["depthBiasConstantFactor"]));}();
float depthBiasClamp;
[&](){depthBiasClamp=static_cast<float>(value_to<int>(json["depthBiasClamp"]));}();
float depthBiasSlopeFactor;
[&](){depthBiasSlopeFactor=static_cast<float>(value_to<int>(json["depthBiasSlopeFactor"]));}();

    PFN_vkCmdSetDepthBias call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBias)get_instance_proc_addr(parent,"vkCmdSetDepthBias");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBias)get_device_proc_addr(parent,"vkCmdSetDepthBias");
    }  
    
{
call_function(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["depthBiasConstantFactor"]=depthBiasConstantFactor;}();
[&](){json["depthBiasClamp"]=depthBiasClamp;}();
[&](){json["depthBiasSlopeFactor"]=depthBiasSlopeFactor;}();


        writeToConn(json);
    }

    void handle_vkCmdSetBlendConstants(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float blendConstants[4];
[&](){
        auto& arr_SsKZRbG=json["blendConstants"].as_array();
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            [&](){ float temp_SsKZRbG[4][&](){temp_SsKZRbG=static_cast<float>(value_to<int>(arr_SsKZRbG[lLRJClr]));}();blendConstants[lLRJClr]=temp_SsKZRbG;}();
        }
        }();

    PFN_vkCmdSetBlendConstants call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetBlendConstants)get_instance_proc_addr(parent,"vkCmdSetBlendConstants");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetBlendConstants)get_device_proc_addr(parent,"vkCmdSetBlendConstants");
    }  
    
{
call_function(commandBuffer, blendConstants);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
        auto& arr_SsKZRbG=json["blendConstants"].emplace_array();
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            [&](){arr_SsKZRbG[lLRJClr]=blendConstants[lLRJClr];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthBounds(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float minDepthBounds;
[&](){minDepthBounds=static_cast<float>(value_to<int>(json["minDepthBounds"]));}();
float maxDepthBounds;
[&](){maxDepthBounds=static_cast<float>(value_to<int>(json["maxDepthBounds"]));}();

    PFN_vkCmdSetDepthBounds call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBounds)get_instance_proc_addr(parent,"vkCmdSetDepthBounds");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBounds)get_device_proc_addr(parent,"vkCmdSetDepthBounds");
    }  
    
{
call_function(commandBuffer, minDepthBounds, maxDepthBounds);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["minDepthBounds"]=minDepthBounds;}();
[&](){json["maxDepthBounds"]=maxDepthBounds;}();


        writeToConn(json);
    }

    void handle_vkCmdSetStencilCompareMask(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){temp_VFXTqgy=static_cast<int>(value_to<int>(json["faceMask"]));}();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
uint32_t compareMask;
[&](){compareMask=static_cast<uint32_t>(value_to<int>(json["compareMask"]));}();

    PFN_vkCmdSetStencilCompareMask call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilCompareMask)get_instance_proc_addr(parent,"vkCmdSetStencilCompareMask");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilCompareMask)get_device_proc_addr(parent,"vkCmdSetStencilCompareMask");
    }  
    
{
call_function(commandBuffer, faceMask, compareMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["compareMask"]=compareMask;}();


        writeToConn(json);
    }

    void handle_vkCmdSetStencilWriteMask(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){temp_VFXTqgy=static_cast<int>(value_to<int>(json["faceMask"]));}();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
uint32_t writeMask;
[&](){writeMask=static_cast<uint32_t>(value_to<int>(json["writeMask"]));}();

    PFN_vkCmdSetStencilWriteMask call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilWriteMask)get_instance_proc_addr(parent,"vkCmdSetStencilWriteMask");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilWriteMask)get_device_proc_addr(parent,"vkCmdSetStencilWriteMask");
    }  
    
{
call_function(commandBuffer, faceMask, writeMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["writeMask"]=writeMask;}();


        writeToConn(json);
    }

    void handle_vkCmdSetStencilReference(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){temp_VFXTqgy=static_cast<int>(value_to<int>(json["faceMask"]));}();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
uint32_t reference;
[&](){reference=static_cast<uint32_t>(value_to<int>(json["reference"]));}();

    PFN_vkCmdSetStencilReference call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilReference)get_instance_proc_addr(parent,"vkCmdSetStencilReference");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilReference)get_device_proc_addr(parent,"vkCmdSetStencilReference");
    }  
    
{
call_function(commandBuffer, faceMask, reference);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["reference"]=reference;}();


        writeToConn(json);
    }

    void handle_vkCmdBindDescriptorSets(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t firstSet;
[&](){firstSet=static_cast<uint32_t>(value_to<int>(json["firstSet"]));}();
uint32_t descriptorSetCount;
[&](){descriptorSetCount=static_cast<uint32_t>(value_to<int>(json["descriptorSetCount"]));}();
VkDescriptorSet* pDescriptorSets;
[&](){ VkDescriptorSet* temp_ypxprPw[&](){
            if (json["pDescriptorSets"].as_array().size()==0){
                temp_ypxprPw=NULL;
            return; }temp_ypxprPw=(VkDescriptorSet*)malloc(descriptorSetCount*sizeof(VkDescriptorSet));
        auto& arr_EoTJzqV=json["pDescriptorSets"].as_array();
        for(int ignhEiw=0; ignhEiw < descriptorSetCount; ignhEiw++){
            [&](){deserialize_VkDescriptorSet(arr_EoTJzqV[ignhEiw], temp_ypxprPw[ignhEiw]);}();
        }
        }();pDescriptorSets=temp_ypxprPw;}();
uint32_t dynamicOffsetCount;
[&](){dynamicOffsetCount=static_cast<uint32_t>(value_to<int>(json["dynamicOffsetCount"]));}();
uint32_t* pDynamicOffsets;
[&](){ uint32_t* temp_jGgZaTJ[&](){
            if (json["pDynamicOffsets"].as_array().size()==0){
                temp_jGgZaTJ=NULL;
            return; }temp_jGgZaTJ=(uint32_t*)malloc(dynamicOffsetCount*sizeof(uint32_t));
        auto& arr_QbUQxOl=json["pDynamicOffsets"].as_array();
        for(int yNPUnDM=0; yNPUnDM < dynamicOffsetCount; yNPUnDM++){
            [&](){temp_jGgZaTJ[yNPUnDM]=static_cast<uint32_t>(value_to<int>(arr_QbUQxOl[yNPUnDM]));}();
        }
        }();pDynamicOffsets=temp_jGgZaTJ;}();

    PFN_vkCmdBindDescriptorSets call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindDescriptorSets)get_instance_proc_addr(parent,"vkCmdBindDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindDescriptorSets)get_device_proc_addr(parent,"vkCmdBindDescriptorSets");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=firstSet;}();
[&](){json["descriptorSetCount"]=descriptorSetCount;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }
        auto& arr_JZNsxgK=json["pDescriptorSets"].emplace_array();
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        }();
[&](){json["dynamicOffsetCount"]=dynamicOffsetCount;}();
[&](){
            if (pDynamicOffsets==NULL){
                json["pDynamicOffsets"]=boost::json::array();
            return; }
        auto& arr_Zetuxcc=json["pDynamicOffsets"].emplace_array();
        for(int nxuqgVF=0; nxuqgVF < dynamicOffsetCount; nxuqgVF++){
            [&](){arr_Zetuxcc[nxuqgVF]=pDynamicOffsets[nxuqgVF];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBindIndexBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
VkIndexType indexType;
[&](){[&](){int temp_GdrXdVh;[&](){temp_GdrXdVh=static_cast<int>(value_to<int>(json["indexType"]));}();indexType=(VkIndexType)temp_GdrXdVh;}();}();

    PFN_vkCmdBindIndexBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindIndexBuffer)get_instance_proc_addr(parent,"vkCmdBindIndexBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindIndexBuffer)get_device_proc_addr(parent,"vkCmdBindIndexBuffer");
    }  
    
{
call_function(commandBuffer, buffer, offset, indexType);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){[&](){json["indexType"]=indexType;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdBindVertexBuffers(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstBinding;
[&](){firstBinding=static_cast<uint32_t>(value_to<int>(json["firstBinding"]));}();
uint32_t bindingCount;
[&](){bindingCount=static_cast<uint32_t>(value_to<int>(json["bindingCount"]));}();
VkBuffer* pBuffers;
[&](){ VkBuffer* temp_XooJXwK[&](){
            if (json["pBuffers"].as_array().size()==0){
                temp_XooJXwK=NULL;
            return; }temp_XooJXwK=(VkBuffer*)malloc(bindingCount*sizeof(VkBuffer));
        auto& arr_ShVTBbp=json["pBuffers"].as_array();
        for(int loSrvWd=0; loSrvWd < bindingCount; loSrvWd++){
            [&](){deserialize_VkBuffer(arr_ShVTBbp[loSrvWd], temp_XooJXwK[loSrvWd]);}();
        }
        }();pBuffers=temp_XooJXwK;}();
VkDeviceSize* pOffsets;
[&](){ VkDeviceSize* temp_rsVsAoT[&](){
            if (json["pOffsets"].as_array().size()==0){
                temp_rsVsAoT=NULL;
            return; }temp_rsVsAoT=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_uWdiGtF=json["pOffsets"].as_array();
        for(int ELYQTNF=0; ELYQTNF < bindingCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){temp_uWdiGtF=static_cast<uint64_t>(value_to<int>(arr_uWdiGtF[ELYQTNF]));}();temp_rsVsAoT[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();pOffsets=temp_rsVsAoT;}();

    PFN_vkCmdBindVertexBuffers call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindVertexBuffers)get_instance_proc_addr(parent,"vkCmdBindVertexBuffers");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindVertexBuffers)get_device_proc_addr(parent,"vkCmdBindVertexBuffers");
    }  
    
{
call_function(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }
        auto& arr_ENtnMTo=json["pBuffers"].emplace_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }
        auto& arr_YvpyTDd=json["pOffsets"].emplace_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDraw(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t vertexCount;
[&](){vertexCount=static_cast<uint32_t>(value_to<int>(json["vertexCount"]));}();
uint32_t instanceCount;
[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
uint32_t firstVertex;
[&](){firstVertex=static_cast<uint32_t>(value_to<int>(json["firstVertex"]));}();
uint32_t firstInstance;
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();

    PFN_vkCmdDraw call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDraw)get_instance_proc_addr(parent,"vkCmdDraw");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDraw)get_device_proc_addr(parent,"vkCmdDraw");
    }  
    
{
call_function(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexCount"]=vertexCount;}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstVertex"]=firstVertex;}();
[&](){json["firstInstance"]=firstInstance;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawIndexed(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t indexCount;
[&](){indexCount=static_cast<uint32_t>(value_to<int>(json["indexCount"]));}();
uint32_t instanceCount;
[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
uint32_t firstIndex;
[&](){firstIndex=static_cast<uint32_t>(value_to<int>(json["firstIndex"]));}();
int32_t vertexOffset;
[&](){vertexOffset=static_cast<int32_t>(value_to<int>(json["vertexOffset"]));}();
uint32_t firstInstance;
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();

    PFN_vkCmdDrawIndexed call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndexed)get_instance_proc_addr(parent,"vkCmdDrawIndexed");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndexed)get_device_proc_addr(parent,"vkCmdDrawIndexed");
    }  
    
{
call_function(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["indexCount"]=indexCount;}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstIndex"]=firstIndex;}();
[&](){json["vertexOffset"]=vertexOffset;}();
[&](){json["firstInstance"]=firstInstance;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawMultiEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t drawCount;
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
VkMultiDrawInfoEXT* pVertexInfo;
[&](){ VkMultiDrawInfoEXT* temp_Oawkcae[&](){
            if (json["pVertexInfo"].as_array().size()==0){
                temp_Oawkcae=NULL;
            return; }temp_Oawkcae=(VkMultiDrawInfoEXT*)malloc(drawCount*sizeof(VkMultiDrawInfoEXT));
        auto& arr_SygHzZS=json["pVertexInfo"].as_array();
        for(int iVtYwjb=0; iVtYwjb < drawCount; iVtYwjb++){
            [&](){
            auto& temp=arr_SygHzZS[iVtYwjb].as_object();
            deserialize_struct(temp,temp_Oawkcae[iVtYwjb]);
            }();
        }
        }();pVertexInfo=temp_Oawkcae;}();
uint32_t instanceCount;
[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
uint32_t firstInstance;
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDrawMultiEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMultiEXT)get_instance_proc_addr(parent,"vkCmdDrawMultiEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMultiEXT)get_device_proc_addr(parent,"vkCmdDrawMultiEXT");
    }  
    
{
call_function(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=drawCount;}();
[&](){
            if (pVertexInfo==NULL){
                json["pVertexInfo"]=boost::json::array();
            return; }
        auto& arr_NmVssTF=json["pVertexInfo"].emplace_array();
        for(int xJCsgzh=0; xJCsgzh < drawCount; xJCsgzh++){
            [&](){
            auto& temp=arr_NmVssTF[xJCsgzh].emplace_object();
            return serialize_struct(temp, pVertexInfo[xJCsgzh]);
            }();
        }
        }();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawMultiIndexedEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t drawCount;
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
VkMultiDrawIndexedInfoEXT* pIndexInfo;
[&](){ VkMultiDrawIndexedInfoEXT* temp_oEhYbjO[&](){
            if (json["pIndexInfo"].as_array().size()==0){
                temp_oEhYbjO=NULL;
            return; }temp_oEhYbjO=(VkMultiDrawIndexedInfoEXT*)malloc(drawCount*sizeof(VkMultiDrawIndexedInfoEXT));
        auto& arr_jliksnn=json["pIndexInfo"].as_array();
        for(int cbQpceE=0; cbQpceE < drawCount; cbQpceE++){
            [&](){
            auto& temp=arr_jliksnn[cbQpceE].as_object();
            deserialize_struct(temp,temp_oEhYbjO[cbQpceE]);
            }();
        }
        }();pIndexInfo=temp_oEhYbjO;}();
uint32_t instanceCount;
[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
uint32_t firstInstance;
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();
int32_t* pVertexOffset;
[&](){ int32_t* temp_qdOrHRD[&](){
            if (json["pVertexOffset"].as_array().size()==0){
                temp_qdOrHRD=NULL;
            return; }temp_qdOrHRD=(int32_t*)malloc(1*sizeof(int32_t));
        auto& arr_IdSDtoD=json["pVertexOffset"].as_array();
        for(int XPkpqBK=0; XPkpqBK < 1; XPkpqBK++){
            [&](){temp_qdOrHRD[XPkpqBK]=static_cast<int32_t>(value_to<int>(arr_IdSDtoD[XPkpqBK]));}();
        }
        }();pVertexOffset=temp_qdOrHRD;}();

    PFN_vkCmdDrawMultiIndexedEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMultiIndexedEXT)get_instance_proc_addr(parent,"vkCmdDrawMultiIndexedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMultiIndexedEXT)get_device_proc_addr(parent,"vkCmdDrawMultiIndexedEXT");
    }  
    
{
call_function(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=drawCount;}();
[&](){
            if (pIndexInfo==NULL){
                json["pIndexInfo"]=boost::json::array();
            return; }
        auto& arr_OvAOCiL=json["pIndexInfo"].emplace_array();
        for(int FmfkOAV=0; FmfkOAV < drawCount; FmfkOAV++){
            [&](){
            auto& temp=arr_OvAOCiL[FmfkOAV].emplace_object();
            return serialize_struct(temp, pIndexInfo[FmfkOAV]);
            }();
        }
        }();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){json["stride"]=stride;}();
[&](){
            if (pVertexOffset==NULL){
                json["pVertexOffset"]=boost::json::array();
            return; }
        auto& arr_PavgIEG=json["pVertexOffset"].emplace_array();
        for(int PNvrUEs=0; PNvrUEs < 1; PNvrUEs++){
            [&](){arr_PavgIEG[PNvrUEs]=pVertexOffset[PNvrUEs];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDrawIndirect(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDrawIndirect call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndirect)get_instance_proc_addr(parent,"vkCmdDrawIndirect");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndirect)get_device_proc_addr(parent,"vkCmdDrawIndirect");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawIndexedIndirect(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDrawIndexedIndirect call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndexedIndirect)get_instance_proc_addr(parent,"vkCmdDrawIndexedIndirect");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndexedIndirect)get_device_proc_addr(parent,"vkCmdDrawIndexedIndirect");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdDispatch(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t groupCountX;
[&](){groupCountX=static_cast<uint32_t>(value_to<int>(json["groupCountX"]));}();
uint32_t groupCountY;
[&](){groupCountY=static_cast<uint32_t>(value_to<int>(json["groupCountY"]));}();
uint32_t groupCountZ;
[&](){groupCountZ=static_cast<uint32_t>(value_to<int>(json["groupCountZ"]));}();

    PFN_vkCmdDispatch call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDispatch)get_instance_proc_addr(parent,"vkCmdDispatch");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDispatch)get_device_proc_addr(parent,"vkCmdDispatch");
    }  
    
{
call_function(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();


        writeToConn(json);
    }

    void handle_vkCmdDispatchIndirect(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();

    PFN_vkCmdDispatchIndirect call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDispatchIndirect)get_instance_proc_addr(parent,"vkCmdDispatchIndirect");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDispatchIndirect)get_device_proc_addr(parent,"vkCmdDispatchIndirect");
    }  
    
{
call_function(commandBuffer, buffer, offset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSubpassShadingHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdSubpassShadingHUAWEI call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSubpassShadingHUAWEI)get_instance_proc_addr(parent,"vkCmdSubpassShadingHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSubpassShadingHUAWEI)get_device_proc_addr(parent,"vkCmdSubpassShadingHUAWEI");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        writeToConn(json);
    }

    void handle_vkCmdDrawClusterHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t groupCountX;
[&](){groupCountX=static_cast<uint32_t>(value_to<int>(json["groupCountX"]));}();
uint32_t groupCountY;
[&](){groupCountY=static_cast<uint32_t>(value_to<int>(json["groupCountY"]));}();
uint32_t groupCountZ;
[&](){groupCountZ=static_cast<uint32_t>(value_to<int>(json["groupCountZ"]));}();

    PFN_vkCmdDrawClusterHUAWEI call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawClusterHUAWEI)get_instance_proc_addr(parent,"vkCmdDrawClusterHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawClusterHUAWEI)get_device_proc_addr(parent,"vkCmdDrawClusterHUAWEI");
    }  
    
{
call_function(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawClusterIndirectHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();

    PFN_vkCmdDrawClusterIndirectHUAWEI call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawClusterIndirectHUAWEI)get_instance_proc_addr(parent,"vkCmdDrawClusterIndirectHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawClusterIndirectHUAWEI)get_device_proc_addr(parent,"vkCmdDrawClusterIndirectHUAWEI");
    }  
    
{
call_function(commandBuffer, buffer, offset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();


        writeToConn(json);
    }

    void handle_vkCmdUpdatePipelineIndirectBufferNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

    PFN_vkCmdUpdatePipelineIndirectBufferNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdUpdatePipelineIndirectBufferNV)get_instance_proc_addr(parent,"vkCmdUpdatePipelineIndirectBufferNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdUpdatePipelineIndirectBufferNV)get_device_proc_addr(parent,"vkCmdUpdatePipelineIndirectBufferNV");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, pipeline);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();


        writeToConn(json);
    }

    void handle_vkCmdCopyBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer srcBuffer;
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
uint32_t regionCount;
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();
VkBufferCopy* pRegions;
[&](){ VkBufferCopy* temp_kIqXSWJ[&](){
            if (json["pRegions"].as_array().size()==0){
                temp_kIqXSWJ=NULL;
            return; }temp_kIqXSWJ=(VkBufferCopy*)malloc(regionCount*sizeof(VkBufferCopy));
        auto& arr_MJNgYRy=json["pRegions"].as_array();
        for(int BwnoKUH=0; BwnoKUH < regionCount; BwnoKUH++){
            [&](){
            auto& temp=arr_MJNgYRy[BwnoKUH].as_object();
            deserialize_struct(temp,temp_kIqXSWJ[BwnoKUH]);
            }();
        }
        }();pRegions=temp_kIqXSWJ;}();

    PFN_vkCmdCopyBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyBuffer)get_instance_proc_addr(parent,"vkCmdCopyBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyBuffer)get_device_proc_addr(parent,"vkCmdCopyBuffer");
    }  
    
{
call_function(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_McSYWcQ=json["pRegions"].emplace_array();
        for(int IaMuFrO=0; IaMuFrO < regionCount; IaMuFrO++){
            [&](){
            auto& temp=arr_McSYWcQ[IaMuFrO].emplace_object();
            return serialize_struct(temp, pRegions[IaMuFrO]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){temp_zMKCozb=static_cast<int>(value_to<int>(json["srcImageLayout"]));}();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();
VkImageCopy* pRegions;
[&](){ VkImageCopy* temp_xdHPqoW[&](){
            if (json["pRegions"].as_array().size()==0){
                temp_xdHPqoW=NULL;
            return; }temp_xdHPqoW=(VkImageCopy*)malloc(regionCount*sizeof(VkImageCopy));
        auto& arr_sMBHaLF=json["pRegions"].as_array();
        for(int lLnttNm=0; lLnttNm < regionCount; lLnttNm++){
            [&](){
            auto& temp=arr_sMBHaLF[lLnttNm].as_object();
            deserialize_struct(temp,temp_xdHPqoW[lLnttNm]);
            }();
        }
        }();pRegions=temp_xdHPqoW;}();

    PFN_vkCmdCopyImage call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyImage)get_instance_proc_addr(parent,"vkCmdCopyImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyImage)get_device_proc_addr(parent,"vkCmdCopyImage");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_HMPixWj=json["pRegions"].emplace_array();
        for(int TvxHvSV=0; TvxHvSV < regionCount; TvxHvSV++){
            [&](){
            auto& temp=arr_HMPixWj[TvxHvSV].emplace_object();
            return serialize_struct(temp, pRegions[TvxHvSV]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBlitImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){temp_zMKCozb=static_cast<int>(value_to<int>(json["srcImageLayout"]));}();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();
VkImageBlit* pRegions;
[&](){ VkImageBlit* temp_AoEBCHe[&](){
            if (json["pRegions"].as_array().size()==0){
                temp_AoEBCHe=NULL;
            return; }temp_AoEBCHe=(VkImageBlit*)malloc(regionCount*sizeof(VkImageBlit));
        auto& arr_aDcnXeL=json["pRegions"].as_array();
        for(int khqBNUP=0; khqBNUP < regionCount; khqBNUP++){
            [&](){
            auto& temp=arr_aDcnXeL[khqBNUP].as_object();
            deserialize_struct(temp,temp_AoEBCHe[khqBNUP]);
            }();
        }
        }();pRegions=temp_AoEBCHe;}();
VkFilter filter;
[&](){[&](){int temp_DaCTyEq;[&](){temp_DaCTyEq=static_cast<int>(value_to<int>(json["filter"]));}();filter=(VkFilter)temp_DaCTyEq;}();}();

    PFN_vkCmdBlitImage call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBlitImage)get_instance_proc_addr(parent,"vkCmdBlitImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBlitImage)get_device_proc_addr(parent,"vkCmdBlitImage");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_dQsoHhP=json["pRegions"].emplace_array();
        for(int YEXYPDJ=0; YEXYPDJ < regionCount; YEXYPDJ++){
            [&](){
            auto& temp=arr_dQsoHhP[YEXYPDJ].emplace_object();
            return serialize_struct(temp, pRegions[YEXYPDJ]);
            }();
        }
        }();
[&](){[&](){[&](){json["filter"]=filter;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdCopyBufferToImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer srcBuffer;
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();
VkBufferImageCopy* pRegions;
[&](){ VkBufferImageCopy* temp_rMefUms[&](){
            if (json["pRegions"].as_array().size()==0){
                temp_rMefUms=NULL;
            return; }temp_rMefUms=(VkBufferImageCopy*)malloc(regionCount*sizeof(VkBufferImageCopy));
        auto& arr_Gfapiec=json["pRegions"].as_array();
        for(int edvwarx=0; edvwarx < regionCount; edvwarx++){
            [&](){
            auto& temp=arr_Gfapiec[edvwarx].as_object();
            deserialize_struct(temp,temp_rMefUms[edvwarx]);
            }();
        }
        }();pRegions=temp_rMefUms;}();

    PFN_vkCmdCopyBufferToImage call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyBufferToImage)get_instance_proc_addr(parent,"vkCmdCopyBufferToImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyBufferToImage)get_device_proc_addr(parent,"vkCmdCopyBufferToImage");
    }  
    
{
call_function(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_igZnVsu=json["pRegions"].emplace_array();
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto& temp=arr_igZnVsu[yuuZKOo].emplace_object();
            return serialize_struct(temp, pRegions[yuuZKOo]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyImageToBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){temp_zMKCozb=static_cast<int>(value_to<int>(json["srcImageLayout"]));}();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
uint32_t regionCount;
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();
VkBufferImageCopy* pRegions;
[&](){ VkBufferImageCopy* temp_rMefUms[&](){
            if (json["pRegions"].as_array().size()==0){
                temp_rMefUms=NULL;
            return; }temp_rMefUms=(VkBufferImageCopy*)malloc(regionCount*sizeof(VkBufferImageCopy));
        auto& arr_Gfapiec=json["pRegions"].as_array();
        for(int edvwarx=0; edvwarx < regionCount; edvwarx++){
            [&](){
            auto& temp=arr_Gfapiec[edvwarx].as_object();
            deserialize_struct(temp,temp_rMefUms[edvwarx]);
            }();
        }
        }();pRegions=temp_rMefUms;}();

    PFN_vkCmdCopyImageToBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyImageToBuffer)get_instance_proc_addr(parent,"vkCmdCopyImageToBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyImageToBuffer)get_device_proc_addr(parent,"vkCmdCopyImageToBuffer");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_igZnVsu=json["pRegions"].emplace_array();
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto& temp=arr_igZnVsu[yuuZKOo].emplace_object();
            return serialize_struct(temp, pRegions[yuuZKOo]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryIndirectNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress copyBufferAddress;
[&](){uint64_t temp_qveUnrh;[&](){temp_qveUnrh=static_cast<uint64_t>(value_to<int>(json["copyBufferAddress"]));}();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
uint32_t copyCount;
[&](){copyCount=static_cast<uint32_t>(value_to<int>(json["copyCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdCopyMemoryIndirectNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMemoryIndirectNV)get_instance_proc_addr(parent,"vkCmdCopyMemoryIndirectNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMemoryIndirectNV)get_device_proc_addr(parent,"vkCmdCopyMemoryIndirectNV");
    }  
    
{
call_function(commandBuffer, copyBufferAddress, copyCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=copyBufferAddress;}();}();
[&](){json["copyCount"]=copyCount;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryToImageIndirectNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress copyBufferAddress;
[&](){uint64_t temp_qveUnrh;[&](){temp_qveUnrh=static_cast<uint64_t>(value_to<int>(json["copyBufferAddress"]));}();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
uint32_t copyCount;
[&](){copyCount=static_cast<uint32_t>(value_to<int>(json["copyCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
VkImageSubresourceLayers* pImageSubresources;
[&](){ VkImageSubresourceLayers* temp_QzEBEGL[&](){
            if (json["pImageSubresources"].as_array().size()==0){
                temp_QzEBEGL=NULL;
            return; }temp_QzEBEGL=(VkImageSubresourceLayers*)malloc(copyCount*sizeof(VkImageSubresourceLayers));
        auto& arr_WxjWdjD=json["pImageSubresources"].as_array();
        for(int ApBwZPM=0; ApBwZPM < copyCount; ApBwZPM++){
            [&](){
            auto& temp=arr_WxjWdjD[ApBwZPM].as_object();
            deserialize_struct(temp,temp_QzEBEGL[ApBwZPM]);
            }();
        }
        }();pImageSubresources=temp_QzEBEGL;}();

    PFN_vkCmdCopyMemoryToImageIndirectNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMemoryToImageIndirectNV)get_instance_proc_addr(parent,"vkCmdCopyMemoryToImageIndirectNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMemoryToImageIndirectNV)get_device_proc_addr(parent,"vkCmdCopyMemoryToImageIndirectNV");
    }  
    
{
call_function(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=copyBufferAddress;}();}();
[&](){json["copyCount"]=copyCount;}();
[&](){json["stride"]=stride;}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){
            if (pImageSubresources==NULL){
                json["pImageSubresources"]=boost::json::array();
            return; }
        auto& arr_hVMAkcO=json["pImageSubresources"].emplace_array();
        for(int OfGHasS=0; OfGHasS < copyCount; OfGHasS++){
            [&](){
            auto& temp=arr_hVMAkcO[OfGHasS].emplace_object();
            return serialize_struct(temp, pImageSubresources[OfGHasS]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdUpdateBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
VkDeviceSize dataSize;
[&](){uint64_t temp_SwYyzuh;[&](){temp_SwYyzuh=static_cast<uint64_t>(value_to<int>(json["dataSize"]));}();dataSize=(VkDeviceSize)temp_SwYyzuh;}();
void* pData;
[&](){ void* temp_wIvtWll[&](){
            if (json["pData"].as_array().size()==0){
                temp_wIvtWll=NULL;
            return; }char* temp_eeRffBc;[&](){
            if (json["pData"].as_array().size()==0){
                temp_eeRffBc=NULL;
            return; }temp_eeRffBc=(char*)malloc(dataSize*sizeof(char));
        auto& arr_ZPnOSxW=json["pData"].as_array();
        for(int mhoQVXX=0; mhoQVXX < dataSize; mhoQVXX++){
            [&](){temp_eeRffBc[mhoQVXX]=static_cast<char>(value_to<int>(arr_ZPnOSxW[mhoQVXX]));}();
        }
        }();temp_wIvtWll=temp_eeRffBc;}();pData=temp_wIvtWll;}();

    PFN_vkCmdUpdateBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdUpdateBuffer)get_instance_proc_addr(parent,"vkCmdUpdateBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdUpdateBuffer)get_device_proc_addr(parent,"vkCmdUpdateBuffer");
    }  
    
{
call_function(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["dataSize"]=dataSize;}();}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_wjMrkki=json["pData"].emplace_array();
        for(int qQUyxsG=0; qQUyxsG < dataSize; qQUyxsG++){
            [&](){arr_wjMrkki[qQUyxsG]=((char*)(pData))[qQUyxsG];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkCmdFillBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
VkDeviceSize size;
[&](){uint64_t temp_PlNcOBd;[&](){temp_PlNcOBd=static_cast<uint64_t>(value_to<int>(json["size"]));}();size=(VkDeviceSize)temp_PlNcOBd;}();
uint32_t data;
[&](){data=static_cast<uint32_t>(value_to<int>(json["data"]));}();

    PFN_vkCmdFillBuffer call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdFillBuffer)get_instance_proc_addr(parent,"vkCmdFillBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdFillBuffer)get_device_proc_addr(parent,"vkCmdFillBuffer");
    }  
    
{
call_function(commandBuffer, dstBuffer, dstOffset, size, data);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){json["data"]=data;}();


        writeToConn(json);
    }

    void handle_vkCmdClearColorImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){temp_VgsvIeW=static_cast<int>(value_to<int>(json["imageLayout"]));}();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();
VkClearColorValue* pColor;
[&](){ VkClearColorValue* temp_YJDXyAr[&](){
            if (json["pColor"].as_array().size()==0){
                temp_YJDXyAr=NULL;
            return; }temp_YJDXyAr=(VkClearColorValue*)malloc(1*sizeof(VkClearColorValue));
        auto& arr_GpwuhjC=json["pColor"].as_array();
        for(int ltCZWMn=0; ltCZWMn < 1; ltCZWMn++){
            [&](){
            auto& temp=arr_GpwuhjC[ltCZWMn].as_object();
            deserialize_struct(temp,temp_YJDXyAr[ltCZWMn]);
            }();
        }
        }();pColor=temp_YJDXyAr;}();
uint32_t rangeCount;
[&](){rangeCount=static_cast<uint32_t>(value_to<int>(json["rangeCount"]));}();
VkImageSubresourceRange* pRanges;
[&](){ VkImageSubresourceRange* temp_FeuXmjY[&](){
            if (json["pRanges"].as_array().size()==0){
                temp_FeuXmjY=NULL;
            return; }temp_FeuXmjY=(VkImageSubresourceRange*)malloc(rangeCount*sizeof(VkImageSubresourceRange));
        auto& arr_HvOwEDl=json["pRanges"].as_array();
        for(int zzMqHgz=0; zzMqHgz < rangeCount; zzMqHgz++){
            [&](){
            auto& temp=arr_HvOwEDl[zzMqHgz].as_object();
            deserialize_struct(temp,temp_FeuXmjY[zzMqHgz]);
            }();
        }
        }();pRanges=temp_FeuXmjY;}();

    PFN_vkCmdClearColorImage call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdClearColorImage)get_instance_proc_addr(parent,"vkCmdClearColorImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdClearColorImage)get_device_proc_addr(parent,"vkCmdClearColorImage");
    }  
    
{
call_function(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
[&](){
            if (pColor==NULL){
                json["pColor"]=boost::json::array();
            return; }
        auto& arr_SGRyjqE=json["pColor"].emplace_array();
        for(int ldPlUDi=0; ldPlUDi < 1; ldPlUDi++){
            [&](){
            auto& temp=arr_SGRyjqE[ldPlUDi].emplace_object();
            return serialize_struct(temp, pColor[ldPlUDi]);
            }();
        }
        }();
[&](){json["rangeCount"]=rangeCount;}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=boost::json::array();
            return; }
        auto& arr_BisbUqU=json["pRanges"].emplace_array();
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto& temp=arr_BisbUqU[IZgopUD].emplace_object();
            return serialize_struct(temp, pRanges[IZgopUD]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdClearDepthStencilImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){temp_VgsvIeW=static_cast<int>(value_to<int>(json["imageLayout"]));}();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();
VkClearDepthStencilValue* pDepthStencil;
[&](){ VkClearDepthStencilValue* temp_AkkBMYS[&](){
            if (json["pDepthStencil"].as_array().size()==0){
                temp_AkkBMYS=NULL;
            return; }temp_AkkBMYS=(VkClearDepthStencilValue*)malloc(1*sizeof(VkClearDepthStencilValue));
        auto& arr_PIAYblz=json["pDepthStencil"].as_array();
        for(int zQOULOl=0; zQOULOl < 1; zQOULOl++){
            [&](){
            auto& temp=arr_PIAYblz[zQOULOl].as_object();
            deserialize_struct(temp,temp_AkkBMYS[zQOULOl]);
            }();
        }
        }();pDepthStencil=temp_AkkBMYS;}();
uint32_t rangeCount;
[&](){rangeCount=static_cast<uint32_t>(value_to<int>(json["rangeCount"]));}();
VkImageSubresourceRange* pRanges;
[&](){ VkImageSubresourceRange* temp_FeuXmjY[&](){
            if (json["pRanges"].as_array().size()==0){
                temp_FeuXmjY=NULL;
            return; }temp_FeuXmjY=(VkImageSubresourceRange*)malloc(rangeCount*sizeof(VkImageSubresourceRange));
        auto& arr_HvOwEDl=json["pRanges"].as_array();
        for(int zzMqHgz=0; zzMqHgz < rangeCount; zzMqHgz++){
            [&](){
            auto& temp=arr_HvOwEDl[zzMqHgz].as_object();
            deserialize_struct(temp,temp_FeuXmjY[zzMqHgz]);
            }();
        }
        }();pRanges=temp_FeuXmjY;}();

    PFN_vkCmdClearDepthStencilImage call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdClearDepthStencilImage)get_instance_proc_addr(parent,"vkCmdClearDepthStencilImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdClearDepthStencilImage)get_device_proc_addr(parent,"vkCmdClearDepthStencilImage");
    }  
    
{
call_function(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
[&](){
            if (pDepthStencil==NULL){
                json["pDepthStencil"]=boost::json::array();
            return; }
        auto& arr_gYzlVps=json["pDepthStencil"].emplace_array();
        for(int jJUemfv=0; jJUemfv < 1; jJUemfv++){
            [&](){
            auto& temp=arr_gYzlVps[jJUemfv].emplace_object();
            return serialize_struct(temp, pDepthStencil[jJUemfv]);
            }();
        }
        }();
[&](){json["rangeCount"]=rangeCount;}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=boost::json::array();
            return; }
        auto& arr_BisbUqU=json["pRanges"].emplace_array();
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto& temp=arr_BisbUqU[IZgopUD].emplace_object();
            return serialize_struct(temp, pRanges[IZgopUD]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdClearAttachments(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t attachmentCount;
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();
VkClearAttachment* pAttachments;
[&](){ VkClearAttachment* temp_KHUtHEe[&](){
            if (json["pAttachments"].as_array().size()==0){
                temp_KHUtHEe=NULL;
            return; }temp_KHUtHEe=(VkClearAttachment*)malloc(attachmentCount*sizeof(VkClearAttachment));
        auto& arr_cdEOPrs=json["pAttachments"].as_array();
        for(int bLOSZTT=0; bLOSZTT < attachmentCount; bLOSZTT++){
            [&](){
            auto& temp=arr_cdEOPrs[bLOSZTT].as_object();
            deserialize_struct(temp,temp_KHUtHEe[bLOSZTT]);
            }();
        }
        }();pAttachments=temp_KHUtHEe;}();
uint32_t rectCount;
[&](){rectCount=static_cast<uint32_t>(value_to<int>(json["rectCount"]));}();
VkClearRect* pRects;
[&](){ VkClearRect* temp_YKDsnTr[&](){
            if (json["pRects"].as_array().size()==0){
                temp_YKDsnTr=NULL;
            return; }temp_YKDsnTr=(VkClearRect*)malloc(rectCount*sizeof(VkClearRect));
        auto& arr_cMVnppZ=json["pRects"].as_array();
        for(int RmtJABT=0; RmtJABT < rectCount; RmtJABT++){
            [&](){
            auto& temp=arr_cMVnppZ[RmtJABT].as_object();
            deserialize_struct(temp,temp_YKDsnTr[RmtJABT]);
            }();
        }
        }();pRects=temp_YKDsnTr;}();

    PFN_vkCmdClearAttachments call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdClearAttachments)get_instance_proc_addr(parent,"vkCmdClearAttachments");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdClearAttachments)get_device_proc_addr(parent,"vkCmdClearAttachments");
    }  
    
{
call_function(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pAttachments==NULL){
                json["pAttachments"]=boost::json::array();
            return; }
        auto& arr_fOlilkR=json["pAttachments"].emplace_array();
        for(int BsFiayf=0; BsFiayf < attachmentCount; BsFiayf++){
            [&](){
            auto& temp=arr_fOlilkR[BsFiayf].emplace_object();
            return serialize_struct(temp, pAttachments[BsFiayf]);
            }();
        }
        }();
[&](){json["rectCount"]=rectCount;}();
[&](){
            if (pRects==NULL){
                json["pRects"]=boost::json::array();
            return; }
        auto& arr_cgJwUFb=json["pRects"].emplace_array();
        for(int HncrKEH=0; HncrKEH < rectCount; HncrKEH++){
            [&](){
            auto& temp=arr_cgJwUFb[HncrKEH].emplace_object();
            return serialize_struct(temp, pRects[HncrKEH]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdResolveImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){temp_zMKCozb=static_cast<int>(value_to<int>(json["srcImageLayout"]));}();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();
VkImageResolve* pRegions;
[&](){ VkImageResolve* temp_rjwJGWS[&](){
            if (json["pRegions"].as_array().size()==0){
                temp_rjwJGWS=NULL;
            return; }temp_rjwJGWS=(VkImageResolve*)malloc(regionCount*sizeof(VkImageResolve));
        auto& arr_XxhLAuH=json["pRegions"].as_array();
        for(int vuJYXjg=0; vuJYXjg < regionCount; vuJYXjg++){
            [&](){
            auto& temp=arr_XxhLAuH[vuJYXjg].as_object();
            deserialize_struct(temp,temp_rjwJGWS[vuJYXjg]);
            }();
        }
        }();pRegions=temp_rjwJGWS;}();

    PFN_vkCmdResolveImage call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResolveImage)get_instance_proc_addr(parent,"vkCmdResolveImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResolveImage)get_device_proc_addr(parent,"vkCmdResolveImage");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_OGNZeww=json["pRegions"].emplace_array();
        for(int UbqELUx=0; UbqELUx < regionCount; UbqELUx++){
            [&](){
            auto& temp=arr_OGNZeww[UbqELUx].emplace_object();
            return serialize_struct(temp, pRegions[UbqELUx]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetEvent(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkPipelineStageFlags stageMask;
[&](){[&](){int temp_aUxfTbC;[&](){temp_aUxfTbC=static_cast<int>(value_to<int>(json["stageMask"]));}();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

    PFN_vkCmdSetEvent call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetEvent)get_instance_proc_addr(parent,"vkCmdSetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetEvent)get_device_proc_addr(parent,"vkCmdSetEvent");
    }  
    
{
call_function(commandBuffer, event, stageMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdResetEvent(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkPipelineStageFlags stageMask;
[&](){[&](){int temp_aUxfTbC;[&](){temp_aUxfTbC=static_cast<int>(value_to<int>(json["stageMask"]));}();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

    PFN_vkCmdResetEvent call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResetEvent)get_instance_proc_addr(parent,"vkCmdResetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResetEvent)get_device_proc_addr(parent,"vkCmdResetEvent");
    }  
    
{
call_function(commandBuffer, event, stageMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdWaitEvents(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t eventCount;
[&](){eventCount=static_cast<uint32_t>(value_to<int>(json["eventCount"]));}();
VkEvent* pEvents;
[&](){ VkEvent* temp_DnisCCa[&](){
            if (json["pEvents"].as_array().size()==0){
                temp_DnisCCa=NULL;
            return; }temp_DnisCCa=(VkEvent*)malloc(eventCount*sizeof(VkEvent));
        auto& arr_QYtHNne=json["pEvents"].as_array();
        for(int RuhNVwi=0; RuhNVwi < eventCount; RuhNVwi++){
            [&](){deserialize_VkEvent(arr_QYtHNne[RuhNVwi], temp_DnisCCa[RuhNVwi]);}();
        }
        }();pEvents=temp_DnisCCa;}();
VkPipelineStageFlags srcStageMask;
[&](){[&](){int temp_puDZLNO;[&](){temp_puDZLNO=static_cast<int>(value_to<int>(json["srcStageMask"]));}();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
VkPipelineStageFlags dstStageMask;
[&](){[&](){int temp_OgAwXVW;[&](){temp_OgAwXVW=static_cast<int>(value_to<int>(json["dstStageMask"]));}();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
uint32_t memoryBarrierCount;
[&](){memoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["memoryBarrierCount"]));}();
VkMemoryBarrier* pMemoryBarriers;
[&](){ VkMemoryBarrier* temp_CZHoAZh[&](){
            if (json["pMemoryBarriers"].as_array().size()==0){
                temp_CZHoAZh=NULL;
            return; }temp_CZHoAZh=(VkMemoryBarrier*)malloc(memoryBarrierCount*sizeof(VkMemoryBarrier));
        auto& arr_jpHrKrx=json["pMemoryBarriers"].as_array();
        for(int TyfEutX=0; TyfEutX < memoryBarrierCount; TyfEutX++){
            [&](){
            auto& temp=arr_jpHrKrx[TyfEutX].as_object();
            deserialize_struct(temp,temp_CZHoAZh[TyfEutX]);
            }();
        }
        }();pMemoryBarriers=temp_CZHoAZh;}();
uint32_t bufferMemoryBarrierCount;
[&](){bufferMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["bufferMemoryBarrierCount"]));}();
VkBufferMemoryBarrier* pBufferMemoryBarriers;
[&](){ VkBufferMemoryBarrier* temp_hFLMYHu[&](){
            if (json["pBufferMemoryBarriers"].as_array().size()==0){
                temp_hFLMYHu=NULL;
            return; }temp_hFLMYHu=(VkBufferMemoryBarrier*)malloc(bufferMemoryBarrierCount*sizeof(VkBufferMemoryBarrier));
        auto& arr_gVbYbae=json["pBufferMemoryBarriers"].as_array();
        for(int ewqDhcn=0; ewqDhcn < bufferMemoryBarrierCount; ewqDhcn++){
            [&](){
            auto& temp=arr_gVbYbae[ewqDhcn].as_object();
            deserialize_struct(temp,temp_hFLMYHu[ewqDhcn]);
            }();
        }
        }();pBufferMemoryBarriers=temp_hFLMYHu;}();
uint32_t imageMemoryBarrierCount;
[&](){imageMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["imageMemoryBarrierCount"]));}();
VkImageMemoryBarrier* pImageMemoryBarriers;
[&](){ VkImageMemoryBarrier* temp_jZSPyTO[&](){
            if (json["pImageMemoryBarriers"].as_array().size()==0){
                temp_jZSPyTO=NULL;
            return; }temp_jZSPyTO=(VkImageMemoryBarrier*)malloc(imageMemoryBarrierCount*sizeof(VkImageMemoryBarrier));
        auto& arr_bBtNYaN=json["pImageMemoryBarriers"].as_array();
        for(int ASYxaRK=0; ASYxaRK < imageMemoryBarrierCount; ASYxaRK++){
            [&](){
            auto& temp=arr_bBtNYaN[ASYxaRK].as_object();
            deserialize_struct(temp,temp_jZSPyTO[ASYxaRK]);
            }();
        }
        }();pImageMemoryBarriers=temp_jZSPyTO;}();

    PFN_vkCmdWaitEvents call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWaitEvents)get_instance_proc_addr(parent,"vkCmdWaitEvents");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWaitEvents)get_device_proc_addr(parent,"vkCmdWaitEvents");
    }  
    
{
call_function(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=eventCount;}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=boost::json::array();
            return; }
        auto& arr_tUuyOPJ=json["pEvents"].emplace_array();
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        }();
[&](){[&](){[&](){json["srcStageMask"]=srcStageMask;}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=dstStageMask;}();}();}();
[&](){json["memoryBarrierCount"]=memoryBarrierCount;}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_fXDYoDs=json["pMemoryBarriers"].emplace_array();
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto& temp=arr_fXDYoDs[JhnlCAW].emplace_object();
            return serialize_struct(temp, pMemoryBarriers[JhnlCAW]);
            }();
        }
        }();
[&](){json["bufferMemoryBarrierCount"]=bufferMemoryBarrierCount;}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_FmJTDmX=json["pBufferMemoryBarriers"].emplace_array();
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto& temp=arr_FmJTDmX[aFMQios].emplace_object();
            return serialize_struct(temp, pBufferMemoryBarriers[aFMQios]);
            }();
        }
        }();
[&](){json["imageMemoryBarrierCount"]=imageMemoryBarrierCount;}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_nkkvvYR=json["pImageMemoryBarriers"].emplace_array();
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto& temp=arr_nkkvvYR[trWYSmx].emplace_object();
            return serialize_struct(temp, pImageMemoryBarriers[trWYSmx]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdPipelineBarrier(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlags srcStageMask;
[&](){[&](){int temp_puDZLNO;[&](){temp_puDZLNO=static_cast<int>(value_to<int>(json["srcStageMask"]));}();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
VkPipelineStageFlags dstStageMask;
[&](){[&](){int temp_OgAwXVW;[&](){temp_OgAwXVW=static_cast<int>(value_to<int>(json["dstStageMask"]));}();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
VkDependencyFlags dependencyFlags;
[&](){[&](){int temp_MJCELwI;[&](){temp_MJCELwI=static_cast<int>(value_to<int>(json["dependencyFlags"]));}();dependencyFlags=(VkDependencyFlags)temp_MJCELwI;}();}();
uint32_t memoryBarrierCount;
[&](){memoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["memoryBarrierCount"]));}();
VkMemoryBarrier* pMemoryBarriers;
[&](){ VkMemoryBarrier* temp_CZHoAZh[&](){
            if (json["pMemoryBarriers"].as_array().size()==0){
                temp_CZHoAZh=NULL;
            return; }temp_CZHoAZh=(VkMemoryBarrier*)malloc(memoryBarrierCount*sizeof(VkMemoryBarrier));
        auto& arr_jpHrKrx=json["pMemoryBarriers"].as_array();
        for(int TyfEutX=0; TyfEutX < memoryBarrierCount; TyfEutX++){
            [&](){
            auto& temp=arr_jpHrKrx[TyfEutX].as_object();
            deserialize_struct(temp,temp_CZHoAZh[TyfEutX]);
            }();
        }
        }();pMemoryBarriers=temp_CZHoAZh;}();
uint32_t bufferMemoryBarrierCount;
[&](){bufferMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["bufferMemoryBarrierCount"]));}();
VkBufferMemoryBarrier* pBufferMemoryBarriers;
[&](){ VkBufferMemoryBarrier* temp_hFLMYHu[&](){
            if (json["pBufferMemoryBarriers"].as_array().size()==0){
                temp_hFLMYHu=NULL;
            return; }temp_hFLMYHu=(VkBufferMemoryBarrier*)malloc(bufferMemoryBarrierCount*sizeof(VkBufferMemoryBarrier));
        auto& arr_gVbYbae=json["pBufferMemoryBarriers"].as_array();
        for(int ewqDhcn=0; ewqDhcn < bufferMemoryBarrierCount; ewqDhcn++){
            [&](){
            auto& temp=arr_gVbYbae[ewqDhcn].as_object();
            deserialize_struct(temp,temp_hFLMYHu[ewqDhcn]);
            }();
        }
        }();pBufferMemoryBarriers=temp_hFLMYHu;}();
uint32_t imageMemoryBarrierCount;
[&](){imageMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["imageMemoryBarrierCount"]));}();
VkImageMemoryBarrier* pImageMemoryBarriers;
[&](){ VkImageMemoryBarrier* temp_jZSPyTO[&](){
            if (json["pImageMemoryBarriers"].as_array().size()==0){
                temp_jZSPyTO=NULL;
            return; }temp_jZSPyTO=(VkImageMemoryBarrier*)malloc(imageMemoryBarrierCount*sizeof(VkImageMemoryBarrier));
        auto& arr_bBtNYaN=json["pImageMemoryBarriers"].as_array();
        for(int ASYxaRK=0; ASYxaRK < imageMemoryBarrierCount; ASYxaRK++){
            [&](){
            auto& temp=arr_bBtNYaN[ASYxaRK].as_object();
            deserialize_struct(temp,temp_jZSPyTO[ASYxaRK]);
            }();
        }
        }();pImageMemoryBarriers=temp_jZSPyTO;}();

    PFN_vkCmdPipelineBarrier call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPipelineBarrier)get_instance_proc_addr(parent,"vkCmdPipelineBarrier");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPipelineBarrier)get_device_proc_addr(parent,"vkCmdPipelineBarrier");
    }  
    
{
call_function(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["srcStageMask"]=srcStageMask;}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=dstStageMask;}();}();}();
[&](){[&](){[&](){json["dependencyFlags"]=dependencyFlags;}();}();}();
[&](){json["memoryBarrierCount"]=memoryBarrierCount;}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_fXDYoDs=json["pMemoryBarriers"].emplace_array();
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto& temp=arr_fXDYoDs[JhnlCAW].emplace_object();
            return serialize_struct(temp, pMemoryBarriers[JhnlCAW]);
            }();
        }
        }();
[&](){json["bufferMemoryBarrierCount"]=bufferMemoryBarrierCount;}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_FmJTDmX=json["pBufferMemoryBarriers"].emplace_array();
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto& temp=arr_FmJTDmX[aFMQios].emplace_object();
            return serialize_struct(temp, pBufferMemoryBarriers[aFMQios]);
            }();
        }
        }();
[&](){json["imageMemoryBarrierCount"]=imageMemoryBarrierCount;}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_nkkvvYR=json["pImageMemoryBarriers"].emplace_array();
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto& temp=arr_nkkvvYR[trWYSmx].emplace_object();
            return serialize_struct(temp, pImageMemoryBarriers[trWYSmx]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBeginQuery(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();
VkQueryControlFlags flags;
[&](){[&](){int temp_iyzDJOK;[&](){temp_iyzDJOK=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();

    PFN_vkCmdBeginQuery call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginQuery)get_instance_proc_addr(parent,"vkCmdBeginQuery");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginQuery)get_device_proc_addr(parent,"vkCmdBeginQuery");
    }  
    
{
call_function(commandBuffer, queryPool, query, flags);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdEndQuery(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();

    PFN_vkCmdEndQuery call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndQuery)get_instance_proc_addr(parent,"vkCmdEndQuery");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndQuery)get_device_proc_addr(parent,"vkCmdEndQuery");
    }  
    
{
call_function(commandBuffer, queryPool, query);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();


        writeToConn(json);
    }

    void handle_vkCmdBeginConditionalRenderingEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin;
[&](){ VkConditionalRenderingBeginInfoEXT* temp_HYLiQwM[&](){
            if (json["pConditionalRenderingBegin"].as_array().size()==0){
                temp_HYLiQwM=NULL;
            return; }temp_HYLiQwM=(VkConditionalRenderingBeginInfoEXT*)malloc(1*sizeof(VkConditionalRenderingBeginInfoEXT));
        auto& arr_OXqnNde=json["pConditionalRenderingBegin"].as_array();
        for(int xncJDyc=0; xncJDyc < 1; xncJDyc++){
            [&](){
            auto& temp=arr_OXqnNde[xncJDyc].as_object();
            deserialize_struct(temp,temp_HYLiQwM[xncJDyc]);
            }();
        }
        }();pConditionalRenderingBegin=temp_HYLiQwM;}();

    PFN_vkCmdBeginConditionalRenderingEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginConditionalRenderingEXT)get_instance_proc_addr(parent,"vkCmdBeginConditionalRenderingEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginConditionalRenderingEXT)get_device_proc_addr(parent,"vkCmdBeginConditionalRenderingEXT");
    }  
    
{
call_function(commandBuffer, pConditionalRenderingBegin);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pConditionalRenderingBegin==NULL){
                json["pConditionalRenderingBegin"]=boost::json::array();
            return; }
        auto& arr_guEoeuh=json["pConditionalRenderingBegin"].emplace_array();
        for(int KETgcvj=0; KETgcvj < 1; KETgcvj++){
            [&](){
            auto& temp=arr_guEoeuh[KETgcvj].emplace_object();
            return serialize_struct(temp, pConditionalRenderingBegin[KETgcvj]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdEndConditionalRenderingEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndConditionalRenderingEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndConditionalRenderingEXT)get_instance_proc_addr(parent,"vkCmdEndConditionalRenderingEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndConditionalRenderingEXT)get_device_proc_addr(parent,"vkCmdEndConditionalRenderingEXT");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        writeToConn(json);
    }

    void handle_vkCmdResetQueryPool(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();
uint32_t queryCount;
[&](){queryCount=static_cast<uint32_t>(value_to<int>(json["queryCount"]));}();

    PFN_vkCmdResetQueryPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResetQueryPool)get_instance_proc_addr(parent,"vkCmdResetQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResetQueryPool)get_device_proc_addr(parent,"vkCmdResetQueryPool");
    }  
    
{
call_function(commandBuffer, queryPool, firstQuery, queryCount);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();


        writeToConn(json);
    }

    void handle_vkCmdWriteTimestamp(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlagBits pipelineStage;
[&](){[&](){int temp_WILNXWI;[&](){temp_WILNXWI=static_cast<int>(value_to<int>(json["pipelineStage"]));}();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();

    PFN_vkCmdWriteTimestamp call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteTimestamp)get_instance_proc_addr(parent,"vkCmdWriteTimestamp");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteTimestamp)get_device_proc_addr(parent,"vkCmdWriteTimestamp");
    }  
    
{
call_function(commandBuffer, pipelineStage, queryPool, query);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=pipelineStage;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();


        writeToConn(json);
    }

    void handle_vkCmdCopyQueryPoolResults(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();
uint32_t queryCount;
[&](){queryCount=static_cast<uint32_t>(value_to<int>(json["queryCount"]));}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
VkDeviceSize stride;
[&](){uint64_t temp_fLSTSIg;[&](){temp_fLSTSIg=static_cast<uint64_t>(value_to<int>(json["stride"]));}();stride=(VkDeviceSize)temp_fLSTSIg;}();
VkQueryResultFlags flags;
[&](){[&](){int temp_jzLjdpj;[&](){temp_jzLjdpj=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();

    PFN_vkCmdCopyQueryPoolResults call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyQueryPoolResults)get_instance_proc_addr(parent,"vkCmdCopyQueryPoolResults");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyQueryPoolResults)get_device_proc_addr(parent,"vkCmdCopyQueryPoolResults");
    }  
    
{
call_function(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["stride"]=stride;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdPushConstants(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
VkShaderStageFlags stageFlags;
[&](){[&](){int temp_oWGKgUV;[&](){temp_oWGKgUV=static_cast<int>(value_to<int>(json["stageFlags"]));}();stageFlags=(VkShaderStageFlags)temp_oWGKgUV;}();}();
uint32_t offset;
[&](){offset=static_cast<uint32_t>(value_to<int>(json["offset"]));}();
uint32_t size;
[&](){size=static_cast<uint32_t>(value_to<int>(json["size"]));}();
void* pValues;
[&](){ void* temp_rTtOoAA[&](){
            if (json["pValues"].as_array().size()==0){
                temp_rTtOoAA=NULL;
            return; }char* temp_JvCgRni;[&](){
            if (json["pValues"].as_array().size()==0){
                temp_JvCgRni=NULL;
            return; }temp_JvCgRni=(char*)malloc(size*sizeof(char));
        auto& arr_XmPsHqR=json["pValues"].as_array();
        for(int eyrTqdl=0; eyrTqdl < size; eyrTqdl++){
            [&](){temp_JvCgRni[eyrTqdl]=static_cast<char>(value_to<int>(arr_XmPsHqR[eyrTqdl]));}();
        }
        }();temp_rTtOoAA=temp_JvCgRni;}();pValues=temp_rTtOoAA;}();

    PFN_vkCmdPushConstants call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPushConstants)get_instance_proc_addr(parent,"vkCmdPushConstants");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPushConstants)get_device_proc_addr(parent,"vkCmdPushConstants");
    }  
    
{
call_function(commandBuffer, layout, stageFlags, offset, size, pValues);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){[&](){[&](){json["stageFlags"]=stageFlags;}();}();}();
[&](){json["offset"]=offset;}();
[&](){json["size"]=size;}();
[&](){
            if (pValues==NULL){
                json["pValues"]=boost::json::array();
            return; }[&](){
            if (((char*)(pValues))==NULL){
                json["pValues"]=boost::json::array();
            return; }
        auto& arr_NQXrjwW=json["pValues"].emplace_array();
        for(int GopYbEO=0; GopYbEO < size; GopYbEO++){
            [&](){arr_NQXrjwW[GopYbEO]=((char*)(pValues))[GopYbEO];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkCmdBeginRenderPass(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkRenderPassBeginInfo* pRenderPassBegin;
[&](){ VkRenderPassBeginInfo* temp_ziYLYAn[&](){
            if (json["pRenderPassBegin"].as_array().size()==0){
                temp_ziYLYAn=NULL;
            return; }temp_ziYLYAn=(VkRenderPassBeginInfo*)malloc(1*sizeof(VkRenderPassBeginInfo));
        auto& arr_DvmhBAI=json["pRenderPassBegin"].as_array();
        for(int MzTximI=0; MzTximI < 1; MzTximI++){
            [&](){
            auto& temp=arr_DvmhBAI[MzTximI].as_object();
            deserialize_struct(temp,temp_ziYLYAn[MzTximI]);
            }();
        }
        }();pRenderPassBegin=temp_ziYLYAn;}();
VkSubpassContents contents;
[&](){[&](){int temp_pXPXcBB;[&](){temp_pXPXcBB=static_cast<int>(value_to<int>(json["contents"]));}();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

    PFN_vkCmdBeginRenderPass call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginRenderPass)get_instance_proc_addr(parent,"vkCmdBeginRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginRenderPass)get_device_proc_addr(parent,"vkCmdBeginRenderPass");
    }  
    
{
call_function(commandBuffer, pRenderPassBegin, contents);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=boost::json::array();
            return; }
        auto& arr_XtnTubd=json["pRenderPassBegin"].emplace_array();
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto& temp=arr_XtnTubd[lCAvoJt].emplace_object();
            return serialize_struct(temp, pRenderPassBegin[lCAvoJt]);
            }();
        }
        }();
[&](){[&](){[&](){json["contents"]=contents;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdNextSubpass(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSubpassContents contents;
[&](){[&](){int temp_pXPXcBB;[&](){temp_pXPXcBB=static_cast<int>(value_to<int>(json["contents"]));}();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

    PFN_vkCmdNextSubpass call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdNextSubpass)get_instance_proc_addr(parent,"vkCmdNextSubpass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdNextSubpass)get_device_proc_addr(parent,"vkCmdNextSubpass");
    }  
    
{
call_function(commandBuffer, contents);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["contents"]=contents;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdEndRenderPass(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndRenderPass call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndRenderPass)get_instance_proc_addr(parent,"vkCmdEndRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndRenderPass)get_device_proc_addr(parent,"vkCmdEndRenderPass");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        writeToConn(json);
    }

    void handle_vkCmdExecuteCommands(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t commandBufferCount;
[&](){commandBufferCount=static_cast<uint32_t>(value_to<int>(json["commandBufferCount"]));}();
VkCommandBuffer* pCommandBuffers;
[&](){ VkCommandBuffer* temp_zutnffS[&](){
            if (json["pCommandBuffers"].as_array().size()==0){
                temp_zutnffS=NULL;
            return; }temp_zutnffS=(VkCommandBuffer*)malloc(commandBufferCount*sizeof(VkCommandBuffer));
        auto& arr_aIQpbyi=json["pCommandBuffers"].as_array();
        for(int Neoyndt=0; Neoyndt < commandBufferCount; Neoyndt++){
            [&](){deserialize_VkCommandBuffer(arr_aIQpbyi[Neoyndt], temp_zutnffS[Neoyndt]);}();
        }
        }();pCommandBuffers=temp_zutnffS;}();

    PFN_vkCmdExecuteCommands call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdExecuteCommands)get_instance_proc_addr(parent,"vkCmdExecuteCommands");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdExecuteCommands)get_device_proc_addr(parent,"vkCmdExecuteCommands");
    }  
    
{
call_function(commandBuffer, commandBufferCount, pCommandBuffers);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["commandBufferCount"]=commandBufferCount;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }
        auto& arr_PdRlpEO=json["pCommandBuffers"].emplace_array();
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkDisplayPropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayPropertiesKHR*)malloc(*pPropertyCount*sizeof(VkDisplayPropertiesKHR));
        auto& arr_jKVTjSh=json["pProperties"].as_array();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto& temp=arr_jKVTjSh[ULwTWiE].as_object();
            deserialize_struct(temp,pProperties[ULwTWiE]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayPropertiesKHR");
    }  
    
{
auto result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_jKVTjSh=json["pProperties"].emplace_array();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto& temp=arr_jKVTjSh[ULwTWiE].emplace_object();
            return serialize_struct(temp, pProperties[ULwTWiE]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkDisplayPlanePropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayPlanePropertiesKHR*)malloc(*pPropertyCount*sizeof(VkDisplayPlanePropertiesKHR));
        auto& arr_TBQSgXa=json["pProperties"].as_array();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto& temp=arr_TBQSgXa[yGKhOKS].as_object();
            deserialize_struct(temp,pProperties[yGKhOKS]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    }  
    
{
auto result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_TBQSgXa=json["pProperties"].emplace_array();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto& temp=arr_TBQSgXa[yGKhOKS].emplace_object();
            return serialize_struct(temp, pProperties[yGKhOKS]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDisplayPlaneSupportedDisplaysKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t planeIndex;
[&](){planeIndex=static_cast<uint32_t>(value_to<int>(json["planeIndex"]));}();
uint32_t* pDisplayCount;
[&](){
            if (json["pDisplayCount"].as_array().size()==0){
                pDisplayCount=NULL;
            return; }pDisplayCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_HfQXIoE=json["pDisplayCount"].as_array();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){pDisplayCount[tJtenSc]=static_cast<uint32_t>(value_to<int>(arr_HfQXIoE[tJtenSc]));}();
        }
        }();
VkDisplayKHR* pDisplays;
[&](){
            if (json["pDisplays"].as_array().size()==0){
                pDisplays=NULL;
            return; }pDisplays=(VkDisplayKHR*)malloc(*pDisplayCount*sizeof(VkDisplayKHR));
        auto& arr_zfKAWAH=json["pDisplays"].as_array();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){deserialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV], pDisplays[OSaHdZV]);}();
        }
        }();

    PFN_vkGetDisplayPlaneSupportedDisplaysKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayPlaneSupportedDisplaysKHR)get_instance_proc_addr(parent,"vkGetDisplayPlaneSupportedDisplaysKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayPlaneSupportedDisplaysKHR)get_device_proc_addr(parent,"vkGetDisplayPlaneSupportedDisplaysKHR");
    }  
    
{
auto result=call_function(physicalDevice, planeIndex, pDisplayCount, pDisplays);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["planeIndex"]=planeIndex;}();
[&](){
            if (pDisplayCount==NULL){
                json["pDisplayCount"]=boost::json::array();
            return; }
        auto& arr_HfQXIoE=json["pDisplayCount"].emplace_array();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){arr_HfQXIoE[tJtenSc]=pDisplayCount[tJtenSc];}();
        }
        }();
[&](){
            if (pDisplays==NULL){
                json["pDisplays"]=boost::json::array();
            return; }
        auto& arr_zfKAWAH=json["pDisplays"].emplace_array();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){serialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV],pDisplays[OSaHdZV]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDisplayModePropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkDisplayModePropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayModePropertiesKHR*)malloc(*pPropertyCount*sizeof(VkDisplayModePropertiesKHR));
        auto& arr_kllbUBl=json["pProperties"].as_array();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto& temp=arr_kllbUBl[MCBnXbq].as_object();
            deserialize_struct(temp,pProperties[MCBnXbq]);
            }();
        }
        }();

    PFN_vkGetDisplayModePropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayModePropertiesKHR)get_instance_proc_addr(parent,"vkGetDisplayModePropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayModePropertiesKHR)get_device_proc_addr(parent,"vkGetDisplayModePropertiesKHR");
    }  
    
{
auto result=call_function(physicalDevice, display, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_kllbUBl=json["pProperties"].emplace_array();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto& temp=arr_kllbUBl[MCBnXbq].emplace_object();
            return serialize_struct(temp, pProperties[MCBnXbq]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateDisplayModeKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
VkDisplayModeCreateInfoKHR* pCreateInfo;
[&](){ VkDisplayModeCreateInfoKHR* temp_rTdQksT[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_rTdQksT=NULL;
            return; }temp_rTdQksT=(VkDisplayModeCreateInfoKHR*)malloc(1*sizeof(VkDisplayModeCreateInfoKHR));
        auto& arr_UCnUDZD=json["pCreateInfo"].as_array();
        for(int WMiWEeP=0; WMiWEeP < 1; WMiWEeP++){
            [&](){
            auto& temp=arr_UCnUDZD[WMiWEeP].as_object();
            deserialize_struct(temp,temp_rTdQksT[WMiWEeP]);
            }();
        }
        }();pCreateInfo=temp_rTdQksT;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkDisplayModeKHR* pMode;
[&](){
            if (json["pMode"].as_array().size()==0){
                pMode=NULL;
            return; }pMode=(VkDisplayModeKHR*)malloc(1*sizeof(VkDisplayModeKHR));
        auto& arr_CHqKWyT=json["pMode"].as_array();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){deserialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo], pMode[PRMVnqo]);}();
        }
        }();

    PFN_vkCreateDisplayModeKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDisplayModeKHR)get_instance_proc_addr(parent,"vkCreateDisplayModeKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDisplayModeKHR)get_device_proc_addr(parent,"vkCreateDisplayModeKHR");
    }  
    
{
auto result=call_function(physicalDevice, display, pCreateInfo, pAllocator, pMode);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_mQflhNS=json["pCreateInfo"].emplace_array();
        for(int UOiSdEd=0; UOiSdEd < 1; UOiSdEd++){
            [&](){
            auto& temp=arr_mQflhNS[UOiSdEd].emplace_object();
            return serialize_struct(temp, pCreateInfo[UOiSdEd]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMode==NULL){
                json["pMode"]=boost::json::array();
            return; }
        auto& arr_CHqKWyT=json["pMode"].emplace_array();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){serialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo],pMode[PRMVnqo]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDisplayPlaneCapabilitiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayModeKHR mode;
[&](){deserialize_VkDisplayModeKHR(json["mode"], mode);}();
uint32_t planeIndex;
[&](){planeIndex=static_cast<uint32_t>(value_to<int>(json["planeIndex"]));}();
VkDisplayPlaneCapabilitiesKHR* pCapabilities;
[&](){
            if (json["pCapabilities"].as_array().size()==0){
                pCapabilities=NULL;
            return; }pCapabilities=(VkDisplayPlaneCapabilitiesKHR*)malloc(1*sizeof(VkDisplayPlaneCapabilitiesKHR));
        auto& arr_HrzVMCr=json["pCapabilities"].as_array();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto& temp=arr_HrzVMCr[aOxwnlc].as_object();
            deserialize_struct(temp,pCapabilities[aOxwnlc]);
            }();
        }
        }();

    PFN_vkGetDisplayPlaneCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayPlaneCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetDisplayPlaneCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayPlaneCapabilitiesKHR)get_device_proc_addr(parent,"vkGetDisplayPlaneCapabilitiesKHR");
    }  
    
{
auto result=call_function(physicalDevice, mode, planeIndex, pCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayModeKHR(json["mode"],mode);}();
[&](){json["planeIndex"]=planeIndex;}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }
        auto& arr_HrzVMCr=json["pCapabilities"].emplace_array();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto& temp=arr_HrzVMCr[aOxwnlc].emplace_object();
            return serialize_struct(temp, pCapabilities[aOxwnlc]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateDisplayPlaneSurfaceKHR(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDisplaySurfaceCreateInfoKHR* pCreateInfo;
[&](){ VkDisplaySurfaceCreateInfoKHR* temp_LRRcgWe[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_LRRcgWe=NULL;
            return; }temp_LRRcgWe=(VkDisplaySurfaceCreateInfoKHR*)malloc(1*sizeof(VkDisplaySurfaceCreateInfoKHR));
        auto& arr_KiZtqkd=json["pCreateInfo"].as_array();
        for(int MxInMZf=0; MxInMZf < 1; MxInMZf++){
            [&](){
            auto& temp=arr_KiZtqkd[MxInMZf].as_object();
            deserialize_struct(temp,temp_LRRcgWe[MxInMZf]);
            }();
        }
        }();pCreateInfo=temp_LRRcgWe;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].as_array().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));
        auto& arr_zGtWguc=json["pSurface"].as_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateDisplayPlaneSurfaceKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDisplayPlaneSurfaceKHR)get_instance_proc_addr(parent,"vkCreateDisplayPlaneSurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDisplayPlaneSurfaceKHR)get_device_proc_addr(parent,"vkCreateDisplayPlaneSurfaceKHR");
    }  
    
{
auto result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_pnrRUFC=json["pCreateInfo"].emplace_array();
        for(int KAVLDOd=0; KAVLDOd < 1; KAVLDOd++){
            [&](){
            auto& temp=arr_pnrRUFC[KAVLDOd].emplace_object();
            return serialize_struct(temp, pCreateInfo[KAVLDOd]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }
        auto& arr_zGtWguc=json["pSurface"].emplace_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateSharedSwapchainsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t swapchainCount;
[&](){swapchainCount=static_cast<uint32_t>(value_to<int>(json["swapchainCount"]));}();
VkSwapchainCreateInfoKHR* pCreateInfos;
[&](){ VkSwapchainCreateInfoKHR* temp_AcZsudY[&](){
            if (json["pCreateInfos"].as_array().size()==0){
                temp_AcZsudY=NULL;
            return; }temp_AcZsudY=(VkSwapchainCreateInfoKHR*)malloc(swapchainCount*sizeof(VkSwapchainCreateInfoKHR));
        auto& arr_bfxCAiC=json["pCreateInfos"].as_array();
        for(int hPtbvYT=0; hPtbvYT < swapchainCount; hPtbvYT++){
            [&](){
            auto& temp=arr_bfxCAiC[hPtbvYT].as_object();
            deserialize_struct(temp,temp_AcZsudY[hPtbvYT]);
            }();
        }
        }();pCreateInfos=temp_AcZsudY;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkSwapchainKHR* pSwapchains;
[&](){
            if (json["pSwapchains"].as_array().size()==0){
                pSwapchains=NULL;
            return; }pSwapchains=(VkSwapchainKHR*)malloc(swapchainCount*sizeof(VkSwapchainKHR));
        auto& arr_UlEaWkU=json["pSwapchains"].as_array();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){deserialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd], pSwapchains[SREXLhd]);}();
        }
        }();

    PFN_vkCreateSharedSwapchainsKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSharedSwapchainsKHR)get_instance_proc_addr(parent,"vkCreateSharedSwapchainsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSharedSwapchainsKHR)get_device_proc_addr(parent,"vkCreateSharedSwapchainsKHR");
    }  
    
{
auto result=call_function(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=swapchainCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_GXhEUBn=json["pCreateInfos"].emplace_array();
        for(int KSXdUUO=0; KSXdUUO < swapchainCount; KSXdUUO++){
            [&](){
            auto& temp=arr_GXhEUBn[KSXdUUO].emplace_object();
            return serialize_struct(temp, pCreateInfos[KSXdUUO]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=boost::json::array();
            return; }
        auto& arr_UlEaWkU=json["pSwapchains"].emplace_array();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){serialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd],pSwapchains[SREXLhd]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroySurfaceKHR(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroySurfaceKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySurfaceKHR)get_instance_proc_addr(parent,"vkDestroySurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySurfaceKHR)get_device_proc_addr(parent,"vkDestroySurfaceKHR");
    }  
    
{
call_function(instance, surface, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceSupportKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkBool32* pSupported;
[&](){
            if (json["pSupported"].as_array().size()==0){
                pSupported=NULL;
            return; }pSupported=(VkBool32*)malloc(1*sizeof(VkBool32));
        auto& arr_SEnYPHg=json["pSupported"].as_array();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){uint32_t temp_SEnYPHg;[&](){temp_SEnYPHg=static_cast<uint32_t>(value_to<int>(arr_SEnYPHg[rAhuVoM]));}();pSupported[rAhuVoM]=(VkBool32)temp_SEnYPHg;}();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceSupportKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceSupportKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceSupportKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceSupportKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceSupportKHR");
    }  
    
{
auto result=call_function(physicalDevice, queueFamilyIndex, surface, pSupported);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSupported==NULL){
                json["pSupported"]=boost::json::array();
            return; }
        auto& arr_SEnYPHg=json["pSupported"].emplace_array();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){[&](){arr_SEnYPHg[rAhuVoM]=pSupported[rAhuVoM];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkSurfaceCapabilitiesKHR* pSurfaceCapabilities;
[&](){
            if (json["pSurfaceCapabilities"].as_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }pSurfaceCapabilities=(VkSurfaceCapabilitiesKHR*)malloc(1*sizeof(VkSurfaceCapabilitiesKHR));
        auto& arr_mjTYhnS=json["pSurfaceCapabilities"].as_array();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto& temp=arr_mjTYhnS[MvYVwuP].as_object();
            deserialize_struct(temp,pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    }  
    
{
auto result=call_function(physicalDevice, surface, pSurfaceCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }
        auto& arr_mjTYhnS=json["pSurfaceCapabilities"].emplace_array();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto& temp=arr_mjTYhnS[MvYVwuP].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceFormatsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
uint32_t* pSurfaceFormatCount;
[&](){
            if (json["pSurfaceFormatCount"].as_array().size()==0){
                pSurfaceFormatCount=NULL;
            return; }pSurfaceFormatCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].as_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(value_to<int>(arr_mbQwRYl[bFtFQKD]));}();
        }
        }();
VkSurfaceFormatKHR* pSurfaceFormats;
[&](){
            if (json["pSurfaceFormats"].as_array().size()==0){
                pSurfaceFormats=NULL;
            return; }pSurfaceFormats=(VkSurfaceFormatKHR*)malloc(*pSurfaceFormatCount*sizeof(VkSurfaceFormatKHR));
        auto& arr_FttXsVA=json["pSurfaceFormats"].as_array();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto& temp=arr_FttXsVA[sioXabq].as_object();
            deserialize_struct(temp,pSurfaceFormats[sioXabq]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceFormatsKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormatsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormatsKHR");
    }  
    
{
auto result=call_function(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=boost::json::array();
            return; }
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].emplace_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=pSurfaceFormatCount[bFtFQKD];}();
        }
        }();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=boost::json::array();
            return; }
        auto& arr_FttXsVA=json["pSurfaceFormats"].emplace_array();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto& temp=arr_FttXsVA[sioXabq].emplace_object();
            return serialize_struct(temp, pSurfaceFormats[sioXabq]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfacePresentModesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
uint32_t* pPresentModeCount;
[&](){
            if (json["pPresentModeCount"].as_array().size()==0){
                pPresentModeCount=NULL;
            return; }pPresentModeCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_jrQQyxv=json["pPresentModeCount"].as_array();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){pPresentModeCount[yThsxfd]=static_cast<uint32_t>(value_to<int>(arr_jrQQyxv[yThsxfd]));}();
        }
        }();
VkPresentModeKHR* pPresentModes;
[&](){
            if (json["pPresentModes"].as_array().size()==0){
                pPresentModes=NULL;
            return; }pPresentModes=(VkPresentModeKHR*)malloc(*pPresentModeCount*sizeof(VkPresentModeKHR));
        auto& arr_hrNyEFX=json["pPresentModes"].as_array();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){int temp_ZltIdVU;[&](){temp_ZltIdVU=static_cast<int>(value_to<int>(arr_hrNyEFX[ULOmMaK]));}();pPresentModes[ULOmMaK]=(VkPresentModeKHR)temp_ZltIdVU;}();}();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfacePresentModesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfacePresentModesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfacePresentModesKHR");
    }  
    
{
auto result=call_function(physicalDevice, surface, pPresentModeCount, pPresentModes);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pPresentModeCount==NULL){
                json["pPresentModeCount"]=boost::json::array();
            return; }
        auto& arr_jrQQyxv=json["pPresentModeCount"].emplace_array();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){arr_jrQQyxv[yThsxfd]=pPresentModeCount[yThsxfd];}();
        }
        }();
[&](){
            if (pPresentModes==NULL){
                json["pPresentModes"]=boost::json::array();
            return; }
        auto& arr_hrNyEFX=json["pPresentModes"].emplace_array();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){[&](){arr_hrNyEFX[ULOmMaK]=pPresentModes[ULOmMaK];}();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateSwapchainKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainCreateInfoKHR* pCreateInfo;
[&](){ VkSwapchainCreateInfoKHR* temp_aSmcOBE[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_aSmcOBE=NULL;
            return; }temp_aSmcOBE=(VkSwapchainCreateInfoKHR*)malloc(1*sizeof(VkSwapchainCreateInfoKHR));
        auto& arr_ioKDSXs=json["pCreateInfo"].as_array();
        for(int ugpCvwH=0; ugpCvwH < 1; ugpCvwH++){
            [&](){
            auto& temp=arr_ioKDSXs[ugpCvwH].as_object();
            deserialize_struct(temp,temp_aSmcOBE[ugpCvwH]);
            }();
        }
        }();pCreateInfo=temp_aSmcOBE;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkSwapchainKHR* pSwapchain;
[&](){
            if (json["pSwapchain"].as_array().size()==0){
                pSwapchain=NULL;
            return; }pSwapchain=(VkSwapchainKHR*)malloc(1*sizeof(VkSwapchainKHR));
        auto& arr_vaTnpgr=json["pSwapchain"].as_array();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){deserialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc], pSwapchain[KnKufZc]);}();
        }
        }();

    PFN_vkCreateSwapchainKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSwapchainKHR)get_instance_proc_addr(parent,"vkCreateSwapchainKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSwapchainKHR)get_device_proc_addr(parent,"vkCreateSwapchainKHR");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pSwapchain);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_egkAfIq=json["pCreateInfo"].emplace_array();
        for(int RzLCOHt=0; RzLCOHt < 1; RzLCOHt++){
            [&](){
            auto& temp=arr_egkAfIq[RzLCOHt].emplace_object();
            return serialize_struct(temp, pCreateInfo[RzLCOHt]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSwapchain==NULL){
                json["pSwapchain"]=boost::json::array();
            return; }
        auto& arr_vaTnpgr=json["pSwapchain"].emplace_array();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){serialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc],pSwapchain[KnKufZc]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroySwapchainKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroySwapchainKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySwapchainKHR)get_instance_proc_addr(parent,"vkDestroySwapchainKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySwapchainKHR)get_device_proc_addr(parent,"vkDestroySwapchainKHR");
    }  
    
{
call_function(device, swapchain, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetSwapchainImagesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint32_t* pSwapchainImageCount;
[&](){
            if (json["pSwapchainImageCount"].as_array().size()==0){
                pSwapchainImageCount=NULL;
            return; }pSwapchainImageCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_fUdbkNA=json["pSwapchainImageCount"].as_array();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(value_to<int>(arr_fUdbkNA[YVmxCel]));}();
        }
        }();
VkImage* pSwapchainImages;
[&](){
            if (json["pSwapchainImages"].as_array().size()==0){
                pSwapchainImages=NULL;
            return; }pSwapchainImages=(VkImage*)malloc(*pSwapchainImageCount*sizeof(VkImage));
        auto& arr_KNYDiQo=json["pSwapchainImages"].as_array();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){deserialize_VkImage(arr_KNYDiQo[ICMlCyp], pSwapchainImages[ICMlCyp]);}();
        }
        }();

    PFN_vkGetSwapchainImagesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSwapchainImagesKHR)get_instance_proc_addr(parent,"vkGetSwapchainImagesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSwapchainImagesKHR)get_device_proc_addr(parent,"vkGetSwapchainImagesKHR");
    }  
    
{
auto result=call_function(device, swapchain, pSwapchainImageCount, pSwapchainImages);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pSwapchainImageCount==NULL){
                json["pSwapchainImageCount"]=boost::json::array();
            return; }
        auto& arr_fUdbkNA=json["pSwapchainImageCount"].emplace_array();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){arr_fUdbkNA[YVmxCel]=pSwapchainImageCount[YVmxCel];}();
        }
        }();
[&](){
            if (pSwapchainImages==NULL){
                json["pSwapchainImages"]=boost::json::array();
            return; }
        auto& arr_KNYDiQo=json["pSwapchainImages"].emplace_array();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){serialize_VkImage(arr_KNYDiQo[ICMlCyp],pSwapchainImages[ICMlCyp]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkAcquireNextImageKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint64_t timeout;
[&](){timeout=static_cast<uint64_t>(value_to<int>(json["timeout"]));}();
VkSemaphore semaphore;
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();
uint32_t* pImageIndex;
[&](){
            if (json["pImageIndex"].as_array().size()==0){
                pImageIndex=NULL;
            return; }pImageIndex=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_oSqpNfH=json["pImageIndex"].as_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){pImageIndex[BEjuBtR]=static_cast<uint32_t>(value_to<int>(arr_oSqpNfH[BEjuBtR]));}();
        }
        }();

    PFN_vkAcquireNextImageKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquireNextImageKHR)get_instance_proc_addr(parent,"vkAcquireNextImageKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquireNextImageKHR)get_device_proc_addr(parent,"vkAcquireNextImageKHR");
    }  
    
{
auto result=call_function(device, swapchain, timeout, semaphore, fence, pImageIndex);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["timeout"]=timeout;}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=boost::json::array();
            return; }
        auto& arr_oSqpNfH=json["pImageIndex"].emplace_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=pImageIndex[BEjuBtR];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkQueuePresentKHR(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
VkPresentInfoKHR* pPresentInfo;
[&](){ VkPresentInfoKHR* temp_bNoOQnS[&](){
            if (json["pPresentInfo"].as_array().size()==0){
                temp_bNoOQnS=NULL;
            return; }temp_bNoOQnS=(VkPresentInfoKHR*)malloc(1*sizeof(VkPresentInfoKHR));
        auto& arr_lGNUHER=json["pPresentInfo"].as_array();
        for(int gefTrKz=0; gefTrKz < 1; gefTrKz++){
            [&](){
            auto& temp=arr_lGNUHER[gefTrKz].as_object();
            deserialize_struct(temp,temp_bNoOQnS[gefTrKz]);
            }();
        }
        }();pPresentInfo=temp_bNoOQnS;}();

    PFN_vkQueuePresentKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueuePresentKHR)get_instance_proc_addr(parent,"vkQueuePresentKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueuePresentKHR)get_device_proc_addr(parent,"vkQueuePresentKHR");
    }  
    
{
auto result=call_function(queue, pPresentInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pPresentInfo==NULL){
                json["pPresentInfo"]=boost::json::array();
            return; }
        auto& arr_EyhZHrS=json["pPresentInfo"].emplace_array();
        for(int EKHdNlu=0; EKHdNlu < 1; EKHdNlu++){
            [&](){
            auto& temp=arr_EyhZHrS[EKHdNlu].emplace_object();
            return serialize_struct(temp, pPresentInfo[EKHdNlu]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateXlibSurfaceKHR(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkXlibSurfaceCreateInfoKHR* pCreateInfo;
[&](){ VkXlibSurfaceCreateInfoKHR* temp_zSgnZxI[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_zSgnZxI=NULL;
            return; }temp_zSgnZxI=(VkXlibSurfaceCreateInfoKHR*)malloc(1*sizeof(VkXlibSurfaceCreateInfoKHR));
        auto& arr_wdGSkCh=json["pCreateInfo"].as_array();
        for(int iNgqKFe=0; iNgqKFe < 1; iNgqKFe++){
            [&](){
            auto& temp=arr_wdGSkCh[iNgqKFe].as_object();
            deserialize_struct(temp,temp_zSgnZxI[iNgqKFe]);
            }();
        }
        }();pCreateInfo=temp_zSgnZxI;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].as_array().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));
        auto& arr_zGtWguc=json["pSurface"].as_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateXlibSurfaceKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateXlibSurfaceKHR)get_instance_proc_addr(parent,"vkCreateXlibSurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateXlibSurfaceKHR)get_device_proc_addr(parent,"vkCreateXlibSurfaceKHR");
    }  
    
{
auto result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_xAdBgFR=json["pCreateInfo"].emplace_array();
        for(int sMWpcdX=0; sMWpcdX < 1; sMWpcdX++){
            [&](){
            auto& temp=arr_xAdBgFR[sMWpcdX].emplace_object();
            return serialize_struct(temp, pCreateInfo[sMWpcdX]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }
        auto& arr_zGtWguc=json["pSurface"].emplace_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceXlibPresentationSupportKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
Display* dpy;
[&](){
            if (json["dpy"].as_array().size()==0){
                dpy=NULL;
            return; }dpy=(Display* )(value_to<uintptr_t>(json["dpy"]));}();
VisualID visualID;
[&](){visualID=(VisualID )(value_to<uintptr_t>(json["visualID"]));}();

    PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceXlibPresentationSupportKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceXlibPresentationSupportKHR");
    }  
    
{
auto result=call_function(physicalDevice, queueFamilyIndex, dpy, visualID);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (dpy==NULL){
                json["dpy"]=boost::json::array();
            return; }json["dpy"]=(uintptr_t)dpy;}();
[&](){json["visualID"]=(uintptr_t)visualID;}();


        writeToConn(json);
    }

    void handle_vkCreateXcbSurfaceKHR(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkXcbSurfaceCreateInfoKHR* pCreateInfo;
[&](){ VkXcbSurfaceCreateInfoKHR* temp_nWWNXgc[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_nWWNXgc=NULL;
            return; }temp_nWWNXgc=(VkXcbSurfaceCreateInfoKHR*)malloc(1*sizeof(VkXcbSurfaceCreateInfoKHR));
        auto& arr_fIYRZSR=json["pCreateInfo"].as_array();
        for(int QDYAgHl=0; QDYAgHl < 1; QDYAgHl++){
            [&](){
            auto& temp=arr_fIYRZSR[QDYAgHl].as_object();
            deserialize_struct(temp,temp_nWWNXgc[QDYAgHl]);
            }();
        }
        }();pCreateInfo=temp_nWWNXgc;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].as_array().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));
        auto& arr_zGtWguc=json["pSurface"].as_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateXcbSurfaceKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateXcbSurfaceKHR)get_instance_proc_addr(parent,"vkCreateXcbSurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateXcbSurfaceKHR)get_device_proc_addr(parent,"vkCreateXcbSurfaceKHR");
    }  
    
{
auto result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_yvWYCbg=json["pCreateInfo"].emplace_array();
        for(int DeNvCZU=0; DeNvCZU < 1; DeNvCZU++){
            [&](){
            auto& temp=arr_yvWYCbg[DeNvCZU].emplace_object();
            return serialize_struct(temp, pCreateInfo[DeNvCZU]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }
        auto& arr_zGtWguc=json["pSurface"].emplace_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceXcbPresentationSupportKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
xcb_connection_t* connection;
[&](){
            if (json["connection"].as_array().size()==0){
                connection=NULL;
            return; }connection=(xcb_connection_t* )(value_to<uintptr_t>(json["connection"]));}();
xcb_visualid_t visual_id;
[&](){visual_id=(xcb_visualid_t )(value_to<uintptr_t>(json["visual_id"]));}();

    PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceXcbPresentationSupportKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceXcbPresentationSupportKHR");
    }  
    
{
auto result=call_function(physicalDevice, queueFamilyIndex, connection, visual_id);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (connection==NULL){
                json["connection"]=boost::json::array();
            return; }json["connection"]=(uintptr_t)connection;}();
[&](){json["visual_id"]=(uintptr_t)visual_id;}();


        writeToConn(json);
    }

    void handle_vkCreateDebugReportCallbackEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugReportCallbackCreateInfoEXT* pCreateInfo;
[&](){ VkDebugReportCallbackCreateInfoEXT* temp_iSTySca[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_iSTySca=NULL;
            return; }temp_iSTySca=(VkDebugReportCallbackCreateInfoEXT*)malloc(1*sizeof(VkDebugReportCallbackCreateInfoEXT));
        auto& arr_bvXzZVI=json["pCreateInfo"].as_array();
        for(int wOLpuxo=0; wOLpuxo < 1; wOLpuxo++){
            [&](){
            auto& temp=arr_bvXzZVI[wOLpuxo].as_object();
            deserialize_struct(temp,temp_iSTySca[wOLpuxo]);
            }();
        }
        }();pCreateInfo=temp_iSTySca;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkDebugReportCallbackEXT* pCallback;
[&](){
            if (json["pCallback"].as_array().size()==0){
                pCallback=NULL;
            return; }pCallback=(VkDebugReportCallbackEXT*)malloc(1*sizeof(VkDebugReportCallbackEXT));
        auto& arr_qwLilWz=json["pCallback"].as_array();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){deserialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy], pCallback[GoaYtYy]);}();
        }
        }();

    PFN_vkCreateDebugReportCallbackEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDebugReportCallbackEXT)get_instance_proc_addr(parent,"vkCreateDebugReportCallbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDebugReportCallbackEXT)get_device_proc_addr(parent,"vkCreateDebugReportCallbackEXT");
    }  
    
{
auto result=call_function(instance, pCreateInfo, pAllocator, pCallback);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_YvgjHhM=json["pCreateInfo"].emplace_array();
        for(int BsRBklZ=0; BsRBklZ < 1; BsRBklZ++){
            [&](){
            auto& temp=arr_YvgjHhM[BsRBklZ].emplace_object();
            return serialize_struct(temp, pCreateInfo[BsRBklZ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pCallback==NULL){
                json["pCallback"]=boost::json::array();
            return; }
        auto& arr_qwLilWz=json["pCallback"].emplace_array();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){serialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy],pCallback[GoaYtYy]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyDebugReportCallbackEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugReportCallbackEXT callback;
[&](){deserialize_VkDebugReportCallbackEXT(json["callback"], callback);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyDebugReportCallbackEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDebugReportCallbackEXT)get_instance_proc_addr(parent,"vkDestroyDebugReportCallbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDebugReportCallbackEXT)get_device_proc_addr(parent,"vkDestroyDebugReportCallbackEXT");
    }  
    
{
call_function(instance, callback, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugReportCallbackEXT(json["callback"],callback);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDebugReportMessageEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugReportFlagsEXT flags;
[&](){[&](){int temp_tiROuYA;[&](){temp_tiROuYA=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkDebugReportFlagsEXT)temp_tiROuYA;}();}();
VkDebugReportObjectTypeEXT objectType;
[&](){[&](){int temp_rGtGMFh;[&](){temp_rGtGMFh=static_cast<int>(value_to<int>(json["objectType"]));}();objectType=(VkDebugReportObjectTypeEXT)temp_rGtGMFh;}();}();
uint64_t object;
[&](){object=static_cast<uint64_t>(value_to<int>(json["object"]));}();
size_t location;
[&](){location=static_cast<size_t>(value_to<int>(json["location"]));}();
int32_t messageCode;
[&](){messageCode=static_cast<int32_t>(value_to<int>(json["messageCode"]));}();
char* pLayerPrefix;
[&](){ char* temp_QkxHNwY[&](){
            if (json["pLayerPrefix"].as_array().size()==0){
                temp_QkxHNwY=NULL;
            return; }temp_QkxHNwY=(char*)malloc(json["pLayerPrefix"].as_array().size()*sizeof(char));
        auto& arr_uXlnNyO=json["pLayerPrefix"].as_array();
        for(int tgIwrYh=0; tgIwrYh < json["pLayerPrefix"].as_array().size(); tgIwrYh++){
            [&](){temp_QkxHNwY[tgIwrYh]=static_cast<char>(value_to<int>(arr_uXlnNyO[tgIwrYh]));}();
        }
        }();pLayerPrefix=temp_QkxHNwY;}();
char* pMessage;
[&](){ char* temp_jYCwXfq[&](){
            if (json["pMessage"].as_array().size()==0){
                temp_jYCwXfq=NULL;
            return; }temp_jYCwXfq=(char*)malloc(json["pMessage"].as_array().size()*sizeof(char));
        auto& arr_hjvjHsV=json["pMessage"].as_array();
        for(int WEDXGTi=0; WEDXGTi < json["pMessage"].as_array().size(); WEDXGTi++){
            [&](){temp_jYCwXfq[WEDXGTi]=static_cast<char>(value_to<int>(arr_hjvjHsV[WEDXGTi]));}();
        }
        }();pMessage=temp_jYCwXfq;}();

    PFN_vkDebugReportMessageEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDebugReportMessageEXT)get_instance_proc_addr(parent,"vkDebugReportMessageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDebugReportMessageEXT)get_device_proc_addr(parent,"vkDebugReportMessageEXT");
    }  
    
{
call_function(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["object"]=object;}();
[&](){json["location"]=location;}();
[&](){json["messageCode"]=messageCode;}();
[&](){
            if (pLayerPrefix==NULL){
                json["pLayerPrefix"]=boost::json::array();
            return; }
        auto& arr_SZVAgkt=json["pLayerPrefix"].emplace_array();
        for(int ESuRCqF=0; ESuRCqF < strlen(pLayerPrefix)+1; ESuRCqF++){
            [&](){arr_SZVAgkt[ESuRCqF]=pLayerPrefix[ESuRCqF];}();
        }
        }();
[&](){
            if (pMessage==NULL){
                json["pMessage"]=boost::json::array();
            return; }
        auto& arr_rGBBIki=json["pMessage"].emplace_array();
        for(int ZYKcZZQ=0; ZYKcZZQ < strlen(pMessage)+1; ZYKcZZQ++){
            [&](){arr_rGBBIki[ZYKcZZQ]=pMessage[ZYKcZZQ];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDebugMarkerSetObjectNameEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDebugMarkerObjectNameInfoEXT* pNameInfo;
[&](){ VkDebugMarkerObjectNameInfoEXT* temp_WzToUiV[&](){
            if (json["pNameInfo"].as_array().size()==0){
                temp_WzToUiV=NULL;
            return; }temp_WzToUiV=(VkDebugMarkerObjectNameInfoEXT*)malloc(1*sizeof(VkDebugMarkerObjectNameInfoEXT));
        auto& arr_VqYlRlZ=json["pNameInfo"].as_array();
        for(int rPEeNJT=0; rPEeNJT < 1; rPEeNJT++){
            [&](){
            auto& temp=arr_VqYlRlZ[rPEeNJT].as_object();
            deserialize_struct(temp,temp_WzToUiV[rPEeNJT]);
            }();
        }
        }();pNameInfo=temp_WzToUiV;}();

    PFN_vkDebugMarkerSetObjectNameEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDebugMarkerSetObjectNameEXT)get_instance_proc_addr(parent,"vkDebugMarkerSetObjectNameEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDebugMarkerSetObjectNameEXT)get_device_proc_addr(parent,"vkDebugMarkerSetObjectNameEXT");
    }  
    
{
auto result=call_function(device, pNameInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=boost::json::array();
            return; }
        auto& arr_WQmILKl=json["pNameInfo"].emplace_array();
        for(int VlhHang=0; VlhHang < 1; VlhHang++){
            [&](){
            auto& temp=arr_WQmILKl[VlhHang].emplace_object();
            return serialize_struct(temp, pNameInfo[VlhHang]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDebugMarkerSetObjectTagEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDebugMarkerObjectTagInfoEXT* pTagInfo;
[&](){ VkDebugMarkerObjectTagInfoEXT* temp_GQDZGYy[&](){
            if (json["pTagInfo"].as_array().size()==0){
                temp_GQDZGYy=NULL;
            return; }temp_GQDZGYy=(VkDebugMarkerObjectTagInfoEXT*)malloc(1*sizeof(VkDebugMarkerObjectTagInfoEXT));
        auto& arr_RbbYJqv=json["pTagInfo"].as_array();
        for(int RnIbuuZ=0; RnIbuuZ < 1; RnIbuuZ++){
            [&](){
            auto& temp=arr_RbbYJqv[RnIbuuZ].as_object();
            deserialize_struct(temp,temp_GQDZGYy[RnIbuuZ]);
            }();
        }
        }();pTagInfo=temp_GQDZGYy;}();

    PFN_vkDebugMarkerSetObjectTagEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDebugMarkerSetObjectTagEXT)get_instance_proc_addr(parent,"vkDebugMarkerSetObjectTagEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDebugMarkerSetObjectTagEXT)get_device_proc_addr(parent,"vkDebugMarkerSetObjectTagEXT");
    }  
    
{
auto result=call_function(device, pTagInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=boost::json::array();
            return; }
        auto& arr_uESKIxS=json["pTagInfo"].emplace_array();
        for(int fibGciH=0; fibGciH < 1; fibGciH++){
            [&](){
            auto& temp=arr_uESKIxS[fibGciH].emplace_object();
            return serialize_struct(temp, pTagInfo[fibGciH]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDebugMarkerBeginEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
[&](){ VkDebugMarkerMarkerInfoEXT* temp_YBrWqkU[&](){
            if (json["pMarkerInfo"].as_array().size()==0){
                temp_YBrWqkU=NULL;
            return; }temp_YBrWqkU=(VkDebugMarkerMarkerInfoEXT*)malloc(1*sizeof(VkDebugMarkerMarkerInfoEXT));
        auto& arr_dufSdWh=json["pMarkerInfo"].as_array();
        for(int wWwHKWF=0; wWwHKWF < 1; wWwHKWF++){
            [&](){
            auto& temp=arr_dufSdWh[wWwHKWF].as_object();
            deserialize_struct(temp,temp_YBrWqkU[wWwHKWF]);
            }();
        }
        }();pMarkerInfo=temp_YBrWqkU;}();

    PFN_vkCmdDebugMarkerBeginEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDebugMarkerBeginEXT)get_instance_proc_addr(parent,"vkCmdDebugMarkerBeginEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDebugMarkerBeginEXT)get_device_proc_addr(parent,"vkCmdDebugMarkerBeginEXT");
    }  
    
{
call_function(commandBuffer, pMarkerInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }
        auto& arr_sUKpmoY=json["pMarkerInfo"].emplace_array();
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto& temp=arr_sUKpmoY[MSMqdqs].emplace_object();
            return serialize_struct(temp, pMarkerInfo[MSMqdqs]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDebugMarkerEndEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdDebugMarkerEndEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDebugMarkerEndEXT)get_instance_proc_addr(parent,"vkCmdDebugMarkerEndEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDebugMarkerEndEXT)get_device_proc_addr(parent,"vkCmdDebugMarkerEndEXT");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        writeToConn(json);
    }

    void handle_vkCmdDebugMarkerInsertEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
[&](){ VkDebugMarkerMarkerInfoEXT* temp_YBrWqkU[&](){
            if (json["pMarkerInfo"].as_array().size()==0){
                temp_YBrWqkU=NULL;
            return; }temp_YBrWqkU=(VkDebugMarkerMarkerInfoEXT*)malloc(1*sizeof(VkDebugMarkerMarkerInfoEXT));
        auto& arr_dufSdWh=json["pMarkerInfo"].as_array();
        for(int wWwHKWF=0; wWwHKWF < 1; wWwHKWF++){
            [&](){
            auto& temp=arr_dufSdWh[wWwHKWF].as_object();
            deserialize_struct(temp,temp_YBrWqkU[wWwHKWF]);
            }();
        }
        }();pMarkerInfo=temp_YBrWqkU;}();

    PFN_vkCmdDebugMarkerInsertEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDebugMarkerInsertEXT)get_instance_proc_addr(parent,"vkCmdDebugMarkerInsertEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDebugMarkerInsertEXT)get_device_proc_addr(parent,"vkCmdDebugMarkerInsertEXT");
    }  
    
{
call_function(commandBuffer, pMarkerInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }
        auto& arr_sUKpmoY=json["pMarkerInfo"].emplace_array();
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto& temp=arr_sUKpmoY[MSMqdqs].emplace_object();
            return serialize_struct(temp, pMarkerInfo[MSMqdqs]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
VkImageType type;
[&](){[&](){int temp_bMZuPlo;[&](){temp_bMZuPlo=static_cast<int>(value_to<int>(json["type"]));}();type=(VkImageType)temp_bMZuPlo;}();}();
VkImageTiling tiling;
[&](){[&](){int temp_PtqdPDE;[&](){temp_PtqdPDE=static_cast<int>(value_to<int>(json["tiling"]));}();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
VkImageUsageFlags usage;
[&](){[&](){int temp_sXuQFYv;[&](){temp_sXuQFYv=static_cast<int>(value_to<int>(json["usage"]));}();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
VkImageCreateFlags flags;
[&](){[&](){int temp_LpOHWxp;[&](){temp_LpOHWxp=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
VkExternalMemoryHandleTypeFlagsNV externalHandleType;
[&](){[&](){int temp_DSfbDyM;[&](){temp_DSfbDyM=static_cast<int>(value_to<int>(json["externalHandleType"]));}();externalHandleType=(VkExternalMemoryHandleTypeFlagsNV)temp_DSfbDyM;}();}();
VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties;
[&](){
            if (json["pExternalImageFormatProperties"].as_array().size()==0){
                pExternalImageFormatProperties=NULL;
            return; }pExternalImageFormatProperties=(VkExternalImageFormatPropertiesNV*)malloc(1*sizeof(VkExternalImageFormatPropertiesNV));
        auto& arr_gXHGwln=json["pExternalImageFormatProperties"].as_array();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto& temp=arr_gXHGwln[CfNLqMF].as_object();
            deserialize_struct(temp,pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
    }  
    
{
auto result=call_function(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["externalHandleType"]=externalHandleType;}();}();}();
[&](){
            if (pExternalImageFormatProperties==NULL){
                json["pExternalImageFormatProperties"]=boost::json::array();
            return; }
        auto& arr_gXHGwln=json["pExternalImageFormatProperties"].emplace_array();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto& temp=arr_gXHGwln[CfNLqMF].emplace_object();
            return serialize_struct(temp, pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdExecuteGeneratedCommandsNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 isPreprocessed;
[&](){uint32_t temp_tPMaOPc;[&](){temp_tPMaOPc=static_cast<uint32_t>(value_to<int>(json["isPreprocessed"]));}();isPreprocessed=(VkBool32)temp_tPMaOPc;}();
VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo;
[&](){ VkGeneratedCommandsInfoNV* temp_AYGolkM[&](){
            if (json["pGeneratedCommandsInfo"].as_array().size()==0){
                temp_AYGolkM=NULL;
            return; }temp_AYGolkM=(VkGeneratedCommandsInfoNV*)malloc(1*sizeof(VkGeneratedCommandsInfoNV));
        auto& arr_HWCDzqJ=json["pGeneratedCommandsInfo"].as_array();
        for(int ZktpRSr=0; ZktpRSr < 1; ZktpRSr++){
            [&](){
            auto& temp=arr_HWCDzqJ[ZktpRSr].as_object();
            deserialize_struct(temp,temp_AYGolkM[ZktpRSr]);
            }();
        }
        }();pGeneratedCommandsInfo=temp_AYGolkM;}();

    PFN_vkCmdExecuteGeneratedCommandsNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdExecuteGeneratedCommandsNV)get_instance_proc_addr(parent,"vkCmdExecuteGeneratedCommandsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdExecuteGeneratedCommandsNV)get_device_proc_addr(parent,"vkCmdExecuteGeneratedCommandsNV");
    }  
    
{
call_function(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["isPreprocessed"]=isPreprocessed;}();}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=boost::json::array();
            return; }
        auto& arr_mvZtJqS=json["pGeneratedCommandsInfo"].emplace_array();
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto& temp=arr_mvZtJqS[breVZQP].emplace_object();
            return serialize_struct(temp, pGeneratedCommandsInfo[breVZQP]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdPreprocessGeneratedCommandsNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo;
[&](){ VkGeneratedCommandsInfoNV* temp_AYGolkM[&](){
            if (json["pGeneratedCommandsInfo"].as_array().size()==0){
                temp_AYGolkM=NULL;
            return; }temp_AYGolkM=(VkGeneratedCommandsInfoNV*)malloc(1*sizeof(VkGeneratedCommandsInfoNV));
        auto& arr_HWCDzqJ=json["pGeneratedCommandsInfo"].as_array();
        for(int ZktpRSr=0; ZktpRSr < 1; ZktpRSr++){
            [&](){
            auto& temp=arr_HWCDzqJ[ZktpRSr].as_object();
            deserialize_struct(temp,temp_AYGolkM[ZktpRSr]);
            }();
        }
        }();pGeneratedCommandsInfo=temp_AYGolkM;}();

    PFN_vkCmdPreprocessGeneratedCommandsNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPreprocessGeneratedCommandsNV)get_instance_proc_addr(parent,"vkCmdPreprocessGeneratedCommandsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPreprocessGeneratedCommandsNV)get_device_proc_addr(parent,"vkCmdPreprocessGeneratedCommandsNV");
    }  
    
{
call_function(commandBuffer, pGeneratedCommandsInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=boost::json::array();
            return; }
        auto& arr_mvZtJqS=json["pGeneratedCommandsInfo"].emplace_array();
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto& temp=arr_mvZtJqS[breVZQP].emplace_object();
            return serialize_struct(temp, pGeneratedCommandsInfo[breVZQP]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBindPipelineShaderGroupNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t groupIndex;
[&](){groupIndex=static_cast<uint32_t>(value_to<int>(json["groupIndex"]));}();

    PFN_vkCmdBindPipelineShaderGroupNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindPipelineShaderGroupNV)get_instance_proc_addr(parent,"vkCmdBindPipelineShaderGroupNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindPipelineShaderGroupNV)get_device_proc_addr(parent,"vkCmdBindPipelineShaderGroupNV");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["groupIndex"]=groupIndex;}();


        writeToConn(json);
    }

    void handle_vkGetGeneratedCommandsMemoryRequirementsNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo;
[&](){ VkGeneratedCommandsMemoryRequirementsInfoNV* temp_lJhIAmh[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_lJhIAmh=NULL;
            return; }temp_lJhIAmh=(VkGeneratedCommandsMemoryRequirementsInfoNV*)malloc(1*sizeof(VkGeneratedCommandsMemoryRequirementsInfoNV));
        auto& arr_KgvktJY=json["pInfo"].as_array();
        for(int JNwrpFH=0; JNwrpFH < 1; JNwrpFH++){
            [&](){
            auto& temp=arr_KgvktJY[JNwrpFH].as_object();
            deserialize_struct(temp,temp_lJhIAmh[JNwrpFH]);
            }();
        }
        }();pInfo=temp_lJhIAmh;}();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetGeneratedCommandsMemoryRequirementsNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetGeneratedCommandsMemoryRequirementsNV)get_instance_proc_addr(parent,"vkGetGeneratedCommandsMemoryRequirementsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetGeneratedCommandsMemoryRequirementsNV)get_device_proc_addr(parent,"vkGetGeneratedCommandsMemoryRequirementsNV");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_bVjZkmU=json["pInfo"].emplace_array();
        for(int suoLDtj=0; suoLDtj < 1; suoLDtj++){
            [&](){
            auto& temp=arr_bVjZkmU[suoLDtj].emplace_object();
            return serialize_struct(temp, pInfo[suoLDtj]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateIndirectCommandsLayoutNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo;
[&](){ VkIndirectCommandsLayoutCreateInfoNV* temp_IoZfFzs[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_IoZfFzs=NULL;
            return; }temp_IoZfFzs=(VkIndirectCommandsLayoutCreateInfoNV*)malloc(1*sizeof(VkIndirectCommandsLayoutCreateInfoNV));
        auto& arr_moJlSYv=json["pCreateInfo"].as_array();
        for(int GBtaMlf=0; GBtaMlf < 1; GBtaMlf++){
            [&](){
            auto& temp=arr_moJlSYv[GBtaMlf].as_object();
            deserialize_struct(temp,temp_IoZfFzs[GBtaMlf]);
            }();
        }
        }();pCreateInfo=temp_IoZfFzs;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkIndirectCommandsLayoutNV* pIndirectCommandsLayout;
[&](){
            if (json["pIndirectCommandsLayout"].as_array().size()==0){
                pIndirectCommandsLayout=NULL;
            return; }pIndirectCommandsLayout=(VkIndirectCommandsLayoutNV*)malloc(1*sizeof(VkIndirectCommandsLayoutNV));
        auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].as_array();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){deserialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy], pIndirectCommandsLayout[becsFhy]);}();
        }
        }();

    PFN_vkCreateIndirectCommandsLayoutNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateIndirectCommandsLayoutNV)get_instance_proc_addr(parent,"vkCreateIndirectCommandsLayoutNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateIndirectCommandsLayoutNV)get_device_proc_addr(parent,"vkCreateIndirectCommandsLayoutNV");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_EQPGiEt=json["pCreateInfo"].emplace_array();
        for(int TPVCKbG=0; TPVCKbG < 1; TPVCKbG++){
            [&](){
            auto& temp=arr_EQPGiEt[TPVCKbG].emplace_object();
            return serialize_struct(temp, pCreateInfo[TPVCKbG]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pIndirectCommandsLayout==NULL){
                json["pIndirectCommandsLayout"]=boost::json::array();
            return; }
        auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].emplace_array();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){serialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy],pIndirectCommandsLayout[becsFhy]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyIndirectCommandsLayoutNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkIndirectCommandsLayoutNV indirectCommandsLayout;
[&](){deserialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"], indirectCommandsLayout);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyIndirectCommandsLayoutNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyIndirectCommandsLayoutNV)get_instance_proc_addr(parent,"vkDestroyIndirectCommandsLayoutNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyIndirectCommandsLayoutNV)get_device_proc_addr(parent,"vkDestroyIndirectCommandsLayoutNV");
    }  
    
{
call_function(device, indirectCommandsLayout, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"],indirectCommandsLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFeatures2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceFeatures2* pFeatures;
[&](){
            if (json["pFeatures"].as_array().size()==0){
                pFeatures=NULL;
            return; }pFeatures=(VkPhysicalDeviceFeatures2*)malloc(1*sizeof(VkPhysicalDeviceFeatures2));
        auto& arr_QUwriqy=json["pFeatures"].as_array();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto& temp=arr_QUwriqy[AlewVZE].as_object();
            deserialize_struct(temp,pFeatures[AlewVZE]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFeatures2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFeatures2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFeatures2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFeatures2)get_device_proc_addr(parent,"vkGetPhysicalDeviceFeatures2");
    }  
    
{
call_function(physicalDevice, pFeatures);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=boost::json::array();
            return; }
        auto& arr_QUwriqy=json["pFeatures"].emplace_array();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto& temp=arr_QUwriqy[AlewVZE].emplace_object();
            return serialize_struct(temp, pFeatures[AlewVZE]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceProperties2* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkPhysicalDeviceProperties2*)malloc(1*sizeof(VkPhysicalDeviceProperties2));
        auto& arr_oZVBLox=json["pProperties"].as_array();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto& temp=arr_oZVBLox[pxUpVYV].as_object();
            deserialize_struct(temp,pProperties[pxUpVYV]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceProperties2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceProperties2");
    }  
    
{
call_function(physicalDevice, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_oZVBLox=json["pProperties"].emplace_array();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto& temp=arr_oZVBLox[pxUpVYV].emplace_object();
            return serialize_struct(temp, pProperties[pxUpVYV]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFormatProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
VkFormatProperties2* pFormatProperties;
[&](){
            if (json["pFormatProperties"].as_array().size()==0){
                pFormatProperties=NULL;
            return; }pFormatProperties=(VkFormatProperties2*)malloc(1*sizeof(VkFormatProperties2));
        auto& arr_RNYTnLU=json["pFormatProperties"].as_array();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto& temp=arr_RNYTnLU[VZFdkqX].as_object();
            deserialize_struct(temp,pFormatProperties[VZFdkqX]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFormatProperties2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties2");
    }  
    
{
call_function(physicalDevice, format, pFormatProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=boost::json::array();
            return; }
        auto& arr_RNYTnLU=json["pFormatProperties"].emplace_array();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto& temp=arr_RNYTnLU[VZFdkqX].emplace_object();
            return serialize_struct(temp, pFormatProperties[VZFdkqX]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceImageFormatProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
[&](){ VkPhysicalDeviceImageFormatInfo2* temp_alkoaXY[&](){
            if (json["pImageFormatInfo"].as_array().size()==0){
                temp_alkoaXY=NULL;
            return; }temp_alkoaXY=(VkPhysicalDeviceImageFormatInfo2*)malloc(1*sizeof(VkPhysicalDeviceImageFormatInfo2));
        auto& arr_DmAdZhK=json["pImageFormatInfo"].as_array();
        for(int ZeNdrVN=0; ZeNdrVN < 1; ZeNdrVN++){
            [&](){
            auto& temp=arr_DmAdZhK[ZeNdrVN].as_object();
            deserialize_struct(temp,temp_alkoaXY[ZeNdrVN]);
            }();
        }
        }();pImageFormatInfo=temp_alkoaXY;}();
VkImageFormatProperties2* pImageFormatProperties;
[&](){
            if (json["pImageFormatProperties"].as_array().size()==0){
                pImageFormatProperties=NULL;
            return; }pImageFormatProperties=(VkImageFormatProperties2*)malloc(1*sizeof(VkImageFormatProperties2));
        auto& arr_wmAZzRc=json["pImageFormatProperties"].as_array();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto& temp=arr_wmAZzRc[NQfBHSv].as_object();
            deserialize_struct(temp,pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceImageFormatProperties2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties2");
    }  
    
{
auto result=call_function(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pImageFormatInfo==NULL){
                json["pImageFormatInfo"]=boost::json::array();
            return; }
        auto& arr_MpVGyYe=json["pImageFormatInfo"].emplace_array();
        for(int YAeYFEt=0; YAeYFEt < 1; YAeYFEt++){
            [&](){
            auto& temp=arr_MpVGyYe[YAeYFEt].emplace_object();
            return serialize_struct(temp, pImageFormatInfo[YAeYFEt]);
            }();
        }
        }();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }
        auto& arr_wmAZzRc=json["pImageFormatProperties"].emplace_array();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto& temp=arr_wmAZzRc[NQfBHSv].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceQueueFamilyProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pQueueFamilyPropertyCount;
[&](){
            if (json["pQueueFamilyPropertyCount"].as_array().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }pQueueFamilyPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].as_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(value_to<int>(arr_tzRlmPf[cPKCUxv]));}();
        }
        }();
VkQueueFamilyProperties2* pQueueFamilyProperties;
[&](){
            if (json["pQueueFamilyProperties"].as_array().size()==0){
                pQueueFamilyProperties=NULL;
            return; }pQueueFamilyProperties=(VkQueueFamilyProperties2*)malloc(*pQueueFamilyPropertyCount*sizeof(VkQueueFamilyProperties2));
        auto& arr_NqmNsHw=json["pQueueFamilyProperties"].as_array();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto& temp=arr_NqmNsHw[UxEWlik].as_object();
            deserialize_struct(temp,pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceQueueFamilyProperties2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties2");
    }  
    
{
call_function(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=boost::json::array();
            return; }
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].emplace_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=pQueueFamilyPropertyCount[cPKCUxv];}();
        }
        }();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=boost::json::array();
            return; }
        auto& arr_NqmNsHw=json["pQueueFamilyProperties"].emplace_array();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto& temp=arr_NqmNsHw[UxEWlik].emplace_object();
            return serialize_struct(temp, pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceMemoryProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
[&](){
            if (json["pMemoryProperties"].as_array().size()==0){
                pMemoryProperties=NULL;
            return; }pMemoryProperties=(VkPhysicalDeviceMemoryProperties2*)malloc(1*sizeof(VkPhysicalDeviceMemoryProperties2));
        auto& arr_nJXNYGt=json["pMemoryProperties"].as_array();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto& temp=arr_nJXNYGt[tFDFCkf].as_object();
            deserialize_struct(temp,pMemoryProperties[tFDFCkf]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceMemoryProperties2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties2");
    }  
    
{
call_function(physicalDevice, pMemoryProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=boost::json::array();
            return; }
        auto& arr_nJXNYGt=json["pMemoryProperties"].emplace_array();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto& temp=arr_nJXNYGt[tFDFCkf].emplace_object();
            return serialize_struct(temp, pMemoryProperties[tFDFCkf]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSparseImageFormatProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
[&](){ VkPhysicalDeviceSparseImageFormatInfo2* temp_XIPmBGZ[&](){
            if (json["pFormatInfo"].as_array().size()==0){
                temp_XIPmBGZ=NULL;
            return; }temp_XIPmBGZ=(VkPhysicalDeviceSparseImageFormatInfo2*)malloc(1*sizeof(VkPhysicalDeviceSparseImageFormatInfo2));
        auto& arr_NQMYVvv=json["pFormatInfo"].as_array();
        for(int SsKlkUy=0; SsKlkUy < 1; SsKlkUy++){
            [&](){
            auto& temp=arr_NQMYVvv[SsKlkUy].as_object();
            deserialize_struct(temp,temp_XIPmBGZ[SsKlkUy]);
            }();
        }
        }();pFormatInfo=temp_XIPmBGZ;}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkSparseImageFormatProperties2* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkSparseImageFormatProperties2*)malloc(*pPropertyCount*sizeof(VkSparseImageFormatProperties2));
        auto& arr_YaLkATe=json["pProperties"].as_array();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto& temp=arr_YaLkATe[lIrIGCv].as_object();
            deserialize_struct(temp,pProperties[lIrIGCv]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties2");
    }  
    
{
call_function(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFormatInfo==NULL){
                json["pFormatInfo"]=boost::json::array();
            return; }
        auto& arr_nZOUWlt=json["pFormatInfo"].emplace_array();
        for(int cvknnOe=0; cvknnOe < 1; cvknnOe++){
            [&](){
            auto& temp=arr_nZOUWlt[cvknnOe].emplace_object();
            return serialize_struct(temp, pFormatInfo[cvknnOe]);
            }();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_YaLkATe=json["pProperties"].emplace_array();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto& temp=arr_YaLkATe[lIrIGCv].emplace_object();
            return serialize_struct(temp, pProperties[lIrIGCv]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdPushDescriptorSetKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t set;
[&](){set=static_cast<uint32_t>(value_to<int>(json["set"]));}();
uint32_t descriptorWriteCount;
[&](){descriptorWriteCount=static_cast<uint32_t>(value_to<int>(json["descriptorWriteCount"]));}();
VkWriteDescriptorSet* pDescriptorWrites;
[&](){ VkWriteDescriptorSet* temp_RotfizJ[&](){
            if (json["pDescriptorWrites"].as_array().size()==0){
                temp_RotfizJ=NULL;
            return; }temp_RotfizJ=(VkWriteDescriptorSet*)malloc(descriptorWriteCount*sizeof(VkWriteDescriptorSet));
        auto& arr_YJcGFpk=json["pDescriptorWrites"].as_array();
        for(int PyFuMgH=0; PyFuMgH < descriptorWriteCount; PyFuMgH++){
            [&](){
            auto& temp=arr_YJcGFpk[PyFuMgH].as_object();
            deserialize_struct(temp,temp_RotfizJ[PyFuMgH]);
            }();
        }
        }();pDescriptorWrites=temp_RotfizJ;}();

    PFN_vkCmdPushDescriptorSetKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPushDescriptorSetKHR)get_instance_proc_addr(parent,"vkCmdPushDescriptorSetKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPushDescriptorSetKHR)get_device_proc_addr(parent,"vkCmdPushDescriptorSetKHR");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
[&](){json["descriptorWriteCount"]=descriptorWriteCount;}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=boost::json::array();
            return; }
        auto& arr_AuOrFWk=json["pDescriptorWrites"].emplace_array();
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto& temp=arr_AuOrFWk[qJACxKx].emplace_object();
            return serialize_struct(temp, pDescriptorWrites[qJACxKx]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkTrimCommandPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
VkCommandPoolTrimFlags flags;
[&](){[&](){int temp_FGvozFl;[&](){temp_FGvozFl=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkCommandPoolTrimFlags)temp_FGvozFl;}();}();

    PFN_vkTrimCommandPool call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkTrimCommandPool)get_instance_proc_addr(parent,"vkTrimCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkTrimCommandPool)get_device_proc_addr(parent,"vkTrimCommandPool");
    }  
    
{
call_function(device, commandPool, flags);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalBufferProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
[&](){ VkPhysicalDeviceExternalBufferInfo* temp_BiGBBFw[&](){
            if (json["pExternalBufferInfo"].as_array().size()==0){
                temp_BiGBBFw=NULL;
            return; }temp_BiGBBFw=(VkPhysicalDeviceExternalBufferInfo*)malloc(1*sizeof(VkPhysicalDeviceExternalBufferInfo));
        auto& arr_ISfKJVQ=json["pExternalBufferInfo"].as_array();
        for(int rmWnLWl=0; rmWnLWl < 1; rmWnLWl++){
            [&](){
            auto& temp=arr_ISfKJVQ[rmWnLWl].as_object();
            deserialize_struct(temp,temp_BiGBBFw[rmWnLWl]);
            }();
        }
        }();pExternalBufferInfo=temp_BiGBBFw;}();
VkExternalBufferProperties* pExternalBufferProperties;
[&](){
            if (json["pExternalBufferProperties"].as_array().size()==0){
                pExternalBufferProperties=NULL;
            return; }pExternalBufferProperties=(VkExternalBufferProperties*)malloc(1*sizeof(VkExternalBufferProperties));
        auto& arr_oXzExYk=json["pExternalBufferProperties"].as_array();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto& temp=arr_oXzExYk[ufvutei].as_object();
            deserialize_struct(temp,pExternalBufferProperties[ufvutei]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalBufferProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalBufferProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalBufferProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalBufferProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalBufferProperties");
    }  
    
{
call_function(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalBufferInfo==NULL){
                json["pExternalBufferInfo"]=boost::json::array();
            return; }
        auto& arr_VbIxQJg=json["pExternalBufferInfo"].emplace_array();
        for(int XeSwNaV=0; XeSwNaV < 1; XeSwNaV++){
            [&](){
            auto& temp=arr_VbIxQJg[XeSwNaV].emplace_object();
            return serialize_struct(temp, pExternalBufferInfo[XeSwNaV]);
            }();
        }
        }();
[&](){
            if (pExternalBufferProperties==NULL){
                json["pExternalBufferProperties"]=boost::json::array();
            return; }
        auto& arr_oXzExYk=json["pExternalBufferProperties"].emplace_array();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto& temp=arr_oXzExYk[ufvutei].emplace_object();
            return serialize_struct(temp, pExternalBufferProperties[ufvutei]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetMemoryFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMemoryGetFdInfoKHR* pGetFdInfo;
[&](){ VkMemoryGetFdInfoKHR* temp_fLjnSxF[&](){
            if (json["pGetFdInfo"].as_array().size()==0){
                temp_fLjnSxF=NULL;
            return; }temp_fLjnSxF=(VkMemoryGetFdInfoKHR*)malloc(1*sizeof(VkMemoryGetFdInfoKHR));
        auto& arr_YGnGiDl=json["pGetFdInfo"].as_array();
        for(int QwmRuDs=0; QwmRuDs < 1; QwmRuDs++){
            [&](){
            auto& temp=arr_YGnGiDl[QwmRuDs].as_object();
            deserialize_struct(temp,temp_fLjnSxF[QwmRuDs]);
            }();
        }
        }();pGetFdInfo=temp_fLjnSxF;}();
int* pFd;
[&](){
            if (json["pFd"].as_array().size()==0){
                pFd=NULL;
            return; }pFd=(int*)malloc(1*sizeof(int));
        auto& arr_iYlwGBh=json["pFd"].as_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){pFd[ENGggcC]=static_cast<int>(value_to<int>(arr_iYlwGBh[ENGggcC]));}();
        }
        }();

    PFN_vkGetMemoryFdKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMemoryFdKHR)get_instance_proc_addr(parent,"vkGetMemoryFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMemoryFdKHR)get_device_proc_addr(parent,"vkGetMemoryFdKHR");
    }  
    
{
auto result=call_function(device, pGetFdInfo, pFd);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }
        auto& arr_imCbcqk=json["pGetFdInfo"].emplace_array();
        for(int oZoTEJx=0; oZoTEJx < 1; oZoTEJx++){
            [&](){
            auto& temp=arr_imCbcqk[oZoTEJx].emplace_object();
            return serialize_struct(temp, pGetFdInfo[oZoTEJx]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }
        auto& arr_iYlwGBh=json["pFd"].emplace_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetMemoryFdPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkExternalMemoryHandleTypeFlagBits handleType;
[&](){[&](){int temp_vuWMBJk;[&](){temp_vuWMBJk=static_cast<int>(value_to<int>(json["handleType"]));}();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();
int fd;
[&](){fd=static_cast<int>(value_to<int>(json["fd"]));}();
VkMemoryFdPropertiesKHR* pMemoryFdProperties;
[&](){
            if (json["pMemoryFdProperties"].as_array().size()==0){
                pMemoryFdProperties=NULL;
            return; }pMemoryFdProperties=(VkMemoryFdPropertiesKHR*)malloc(1*sizeof(VkMemoryFdPropertiesKHR));
        auto& arr_tzzZhYk=json["pMemoryFdProperties"].as_array();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto& temp=arr_tzzZhYk[UpKTZRJ].as_object();
            deserialize_struct(temp,pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();

    PFN_vkGetMemoryFdPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMemoryFdPropertiesKHR)get_instance_proc_addr(parent,"vkGetMemoryFdPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMemoryFdPropertiesKHR)get_device_proc_addr(parent,"vkGetMemoryFdPropertiesKHR");
    }  
    
{
auto result=call_function(device, handleType, fd, pMemoryFdProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=handleType;}();}();}();
[&](){json["fd"]=fd;}();
[&](){
            if (pMemoryFdProperties==NULL){
                json["pMemoryFdProperties"]=boost::json::array();
            return; }
        auto& arr_tzzZhYk=json["pMemoryFdProperties"].emplace_array();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto& temp=arr_tzzZhYk[UpKTZRJ].emplace_object();
            return serialize_struct(temp, pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetMemoryRemoteAddressNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo;
[&](){ VkMemoryGetRemoteAddressInfoNV* temp_lZyOzjo[&](){
            if (json["pMemoryGetRemoteAddressInfo"].as_array().size()==0){
                temp_lZyOzjo=NULL;
            return; }temp_lZyOzjo=(VkMemoryGetRemoteAddressInfoNV*)malloc(1*sizeof(VkMemoryGetRemoteAddressInfoNV));
        auto& arr_qzVONyK=json["pMemoryGetRemoteAddressInfo"].as_array();
        for(int vBoigyh=0; vBoigyh < 1; vBoigyh++){
            [&](){
            auto& temp=arr_qzVONyK[vBoigyh].as_object();
            deserialize_struct(temp,temp_lZyOzjo[vBoigyh]);
            }();
        }
        }();pMemoryGetRemoteAddressInfo=temp_lZyOzjo;}();
VkRemoteAddressNV* pAddress;
[&](){
            if (json["pAddress"].as_array().size()==0){
                pAddress=NULL;
            return; }pAddress=(VkRemoteAddressNV*)malloc(1*sizeof(VkRemoteAddressNV));
        auto& arr_LTIxmQF=json["pAddress"].as_array();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){void* temp_LTIxmQF;[&](){
            if (arr_LTIxmQF[LIvckbR].as_array().size()==0){
                temp_LTIxmQF=NULL;
            return; }char* temp_KKuuYCW;[&](){
            if (arr_LTIxmQF[LIvckbR].as_array().size()==0){
                temp_KKuuYCW=NULL;
            return; }temp_KKuuYCW=(char*)malloc(arr_LTIxmQF[LIvckbR].as_array().size()*sizeof(char));
        auto& arr_ydTJNuu=arr_LTIxmQF[LIvckbR].as_array();
        for(int DAUTQtp=0; DAUTQtp < arr_LTIxmQF[LIvckbR].as_array().size(); DAUTQtp++){
            [&](){temp_KKuuYCW[DAUTQtp]=static_cast<char>(value_to<int>(arr_ydTJNuu[DAUTQtp]));}();
        }
        }();temp_LTIxmQF=temp_KKuuYCW;}();pAddress[LIvckbR]=(VkRemoteAddressNV)temp_LTIxmQF;}();
        }
        }();

    PFN_vkGetMemoryRemoteAddressNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMemoryRemoteAddressNV)get_instance_proc_addr(parent,"vkGetMemoryRemoteAddressNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMemoryRemoteAddressNV)get_device_proc_addr(parent,"vkGetMemoryRemoteAddressNV");
    }  
    
{
auto result=call_function(device, pMemoryGetRemoteAddressInfo, pAddress);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryGetRemoteAddressInfo==NULL){
                json["pMemoryGetRemoteAddressInfo"]=boost::json::array();
            return; }
        auto& arr_JYmQngD=json["pMemoryGetRemoteAddressInfo"].emplace_array();
        for(int tlzypUU=0; tlzypUU < 1; tlzypUU++){
            [&](){
            auto& temp=arr_JYmQngD[tlzypUU].emplace_object();
            return serialize_struct(temp, pMemoryGetRemoteAddressInfo[tlzypUU]);
            }();
        }
        }();
[&](){
            if (pAddress==NULL){
                json["pAddress"]=boost::json::array();
            return; }
        auto& arr_LTIxmQF=json["pAddress"].emplace_array();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){[&](){
            if (pAddress[LIvckbR]==NULL){
                arr_LTIxmQF[LIvckbR]=boost::json::array();
            return; }[&](){
            if (((char*)(pAddress[LIvckbR]))==NULL){
                arr_LTIxmQF[LIvckbR]=boost::json::array();
            return; }
        auto& arr_ydTJNuu=arr_LTIxmQF[LIvckbR].emplace_array();
        for(int DAUTQtp=0; DAUTQtp < strlen(((char*)(pAddress[LIvckbR])))+1; DAUTQtp++){
            [&](){arr_ydTJNuu[DAUTQtp]=((char*)(pAddress[LIvckbR]))[DAUTQtp];}();
        }
        }();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalSemaphoreProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
[&](){ VkPhysicalDeviceExternalSemaphoreInfo* temp_CfnUsYN[&](){
            if (json["pExternalSemaphoreInfo"].as_array().size()==0){
                temp_CfnUsYN=NULL;
            return; }temp_CfnUsYN=(VkPhysicalDeviceExternalSemaphoreInfo*)malloc(1*sizeof(VkPhysicalDeviceExternalSemaphoreInfo));
        auto& arr_giUwPMB=json["pExternalSemaphoreInfo"].as_array();
        for(int gtMcAOQ=0; gtMcAOQ < 1; gtMcAOQ++){
            [&](){
            auto& temp=arr_giUwPMB[gtMcAOQ].as_object();
            deserialize_struct(temp,temp_CfnUsYN[gtMcAOQ]);
            }();
        }
        }();pExternalSemaphoreInfo=temp_CfnUsYN;}();
VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
[&](){
            if (json["pExternalSemaphoreProperties"].as_array().size()==0){
                pExternalSemaphoreProperties=NULL;
            return; }pExternalSemaphoreProperties=(VkExternalSemaphoreProperties*)malloc(1*sizeof(VkExternalSemaphoreProperties));
        auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].as_array();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto& temp=arr_yLCjbDt[rKjPzGR].as_object();
            deserialize_struct(temp,pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalSemaphoreProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalSemaphoreProperties");
    }  
    
{
call_function(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalSemaphoreInfo==NULL){
                json["pExternalSemaphoreInfo"]=boost::json::array();
            return; }
        auto& arr_qgIgkyH=json["pExternalSemaphoreInfo"].emplace_array();
        for(int VMbMUUS=0; VMbMUUS < 1; VMbMUUS++){
            [&](){
            auto& temp=arr_qgIgkyH[VMbMUUS].emplace_object();
            return serialize_struct(temp, pExternalSemaphoreInfo[VMbMUUS]);
            }();
        }
        }();
[&](){
            if (pExternalSemaphoreProperties==NULL){
                json["pExternalSemaphoreProperties"]=boost::json::array();
            return; }
        auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].emplace_array();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto& temp=arr_yLCjbDt[rKjPzGR].emplace_object();
            return serialize_struct(temp, pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetSemaphoreFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphoreGetFdInfoKHR* pGetFdInfo;
[&](){ VkSemaphoreGetFdInfoKHR* temp_PPrOOdl[&](){
            if (json["pGetFdInfo"].as_array().size()==0){
                temp_PPrOOdl=NULL;
            return; }temp_PPrOOdl=(VkSemaphoreGetFdInfoKHR*)malloc(1*sizeof(VkSemaphoreGetFdInfoKHR));
        auto& arr_BVoUZWb=json["pGetFdInfo"].as_array();
        for(int BGuubyW=0; BGuubyW < 1; BGuubyW++){
            [&](){
            auto& temp=arr_BVoUZWb[BGuubyW].as_object();
            deserialize_struct(temp,temp_PPrOOdl[BGuubyW]);
            }();
        }
        }();pGetFdInfo=temp_PPrOOdl;}();
int* pFd;
[&](){
            if (json["pFd"].as_array().size()==0){
                pFd=NULL;
            return; }pFd=(int*)malloc(1*sizeof(int));
        auto& arr_iYlwGBh=json["pFd"].as_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){pFd[ENGggcC]=static_cast<int>(value_to<int>(arr_iYlwGBh[ENGggcC]));}();
        }
        }();

    PFN_vkGetSemaphoreFdKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSemaphoreFdKHR)get_instance_proc_addr(parent,"vkGetSemaphoreFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSemaphoreFdKHR)get_device_proc_addr(parent,"vkGetSemaphoreFdKHR");
    }  
    
{
auto result=call_function(device, pGetFdInfo, pFd);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }
        auto& arr_fyTHWII=json["pGetFdInfo"].emplace_array();
        for(int dBynwwO=0; dBynwwO < 1; dBynwwO++){
            [&](){
            auto& temp=arr_fyTHWII[dBynwwO].emplace_object();
            return serialize_struct(temp, pGetFdInfo[dBynwwO]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }
        auto& arr_iYlwGBh=json["pFd"].emplace_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkImportSemaphoreFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo;
[&](){ VkImportSemaphoreFdInfoKHR* temp_nydLElg[&](){
            if (json["pImportSemaphoreFdInfo"].as_array().size()==0){
                temp_nydLElg=NULL;
            return; }temp_nydLElg=(VkImportSemaphoreFdInfoKHR*)malloc(1*sizeof(VkImportSemaphoreFdInfoKHR));
        auto& arr_UrxNRxs=json["pImportSemaphoreFdInfo"].as_array();
        for(int QfVGtJH=0; QfVGtJH < 1; QfVGtJH++){
            [&](){
            auto& temp=arr_UrxNRxs[QfVGtJH].as_object();
            deserialize_struct(temp,temp_nydLElg[QfVGtJH]);
            }();
        }
        }();pImportSemaphoreFdInfo=temp_nydLElg;}();

    PFN_vkImportSemaphoreFdKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkImportSemaphoreFdKHR)get_instance_proc_addr(parent,"vkImportSemaphoreFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkImportSemaphoreFdKHR)get_device_proc_addr(parent,"vkImportSemaphoreFdKHR");
    }  
    
{
auto result=call_function(device, pImportSemaphoreFdInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportSemaphoreFdInfo==NULL){
                json["pImportSemaphoreFdInfo"]=boost::json::array();
            return; }
        auto& arr_vWNEWeX=json["pImportSemaphoreFdInfo"].emplace_array();
        for(int kfpLCyT=0; kfpLCyT < 1; kfpLCyT++){
            [&](){
            auto& temp=arr_vWNEWeX[kfpLCyT].emplace_object();
            return serialize_struct(temp, pImportSemaphoreFdInfo[kfpLCyT]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalFenceProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
[&](){ VkPhysicalDeviceExternalFenceInfo* temp_LfaSRmq[&](){
            if (json["pExternalFenceInfo"].as_array().size()==0){
                temp_LfaSRmq=NULL;
            return; }temp_LfaSRmq=(VkPhysicalDeviceExternalFenceInfo*)malloc(1*sizeof(VkPhysicalDeviceExternalFenceInfo));
        auto& arr_cmsSEwq=json["pExternalFenceInfo"].as_array();
        for(int qxHSgjk=0; qxHSgjk < 1; qxHSgjk++){
            [&](){
            auto& temp=arr_cmsSEwq[qxHSgjk].as_object();
            deserialize_struct(temp,temp_LfaSRmq[qxHSgjk]);
            }();
        }
        }();pExternalFenceInfo=temp_LfaSRmq;}();
VkExternalFenceProperties* pExternalFenceProperties;
[&](){
            if (json["pExternalFenceProperties"].as_array().size()==0){
                pExternalFenceProperties=NULL;
            return; }pExternalFenceProperties=(VkExternalFenceProperties*)malloc(1*sizeof(VkExternalFenceProperties));
        auto& arr_nPbItsj=json["pExternalFenceProperties"].as_array();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto& temp=arr_nPbItsj[VoSEUdo].as_object();
            deserialize_struct(temp,pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalFenceProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalFenceProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalFenceProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalFenceProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalFenceProperties");
    }  
    
{
call_function(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalFenceInfo==NULL){
                json["pExternalFenceInfo"]=boost::json::array();
            return; }
        auto& arr_DSVeGvM=json["pExternalFenceInfo"].emplace_array();
        for(int ApMvCYQ=0; ApMvCYQ < 1; ApMvCYQ++){
            [&](){
            auto& temp=arr_DSVeGvM[ApMvCYQ].emplace_object();
            return serialize_struct(temp, pExternalFenceInfo[ApMvCYQ]);
            }();
        }
        }();
[&](){
            if (pExternalFenceProperties==NULL){
                json["pExternalFenceProperties"]=boost::json::array();
            return; }
        auto& arr_nPbItsj=json["pExternalFenceProperties"].emplace_array();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto& temp=arr_nPbItsj[VoSEUdo].emplace_object();
            return serialize_struct(temp, pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetFenceFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFenceGetFdInfoKHR* pGetFdInfo;
[&](){ VkFenceGetFdInfoKHR* temp_tuaomnR[&](){
            if (json["pGetFdInfo"].as_array().size()==0){
                temp_tuaomnR=NULL;
            return; }temp_tuaomnR=(VkFenceGetFdInfoKHR*)malloc(1*sizeof(VkFenceGetFdInfoKHR));
        auto& arr_xyswZQS=json["pGetFdInfo"].as_array();
        for(int pCVXTsZ=0; pCVXTsZ < 1; pCVXTsZ++){
            [&](){
            auto& temp=arr_xyswZQS[pCVXTsZ].as_object();
            deserialize_struct(temp,temp_tuaomnR[pCVXTsZ]);
            }();
        }
        }();pGetFdInfo=temp_tuaomnR;}();
int* pFd;
[&](){
            if (json["pFd"].as_array().size()==0){
                pFd=NULL;
            return; }pFd=(int*)malloc(1*sizeof(int));
        auto& arr_iYlwGBh=json["pFd"].as_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){pFd[ENGggcC]=static_cast<int>(value_to<int>(arr_iYlwGBh[ENGggcC]));}();
        }
        }();

    PFN_vkGetFenceFdKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetFenceFdKHR)get_instance_proc_addr(parent,"vkGetFenceFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetFenceFdKHR)get_device_proc_addr(parent,"vkGetFenceFdKHR");
    }  
    
{
auto result=call_function(device, pGetFdInfo, pFd);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }
        auto& arr_mgmOmEV=json["pGetFdInfo"].emplace_array();
        for(int DYSusBe=0; DYSusBe < 1; DYSusBe++){
            [&](){
            auto& temp=arr_mgmOmEV[DYSusBe].emplace_object();
            return serialize_struct(temp, pGetFdInfo[DYSusBe]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }
        auto& arr_iYlwGBh=json["pFd"].emplace_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkImportFenceFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImportFenceFdInfoKHR* pImportFenceFdInfo;
[&](){ VkImportFenceFdInfoKHR* temp_jQnJUqC[&](){
            if (json["pImportFenceFdInfo"].as_array().size()==0){
                temp_jQnJUqC=NULL;
            return; }temp_jQnJUqC=(VkImportFenceFdInfoKHR*)malloc(1*sizeof(VkImportFenceFdInfoKHR));
        auto& arr_fzWADTd=json["pImportFenceFdInfo"].as_array();
        for(int nbyOjBi=0; nbyOjBi < 1; nbyOjBi++){
            [&](){
            auto& temp=arr_fzWADTd[nbyOjBi].as_object();
            deserialize_struct(temp,temp_jQnJUqC[nbyOjBi]);
            }();
        }
        }();pImportFenceFdInfo=temp_jQnJUqC;}();

    PFN_vkImportFenceFdKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkImportFenceFdKHR)get_instance_proc_addr(parent,"vkImportFenceFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkImportFenceFdKHR)get_device_proc_addr(parent,"vkImportFenceFdKHR");
    }  
    
{
auto result=call_function(device, pImportFenceFdInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportFenceFdInfo==NULL){
                json["pImportFenceFdInfo"]=boost::json::array();
            return; }
        auto& arr_PmxwQMO=json["pImportFenceFdInfo"].emplace_array();
        for(int QSUnAUF=0; QSUnAUF < 1; QSUnAUF++){
            [&](){
            auto& temp=arr_PmxwQMO[QSUnAUF].emplace_object();
            return serialize_struct(temp, pImportFenceFdInfo[QSUnAUF]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkReleaseDisplayEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();

    PFN_vkReleaseDisplayEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkReleaseDisplayEXT)get_instance_proc_addr(parent,"vkReleaseDisplayEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkReleaseDisplayEXT)get_device_proc_addr(parent,"vkReleaseDisplayEXT");
    }  
    
{
auto result=call_function(physicalDevice, display);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();


        writeToConn(json);
    }

    void handle_vkDisplayPowerControlEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
VkDisplayPowerInfoEXT* pDisplayPowerInfo;
[&](){ VkDisplayPowerInfoEXT* temp_ZNXmGnS[&](){
            if (json["pDisplayPowerInfo"].as_array().size()==0){
                temp_ZNXmGnS=NULL;
            return; }temp_ZNXmGnS=(VkDisplayPowerInfoEXT*)malloc(1*sizeof(VkDisplayPowerInfoEXT));
        auto& arr_VSwTzCL=json["pDisplayPowerInfo"].as_array();
        for(int KtsnURa=0; KtsnURa < 1; KtsnURa++){
            [&](){
            auto& temp=arr_VSwTzCL[KtsnURa].as_object();
            deserialize_struct(temp,temp_ZNXmGnS[KtsnURa]);
            }();
        }
        }();pDisplayPowerInfo=temp_ZNXmGnS;}();

    PFN_vkDisplayPowerControlEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDisplayPowerControlEXT)get_instance_proc_addr(parent,"vkDisplayPowerControlEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDisplayPowerControlEXT)get_device_proc_addr(parent,"vkDisplayPowerControlEXT");
    }  
    
{
auto result=call_function(device, display, pDisplayPowerInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayPowerInfo==NULL){
                json["pDisplayPowerInfo"]=boost::json::array();
            return; }
        auto& arr_MrfcjyV=json["pDisplayPowerInfo"].emplace_array();
        for(int xtIgTXd=0; xtIgTXd < 1; xtIgTXd++){
            [&](){
            auto& temp=arr_MrfcjyV[xtIgTXd].emplace_object();
            return serialize_struct(temp, pDisplayPowerInfo[xtIgTXd]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkRegisterDeviceEventEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceEventInfoEXT* pDeviceEventInfo;
[&](){ VkDeviceEventInfoEXT* temp_JaFgtFd[&](){
            if (json["pDeviceEventInfo"].as_array().size()==0){
                temp_JaFgtFd=NULL;
            return; }temp_JaFgtFd=(VkDeviceEventInfoEXT*)malloc(1*sizeof(VkDeviceEventInfoEXT));
        auto& arr_EoseEDE=json["pDeviceEventInfo"].as_array();
        for(int obNGZvs=0; obNGZvs < 1; obNGZvs++){
            [&](){
            auto& temp=arr_EoseEDE[obNGZvs].as_object();
            deserialize_struct(temp,temp_JaFgtFd[obNGZvs]);
            }();
        }
        }();pDeviceEventInfo=temp_JaFgtFd;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkFence* pFence;
[&](){
            if (json["pFence"].as_array().size()==0){
                pFence=NULL;
            return; }pFence=(VkFence*)malloc(1*sizeof(VkFence));
        auto& arr_SJohVKr=json["pFence"].as_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();

    PFN_vkRegisterDeviceEventEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkRegisterDeviceEventEXT)get_instance_proc_addr(parent,"vkRegisterDeviceEventEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkRegisterDeviceEventEXT)get_device_proc_addr(parent,"vkRegisterDeviceEventEXT");
    }  
    
{
auto result=call_function(device, pDeviceEventInfo, pAllocator, pFence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceEventInfo==NULL){
                json["pDeviceEventInfo"]=boost::json::array();
            return; }
        auto& arr_PBonFka=json["pDeviceEventInfo"].emplace_array();
        for(int JNqwWzK=0; JNqwWzK < 1; JNqwWzK++){
            [&](){
            auto& temp=arr_PBonFka[JNqwWzK].emplace_object();
            return serialize_struct(temp, pDeviceEventInfo[JNqwWzK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }
        auto& arr_SJohVKr=json["pFence"].emplace_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkRegisterDisplayEventEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
VkDisplayEventInfoEXT* pDisplayEventInfo;
[&](){ VkDisplayEventInfoEXT* temp_iAVCSup[&](){
            if (json["pDisplayEventInfo"].as_array().size()==0){
                temp_iAVCSup=NULL;
            return; }temp_iAVCSup=(VkDisplayEventInfoEXT*)malloc(1*sizeof(VkDisplayEventInfoEXT));
        auto& arr_dFojYev=json["pDisplayEventInfo"].as_array();
        for(int ABwoOha=0; ABwoOha < 1; ABwoOha++){
            [&](){
            auto& temp=arr_dFojYev[ABwoOha].as_object();
            deserialize_struct(temp,temp_iAVCSup[ABwoOha]);
            }();
        }
        }();pDisplayEventInfo=temp_iAVCSup;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkFence* pFence;
[&](){
            if (json["pFence"].as_array().size()==0){
                pFence=NULL;
            return; }pFence=(VkFence*)malloc(1*sizeof(VkFence));
        auto& arr_SJohVKr=json["pFence"].as_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();

    PFN_vkRegisterDisplayEventEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkRegisterDisplayEventEXT)get_instance_proc_addr(parent,"vkRegisterDisplayEventEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkRegisterDisplayEventEXT)get_device_proc_addr(parent,"vkRegisterDisplayEventEXT");
    }  
    
{
auto result=call_function(device, display, pDisplayEventInfo, pAllocator, pFence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayEventInfo==NULL){
                json["pDisplayEventInfo"]=boost::json::array();
            return; }
        auto& arr_EEWRWgk=json["pDisplayEventInfo"].emplace_array();
        for(int ZywgBIl=0; ZywgBIl < 1; ZywgBIl++){
            [&](){
            auto& temp=arr_EEWRWgk[ZywgBIl].emplace_object();
            return serialize_struct(temp, pDisplayEventInfo[ZywgBIl]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }
        auto& arr_SJohVKr=json["pFence"].emplace_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetSwapchainCounterEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkSurfaceCounterFlagBitsEXT counter;
[&](){[&](){int temp_RusGBTK;[&](){temp_RusGBTK=static_cast<int>(value_to<int>(json["counter"]));}();counter=(VkSurfaceCounterFlagBitsEXT)temp_RusGBTK;}();}();
uint64_t* pCounterValue;
[&](){
            if (json["pCounterValue"].as_array().size()==0){
                pCounterValue=NULL;
            return; }pCounterValue=(uint64_t*)malloc(1*sizeof(uint64_t));
        auto& arr_VmPfCNz=json["pCounterValue"].as_array();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){pCounterValue[BVcpEyO]=static_cast<uint64_t>(value_to<int>(arr_VmPfCNz[BVcpEyO]));}();
        }
        }();

    PFN_vkGetSwapchainCounterEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSwapchainCounterEXT)get_instance_proc_addr(parent,"vkGetSwapchainCounterEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSwapchainCounterEXT)get_device_proc_addr(parent,"vkGetSwapchainCounterEXT");
    }  
    
{
auto result=call_function(device, swapchain, counter, pCounterValue);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){[&](){[&](){json["counter"]=counter;}();}();}();
[&](){
            if (pCounterValue==NULL){
                json["pCounterValue"]=boost::json::array();
            return; }
        auto& arr_VmPfCNz=json["pCounterValue"].emplace_array();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){arr_VmPfCNz[BVcpEyO]=pCounterValue[BVcpEyO];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceCapabilities2EXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkSurfaceCapabilities2EXT* pSurfaceCapabilities;
[&](){
            if (json["pSurfaceCapabilities"].as_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }pSurfaceCapabilities=(VkSurfaceCapabilities2EXT*)malloc(1*sizeof(VkSurfaceCapabilities2EXT));
        auto& arr_KYzynfJ=json["pSurfaceCapabilities"].as_array();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto& temp=arr_KYzynfJ[QJCcfVY].as_object();
            deserialize_struct(temp,pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2EXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2EXT");
    }  
    
{
auto result=call_function(physicalDevice, surface, pSurfaceCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }
        auto& arr_KYzynfJ=json["pSurfaceCapabilities"].emplace_array();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto& temp=arr_KYzynfJ[QJCcfVY].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkEnumeratePhysicalDeviceGroups(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
uint32_t* pPhysicalDeviceGroupCount;
[&](){
            if (json["pPhysicalDeviceGroupCount"].as_array().size()==0){
                pPhysicalDeviceGroupCount=NULL;
            return; }pPhysicalDeviceGroupCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].as_array();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(value_to<int>(arr_Cmahtvc[SYfwvYv]));}();
        }
        }();
VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
[&](){
            if (json["pPhysicalDeviceGroupProperties"].as_array().size()==0){
                pPhysicalDeviceGroupProperties=NULL;
            return; }pPhysicalDeviceGroupProperties=(VkPhysicalDeviceGroupProperties*)malloc(*pPhysicalDeviceGroupCount*sizeof(VkPhysicalDeviceGroupProperties));
        auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].as_array();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto& temp=arr_kSmADNy[LorZWUi].as_object();
            deserialize_struct(temp,pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();

    PFN_vkEnumeratePhysicalDeviceGroups call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumeratePhysicalDeviceGroups)get_instance_proc_addr(parent,"vkEnumeratePhysicalDeviceGroups");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumeratePhysicalDeviceGroups)get_device_proc_addr(parent,"vkEnumeratePhysicalDeviceGroups");
    }  
    
{
auto result=call_function(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceGroupCount==NULL){
                json["pPhysicalDeviceGroupCount"]=boost::json::array();
            return; }
        auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].emplace_array();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){arr_Cmahtvc[SYfwvYv]=pPhysicalDeviceGroupCount[SYfwvYv];}();
        }
        }();
[&](){
            if (pPhysicalDeviceGroupProperties==NULL){
                json["pPhysicalDeviceGroupProperties"]=boost::json::array();
            return; }
        auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].emplace_array();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto& temp=arr_kSmADNy[LorZWUi].emplace_object();
            return serialize_struct(temp, pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceGroupPeerMemoryFeatures(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t heapIndex;
[&](){heapIndex=static_cast<uint32_t>(value_to<int>(json["heapIndex"]));}();
uint32_t localDeviceIndex;
[&](){localDeviceIndex=static_cast<uint32_t>(value_to<int>(json["localDeviceIndex"]));}();
uint32_t remoteDeviceIndex;
[&](){remoteDeviceIndex=static_cast<uint32_t>(value_to<int>(json["remoteDeviceIndex"]));}();
VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
[&](){
            if (json["pPeerMemoryFeatures"].as_array().size()==0){
                pPeerMemoryFeatures=NULL;
            return; }pPeerMemoryFeatures=(VkPeerMemoryFeatureFlags*)malloc(1*sizeof(VkPeerMemoryFeatureFlags));
        auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].as_array();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){int temp_ohtAtfL;[&](){temp_ohtAtfL=static_cast<int>(value_to<int>(arr_IMNDPVx[dvtpqQO]));}();pPeerMemoryFeatures[dvtpqQO]=(VkPeerMemoryFeatureFlags)temp_ohtAtfL;}();}();
        }
        }();

    PFN_vkGetDeviceGroupPeerMemoryFeatures call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceGroupPeerMemoryFeatures)get_instance_proc_addr(parent,"vkGetDeviceGroupPeerMemoryFeatures");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceGroupPeerMemoryFeatures)get_device_proc_addr(parent,"vkGetDeviceGroupPeerMemoryFeatures");
    }  
    
{
call_function(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["heapIndex"]=heapIndex;}();
[&](){json["localDeviceIndex"]=localDeviceIndex;}();
[&](){json["remoteDeviceIndex"]=remoteDeviceIndex;}();
[&](){
            if (pPeerMemoryFeatures==NULL){
                json["pPeerMemoryFeatures"]=boost::json::array();
            return; }
        auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].emplace_array();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){[&](){arr_IMNDPVx[dvtpqQO]=pPeerMemoryFeatures[dvtpqQO];}();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBindBufferMemory2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t bindInfoCount;
[&](){bindInfoCount=static_cast<uint32_t>(value_to<int>(json["bindInfoCount"]));}();
VkBindBufferMemoryInfo* pBindInfos;
[&](){ VkBindBufferMemoryInfo* temp_ZJzzJwa[&](){
            if (json["pBindInfos"].as_array().size()==0){
                temp_ZJzzJwa=NULL;
            return; }temp_ZJzzJwa=(VkBindBufferMemoryInfo*)malloc(bindInfoCount*sizeof(VkBindBufferMemoryInfo));
        auto& arr_KcaAJZC=json["pBindInfos"].as_array();
        for(int sAHPDKw=0; sAHPDKw < bindInfoCount; sAHPDKw++){
            [&](){
            auto& temp=arr_KcaAJZC[sAHPDKw].as_object();
            deserialize_struct(temp,temp_ZJzzJwa[sAHPDKw]);
            }();
        }
        }();pBindInfos=temp_ZJzzJwa;}();

    PFN_vkBindBufferMemory2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindBufferMemory2)get_instance_proc_addr(parent,"vkBindBufferMemory2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindBufferMemory2)get_device_proc_addr(parent,"vkBindBufferMemory2");
    }  
    
{
auto result=call_function(device, bindInfoCount, pBindInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }
        auto& arr_NWunNSr=json["pBindInfos"].emplace_array();
        for(int DbCSPHR=0; DbCSPHR < bindInfoCount; DbCSPHR++){
            [&](){
            auto& temp=arr_NWunNSr[DbCSPHR].emplace_object();
            return serialize_struct(temp, pBindInfos[DbCSPHR]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBindImageMemory2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t bindInfoCount;
[&](){bindInfoCount=static_cast<uint32_t>(value_to<int>(json["bindInfoCount"]));}();
VkBindImageMemoryInfo* pBindInfos;
[&](){ VkBindImageMemoryInfo* temp_aqUJUsD[&](){
            if (json["pBindInfos"].as_array().size()==0){
                temp_aqUJUsD=NULL;
            return; }temp_aqUJUsD=(VkBindImageMemoryInfo*)malloc(bindInfoCount*sizeof(VkBindImageMemoryInfo));
        auto& arr_OyrgWGZ=json["pBindInfos"].as_array();
        for(int jeBxOVo=0; jeBxOVo < bindInfoCount; jeBxOVo++){
            [&](){
            auto& temp=arr_OyrgWGZ[jeBxOVo].as_object();
            deserialize_struct(temp,temp_aqUJUsD[jeBxOVo]);
            }();
        }
        }();pBindInfos=temp_aqUJUsD;}();

    PFN_vkBindImageMemory2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindImageMemory2)get_instance_proc_addr(parent,"vkBindImageMemory2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindImageMemory2)get_device_proc_addr(parent,"vkBindImageMemory2");
    }  
    
{
auto result=call_function(device, bindInfoCount, pBindInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }
        auto& arr_FifZmRy=json["pBindInfos"].emplace_array();
        for(int TInZfLo=0; TInZfLo < bindInfoCount; TInZfLo++){
            [&](){
            auto& temp=arr_FifZmRy[TInZfLo].emplace_object();
            return serialize_struct(temp, pBindInfos[TInZfLo]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetDeviceMask(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t deviceMask;
[&](){deviceMask=static_cast<uint32_t>(value_to<int>(json["deviceMask"]));}();

    PFN_vkCmdSetDeviceMask call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDeviceMask)get_instance_proc_addr(parent,"vkCmdSetDeviceMask");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDeviceMask)get_device_proc_addr(parent,"vkCmdSetDeviceMask");
    }  
    
{
call_function(commandBuffer, deviceMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["deviceMask"]=deviceMask;}();


        writeToConn(json);
    }

    void handle_vkGetDeviceGroupPresentCapabilitiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities;
[&](){
            if (json["pDeviceGroupPresentCapabilities"].as_array().size()==0){
                pDeviceGroupPresentCapabilities=NULL;
            return; }pDeviceGroupPresentCapabilities=(VkDeviceGroupPresentCapabilitiesKHR*)malloc(1*sizeof(VkDeviceGroupPresentCapabilitiesKHR));
        auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].as_array();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto& temp=arr_gEodIfI[HHoUQIw].as_object();
            deserialize_struct(temp,pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();

    PFN_vkGetDeviceGroupPresentCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceGroupPresentCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetDeviceGroupPresentCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceGroupPresentCapabilitiesKHR)get_device_proc_addr(parent,"vkGetDeviceGroupPresentCapabilitiesKHR");
    }  
    
{
auto result=call_function(device, pDeviceGroupPresentCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceGroupPresentCapabilities==NULL){
                json["pDeviceGroupPresentCapabilities"]=boost::json::array();
            return; }
        auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].emplace_array();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto& temp=arr_gEodIfI[HHoUQIw].emplace_object();
            return serialize_struct(temp, pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceGroupSurfacePresentModesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkDeviceGroupPresentModeFlagsKHR* pModes;
[&](){
            if (json["pModes"].as_array().size()==0){
                pModes=NULL;
            return; }pModes=(VkDeviceGroupPresentModeFlagsKHR*)malloc(1*sizeof(VkDeviceGroupPresentModeFlagsKHR));
        auto& arr_RUtBuZy=json["pModes"].as_array();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){int temp_TkvTwGZ;[&](){temp_TkvTwGZ=static_cast<int>(value_to<int>(arr_RUtBuZy[OxSHrMn]));}();pModes[OxSHrMn]=(VkDeviceGroupPresentModeFlagsKHR)temp_TkvTwGZ;}();}();
        }
        }();

    PFN_vkGetDeviceGroupSurfacePresentModesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceGroupSurfacePresentModesKHR)get_instance_proc_addr(parent,"vkGetDeviceGroupSurfacePresentModesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceGroupSurfacePresentModesKHR)get_device_proc_addr(parent,"vkGetDeviceGroupSurfacePresentModesKHR");
    }  
    
{
auto result=call_function(device, surface, pModes);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pModes==NULL){
                json["pModes"]=boost::json::array();
            return; }
        auto& arr_RUtBuZy=json["pModes"].emplace_array();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){[&](){arr_RUtBuZy[OxSHrMn]=pModes[OxSHrMn];}();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkAcquireNextImage2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAcquireNextImageInfoKHR* pAcquireInfo;
[&](){ VkAcquireNextImageInfoKHR* temp_lUDrJTD[&](){
            if (json["pAcquireInfo"].as_array().size()==0){
                temp_lUDrJTD=NULL;
            return; }temp_lUDrJTD=(VkAcquireNextImageInfoKHR*)malloc(1*sizeof(VkAcquireNextImageInfoKHR));
        auto& arr_DnycGJU=json["pAcquireInfo"].as_array();
        for(int tNYAOen=0; tNYAOen < 1; tNYAOen++){
            [&](){
            auto& temp=arr_DnycGJU[tNYAOen].as_object();
            deserialize_struct(temp,temp_lUDrJTD[tNYAOen]);
            }();
        }
        }();pAcquireInfo=temp_lUDrJTD;}();
uint32_t* pImageIndex;
[&](){
            if (json["pImageIndex"].as_array().size()==0){
                pImageIndex=NULL;
            return; }pImageIndex=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_oSqpNfH=json["pImageIndex"].as_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){pImageIndex[BEjuBtR]=static_cast<uint32_t>(value_to<int>(arr_oSqpNfH[BEjuBtR]));}();
        }
        }();

    PFN_vkAcquireNextImage2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquireNextImage2KHR)get_instance_proc_addr(parent,"vkAcquireNextImage2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquireNextImage2KHR)get_device_proc_addr(parent,"vkAcquireNextImage2KHR");
    }  
    
{
auto result=call_function(device, pAcquireInfo, pImageIndex);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=boost::json::array();
            return; }
        auto& arr_plPbild=json["pAcquireInfo"].emplace_array();
        for(int QzLRJum=0; QzLRJum < 1; QzLRJum++){
            [&](){
            auto& temp=arr_plPbild[QzLRJum].emplace_object();
            return serialize_struct(temp, pAcquireInfo[QzLRJum]);
            }();
        }
        }();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=boost::json::array();
            return; }
        auto& arr_oSqpNfH=json["pImageIndex"].emplace_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=pImageIndex[BEjuBtR];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDispatchBase(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t baseGroupX;
[&](){baseGroupX=static_cast<uint32_t>(value_to<int>(json["baseGroupX"]));}();
uint32_t baseGroupY;
[&](){baseGroupY=static_cast<uint32_t>(value_to<int>(json["baseGroupY"]));}();
uint32_t baseGroupZ;
[&](){baseGroupZ=static_cast<uint32_t>(value_to<int>(json["baseGroupZ"]));}();
uint32_t groupCountX;
[&](){groupCountX=static_cast<uint32_t>(value_to<int>(json["groupCountX"]));}();
uint32_t groupCountY;
[&](){groupCountY=static_cast<uint32_t>(value_to<int>(json["groupCountY"]));}();
uint32_t groupCountZ;
[&](){groupCountZ=static_cast<uint32_t>(value_to<int>(json["groupCountZ"]));}();

    PFN_vkCmdDispatchBase call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDispatchBase)get_instance_proc_addr(parent,"vkCmdDispatchBase");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDispatchBase)get_device_proc_addr(parent,"vkCmdDispatchBase");
    }  
    
{
call_function(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["baseGroupX"]=baseGroupX;}();
[&](){json["baseGroupY"]=baseGroupY;}();
[&](){json["baseGroupZ"]=baseGroupZ;}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDevicePresentRectanglesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
uint32_t* pRectCount;
[&](){
            if (json["pRectCount"].as_array().size()==0){
                pRectCount=NULL;
            return; }pRectCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_vsEoMvr=json["pRectCount"].as_array();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){pRectCount[TgFYlRi]=static_cast<uint32_t>(value_to<int>(arr_vsEoMvr[TgFYlRi]));}();
        }
        }();
VkRect2D* pRects;
[&](){
            if (json["pRects"].as_array().size()==0){
                pRects=NULL;
            return; }pRects=(VkRect2D*)malloc(*pRectCount*sizeof(VkRect2D));
        auto& arr_BxIGDMm=json["pRects"].as_array();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto& temp=arr_BxIGDMm[LNnHsjT].as_object();
            deserialize_struct(temp,pRects[LNnHsjT]);
            }();
        }
        }();

    PFN_vkGetPhysicalDevicePresentRectanglesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDevicePresentRectanglesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDevicePresentRectanglesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDevicePresentRectanglesKHR)get_device_proc_addr(parent,"vkGetPhysicalDevicePresentRectanglesKHR");
    }  
    
{
auto result=call_function(physicalDevice, surface, pRectCount, pRects);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pRectCount==NULL){
                json["pRectCount"]=boost::json::array();
            return; }
        auto& arr_vsEoMvr=json["pRectCount"].emplace_array();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){arr_vsEoMvr[TgFYlRi]=pRectCount[TgFYlRi];}();
        }
        }();
[&](){
            if (pRects==NULL){
                json["pRects"]=boost::json::array();
            return; }
        auto& arr_BxIGDMm=json["pRects"].emplace_array();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto& temp=arr_BxIGDMm[LNnHsjT].emplace_object();
            return serialize_struct(temp, pRects[LNnHsjT]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateDescriptorUpdateTemplate(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
[&](){ VkDescriptorUpdateTemplateCreateInfo* temp_sVyOEvx[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_sVyOEvx=NULL;
            return; }temp_sVyOEvx=(VkDescriptorUpdateTemplateCreateInfo*)malloc(1*sizeof(VkDescriptorUpdateTemplateCreateInfo));
        auto& arr_VGzFxGk=json["pCreateInfo"].as_array();
        for(int nfmnALE=0; nfmnALE < 1; nfmnALE++){
            [&](){
            auto& temp=arr_VGzFxGk[nfmnALE].as_object();
            deserialize_struct(temp,temp_sVyOEvx[nfmnALE]);
            }();
        }
        }();pCreateInfo=temp_sVyOEvx;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
[&](){
            if (json["pDescriptorUpdateTemplate"].as_array().size()==0){
                pDescriptorUpdateTemplate=NULL;
            return; }pDescriptorUpdateTemplate=(VkDescriptorUpdateTemplate*)malloc(1*sizeof(VkDescriptorUpdateTemplate));
        auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].as_array();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){deserialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS], pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();

    PFN_vkCreateDescriptorUpdateTemplate call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDescriptorUpdateTemplate)get_instance_proc_addr(parent,"vkCreateDescriptorUpdateTemplate");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDescriptorUpdateTemplate)get_device_proc_addr(parent,"vkCreateDescriptorUpdateTemplate");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_GOaQfzV=json["pCreateInfo"].emplace_array();
        for(int bDXkRSI=0; bDXkRSI < 1; bDXkRSI++){
            [&](){
            auto& temp=arr_GOaQfzV[bDXkRSI].emplace_object();
            return serialize_struct(temp, pCreateInfo[bDXkRSI]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDescriptorUpdateTemplate==NULL){
                json["pDescriptorUpdateTemplate"]=boost::json::array();
            return; }
        auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].emplace_array();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){serialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS],pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyDescriptorUpdateTemplate(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorUpdateTemplate descriptorUpdateTemplate;
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyDescriptorUpdateTemplate call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDescriptorUpdateTemplate)get_instance_proc_addr(parent,"vkDestroyDescriptorUpdateTemplate");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDescriptorUpdateTemplate)get_device_proc_addr(parent,"vkDestroyDescriptorUpdateTemplate");
    }  
    
{
call_function(device, descriptorUpdateTemplate, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkUpdateDescriptorSetWithTemplate(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSet descriptorSet;
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
VkDescriptorUpdateTemplate descriptorUpdateTemplate;
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
void* pData;
[&](){ void* temp_GGzqbkU[&](){
            if (json["pData"].as_array().size()==0){
                temp_GGzqbkU=NULL;
            return; }char* temp_cNzVPDf;[&](){
            if (json["pData"].as_array().size()==0){
                temp_cNzVPDf=NULL;
            return; }temp_cNzVPDf=(char*)malloc(json["pData"].as_array().size()*sizeof(char));
        auto& arr_ZPnOSxW=json["pData"].as_array();
        for(int mhoQVXX=0; mhoQVXX < json["pData"].as_array().size(); mhoQVXX++){
            [&](){temp_cNzVPDf[mhoQVXX]=static_cast<char>(value_to<int>(arr_ZPnOSxW[mhoQVXX]));}();
        }
        }();temp_GGzqbkU=temp_cNzVPDf;}();pData=temp_GGzqbkU;}();

    PFN_vkUpdateDescriptorSetWithTemplate call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUpdateDescriptorSetWithTemplate)get_instance_proc_addr(parent,"vkUpdateDescriptorSetWithTemplate");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUpdateDescriptorSetWithTemplate)get_device_proc_addr(parent,"vkUpdateDescriptorSetWithTemplate");
    }  
    
{
call_function(device, descriptorSet, descriptorUpdateTemplate, pData);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_wjMrkki=json["pData"].emplace_array();
        for(int qQUyxsG=0; qQUyxsG < strlen(((char*)(pData)))+1; qQUyxsG++){
            [&](){arr_wjMrkki[qQUyxsG]=((char*)(pData))[qQUyxsG];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkCmdPushDescriptorSetWithTemplateKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDescriptorUpdateTemplate descriptorUpdateTemplate;
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t set;
[&](){set=static_cast<uint32_t>(value_to<int>(json["set"]));}();
void* pData;
[&](){ void* temp_GGzqbkU[&](){
            if (json["pData"].as_array().size()==0){
                temp_GGzqbkU=NULL;
            return; }char* temp_cNzVPDf;[&](){
            if (json["pData"].as_array().size()==0){
                temp_cNzVPDf=NULL;
            return; }temp_cNzVPDf=(char*)malloc(json["pData"].as_array().size()*sizeof(char));
        auto& arr_ZPnOSxW=json["pData"].as_array();
        for(int mhoQVXX=0; mhoQVXX < json["pData"].as_array().size(); mhoQVXX++){
            [&](){temp_cNzVPDf[mhoQVXX]=static_cast<char>(value_to<int>(arr_ZPnOSxW[mhoQVXX]));}();
        }
        }();temp_GGzqbkU=temp_cNzVPDf;}();pData=temp_GGzqbkU;}();

    PFN_vkCmdPushDescriptorSetWithTemplateKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPushDescriptorSetWithTemplateKHR)get_instance_proc_addr(parent,"vkCmdPushDescriptorSetWithTemplateKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPushDescriptorSetWithTemplateKHR)get_device_proc_addr(parent,"vkCmdPushDescriptorSetWithTemplateKHR");
    }  
    
{
call_function(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_wjMrkki=json["pData"].emplace_array();
        for(int qQUyxsG=0; qQUyxsG < strlen(((char*)(pData)))+1; qQUyxsG++){
            [&](){arr_wjMrkki[qQUyxsG]=((char*)(pData))[qQUyxsG];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkSetHdrMetadataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t swapchainCount;
[&](){swapchainCount=static_cast<uint32_t>(value_to<int>(json["swapchainCount"]));}();
VkSwapchainKHR* pSwapchains;
[&](){ VkSwapchainKHR* temp_POCwOFt[&](){
            if (json["pSwapchains"].as_array().size()==0){
                temp_POCwOFt=NULL;
            return; }temp_POCwOFt=(VkSwapchainKHR*)malloc(swapchainCount*sizeof(VkSwapchainKHR));
        auto& arr_iHlSrAW=json["pSwapchains"].as_array();
        for(int IasqrAl=0; IasqrAl < swapchainCount; IasqrAl++){
            [&](){deserialize_VkSwapchainKHR(arr_iHlSrAW[IasqrAl], temp_POCwOFt[IasqrAl]);}();
        }
        }();pSwapchains=temp_POCwOFt;}();
VkHdrMetadataEXT* pMetadata;
[&](){ VkHdrMetadataEXT* temp_WwZqcHf[&](){
            if (json["pMetadata"].as_array().size()==0){
                temp_WwZqcHf=NULL;
            return; }temp_WwZqcHf=(VkHdrMetadataEXT*)malloc(swapchainCount*sizeof(VkHdrMetadataEXT));
        auto& arr_kUxcKTi=json["pMetadata"].as_array();
        for(int IpDaPDf=0; IpDaPDf < swapchainCount; IpDaPDf++){
            [&](){
            auto& temp=arr_kUxcKTi[IpDaPDf].as_object();
            deserialize_struct(temp,temp_WwZqcHf[IpDaPDf]);
            }();
        }
        }();pMetadata=temp_WwZqcHf;}();

    PFN_vkSetHdrMetadataEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetHdrMetadataEXT)get_instance_proc_addr(parent,"vkSetHdrMetadataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetHdrMetadataEXT)get_device_proc_addr(parent,"vkSetHdrMetadataEXT");
    }  
    
{
call_function(device, swapchainCount, pSwapchains, pMetadata);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=swapchainCount;}();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=boost::json::array();
            return; }
        auto& arr_ItrwriJ=json["pSwapchains"].emplace_array();
        for(int ButVMnQ=0; ButVMnQ < swapchainCount; ButVMnQ++){
            [&](){serialize_VkSwapchainKHR(arr_ItrwriJ[ButVMnQ],pSwapchains[ButVMnQ]);}();
        }
        }();
[&](){
            if (pMetadata==NULL){
                json["pMetadata"]=boost::json::array();
            return; }
        auto& arr_gUCeGgy=json["pMetadata"].emplace_array();
        for(int qGnEfca=0; qGnEfca < swapchainCount; qGnEfca++){
            [&](){
            auto& temp=arr_gUCeGgy[qGnEfca].emplace_object();
            return serialize_struct(temp, pMetadata[qGnEfca]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetSwapchainStatusKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();

    PFN_vkGetSwapchainStatusKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSwapchainStatusKHR)get_instance_proc_addr(parent,"vkGetSwapchainStatusKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSwapchainStatusKHR)get_device_proc_addr(parent,"vkGetSwapchainStatusKHR");
    }  
    
{
auto result=call_function(device, swapchain);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();


        writeToConn(json);
    }

    void handle_vkGetRefreshCycleDurationGOOGLE(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties;
[&](){
            if (json["pDisplayTimingProperties"].as_array().size()==0){
                pDisplayTimingProperties=NULL;
            return; }pDisplayTimingProperties=(VkRefreshCycleDurationGOOGLE*)malloc(1*sizeof(VkRefreshCycleDurationGOOGLE));
        auto& arr_nDUaeZL=json["pDisplayTimingProperties"].as_array();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto& temp=arr_nDUaeZL[NSFWKiB].as_object();
            deserialize_struct(temp,pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();

    PFN_vkGetRefreshCycleDurationGOOGLE call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRefreshCycleDurationGOOGLE)get_instance_proc_addr(parent,"vkGetRefreshCycleDurationGOOGLE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRefreshCycleDurationGOOGLE)get_device_proc_addr(parent,"vkGetRefreshCycleDurationGOOGLE");
    }  
    
{
auto result=call_function(device, swapchain, pDisplayTimingProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pDisplayTimingProperties==NULL){
                json["pDisplayTimingProperties"]=boost::json::array();
            return; }
        auto& arr_nDUaeZL=json["pDisplayTimingProperties"].emplace_array();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto& temp=arr_nDUaeZL[NSFWKiB].emplace_object();
            return serialize_struct(temp, pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPastPresentationTimingGOOGLE(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint32_t* pPresentationTimingCount;
[&](){
            if (json["pPresentationTimingCount"].as_array().size()==0){
                pPresentationTimingCount=NULL;
            return; }pPresentationTimingCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_LiCpViZ=json["pPresentationTimingCount"].as_array();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(value_to<int>(arr_LiCpViZ[ihpxywU]));}();
        }
        }();
VkPastPresentationTimingGOOGLE* pPresentationTimings;
[&](){
            if (json["pPresentationTimings"].as_array().size()==0){
                pPresentationTimings=NULL;
            return; }pPresentationTimings=(VkPastPresentationTimingGOOGLE*)malloc(*pPresentationTimingCount*sizeof(VkPastPresentationTimingGOOGLE));
        auto& arr_CGvQjMK=json["pPresentationTimings"].as_array();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto& temp=arr_CGvQjMK[CzbyDFb].as_object();
            deserialize_struct(temp,pPresentationTimings[CzbyDFb]);
            }();
        }
        }();

    PFN_vkGetPastPresentationTimingGOOGLE call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPastPresentationTimingGOOGLE)get_instance_proc_addr(parent,"vkGetPastPresentationTimingGOOGLE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPastPresentationTimingGOOGLE)get_device_proc_addr(parent,"vkGetPastPresentationTimingGOOGLE");
    }  
    
{
auto result=call_function(device, swapchain, pPresentationTimingCount, pPresentationTimings);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pPresentationTimingCount==NULL){
                json["pPresentationTimingCount"]=boost::json::array();
            return; }
        auto& arr_LiCpViZ=json["pPresentationTimingCount"].emplace_array();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){arr_LiCpViZ[ihpxywU]=pPresentationTimingCount[ihpxywU];}();
        }
        }();
[&](){
            if (pPresentationTimings==NULL){
                json["pPresentationTimings"]=boost::json::array();
            return; }
        auto& arr_CGvQjMK=json["pPresentationTimings"].emplace_array();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto& temp=arr_CGvQjMK[CzbyDFb].emplace_object();
            return serialize_struct(temp, pPresentationTimings[CzbyDFb]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetViewportWScalingNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){firstViewport=static_cast<uint32_t>(value_to<int>(json["firstViewport"]));}();
uint32_t viewportCount;
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();
VkViewportWScalingNV* pViewportWScalings;
[&](){ VkViewportWScalingNV* temp_EdVORuF[&](){
            if (json["pViewportWScalings"].as_array().size()==0){
                temp_EdVORuF=NULL;
            return; }temp_EdVORuF=(VkViewportWScalingNV*)malloc(viewportCount*sizeof(VkViewportWScalingNV));
        auto& arr_mRBzXTN=json["pViewportWScalings"].as_array();
        for(int jZGgaiG=0; jZGgaiG < viewportCount; jZGgaiG++){
            [&](){
            auto& temp=arr_mRBzXTN[jZGgaiG].as_object();
            deserialize_struct(temp,temp_EdVORuF[jZGgaiG]);
            }();
        }
        }();pViewportWScalings=temp_EdVORuF;}();

    PFN_vkCmdSetViewportWScalingNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportWScalingNV)get_instance_proc_addr(parent,"vkCmdSetViewportWScalingNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportWScalingNV)get_device_proc_addr(parent,"vkCmdSetViewportWScalingNV");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewportWScalings==NULL){
                json["pViewportWScalings"]=boost::json::array();
            return; }
        auto& arr_gZVGKnq=json["pViewportWScalings"].emplace_array();
        for(int GRZXlou=0; GRZXlou < viewportCount; GRZXlou++){
            [&](){
            auto& temp=arr_gZVGKnq[GRZXlou].emplace_object();
            return serialize_struct(temp, pViewportWScalings[GRZXlou]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetDiscardRectangleEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstDiscardRectangle;
[&](){firstDiscardRectangle=static_cast<uint32_t>(value_to<int>(json["firstDiscardRectangle"]));}();
uint32_t discardRectangleCount;
[&](){discardRectangleCount=static_cast<uint32_t>(value_to<int>(json["discardRectangleCount"]));}();
VkRect2D* pDiscardRectangles;
[&](){ VkRect2D* temp_lgoItKt[&](){
            if (json["pDiscardRectangles"].as_array().size()==0){
                temp_lgoItKt=NULL;
            return; }temp_lgoItKt=(VkRect2D*)malloc(discardRectangleCount*sizeof(VkRect2D));
        auto& arr_GRSsdXy=json["pDiscardRectangles"].as_array();
        for(int sWyneMb=0; sWyneMb < discardRectangleCount; sWyneMb++){
            [&](){
            auto& temp=arr_GRSsdXy[sWyneMb].as_object();
            deserialize_struct(temp,temp_lgoItKt[sWyneMb]);
            }();
        }
        }();pDiscardRectangles=temp_lgoItKt;}();

    PFN_vkCmdSetDiscardRectangleEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDiscardRectangleEXT)get_instance_proc_addr(parent,"vkCmdSetDiscardRectangleEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDiscardRectangleEXT)get_device_proc_addr(parent,"vkCmdSetDiscardRectangleEXT");
    }  
    
{
call_function(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstDiscardRectangle"]=firstDiscardRectangle;}();
[&](){json["discardRectangleCount"]=discardRectangleCount;}();
[&](){
            if (pDiscardRectangles==NULL){
                json["pDiscardRectangles"]=boost::json::array();
            return; }
        auto& arr_uUeweOj=json["pDiscardRectangles"].emplace_array();
        for(int WtUHHLW=0; WtUHHLW < discardRectangleCount; WtUHHLW++){
            [&](){
            auto& temp=arr_uUeweOj[WtUHHLW].emplace_object();
            return serialize_struct(temp, pDiscardRectangles[WtUHHLW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetDiscardRectangleEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 discardRectangleEnable;
[&](){uint32_t temp_GnHxsqE;[&](){temp_GnHxsqE=static_cast<uint32_t>(value_to<int>(json["discardRectangleEnable"]));}();discardRectangleEnable=(VkBool32)temp_GnHxsqE;}();

    PFN_vkCmdSetDiscardRectangleEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDiscardRectangleEnableEXT)get_instance_proc_addr(parent,"vkCmdSetDiscardRectangleEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDiscardRectangleEnableEXT)get_device_proc_addr(parent,"vkCmdSetDiscardRectangleEnableEXT");
    }  
    
{
call_function(commandBuffer, discardRectangleEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["discardRectangleEnable"]=discardRectangleEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetDiscardRectangleModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDiscardRectangleModeEXT discardRectangleMode;
[&](){[&](){int temp_iBxDvRc;[&](){temp_iBxDvRc=static_cast<int>(value_to<int>(json["discardRectangleMode"]));}();discardRectangleMode=(VkDiscardRectangleModeEXT)temp_iBxDvRc;}();}();

    PFN_vkCmdSetDiscardRectangleModeEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDiscardRectangleModeEXT)get_instance_proc_addr(parent,"vkCmdSetDiscardRectangleModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDiscardRectangleModeEXT)get_device_proc_addr(parent,"vkCmdSetDiscardRectangleModeEXT");
    }  
    
{
call_function(commandBuffer, discardRectangleMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["discardRectangleMode"]=discardRectangleMode;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetSampleLocationsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSampleLocationsInfoEXT* pSampleLocationsInfo;
[&](){ VkSampleLocationsInfoEXT* temp_KuvVbSa[&](){
            if (json["pSampleLocationsInfo"].as_array().size()==0){
                temp_KuvVbSa=NULL;
            return; }temp_KuvVbSa=(VkSampleLocationsInfoEXT*)malloc(1*sizeof(VkSampleLocationsInfoEXT));
        auto& arr_bqTfGpl=json["pSampleLocationsInfo"].as_array();
        for(int zJxCCYx=0; zJxCCYx < 1; zJxCCYx++){
            [&](){
            auto& temp=arr_bqTfGpl[zJxCCYx].as_object();
            deserialize_struct(temp,temp_KuvVbSa[zJxCCYx]);
            }();
        }
        }();pSampleLocationsInfo=temp_KuvVbSa;}();

    PFN_vkCmdSetSampleLocationsEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetSampleLocationsEXT)get_instance_proc_addr(parent,"vkCmdSetSampleLocationsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetSampleLocationsEXT)get_device_proc_addr(parent,"vkCmdSetSampleLocationsEXT");
    }  
    
{
call_function(commandBuffer, pSampleLocationsInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSampleLocationsInfo==NULL){
                json["pSampleLocationsInfo"]=boost::json::array();
            return; }
        auto& arr_KfRxBlJ=json["pSampleLocationsInfo"].emplace_array();
        for(int XjGOezZ=0; XjGOezZ < 1; XjGOezZ++){
            [&](){
            auto& temp=arr_KfRxBlJ[XjGOezZ].emplace_object();
            return serialize_struct(temp, pSampleLocationsInfo[XjGOezZ]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceMultisamplePropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSampleCountFlagBits samples;
[&](){[&](){int temp_lbKgbKj;[&](){temp_lbKgbKj=static_cast<int>(value_to<int>(json["samples"]));}();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
VkMultisamplePropertiesEXT* pMultisampleProperties;
[&](){
            if (json["pMultisampleProperties"].as_array().size()==0){
                pMultisampleProperties=NULL;
            return; }pMultisampleProperties=(VkMultisamplePropertiesEXT*)malloc(1*sizeof(VkMultisamplePropertiesEXT));
        auto& arr_IduiRHb=json["pMultisampleProperties"].as_array();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto& temp=arr_IduiRHb[xJhEIjr].as_object();
            deserialize_struct(temp,pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)get_instance_proc_addr(parent,"vkGetPhysicalDeviceMultisamplePropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)get_device_proc_addr(parent,"vkGetPhysicalDeviceMultisamplePropertiesEXT");
    }  
    
{
call_function(physicalDevice, samples, pMultisampleProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){
            if (pMultisampleProperties==NULL){
                json["pMultisampleProperties"]=boost::json::array();
            return; }
        auto& arr_IduiRHb=json["pMultisampleProperties"].emplace_array();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto& temp=arr_IduiRHb[xJhEIjr].emplace_object();
            return serialize_struct(temp, pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceCapabilities2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
[&](){ VkPhysicalDeviceSurfaceInfo2KHR* temp_sZatDoK[&](){
            if (json["pSurfaceInfo"].as_array().size()==0){
                temp_sZatDoK=NULL;
            return; }temp_sZatDoK=(VkPhysicalDeviceSurfaceInfo2KHR*)malloc(1*sizeof(VkPhysicalDeviceSurfaceInfo2KHR));
        auto& arr_wNHWsze=json["pSurfaceInfo"].as_array();
        for(int lTfpfvZ=0; lTfpfvZ < 1; lTfpfvZ++){
            [&](){
            auto& temp=arr_wNHWsze[lTfpfvZ].as_object();
            deserialize_struct(temp,temp_sZatDoK[lTfpfvZ]);
            }();
        }
        }();pSurfaceInfo=temp_sZatDoK;}();
VkSurfaceCapabilities2KHR* pSurfaceCapabilities;
[&](){
            if (json["pSurfaceCapabilities"].as_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }pSurfaceCapabilities=(VkSurfaceCapabilities2KHR*)malloc(1*sizeof(VkSurfaceCapabilities2KHR));
        auto& arr_JfroxEi=json["pSurfaceCapabilities"].as_array();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto& temp=arr_JfroxEi[Baebpht].as_object();
            deserialize_struct(temp,pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2KHR");
    }  
    
{
auto result=call_function(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=boost::json::array();
            return; }
        auto& arr_kqlTDpj=json["pSurfaceInfo"].emplace_array();
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto& temp=arr_kqlTDpj[yiVsRWe].emplace_object();
            return serialize_struct(temp, pSurfaceInfo[yiVsRWe]);
            }();
        }
        }();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }
        auto& arr_JfroxEi=json["pSurfaceCapabilities"].emplace_array();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto& temp=arr_JfroxEi[Baebpht].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceFormats2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
[&](){ VkPhysicalDeviceSurfaceInfo2KHR* temp_sZatDoK[&](){
            if (json["pSurfaceInfo"].as_array().size()==0){
                temp_sZatDoK=NULL;
            return; }temp_sZatDoK=(VkPhysicalDeviceSurfaceInfo2KHR*)malloc(1*sizeof(VkPhysicalDeviceSurfaceInfo2KHR));
        auto& arr_wNHWsze=json["pSurfaceInfo"].as_array();
        for(int lTfpfvZ=0; lTfpfvZ < 1; lTfpfvZ++){
            [&](){
            auto& temp=arr_wNHWsze[lTfpfvZ].as_object();
            deserialize_struct(temp,temp_sZatDoK[lTfpfvZ]);
            }();
        }
        }();pSurfaceInfo=temp_sZatDoK;}();
uint32_t* pSurfaceFormatCount;
[&](){
            if (json["pSurfaceFormatCount"].as_array().size()==0){
                pSurfaceFormatCount=NULL;
            return; }pSurfaceFormatCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].as_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(value_to<int>(arr_mbQwRYl[bFtFQKD]));}();
        }
        }();
VkSurfaceFormat2KHR* pSurfaceFormats;
[&](){
            if (json["pSurfaceFormats"].as_array().size()==0){
                pSurfaceFormats=NULL;
            return; }pSurfaceFormats=(VkSurfaceFormat2KHR*)malloc(*pSurfaceFormatCount*sizeof(VkSurfaceFormat2KHR));
        auto& arr_AuCicsY=json["pSurfaceFormats"].as_array();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto& temp=arr_AuCicsY[lVrVWxA].as_object();
            deserialize_struct(temp,pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceFormats2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormats2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormats2KHR");
    }  
    
{
auto result=call_function(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=boost::json::array();
            return; }
        auto& arr_kqlTDpj=json["pSurfaceInfo"].emplace_array();
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto& temp=arr_kqlTDpj[yiVsRWe].emplace_object();
            return serialize_struct(temp, pSurfaceInfo[yiVsRWe]);
            }();
        }
        }();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=boost::json::array();
            return; }
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].emplace_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=pSurfaceFormatCount[bFtFQKD];}();
        }
        }();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=boost::json::array();
            return; }
        auto& arr_AuCicsY=json["pSurfaceFormats"].emplace_array();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto& temp=arr_AuCicsY[lVrVWxA].emplace_object();
            return serialize_struct(temp, pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayProperties2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkDisplayProperties2KHR* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayProperties2KHR*)malloc(*pPropertyCount*sizeof(VkDisplayProperties2KHR));
        auto& arr_WgClQQW=json["pProperties"].as_array();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto& temp=arr_WgClQQW[IPCMyur].as_object();
            deserialize_struct(temp,pProperties[IPCMyur]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayProperties2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayProperties2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayProperties2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayProperties2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayProperties2KHR");
    }  
    
{
auto result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_WgClQQW=json["pProperties"].emplace_array();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto& temp=arr_WgClQQW[IPCMyur].emplace_object();
            return serialize_struct(temp, pProperties[IPCMyur]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkDisplayPlaneProperties2KHR* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayPlaneProperties2KHR*)malloc(*pPropertyCount*sizeof(VkDisplayPlaneProperties2KHR));
        auto& arr_oqLTQEe=json["pProperties"].as_array();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto& temp=arr_oqLTQEe[KJvijjP].as_object();
            deserialize_struct(temp,pProperties[KJvijjP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
    }  
    
{
auto result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_oqLTQEe=json["pProperties"].emplace_array();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto& temp=arr_oqLTQEe[KJvijjP].emplace_object();
            return serialize_struct(temp, pProperties[KJvijjP]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDisplayModeProperties2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkDisplayModeProperties2KHR* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayModeProperties2KHR*)malloc(*pPropertyCount*sizeof(VkDisplayModeProperties2KHR));
        auto& arr_LvUqkhm=json["pProperties"].as_array();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto& temp=arr_LvUqkhm[gThvzcU].as_object();
            deserialize_struct(temp,pProperties[gThvzcU]);
            }();
        }
        }();

    PFN_vkGetDisplayModeProperties2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayModeProperties2KHR)get_instance_proc_addr(parent,"vkGetDisplayModeProperties2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayModeProperties2KHR)get_device_proc_addr(parent,"vkGetDisplayModeProperties2KHR");
    }  
    
{
auto result=call_function(physicalDevice, display, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_LvUqkhm=json["pProperties"].emplace_array();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto& temp=arr_LvUqkhm[gThvzcU].emplace_object();
            return serialize_struct(temp, pProperties[gThvzcU]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDisplayPlaneCapabilities2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo;
[&](){ VkDisplayPlaneInfo2KHR* temp_QCGsCKU[&](){
            if (json["pDisplayPlaneInfo"].as_array().size()==0){
                temp_QCGsCKU=NULL;
            return; }temp_QCGsCKU=(VkDisplayPlaneInfo2KHR*)malloc(1*sizeof(VkDisplayPlaneInfo2KHR));
        auto& arr_TBmwloa=json["pDisplayPlaneInfo"].as_array();
        for(int OOfQKMi=0; OOfQKMi < 1; OOfQKMi++){
            [&](){
            auto& temp=arr_TBmwloa[OOfQKMi].as_object();
            deserialize_struct(temp,temp_QCGsCKU[OOfQKMi]);
            }();
        }
        }();pDisplayPlaneInfo=temp_QCGsCKU;}();
VkDisplayPlaneCapabilities2KHR* pCapabilities;
[&](){
            if (json["pCapabilities"].as_array().size()==0){
                pCapabilities=NULL;
            return; }pCapabilities=(VkDisplayPlaneCapabilities2KHR*)malloc(1*sizeof(VkDisplayPlaneCapabilities2KHR));
        auto& arr_perBkIp=json["pCapabilities"].as_array();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto& temp=arr_perBkIp[wDZGRHI].as_object();
            deserialize_struct(temp,pCapabilities[wDZGRHI]);
            }();
        }
        }();

    PFN_vkGetDisplayPlaneCapabilities2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayPlaneCapabilities2KHR)get_instance_proc_addr(parent,"vkGetDisplayPlaneCapabilities2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayPlaneCapabilities2KHR)get_device_proc_addr(parent,"vkGetDisplayPlaneCapabilities2KHR");
    }  
    
{
auto result=call_function(physicalDevice, pDisplayPlaneInfo, pCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pDisplayPlaneInfo==NULL){
                json["pDisplayPlaneInfo"]=boost::json::array();
            return; }
        auto& arr_rwBYAlG=json["pDisplayPlaneInfo"].emplace_array();
        for(int iEdZMtQ=0; iEdZMtQ < 1; iEdZMtQ++){
            [&](){
            auto& temp=arr_rwBYAlG[iEdZMtQ].emplace_object();
            return serialize_struct(temp, pDisplayPlaneInfo[iEdZMtQ]);
            }();
        }
        }();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }
        auto& arr_perBkIp=json["pCapabilities"].emplace_array();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto& temp=arr_perBkIp[wDZGRHI].emplace_object();
            return serialize_struct(temp, pCapabilities[wDZGRHI]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetBufferMemoryRequirements2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBufferMemoryRequirementsInfo2* pInfo;
[&](){ VkBufferMemoryRequirementsInfo2* temp_hINJQmh[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_hINJQmh=NULL;
            return; }temp_hINJQmh=(VkBufferMemoryRequirementsInfo2*)malloc(1*sizeof(VkBufferMemoryRequirementsInfo2));
        auto& arr_ollhCFD=json["pInfo"].as_array();
        for(int XMajJXL=0; XMajJXL < 1; XMajJXL++){
            [&](){
            auto& temp=arr_ollhCFD[XMajJXL].as_object();
            deserialize_struct(temp,temp_hINJQmh[XMajJXL]);
            }();
        }
        }();pInfo=temp_hINJQmh;}();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetBufferMemoryRequirements2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferMemoryRequirements2)get_instance_proc_addr(parent,"vkGetBufferMemoryRequirements2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferMemoryRequirements2)get_device_proc_addr(parent,"vkGetBufferMemoryRequirements2");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_xrBSgMU=json["pInfo"].emplace_array();
        for(int XaVdoIX=0; XaVdoIX < 1; XaVdoIX++){
            [&](){
            auto& temp=arr_xrBSgMU[XaVdoIX].emplace_object();
            return serialize_struct(temp, pInfo[XaVdoIX]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetImageMemoryRequirements2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageMemoryRequirementsInfo2* pInfo;
[&](){ VkImageMemoryRequirementsInfo2* temp_qKqLBvY[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_qKqLBvY=NULL;
            return; }temp_qKqLBvY=(VkImageMemoryRequirementsInfo2*)malloc(1*sizeof(VkImageMemoryRequirementsInfo2));
        auto& arr_TCaTbMc=json["pInfo"].as_array();
        for(int fOqTthF=0; fOqTthF < 1; fOqTthF++){
            [&](){
            auto& temp=arr_TCaTbMc[fOqTthF].as_object();
            deserialize_struct(temp,temp_qKqLBvY[fOqTthF]);
            }();
        }
        }();pInfo=temp_qKqLBvY;}();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetImageMemoryRequirements2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageMemoryRequirements2)get_instance_proc_addr(parent,"vkGetImageMemoryRequirements2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageMemoryRequirements2)get_device_proc_addr(parent,"vkGetImageMemoryRequirements2");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_OVesMNt=json["pInfo"].emplace_array();
        for(int xSwhhlO=0; xSwhhlO < 1; xSwhhlO++){
            [&](){
            auto& temp=arr_OVesMNt[xSwhhlO].emplace_object();
            return serialize_struct(temp, pInfo[xSwhhlO]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetImageSparseMemoryRequirements2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageSparseMemoryRequirementsInfo2* pInfo;
[&](){ VkImageSparseMemoryRequirementsInfo2* temp_xynaEcz[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_xynaEcz=NULL;
            return; }temp_xynaEcz=(VkImageSparseMemoryRequirementsInfo2*)malloc(1*sizeof(VkImageSparseMemoryRequirementsInfo2));
        auto& arr_lAUqSdP=json["pInfo"].as_array();
        for(int HzCSbsD=0; HzCSbsD < 1; HzCSbsD++){
            [&](){
            auto& temp=arr_lAUqSdP[HzCSbsD].as_object();
            deserialize_struct(temp,temp_xynaEcz[HzCSbsD]);
            }();
        }
        }();pInfo=temp_xynaEcz;}();
uint32_t* pSparseMemoryRequirementCount;
[&](){
            if (json["pSparseMemoryRequirementCount"].as_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }pSparseMemoryRequirementCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(value_to<int>(arr_QpqRnvg[pFgmjla]));}();
        }
        }();
VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
[&](){
            if (json["pSparseMemoryRequirements"].as_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }pSparseMemoryRequirements=(VkSparseImageMemoryRequirements2*)malloc(*pSparseMemoryRequirementCount*sizeof(VkSparseImageMemoryRequirements2));
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].as_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].as_object();
            deserialize_struct(temp,pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

    PFN_vkGetImageSparseMemoryRequirements2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageSparseMemoryRequirements2)get_instance_proc_addr(parent,"vkGetImageSparseMemoryRequirements2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageSparseMemoryRequirements2)get_device_proc_addr(parent,"vkGetImageSparseMemoryRequirements2");
    }  
    
{
call_function(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_frlqZZl=json["pInfo"].emplace_array();
        for(int DnuwqwS=0; DnuwqwS < 1; DnuwqwS++){
            [&](){
            auto& temp=arr_frlqZZl[DnuwqwS].emplace_object();
            return serialize_struct(temp, pInfo[DnuwqwS]);
            }();
        }
        }();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].emplace_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].emplace_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceBufferMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceBufferMemoryRequirements* pInfo;
[&](){ VkDeviceBufferMemoryRequirements* temp_UMehEib[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_UMehEib=NULL;
            return; }temp_UMehEib=(VkDeviceBufferMemoryRequirements*)malloc(1*sizeof(VkDeviceBufferMemoryRequirements));
        auto& arr_YweeoPK=json["pInfo"].as_array();
        for(int AxMxoFf=0; AxMxoFf < 1; AxMxoFf++){
            [&](){
            auto& temp=arr_YweeoPK[AxMxoFf].as_object();
            deserialize_struct(temp,temp_UMehEib[AxMxoFf]);
            }();
        }
        }();pInfo=temp_UMehEib;}();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetDeviceBufferMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceBufferMemoryRequirements)get_instance_proc_addr(parent,"vkGetDeviceBufferMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceBufferMemoryRequirements)get_device_proc_addr(parent,"vkGetDeviceBufferMemoryRequirements");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_LbYKRdp=json["pInfo"].emplace_array();
        for(int sabbuKR=0; sabbuKR < 1; sabbuKR++){
            [&](){
            auto& temp=arr_LbYKRdp[sabbuKR].emplace_object();
            return serialize_struct(temp, pInfo[sabbuKR]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceImageMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceImageMemoryRequirements* pInfo;
[&](){ VkDeviceImageMemoryRequirements* temp_JIbaGIi[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_JIbaGIi=NULL;
            return; }temp_JIbaGIi=(VkDeviceImageMemoryRequirements*)malloc(1*sizeof(VkDeviceImageMemoryRequirements));
        auto& arr_dPaAvfp=json["pInfo"].as_array();
        for(int xoxwYjr=0; xoxwYjr < 1; xoxwYjr++){
            [&](){
            auto& temp=arr_dPaAvfp[xoxwYjr].as_object();
            deserialize_struct(temp,temp_JIbaGIi[xoxwYjr]);
            }();
        }
        }();pInfo=temp_JIbaGIi;}();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetDeviceImageMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceImageMemoryRequirements)get_instance_proc_addr(parent,"vkGetDeviceImageMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceImageMemoryRequirements)get_device_proc_addr(parent,"vkGetDeviceImageMemoryRequirements");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_dGiJKQX=json["pInfo"].emplace_array();
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto& temp=arr_dGiJKQX[Hfcgcwr].emplace_object();
            return serialize_struct(temp, pInfo[Hfcgcwr]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceImageSparseMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceImageMemoryRequirements* pInfo;
[&](){ VkDeviceImageMemoryRequirements* temp_JIbaGIi[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_JIbaGIi=NULL;
            return; }temp_JIbaGIi=(VkDeviceImageMemoryRequirements*)malloc(1*sizeof(VkDeviceImageMemoryRequirements));
        auto& arr_dPaAvfp=json["pInfo"].as_array();
        for(int xoxwYjr=0; xoxwYjr < 1; xoxwYjr++){
            [&](){
            auto& temp=arr_dPaAvfp[xoxwYjr].as_object();
            deserialize_struct(temp,temp_JIbaGIi[xoxwYjr]);
            }();
        }
        }();pInfo=temp_JIbaGIi;}();
uint32_t* pSparseMemoryRequirementCount;
[&](){
            if (json["pSparseMemoryRequirementCount"].as_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }pSparseMemoryRequirementCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(value_to<int>(arr_QpqRnvg[pFgmjla]));}();
        }
        }();
VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
[&](){
            if (json["pSparseMemoryRequirements"].as_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }pSparseMemoryRequirements=(VkSparseImageMemoryRequirements2*)malloc(*pSparseMemoryRequirementCount*sizeof(VkSparseImageMemoryRequirements2));
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].as_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].as_object();
            deserialize_struct(temp,pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

    PFN_vkGetDeviceImageSparseMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceImageSparseMemoryRequirements)get_instance_proc_addr(parent,"vkGetDeviceImageSparseMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceImageSparseMemoryRequirements)get_device_proc_addr(parent,"vkGetDeviceImageSparseMemoryRequirements");
    }  
    
{
call_function(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_dGiJKQX=json["pInfo"].emplace_array();
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto& temp=arr_dGiJKQX[Hfcgcwr].emplace_object();
            return serialize_struct(temp, pInfo[Hfcgcwr]);
            }();
        }
        }();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].emplace_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].emplace_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateSamplerYcbcrConversion(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
[&](){ VkSamplerYcbcrConversionCreateInfo* temp_cfabXOi[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_cfabXOi=NULL;
            return; }temp_cfabXOi=(VkSamplerYcbcrConversionCreateInfo*)malloc(1*sizeof(VkSamplerYcbcrConversionCreateInfo));
        auto& arr_oCKmosw=json["pCreateInfo"].as_array();
        for(int LUUMfzS=0; LUUMfzS < 1; LUUMfzS++){
            [&](){
            auto& temp=arr_oCKmosw[LUUMfzS].as_object();
            deserialize_struct(temp,temp_cfabXOi[LUUMfzS]);
            }();
        }
        }();pCreateInfo=temp_cfabXOi;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkSamplerYcbcrConversion* pYcbcrConversion;
[&](){
            if (json["pYcbcrConversion"].as_array().size()==0){
                pYcbcrConversion=NULL;
            return; }pYcbcrConversion=(VkSamplerYcbcrConversion*)malloc(1*sizeof(VkSamplerYcbcrConversion));
        auto& arr_joRRIst=json["pYcbcrConversion"].as_array();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){deserialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr], pYcbcrConversion[VRaBMYr]);}();
        }
        }();

    PFN_vkCreateSamplerYcbcrConversion call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSamplerYcbcrConversion)get_instance_proc_addr(parent,"vkCreateSamplerYcbcrConversion");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSamplerYcbcrConversion)get_device_proc_addr(parent,"vkCreateSamplerYcbcrConversion");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_kLHhxUL=json["pCreateInfo"].emplace_array();
        for(int zgqBgkX=0; zgqBgkX < 1; zgqBgkX++){
            [&](){
            auto& temp=arr_kLHhxUL[zgqBgkX].emplace_object();
            return serialize_struct(temp, pCreateInfo[zgqBgkX]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pYcbcrConversion==NULL){
                json["pYcbcrConversion"]=boost::json::array();
            return; }
        auto& arr_joRRIst=json["pYcbcrConversion"].emplace_array();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){serialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr],pYcbcrConversion[VRaBMYr]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroySamplerYcbcrConversion(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSamplerYcbcrConversion ycbcrConversion;
[&](){deserialize_VkSamplerYcbcrConversion(json["ycbcrConversion"], ycbcrConversion);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroySamplerYcbcrConversion call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySamplerYcbcrConversion)get_instance_proc_addr(parent,"vkDestroySamplerYcbcrConversion");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySamplerYcbcrConversion)get_device_proc_addr(parent,"vkDestroySamplerYcbcrConversion");
    }  
    
{
call_function(device, ycbcrConversion, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSamplerYcbcrConversion(json["ycbcrConversion"],ycbcrConversion);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceQueue2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceQueueInfo2* pQueueInfo;
[&](){ VkDeviceQueueInfo2* temp_LsPcKuI[&](){
            if (json["pQueueInfo"].as_array().size()==0){
                temp_LsPcKuI=NULL;
            return; }temp_LsPcKuI=(VkDeviceQueueInfo2*)malloc(1*sizeof(VkDeviceQueueInfo2));
        auto& arr_GihFKhN=json["pQueueInfo"].as_array();
        for(int cWpAFXW=0; cWpAFXW < 1; cWpAFXW++){
            [&](){
            auto& temp=arr_GihFKhN[cWpAFXW].as_object();
            deserialize_struct(temp,temp_LsPcKuI[cWpAFXW]);
            }();
        }
        }();pQueueInfo=temp_LsPcKuI;}();
VkQueue* pQueue;
[&](){
            if (json["pQueue"].as_array().size()==0){
                pQueue=NULL;
            return; }pQueue=(VkQueue*)malloc(1*sizeof(VkQueue));
        auto& arr_rYZbcEA=json["pQueue"].as_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

    PFN_vkGetDeviceQueue2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceQueue2)get_instance_proc_addr(parent,"vkGetDeviceQueue2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceQueue2)get_device_proc_addr(parent,"vkGetDeviceQueue2");
    }  
    
{
call_function(device, pQueueInfo, pQueue);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pQueueInfo==NULL){
                json["pQueueInfo"]=boost::json::array();
            return; }
        auto& arr_bNCRimR=json["pQueueInfo"].emplace_array();
        for(int ubuvbaB=0; ubuvbaB < 1; ubuvbaB++){
            [&](){
            auto& temp=arr_bNCRimR[ubuvbaB].emplace_object();
            return serialize_struct(temp, pQueueInfo[ubuvbaB]);
            }();
        }
        }();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=boost::json::array();
            return; }
        auto& arr_rYZbcEA=json["pQueue"].emplace_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateValidationCacheEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheCreateInfoEXT* pCreateInfo;
[&](){ VkValidationCacheCreateInfoEXT* temp_yFXdRVO[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_yFXdRVO=NULL;
            return; }temp_yFXdRVO=(VkValidationCacheCreateInfoEXT*)malloc(1*sizeof(VkValidationCacheCreateInfoEXT));
        auto& arr_xouGZzH=json["pCreateInfo"].as_array();
        for(int kadSIIj=0; kadSIIj < 1; kadSIIj++){
            [&](){
            auto& temp=arr_xouGZzH[kadSIIj].as_object();
            deserialize_struct(temp,temp_yFXdRVO[kadSIIj]);
            }();
        }
        }();pCreateInfo=temp_yFXdRVO;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkValidationCacheEXT* pValidationCache;
[&](){
            if (json["pValidationCache"].as_array().size()==0){
                pValidationCache=NULL;
            return; }pValidationCache=(VkValidationCacheEXT*)malloc(1*sizeof(VkValidationCacheEXT));
        auto& arr_oYoDWhC=json["pValidationCache"].as_array();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){deserialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs], pValidationCache[ejlwFKs]);}();
        }
        }();

    PFN_vkCreateValidationCacheEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateValidationCacheEXT)get_instance_proc_addr(parent,"vkCreateValidationCacheEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateValidationCacheEXT)get_device_proc_addr(parent,"vkCreateValidationCacheEXT");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pValidationCache);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_ZCXiwLp=json["pCreateInfo"].emplace_array();
        for(int XeWuaSR=0; XeWuaSR < 1; XeWuaSR++){
            [&](){
            auto& temp=arr_ZCXiwLp[XeWuaSR].emplace_object();
            return serialize_struct(temp, pCreateInfo[XeWuaSR]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pValidationCache==NULL){
                json["pValidationCache"]=boost::json::array();
            return; }
        auto& arr_oYoDWhC=json["pValidationCache"].emplace_array();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){serialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs],pValidationCache[ejlwFKs]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyValidationCacheEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheEXT validationCache;
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyValidationCacheEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyValidationCacheEXT)get_instance_proc_addr(parent,"vkDestroyValidationCacheEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyValidationCacheEXT)get_device_proc_addr(parent,"vkDestroyValidationCacheEXT");
    }  
    
{
call_function(device, validationCache, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetValidationCacheDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheEXT validationCache;
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();
size_t* pDataSize;
[&](){
            if (json["pDataSize"].as_array().size()==0){
                pDataSize=NULL;
            return; }pDataSize=(size_t*)malloc(1*sizeof(size_t));
        auto& arr_Zcusyfw=json["pDataSize"].as_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){pDataSize[HCzJfGC]=static_cast<size_t>(value_to<int>(arr_Zcusyfw[HCzJfGC]));}();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){temp_ZtBEjVJ[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_ZtBEjVJ;}();

    PFN_vkGetValidationCacheDataEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetValidationCacheDataEXT)get_instance_proc_addr(parent,"vkGetValidationCacheDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetValidationCacheDataEXT)get_device_proc_addr(parent,"vkGetValidationCacheDataEXT");
    }  
    
{
auto result=call_function(device, validationCache, pDataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].emplace_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkMergeValidationCachesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheEXT dstCache;
[&](){deserialize_VkValidationCacheEXT(json["dstCache"], dstCache);}();
uint32_t srcCacheCount;
[&](){srcCacheCount=static_cast<uint32_t>(value_to<int>(json["srcCacheCount"]));}();
VkValidationCacheEXT* pSrcCaches;
[&](){ VkValidationCacheEXT* temp_ckYqxom[&](){
            if (json["pSrcCaches"].as_array().size()==0){
                temp_ckYqxom=NULL;
            return; }temp_ckYqxom=(VkValidationCacheEXT*)malloc(srcCacheCount*sizeof(VkValidationCacheEXT));
        auto& arr_viZfWEe=json["pSrcCaches"].as_array();
        for(int svBdHjE=0; svBdHjE < srcCacheCount; svBdHjE++){
            [&](){deserialize_VkValidationCacheEXT(arr_viZfWEe[svBdHjE], temp_ckYqxom[svBdHjE]);}();
        }
        }();pSrcCaches=temp_ckYqxom;}();

    PFN_vkMergeValidationCachesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkMergeValidationCachesEXT)get_instance_proc_addr(parent,"vkMergeValidationCachesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkMergeValidationCachesEXT)get_device_proc_addr(parent,"vkMergeValidationCachesEXT");
    }  
    
{
auto result=call_function(device, dstCache, srcCacheCount, pSrcCaches);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=srcCacheCount;}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=boost::json::array();
            return; }
        auto& arr_xXUlTaQ=json["pSrcCaches"].emplace_array();
        for(int AJDSLsE=0; AJDSLsE < srcCacheCount; AJDSLsE++){
            [&](){serialize_VkValidationCacheEXT(arr_xXUlTaQ[AJDSLsE],pSrcCaches[AJDSLsE]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutSupport(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayoutCreateInfo* pCreateInfo;
[&](){ VkDescriptorSetLayoutCreateInfo* temp_JRXOWVB[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_JRXOWVB=NULL;
            return; }temp_JRXOWVB=(VkDescriptorSetLayoutCreateInfo*)malloc(1*sizeof(VkDescriptorSetLayoutCreateInfo));
        auto& arr_oELBvJU=json["pCreateInfo"].as_array();
        for(int RmYFXzA=0; RmYFXzA < 1; RmYFXzA++){
            [&](){
            auto& temp=arr_oELBvJU[RmYFXzA].as_object();
            deserialize_struct(temp,temp_JRXOWVB[RmYFXzA]);
            }();
        }
        }();pCreateInfo=temp_JRXOWVB;}();
VkDescriptorSetLayoutSupport* pSupport;
[&](){
            if (json["pSupport"].as_array().size()==0){
                pSupport=NULL;
            return; }pSupport=(VkDescriptorSetLayoutSupport*)malloc(1*sizeof(VkDescriptorSetLayoutSupport));
        auto& arr_xgzGluH=json["pSupport"].as_array();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto& temp=arr_xgzGluH[UvZyHDI].as_object();
            deserialize_struct(temp,pSupport[UvZyHDI]);
            }();
        }
        }();

    PFN_vkGetDescriptorSetLayoutSupport call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutSupport)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutSupport");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetLayoutSupport)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutSupport");
    }  
    
{
call_function(device, pCreateInfo, pSupport);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_dFRsqIW=json["pCreateInfo"].emplace_array();
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto& temp=arr_dFRsqIW[tUGauKK].emplace_object();
            return serialize_struct(temp, pCreateInfo[tUGauKK]);
            }();
        }
        }();
[&](){
            if (pSupport==NULL){
                json["pSupport"]=boost::json::array();
            return; }
        auto& arr_xgzGluH=json["pSupport"].emplace_array();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto& temp=arr_xgzGluH[UvZyHDI].emplace_object();
            return serialize_struct(temp, pSupport[UvZyHDI]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetShaderInfoAMD(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
VkShaderStageFlagBits shaderStage;
[&](){[&](){int temp_nGZQHxq;[&](){temp_nGZQHxq=static_cast<int>(value_to<int>(json["shaderStage"]));}();shaderStage=(VkShaderStageFlagBits)temp_nGZQHxq;}();}();
VkShaderInfoTypeAMD infoType;
[&](){[&](){int temp_nNfHNkf;[&](){temp_nNfHNkf=static_cast<int>(value_to<int>(json["infoType"]));}();infoType=(VkShaderInfoTypeAMD)temp_nNfHNkf;}();}();
size_t* pInfoSize;
[&](){
            if (json["pInfoSize"].as_array().size()==0){
                pInfoSize=NULL;
            return; }pInfoSize=(size_t*)malloc(1*sizeof(size_t));
        auto& arr_ouDPuUh=json["pInfoSize"].as_array();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){pInfoSize[wpUCmEy]=static_cast<size_t>(value_to<int>(arr_ouDPuUh[wpUCmEy]));}();
        }
        }();
void* pInfo;
[&](){
            if (json["pInfo"].as_array().size()==0){
                pInfo=NULL;
            return; }char* temp_ziBtDwK;[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_ziBtDwK=NULL;
            return; }temp_ziBtDwK=(char*)malloc(*pInfoSize*sizeof(char));
        auto& arr_aWNzgGe=json["pInfo"].as_array();
        for(int sqfWcCN=0; sqfWcCN < *pInfoSize; sqfWcCN++){
            [&](){temp_ziBtDwK[sqfWcCN]=static_cast<char>(value_to<int>(arr_aWNzgGe[sqfWcCN]));}();
        }
        }();pInfo=temp_ziBtDwK;}();

    PFN_vkGetShaderInfoAMD call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetShaderInfoAMD)get_instance_proc_addr(parent,"vkGetShaderInfoAMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetShaderInfoAMD)get_device_proc_addr(parent,"vkGetShaderInfoAMD");
    }  
    
{
auto result=call_function(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){[&](){[&](){json["shaderStage"]=shaderStage;}();}();}();
[&](){[&](){[&](){json["infoType"]=infoType;}();}();}();
[&](){
            if (pInfoSize==NULL){
                json["pInfoSize"]=boost::json::array();
            return; }
        auto& arr_ouDPuUh=json["pInfoSize"].emplace_array();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){arr_ouDPuUh[wpUCmEy]=pInfoSize[wpUCmEy];}();
        }
        }();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }[&](){
            if (((char*)(pInfo))==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_aWNzgGe=json["pInfo"].emplace_array();
        for(int sqfWcCN=0; sqfWcCN < *pInfoSize; sqfWcCN++){
            [&](){arr_aWNzgGe[sqfWcCN]=((char*)(pInfo))[sqfWcCN];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkSetLocalDimmingAMD(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapChain;
[&](){deserialize_VkSwapchainKHR(json["swapChain"], swapChain);}();
VkBool32 localDimmingEnable;
[&](){uint32_t temp_jfGMipq;[&](){temp_jfGMipq=static_cast<uint32_t>(value_to<int>(json["localDimmingEnable"]));}();localDimmingEnable=(VkBool32)temp_jfGMipq;}();

    PFN_vkSetLocalDimmingAMD call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetLocalDimmingAMD)get_instance_proc_addr(parent,"vkSetLocalDimmingAMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetLocalDimmingAMD)get_device_proc_addr(parent,"vkSetLocalDimmingAMD");
    }  
    
{
call_function(device, swapChain, localDimmingEnable);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapChain"],swapChain);}();
[&](){[&](){json["localDimmingEnable"]=localDimmingEnable;}();}();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pTimeDomainCount;
[&](){
            if (json["pTimeDomainCount"].as_array().size()==0){
                pTimeDomainCount=NULL;
            return; }pTimeDomainCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_siSbERs=json["pTimeDomainCount"].as_array();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(value_to<int>(arr_siSbERs[xFQhUzA]));}();
        }
        }();
VkTimeDomainEXT* pTimeDomains;
[&](){
            if (json["pTimeDomains"].as_array().size()==0){
                pTimeDomains=NULL;
            return; }pTimeDomains=(VkTimeDomainEXT*)malloc(*pTimeDomainCount*sizeof(VkTimeDomainEXT));
        auto& arr_fMkUaJq=json["pTimeDomains"].as_array();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){int temp_EryZVUE;[&](){temp_EryZVUE=static_cast<int>(value_to<int>(arr_fMkUaJq[ZiXuFCL]));}();pTimeDomains[ZiXuFCL]=(VkTimeDomainEXT)temp_EryZVUE;}();}();
        }
        }();

    PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)get_instance_proc_addr(parent,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)get_device_proc_addr(parent,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
    }  
    
{
auto result=call_function(physicalDevice, pTimeDomainCount, pTimeDomains);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pTimeDomainCount==NULL){
                json["pTimeDomainCount"]=boost::json::array();
            return; }
        auto& arr_siSbERs=json["pTimeDomainCount"].emplace_array();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){arr_siSbERs[xFQhUzA]=pTimeDomainCount[xFQhUzA];}();
        }
        }();
[&](){
            if (pTimeDomains==NULL){
                json["pTimeDomains"]=boost::json::array();
            return; }
        auto& arr_fMkUaJq=json["pTimeDomains"].emplace_array();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){[&](){arr_fMkUaJq[ZiXuFCL]=pTimeDomains[ZiXuFCL];}();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetCalibratedTimestampsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t timestampCount;
[&](){timestampCount=static_cast<uint32_t>(value_to<int>(json["timestampCount"]));}();
VkCalibratedTimestampInfoEXT* pTimestampInfos;
[&](){ VkCalibratedTimestampInfoEXT* temp_rBhqhqM[&](){
            if (json["pTimestampInfos"].as_array().size()==0){
                temp_rBhqhqM=NULL;
            return; }temp_rBhqhqM=(VkCalibratedTimestampInfoEXT*)malloc(timestampCount*sizeof(VkCalibratedTimestampInfoEXT));
        auto& arr_nEtDxWp=json["pTimestampInfos"].as_array();
        for(int GetmFjY=0; GetmFjY < timestampCount; GetmFjY++){
            [&](){
            auto& temp=arr_nEtDxWp[GetmFjY].as_object();
            deserialize_struct(temp,temp_rBhqhqM[GetmFjY]);
            }();
        }
        }();pTimestampInfos=temp_rBhqhqM;}();
uint64_t* pTimestamps;
[&](){
            if (json["pTimestamps"].as_array().size()==0){
                pTimestamps=NULL;
            return; }pTimestamps=(uint64_t*)malloc(timestampCount*sizeof(uint64_t));
        auto& arr_CHzcvgg=json["pTimestamps"].as_array();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){pTimestamps[ptqlrVt]=static_cast<uint64_t>(value_to<int>(arr_CHzcvgg[ptqlrVt]));}();
        }
        }();
uint64_t* pMaxDeviation;
[&](){
            if (json["pMaxDeviation"].as_array().size()==0){
                pMaxDeviation=NULL;
            return; }pMaxDeviation=(uint64_t*)malloc(1*sizeof(uint64_t));
        auto& arr_zQmthvJ=json["pMaxDeviation"].as_array();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){pMaxDeviation[FUkBved]=static_cast<uint64_t>(value_to<int>(arr_zQmthvJ[FUkBved]));}();
        }
        }();

    PFN_vkGetCalibratedTimestampsEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetCalibratedTimestampsEXT)get_instance_proc_addr(parent,"vkGetCalibratedTimestampsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetCalibratedTimestampsEXT)get_device_proc_addr(parent,"vkGetCalibratedTimestampsEXT");
    }  
    
{
auto result=call_function(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["timestampCount"]=timestampCount;}();
[&](){
            if (pTimestampInfos==NULL){
                json["pTimestampInfos"]=boost::json::array();
            return; }
        auto& arr_XQeyMsT=json["pTimestampInfos"].emplace_array();
        for(int aXwwgcz=0; aXwwgcz < timestampCount; aXwwgcz++){
            [&](){
            auto& temp=arr_XQeyMsT[aXwwgcz].emplace_object();
            return serialize_struct(temp, pTimestampInfos[aXwwgcz]);
            }();
        }
        }();
[&](){
            if (pTimestamps==NULL){
                json["pTimestamps"]=boost::json::array();
            return; }
        auto& arr_CHzcvgg=json["pTimestamps"].emplace_array();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){arr_CHzcvgg[ptqlrVt]=pTimestamps[ptqlrVt];}();
        }
        }();
[&](){
            if (pMaxDeviation==NULL){
                json["pMaxDeviation"]=boost::json::array();
            return; }
        auto& arr_zQmthvJ=json["pMaxDeviation"].emplace_array();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){arr_zQmthvJ[FUkBved]=pMaxDeviation[FUkBved];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkSetDebugUtilsObjectNameEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDebugUtilsObjectNameInfoEXT* pNameInfo;
[&](){ VkDebugUtilsObjectNameInfoEXT* temp_gYgsdux[&](){
            if (json["pNameInfo"].as_array().size()==0){
                temp_gYgsdux=NULL;
            return; }temp_gYgsdux=(VkDebugUtilsObjectNameInfoEXT*)malloc(1*sizeof(VkDebugUtilsObjectNameInfoEXT));
        auto& arr_xezbRdt=json["pNameInfo"].as_array();
        for(int bpyMrKI=0; bpyMrKI < 1; bpyMrKI++){
            [&](){
            auto& temp=arr_xezbRdt[bpyMrKI].as_object();
            deserialize_struct(temp,temp_gYgsdux[bpyMrKI]);
            }();
        }
        }();pNameInfo=temp_gYgsdux;}();

    PFN_vkSetDebugUtilsObjectNameEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetDebugUtilsObjectNameEXT)get_instance_proc_addr(parent,"vkSetDebugUtilsObjectNameEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetDebugUtilsObjectNameEXT)get_device_proc_addr(parent,"vkSetDebugUtilsObjectNameEXT");
    }  
    
{
auto result=call_function(device, pNameInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=boost::json::array();
            return; }
        auto& arr_gpHzyjV=json["pNameInfo"].emplace_array();
        for(int sXDrIfX=0; sXDrIfX < 1; sXDrIfX++){
            [&](){
            auto& temp=arr_gpHzyjV[sXDrIfX].emplace_object();
            return serialize_struct(temp, pNameInfo[sXDrIfX]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkSetDebugUtilsObjectTagEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDebugUtilsObjectTagInfoEXT* pTagInfo;
[&](){ VkDebugUtilsObjectTagInfoEXT* temp_uzkdzSN[&](){
            if (json["pTagInfo"].as_array().size()==0){
                temp_uzkdzSN=NULL;
            return; }temp_uzkdzSN=(VkDebugUtilsObjectTagInfoEXT*)malloc(1*sizeof(VkDebugUtilsObjectTagInfoEXT));
        auto& arr_Ltvhugt=json["pTagInfo"].as_array();
        for(int kYwKoxa=0; kYwKoxa < 1; kYwKoxa++){
            [&](){
            auto& temp=arr_Ltvhugt[kYwKoxa].as_object();
            deserialize_struct(temp,temp_uzkdzSN[kYwKoxa]);
            }();
        }
        }();pTagInfo=temp_uzkdzSN;}();

    PFN_vkSetDebugUtilsObjectTagEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetDebugUtilsObjectTagEXT)get_instance_proc_addr(parent,"vkSetDebugUtilsObjectTagEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetDebugUtilsObjectTagEXT)get_device_proc_addr(parent,"vkSetDebugUtilsObjectTagEXT");
    }  
    
{
auto result=call_function(device, pTagInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=boost::json::array();
            return; }
        auto& arr_jMraQzd=json["pTagInfo"].emplace_array();
        for(int lQZzjnQ=0; lQZzjnQ < 1; lQZzjnQ++){
            [&](){
            auto& temp=arr_jMraQzd[lQZzjnQ].emplace_object();
            return serialize_struct(temp, pTagInfo[lQZzjnQ]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkQueueBeginDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
VkDebugUtilsLabelEXT* pLabelInfo;
[&](){ VkDebugUtilsLabelEXT* temp_uqejSGR[&](){
            if (json["pLabelInfo"].as_array().size()==0){
                temp_uqejSGR=NULL;
            return; }temp_uqejSGR=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_dixLKcm=json["pLabelInfo"].as_array();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            auto& temp=arr_dixLKcm[lWNBzGj].as_object();
            deserialize_struct(temp,temp_uqejSGR[lWNBzGj]);
            }();
        }
        }();pLabelInfo=temp_uqejSGR;}();

    PFN_vkQueueBeginDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueBeginDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkQueueBeginDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueBeginDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkQueueBeginDebugUtilsLabelEXT");
    }  
    
{
call_function(queue, pLabelInfo);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }
        auto& arr_GvONoAl=json["pLabelInfo"].emplace_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkQueueEndDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();

    PFN_vkQueueEndDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueEndDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkQueueEndDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueEndDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkQueueEndDebugUtilsLabelEXT");
    }  
    
{
call_function(queue);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();


        writeToConn(json);
    }

    void handle_vkQueueInsertDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
VkDebugUtilsLabelEXT* pLabelInfo;
[&](){ VkDebugUtilsLabelEXT* temp_uqejSGR[&](){
            if (json["pLabelInfo"].as_array().size()==0){
                temp_uqejSGR=NULL;
            return; }temp_uqejSGR=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_dixLKcm=json["pLabelInfo"].as_array();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            auto& temp=arr_dixLKcm[lWNBzGj].as_object();
            deserialize_struct(temp,temp_uqejSGR[lWNBzGj]);
            }();
        }
        }();pLabelInfo=temp_uqejSGR;}();

    PFN_vkQueueInsertDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueInsertDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkQueueInsertDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueInsertDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkQueueInsertDebugUtilsLabelEXT");
    }  
    
{
call_function(queue, pLabelInfo);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }
        auto& arr_GvONoAl=json["pLabelInfo"].emplace_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBeginDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDebugUtilsLabelEXT* pLabelInfo;
[&](){ VkDebugUtilsLabelEXT* temp_uqejSGR[&](){
            if (json["pLabelInfo"].as_array().size()==0){
                temp_uqejSGR=NULL;
            return; }temp_uqejSGR=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_dixLKcm=json["pLabelInfo"].as_array();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            auto& temp=arr_dixLKcm[lWNBzGj].as_object();
            deserialize_struct(temp,temp_uqejSGR[lWNBzGj]);
            }();
        }
        }();pLabelInfo=temp_uqejSGR;}();

    PFN_vkCmdBeginDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkCmdBeginDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkCmdBeginDebugUtilsLabelEXT");
    }  
    
{
call_function(commandBuffer, pLabelInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }
        auto& arr_GvONoAl=json["pLabelInfo"].emplace_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdEndDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkCmdEndDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkCmdEndDebugUtilsLabelEXT");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        writeToConn(json);
    }

    void handle_vkCmdInsertDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDebugUtilsLabelEXT* pLabelInfo;
[&](){ VkDebugUtilsLabelEXT* temp_uqejSGR[&](){
            if (json["pLabelInfo"].as_array().size()==0){
                temp_uqejSGR=NULL;
            return; }temp_uqejSGR=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_dixLKcm=json["pLabelInfo"].as_array();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            auto& temp=arr_dixLKcm[lWNBzGj].as_object();
            deserialize_struct(temp,temp_uqejSGR[lWNBzGj]);
            }();
        }
        }();pLabelInfo=temp_uqejSGR;}();

    PFN_vkCmdInsertDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdInsertDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkCmdInsertDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdInsertDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkCmdInsertDebugUtilsLabelEXT");
    }  
    
{
call_function(commandBuffer, pLabelInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }
        auto& arr_GvONoAl=json["pLabelInfo"].emplace_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateDebugUtilsMessengerEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo;
[&](){ VkDebugUtilsMessengerCreateInfoEXT* temp_vaOqMqw[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_vaOqMqw=NULL;
            return; }temp_vaOqMqw=(VkDebugUtilsMessengerCreateInfoEXT*)malloc(1*sizeof(VkDebugUtilsMessengerCreateInfoEXT));
        auto& arr_kPYPRLp=json["pCreateInfo"].as_array();
        for(int XvRVXaf=0; XvRVXaf < 1; XvRVXaf++){
            [&](){
            auto& temp=arr_kPYPRLp[XvRVXaf].as_object();
            deserialize_struct(temp,temp_vaOqMqw[XvRVXaf]);
            }();
        }
        }();pCreateInfo=temp_vaOqMqw;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkDebugUtilsMessengerEXT* pMessenger;
[&](){
            if (json["pMessenger"].as_array().size()==0){
                pMessenger=NULL;
            return; }pMessenger=(VkDebugUtilsMessengerEXT*)malloc(1*sizeof(VkDebugUtilsMessengerEXT));
        auto& arr_INDwqtI=json["pMessenger"].as_array();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){deserialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe], pMessenger[XlveIOe]);}();
        }
        }();

    PFN_vkCreateDebugUtilsMessengerEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDebugUtilsMessengerEXT)get_instance_proc_addr(parent,"vkCreateDebugUtilsMessengerEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDebugUtilsMessengerEXT)get_device_proc_addr(parent,"vkCreateDebugUtilsMessengerEXT");
    }  
    
{
auto result=call_function(instance, pCreateInfo, pAllocator, pMessenger);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_alrnjyY=json["pCreateInfo"].emplace_array();
        for(int uDOYkhP=0; uDOYkhP < 1; uDOYkhP++){
            [&](){
            auto& temp=arr_alrnjyY[uDOYkhP].emplace_object();
            return serialize_struct(temp, pCreateInfo[uDOYkhP]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMessenger==NULL){
                json["pMessenger"]=boost::json::array();
            return; }
        auto& arr_INDwqtI=json["pMessenger"].emplace_array();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){serialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe],pMessenger[XlveIOe]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyDebugUtilsMessengerEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugUtilsMessengerEXT messenger;
[&](){deserialize_VkDebugUtilsMessengerEXT(json["messenger"], messenger);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyDebugUtilsMessengerEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDebugUtilsMessengerEXT)get_instance_proc_addr(parent,"vkDestroyDebugUtilsMessengerEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDebugUtilsMessengerEXT)get_device_proc_addr(parent,"vkDestroyDebugUtilsMessengerEXT");
    }  
    
{
call_function(instance, messenger, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugUtilsMessengerEXT(json["messenger"],messenger);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkSubmitDebugUtilsMessageEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
[&](){[&](){int temp_UpocUQR;[&](){temp_UpocUQR=static_cast<int>(value_to<int>(json["messageSeverity"]));}();messageSeverity=(VkDebugUtilsMessageSeverityFlagBitsEXT)temp_UpocUQR;}();}();
VkDebugUtilsMessageTypeFlagsEXT messageTypes;
[&](){[&](){int temp_vbjSEUE;[&](){temp_vbjSEUE=static_cast<int>(value_to<int>(json["messageTypes"]));}();messageTypes=(VkDebugUtilsMessageTypeFlagsEXT)temp_vbjSEUE;}();}();
VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
[&](){ VkDebugUtilsMessengerCallbackDataEXT* temp_wYKMSxv[&](){
            if (json["pCallbackData"].as_array().size()==0){
                temp_wYKMSxv=NULL;
            return; }temp_wYKMSxv=(VkDebugUtilsMessengerCallbackDataEXT*)malloc(1*sizeof(VkDebugUtilsMessengerCallbackDataEXT));
        auto& arr_MlNAOAx=json["pCallbackData"].as_array();
        for(int EdtNsto=0; EdtNsto < 1; EdtNsto++){
            [&](){
            auto& temp=arr_MlNAOAx[EdtNsto].as_object();
            deserialize_struct(temp,temp_wYKMSxv[EdtNsto]);
            }();
        }
        }();pCallbackData=temp_wYKMSxv;}();

    PFN_vkSubmitDebugUtilsMessageEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSubmitDebugUtilsMessageEXT)get_instance_proc_addr(parent,"vkSubmitDebugUtilsMessageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSubmitDebugUtilsMessageEXT)get_device_proc_addr(parent,"vkSubmitDebugUtilsMessageEXT");
    }  
    
{
call_function(instance, messageSeverity, messageTypes, pCallbackData);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["messageSeverity"]=messageSeverity;}();}();}();
[&](){[&](){[&](){json["messageTypes"]=messageTypes;}();}();}();
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=boost::json::array();
            return; }
        auto& arr_kahfHKb=json["pCallbackData"].emplace_array();
        for(int YuXULtv=0; YuXULtv < 1; YuXULtv++){
            [&](){
            auto& temp=arr_kahfHKb[YuXULtv].emplace_object();
            return serialize_struct(temp, pCallbackData[YuXULtv]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetMemoryHostPointerPropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkExternalMemoryHandleTypeFlagBits handleType;
[&](){[&](){int temp_vuWMBJk;[&](){temp_vuWMBJk=static_cast<int>(value_to<int>(json["handleType"]));}();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();
void* pHostPointer;
[&](){ void* temp_pfxjiZa[&](){
            if (json["pHostPointer"].as_array().size()==0){
                temp_pfxjiZa=NULL;
            return; }char* temp_EiZqusU;[&](){
            if (json["pHostPointer"].as_array().size()==0){
                temp_EiZqusU=NULL;
            return; }temp_EiZqusU=(char*)malloc(json["pHostPointer"].as_array().size()*sizeof(char));
        auto& arr_QQzcAle=json["pHostPointer"].as_array();
        for(int xxnXlKy=0; xxnXlKy < json["pHostPointer"].as_array().size(); xxnXlKy++){
            [&](){temp_EiZqusU[xxnXlKy]=static_cast<char>(value_to<int>(arr_QQzcAle[xxnXlKy]));}();
        }
        }();temp_pfxjiZa=temp_EiZqusU;}();pHostPointer=temp_pfxjiZa;}();
VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties;
[&](){
            if (json["pMemoryHostPointerProperties"].as_array().size()==0){
                pMemoryHostPointerProperties=NULL;
            return; }pMemoryHostPointerProperties=(VkMemoryHostPointerPropertiesEXT*)malloc(1*sizeof(VkMemoryHostPointerPropertiesEXT));
        auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].as_array();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto& temp=arr_CBNxdHG[hqDeAHT].as_object();
            deserialize_struct(temp,pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();

    PFN_vkGetMemoryHostPointerPropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMemoryHostPointerPropertiesEXT)get_instance_proc_addr(parent,"vkGetMemoryHostPointerPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMemoryHostPointerPropertiesEXT)get_device_proc_addr(parent,"vkGetMemoryHostPointerPropertiesEXT");
    }  
    
{
auto result=call_function(device, handleType, pHostPointer, pMemoryHostPointerProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=handleType;}();}();}();
[&](){
            if (pHostPointer==NULL){
                json["pHostPointer"]=boost::json::array();
            return; }[&](){
            if (((char*)(pHostPointer))==NULL){
                json["pHostPointer"]=boost::json::array();
            return; }
        auto& arr_jCVfueD=json["pHostPointer"].emplace_array();
        for(int ePeFnfT=0; ePeFnfT < strlen(((char*)(pHostPointer)))+1; ePeFnfT++){
            [&](){arr_jCVfueD[ePeFnfT]=((char*)(pHostPointer))[ePeFnfT];}();
        }
        }();}();
[&](){
            if (pMemoryHostPointerProperties==NULL){
                json["pMemoryHostPointerProperties"]=boost::json::array();
            return; }
        auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].emplace_array();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto& temp=arr_CBNxdHG[hqDeAHT].emplace_object();
            return serialize_struct(temp, pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdWriteBufferMarkerAMD(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlagBits pipelineStage;
[&](){[&](){int temp_WILNXWI;[&](){temp_WILNXWI=static_cast<int>(value_to<int>(json["pipelineStage"]));}();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
uint32_t marker;
[&](){marker=static_cast<uint32_t>(value_to<int>(json["marker"]));}();

    PFN_vkCmdWriteBufferMarkerAMD call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteBufferMarkerAMD)get_instance_proc_addr(parent,"vkCmdWriteBufferMarkerAMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteBufferMarkerAMD)get_device_proc_addr(parent,"vkCmdWriteBufferMarkerAMD");
    }  
    
{
call_function(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=pipelineStage;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){json["marker"]=marker;}();


        writeToConn(json);
    }

    void handle_vkCreateRenderPass2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPassCreateInfo2* pCreateInfo;
[&](){ VkRenderPassCreateInfo2* temp_ZzjHUjM[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_ZzjHUjM=NULL;
            return; }temp_ZzjHUjM=(VkRenderPassCreateInfo2*)malloc(1*sizeof(VkRenderPassCreateInfo2));
        auto& arr_wVuIjAr=json["pCreateInfo"].as_array();
        for(int LBnjMyA=0; LBnjMyA < 1; LBnjMyA++){
            [&](){
            auto& temp=arr_wVuIjAr[LBnjMyA].as_object();
            deserialize_struct(temp,temp_ZzjHUjM[LBnjMyA]);
            }();
        }
        }();pCreateInfo=temp_ZzjHUjM;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkRenderPass* pRenderPass;
[&](){
            if (json["pRenderPass"].as_array().size()==0){
                pRenderPass=NULL;
            return; }pRenderPass=(VkRenderPass*)malloc(1*sizeof(VkRenderPass));
        auto& arr_ZwdXTfx=json["pRenderPass"].as_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();

    PFN_vkCreateRenderPass2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateRenderPass2)get_instance_proc_addr(parent,"vkCreateRenderPass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateRenderPass2)get_device_proc_addr(parent,"vkCreateRenderPass2");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pRenderPass);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_cDssBor=json["pCreateInfo"].emplace_array();
        for(int SgbVidQ=0; SgbVidQ < 1; SgbVidQ++){
            [&](){
            auto& temp=arr_cDssBor[SgbVidQ].emplace_object();
            return serialize_struct(temp, pCreateInfo[SgbVidQ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=boost::json::array();
            return; }
        auto& arr_ZwdXTfx=json["pRenderPass"].emplace_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBeginRenderPass2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkRenderPassBeginInfo* pRenderPassBegin;
[&](){ VkRenderPassBeginInfo* temp_ziYLYAn[&](){
            if (json["pRenderPassBegin"].as_array().size()==0){
                temp_ziYLYAn=NULL;
            return; }temp_ziYLYAn=(VkRenderPassBeginInfo*)malloc(1*sizeof(VkRenderPassBeginInfo));
        auto& arr_DvmhBAI=json["pRenderPassBegin"].as_array();
        for(int MzTximI=0; MzTximI < 1; MzTximI++){
            [&](){
            auto& temp=arr_DvmhBAI[MzTximI].as_object();
            deserialize_struct(temp,temp_ziYLYAn[MzTximI]);
            }();
        }
        }();pRenderPassBegin=temp_ziYLYAn;}();
VkSubpassBeginInfo* pSubpassBeginInfo;
[&](){ VkSubpassBeginInfo* temp_RrUVaEN[&](){
            if (json["pSubpassBeginInfo"].as_array().size()==0){
                temp_RrUVaEN=NULL;
            return; }temp_RrUVaEN=(VkSubpassBeginInfo*)malloc(1*sizeof(VkSubpassBeginInfo));
        auto& arr_EzXVEdi=json["pSubpassBeginInfo"].as_array();
        for(int nrSIqlz=0; nrSIqlz < 1; nrSIqlz++){
            [&](){
            auto& temp=arr_EzXVEdi[nrSIqlz].as_object();
            deserialize_struct(temp,temp_RrUVaEN[nrSIqlz]);
            }();
        }
        }();pSubpassBeginInfo=temp_RrUVaEN;}();

    PFN_vkCmdBeginRenderPass2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginRenderPass2)get_instance_proc_addr(parent,"vkCmdBeginRenderPass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginRenderPass2)get_device_proc_addr(parent,"vkCmdBeginRenderPass2");
    }  
    
{
call_function(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=boost::json::array();
            return; }
        auto& arr_XtnTubd=json["pRenderPassBegin"].emplace_array();
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto& temp=arr_XtnTubd[lCAvoJt].emplace_object();
            return serialize_struct(temp, pRenderPassBegin[lCAvoJt]);
            }();
        }
        }();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=boost::json::array();
            return; }
        auto& arr_yxkVVDb=json["pSubpassBeginInfo"].emplace_array();
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto& temp=arr_yxkVVDb[nzkBQUL].emplace_object();
            return serialize_struct(temp, pSubpassBeginInfo[nzkBQUL]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdNextSubpass2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSubpassBeginInfo* pSubpassBeginInfo;
[&](){ VkSubpassBeginInfo* temp_RrUVaEN[&](){
            if (json["pSubpassBeginInfo"].as_array().size()==0){
                temp_RrUVaEN=NULL;
            return; }temp_RrUVaEN=(VkSubpassBeginInfo*)malloc(1*sizeof(VkSubpassBeginInfo));
        auto& arr_EzXVEdi=json["pSubpassBeginInfo"].as_array();
        for(int nrSIqlz=0; nrSIqlz < 1; nrSIqlz++){
            [&](){
            auto& temp=arr_EzXVEdi[nrSIqlz].as_object();
            deserialize_struct(temp,temp_RrUVaEN[nrSIqlz]);
            }();
        }
        }();pSubpassBeginInfo=temp_RrUVaEN;}();
VkSubpassEndInfo* pSubpassEndInfo;
[&](){ VkSubpassEndInfo* temp_VCIKazT[&](){
            if (json["pSubpassEndInfo"].as_array().size()==0){
                temp_VCIKazT=NULL;
            return; }temp_VCIKazT=(VkSubpassEndInfo*)malloc(1*sizeof(VkSubpassEndInfo));
        auto& arr_GcsVuns=json["pSubpassEndInfo"].as_array();
        for(int rFLLcAK=0; rFLLcAK < 1; rFLLcAK++){
            [&](){
            auto& temp=arr_GcsVuns[rFLLcAK].as_object();
            deserialize_struct(temp,temp_VCIKazT[rFLLcAK]);
            }();
        }
        }();pSubpassEndInfo=temp_VCIKazT;}();

    PFN_vkCmdNextSubpass2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdNextSubpass2)get_instance_proc_addr(parent,"vkCmdNextSubpass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdNextSubpass2)get_device_proc_addr(parent,"vkCmdNextSubpass2");
    }  
    
{
call_function(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=boost::json::array();
            return; }
        auto& arr_yxkVVDb=json["pSubpassBeginInfo"].emplace_array();
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto& temp=arr_yxkVVDb[nzkBQUL].emplace_object();
            return serialize_struct(temp, pSubpassBeginInfo[nzkBQUL]);
            }();
        }
        }();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=boost::json::array();
            return; }
        auto& arr_mmmwoMH=json["pSubpassEndInfo"].emplace_array();
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto& temp=arr_mmmwoMH[oMdHEHu].emplace_object();
            return serialize_struct(temp, pSubpassEndInfo[oMdHEHu]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdEndRenderPass2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSubpassEndInfo* pSubpassEndInfo;
[&](){ VkSubpassEndInfo* temp_VCIKazT[&](){
            if (json["pSubpassEndInfo"].as_array().size()==0){
                temp_VCIKazT=NULL;
            return; }temp_VCIKazT=(VkSubpassEndInfo*)malloc(1*sizeof(VkSubpassEndInfo));
        auto& arr_GcsVuns=json["pSubpassEndInfo"].as_array();
        for(int rFLLcAK=0; rFLLcAK < 1; rFLLcAK++){
            [&](){
            auto& temp=arr_GcsVuns[rFLLcAK].as_object();
            deserialize_struct(temp,temp_VCIKazT[rFLLcAK]);
            }();
        }
        }();pSubpassEndInfo=temp_VCIKazT;}();

    PFN_vkCmdEndRenderPass2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndRenderPass2)get_instance_proc_addr(parent,"vkCmdEndRenderPass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndRenderPass2)get_device_proc_addr(parent,"vkCmdEndRenderPass2");
    }  
    
{
call_function(commandBuffer, pSubpassEndInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=boost::json::array();
            return; }
        auto& arr_mmmwoMH=json["pSubpassEndInfo"].emplace_array();
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto& temp=arr_mmmwoMH[oMdHEHu].emplace_object();
            return serialize_struct(temp, pSubpassEndInfo[oMdHEHu]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetSemaphoreCounterValue(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphore semaphore;
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
uint64_t* pValue;
[&](){
            if (json["pValue"].as_array().size()==0){
                pValue=NULL;
            return; }pValue=(uint64_t*)malloc(1*sizeof(uint64_t));
        auto& arr_xnMrErb=json["pValue"].as_array();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){pValue[fdUIVMD]=static_cast<uint64_t>(value_to<int>(arr_xnMrErb[fdUIVMD]));}();
        }
        }();

    PFN_vkGetSemaphoreCounterValue call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSemaphoreCounterValue)get_instance_proc_addr(parent,"vkGetSemaphoreCounterValue");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSemaphoreCounterValue)get_device_proc_addr(parent,"vkGetSemaphoreCounterValue");
    }  
    
{
auto result=call_function(device, semaphore, pValue);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pValue==NULL){
                json["pValue"]=boost::json::array();
            return; }
        auto& arr_xnMrErb=json["pValue"].emplace_array();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){arr_xnMrErb[fdUIVMD]=pValue[fdUIVMD];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkWaitSemaphores(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphoreWaitInfo* pWaitInfo;
[&](){ VkSemaphoreWaitInfo* temp_MGfkJIs[&](){
            if (json["pWaitInfo"].as_array().size()==0){
                temp_MGfkJIs=NULL;
            return; }temp_MGfkJIs=(VkSemaphoreWaitInfo*)malloc(1*sizeof(VkSemaphoreWaitInfo));
        auto& arr_saOfReP=json["pWaitInfo"].as_array();
        for(int PdcqhvB=0; PdcqhvB < 1; PdcqhvB++){
            [&](){
            auto& temp=arr_saOfReP[PdcqhvB].as_object();
            deserialize_struct(temp,temp_MGfkJIs[PdcqhvB]);
            }();
        }
        }();pWaitInfo=temp_MGfkJIs;}();
uint64_t timeout;
[&](){timeout=static_cast<uint64_t>(value_to<int>(json["timeout"]));}();

    PFN_vkWaitSemaphores call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWaitSemaphores)get_instance_proc_addr(parent,"vkWaitSemaphores");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWaitSemaphores)get_device_proc_addr(parent,"vkWaitSemaphores");
    }  
    
{
auto result=call_function(device, pWaitInfo, timeout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pWaitInfo==NULL){
                json["pWaitInfo"]=boost::json::array();
            return; }
        auto& arr_xzakrWz=json["pWaitInfo"].emplace_array();
        for(int hsOLCWG=0; hsOLCWG < 1; hsOLCWG++){
            [&](){
            auto& temp=arr_xzakrWz[hsOLCWG].emplace_object();
            return serialize_struct(temp, pWaitInfo[hsOLCWG]);
            }();
        }
        }();
[&](){json["timeout"]=timeout;}();


        writeToConn(json);
    }

    void handle_vkSignalSemaphore(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphoreSignalInfo* pSignalInfo;
[&](){ VkSemaphoreSignalInfo* temp_Goozuvn[&](){
            if (json["pSignalInfo"].as_array().size()==0){
                temp_Goozuvn=NULL;
            return; }temp_Goozuvn=(VkSemaphoreSignalInfo*)malloc(1*sizeof(VkSemaphoreSignalInfo));
        auto& arr_NpBehDR=json["pSignalInfo"].as_array();
        for(int AsjxdFQ=0; AsjxdFQ < 1; AsjxdFQ++){
            [&](){
            auto& temp=arr_NpBehDR[AsjxdFQ].as_object();
            deserialize_struct(temp,temp_Goozuvn[AsjxdFQ]);
            }();
        }
        }();pSignalInfo=temp_Goozuvn;}();

    PFN_vkSignalSemaphore call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSignalSemaphore)get_instance_proc_addr(parent,"vkSignalSemaphore");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSignalSemaphore)get_device_proc_addr(parent,"vkSignalSemaphore");
    }  
    
{
auto result=call_function(device, pSignalInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pSignalInfo==NULL){
                json["pSignalInfo"]=boost::json::array();
            return; }
        auto& arr_WdRQTJS=json["pSignalInfo"].emplace_array();
        for(int MYLvJyX=0; MYLvJyX < 1; MYLvJyX++){
            [&](){
            auto& temp=arr_WdRQTJS[MYLvJyX].emplace_object();
            return serialize_struct(temp, pSignalInfo[MYLvJyX]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDrawIndirectCount(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){temp_JpaFKmS=static_cast<uint64_t>(value_to<int>(json["countBufferOffset"]));}();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){maxDrawCount=static_cast<uint32_t>(value_to<int>(json["maxDrawCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDrawIndirectCount call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndirectCount)get_instance_proc_addr(parent,"vkCmdDrawIndirectCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndirectCount)get_device_proc_addr(parent,"vkCmdDrawIndirectCount");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawIndexedIndirectCount(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){temp_JpaFKmS=static_cast<uint64_t>(value_to<int>(json["countBufferOffset"]));}();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){maxDrawCount=static_cast<uint32_t>(value_to<int>(json["maxDrawCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDrawIndexedIndirectCount call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndexedIndirectCount)get_instance_proc_addr(parent,"vkCmdDrawIndexedIndirectCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndexedIndirectCount)get_device_proc_addr(parent,"vkCmdDrawIndexedIndirectCount");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdSetCheckpointNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
void* pCheckpointMarker;
[&](){ void* temp_HtEUWlc[&](){
            if (json["pCheckpointMarker"].as_array().size()==0){
                temp_HtEUWlc=NULL;
            return; }char* temp_AspjKUC;[&](){
            if (json["pCheckpointMarker"].as_array().size()==0){
                temp_AspjKUC=NULL;
            return; }temp_AspjKUC=(char*)malloc(json["pCheckpointMarker"].as_array().size()*sizeof(char));
        auto& arr_QXjSoct=json["pCheckpointMarker"].as_array();
        for(int PQOCPcH=0; PQOCPcH < json["pCheckpointMarker"].as_array().size(); PQOCPcH++){
            [&](){temp_AspjKUC[PQOCPcH]=static_cast<char>(value_to<int>(arr_QXjSoct[PQOCPcH]));}();
        }
        }();temp_HtEUWlc=temp_AspjKUC;}();pCheckpointMarker=temp_HtEUWlc;}();

    PFN_vkCmdSetCheckpointNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCheckpointNV)get_instance_proc_addr(parent,"vkCmdSetCheckpointNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCheckpointNV)get_device_proc_addr(parent,"vkCmdSetCheckpointNV");
    }  
    
{
call_function(commandBuffer, pCheckpointMarker);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCheckpointMarker==NULL){
                json["pCheckpointMarker"]=boost::json::array();
            return; }[&](){
            if (((char*)(pCheckpointMarker))==NULL){
                json["pCheckpointMarker"]=boost::json::array();
            return; }
        auto& arr_JthHPaJ=json["pCheckpointMarker"].emplace_array();
        for(int bwenvGE=0; bwenvGE < strlen(((char*)(pCheckpointMarker)))+1; bwenvGE++){
            [&](){arr_JthHPaJ[bwenvGE]=((char*)(pCheckpointMarker))[bwenvGE];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkGetQueueCheckpointDataNV(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t* pCheckpointDataCount;
[&](){
            if (json["pCheckpointDataCount"].as_array().size()==0){
                pCheckpointDataCount=NULL;
            return; }pCheckpointDataCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].as_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(value_to<int>(arr_LsYqVIK[lgasnOP]));}();
        }
        }();
VkCheckpointDataNV* pCheckpointData;
[&](){
            if (json["pCheckpointData"].as_array().size()==0){
                pCheckpointData=NULL;
            return; }pCheckpointData=(VkCheckpointDataNV*)malloc(*pCheckpointDataCount*sizeof(VkCheckpointDataNV));
        auto& arr_gxwhODc=json["pCheckpointData"].as_array();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto& temp=arr_gxwhODc[TfFHlNo].as_object();
            deserialize_struct(temp,pCheckpointData[TfFHlNo]);
            }();
        }
        }();

    PFN_vkGetQueueCheckpointDataNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetQueueCheckpointDataNV)get_instance_proc_addr(parent,"vkGetQueueCheckpointDataNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetQueueCheckpointDataNV)get_device_proc_addr(parent,"vkGetQueueCheckpointDataNV");
    }  
    
{
call_function(queue, pCheckpointDataCount, pCheckpointData);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=boost::json::array();
            return; }
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].emplace_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=pCheckpointDataCount[lgasnOP];}();
        }
        }();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=boost::json::array();
            return; }
        auto& arr_gxwhODc=json["pCheckpointData"].emplace_array();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto& temp=arr_gxwhODc[TfFHlNo].emplace_object();
            return serialize_struct(temp, pCheckpointData[TfFHlNo]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBindTransformFeedbackBuffersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstBinding;
[&](){firstBinding=static_cast<uint32_t>(value_to<int>(json["firstBinding"]));}();
uint32_t bindingCount;
[&](){bindingCount=static_cast<uint32_t>(value_to<int>(json["bindingCount"]));}();
VkBuffer* pBuffers;
[&](){ VkBuffer* temp_XooJXwK[&](){
            if (json["pBuffers"].as_array().size()==0){
                temp_XooJXwK=NULL;
            return; }temp_XooJXwK=(VkBuffer*)malloc(bindingCount*sizeof(VkBuffer));
        auto& arr_ShVTBbp=json["pBuffers"].as_array();
        for(int loSrvWd=0; loSrvWd < bindingCount; loSrvWd++){
            [&](){deserialize_VkBuffer(arr_ShVTBbp[loSrvWd], temp_XooJXwK[loSrvWd]);}();
        }
        }();pBuffers=temp_XooJXwK;}();
VkDeviceSize* pOffsets;
[&](){ VkDeviceSize* temp_rsVsAoT[&](){
            if (json["pOffsets"].as_array().size()==0){
                temp_rsVsAoT=NULL;
            return; }temp_rsVsAoT=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_uWdiGtF=json["pOffsets"].as_array();
        for(int ELYQTNF=0; ELYQTNF < bindingCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){temp_uWdiGtF=static_cast<uint64_t>(value_to<int>(arr_uWdiGtF[ELYQTNF]));}();temp_rsVsAoT[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();pOffsets=temp_rsVsAoT;}();
VkDeviceSize* pSizes;
[&](){ VkDeviceSize* temp_VbqhwxK[&](){
            if (json["pSizes"].as_array().size()==0){
                temp_VbqhwxK=NULL;
            return; }temp_VbqhwxK=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_cHIDMyb=json["pSizes"].as_array();
        for(int yLUmhkZ=0; yLUmhkZ < bindingCount; yLUmhkZ++){
            [&](){uint64_t temp_cHIDMyb;[&](){temp_cHIDMyb=static_cast<uint64_t>(value_to<int>(arr_cHIDMyb[yLUmhkZ]));}();temp_VbqhwxK[yLUmhkZ]=(VkDeviceSize)temp_cHIDMyb;}();
        }
        }();pSizes=temp_VbqhwxK;}();

    PFN_vkCmdBindTransformFeedbackBuffersEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindTransformFeedbackBuffersEXT)get_instance_proc_addr(parent,"vkCmdBindTransformFeedbackBuffersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindTransformFeedbackBuffersEXT)get_device_proc_addr(parent,"vkCmdBindTransformFeedbackBuffersEXT");
    }  
    
{
call_function(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }
        auto& arr_ENtnMTo=json["pBuffers"].emplace_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }
        auto& arr_YvpyTDd=json["pOffsets"].emplace_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=boost::json::array();
            return; }
        auto& arr_OwyEmcF=json["pSizes"].emplace_array();
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=pSizes[YFhxzVl];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBeginTransformFeedbackEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstCounterBuffer;
[&](){firstCounterBuffer=static_cast<uint32_t>(value_to<int>(json["firstCounterBuffer"]));}();
uint32_t counterBufferCount;
[&](){counterBufferCount=static_cast<uint32_t>(value_to<int>(json["counterBufferCount"]));}();
VkBuffer* pCounterBuffers;
[&](){ VkBuffer* temp_wFllMRv[&](){
            if (json["pCounterBuffers"].as_array().size()==0){
                temp_wFllMRv=NULL;
            return; }temp_wFllMRv=(VkBuffer*)malloc(counterBufferCount*sizeof(VkBuffer));
        auto& arr_BxMTckm=json["pCounterBuffers"].as_array();
        for(int TXsvtyB=0; TXsvtyB < counterBufferCount; TXsvtyB++){
            [&](){deserialize_VkBuffer(arr_BxMTckm[TXsvtyB], temp_wFllMRv[TXsvtyB]);}();
        }
        }();pCounterBuffers=temp_wFllMRv;}();
VkDeviceSize* pCounterBufferOffsets;
[&](){ VkDeviceSize* temp_EUGeeyL[&](){
            if (json["pCounterBufferOffsets"].as_array().size()==0){
                temp_EUGeeyL=NULL;
            return; }temp_EUGeeyL=(VkDeviceSize*)malloc(counterBufferCount*sizeof(VkDeviceSize));
        auto& arr_LrVQuLK=json["pCounterBufferOffsets"].as_array();
        for(int FmZEqMc=0; FmZEqMc < counterBufferCount; FmZEqMc++){
            [&](){uint64_t temp_LrVQuLK;[&](){temp_LrVQuLK=static_cast<uint64_t>(value_to<int>(arr_LrVQuLK[FmZEqMc]));}();temp_EUGeeyL[FmZEqMc]=(VkDeviceSize)temp_LrVQuLK;}();
        }
        }();pCounterBufferOffsets=temp_EUGeeyL;}();

    PFN_vkCmdBeginTransformFeedbackEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginTransformFeedbackEXT)get_instance_proc_addr(parent,"vkCmdBeginTransformFeedbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginTransformFeedbackEXT)get_device_proc_addr(parent,"vkCmdBeginTransformFeedbackEXT");
    }  
    
{
call_function(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=firstCounterBuffer;}();
[&](){json["counterBufferCount"]=counterBufferCount;}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=boost::json::array();
            return; }
        auto& arr_eyGyJgR=json["pCounterBuffers"].emplace_array();
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        }();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=boost::json::array();
            return; }
        auto& arr_AiSbQbQ=json["pCounterBufferOffsets"].emplace_array();
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=pCounterBufferOffsets[ThYypfr];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdEndTransformFeedbackEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstCounterBuffer;
[&](){firstCounterBuffer=static_cast<uint32_t>(value_to<int>(json["firstCounterBuffer"]));}();
uint32_t counterBufferCount;
[&](){counterBufferCount=static_cast<uint32_t>(value_to<int>(json["counterBufferCount"]));}();
VkBuffer* pCounterBuffers;
[&](){ VkBuffer* temp_wFllMRv[&](){
            if (json["pCounterBuffers"].as_array().size()==0){
                temp_wFllMRv=NULL;
            return; }temp_wFllMRv=(VkBuffer*)malloc(counterBufferCount*sizeof(VkBuffer));
        auto& arr_BxMTckm=json["pCounterBuffers"].as_array();
        for(int TXsvtyB=0; TXsvtyB < counterBufferCount; TXsvtyB++){
            [&](){deserialize_VkBuffer(arr_BxMTckm[TXsvtyB], temp_wFllMRv[TXsvtyB]);}();
        }
        }();pCounterBuffers=temp_wFllMRv;}();
VkDeviceSize* pCounterBufferOffsets;
[&](){ VkDeviceSize* temp_EUGeeyL[&](){
            if (json["pCounterBufferOffsets"].as_array().size()==0){
                temp_EUGeeyL=NULL;
            return; }temp_EUGeeyL=(VkDeviceSize*)malloc(counterBufferCount*sizeof(VkDeviceSize));
        auto& arr_LrVQuLK=json["pCounterBufferOffsets"].as_array();
        for(int FmZEqMc=0; FmZEqMc < counterBufferCount; FmZEqMc++){
            [&](){uint64_t temp_LrVQuLK;[&](){temp_LrVQuLK=static_cast<uint64_t>(value_to<int>(arr_LrVQuLK[FmZEqMc]));}();temp_EUGeeyL[FmZEqMc]=(VkDeviceSize)temp_LrVQuLK;}();
        }
        }();pCounterBufferOffsets=temp_EUGeeyL;}();

    PFN_vkCmdEndTransformFeedbackEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndTransformFeedbackEXT)get_instance_proc_addr(parent,"vkCmdEndTransformFeedbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndTransformFeedbackEXT)get_device_proc_addr(parent,"vkCmdEndTransformFeedbackEXT");
    }  
    
{
call_function(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=firstCounterBuffer;}();
[&](){json["counterBufferCount"]=counterBufferCount;}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=boost::json::array();
            return; }
        auto& arr_eyGyJgR=json["pCounterBuffers"].emplace_array();
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        }();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=boost::json::array();
            return; }
        auto& arr_AiSbQbQ=json["pCounterBufferOffsets"].emplace_array();
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=pCounterBufferOffsets[ThYypfr];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBeginQueryIndexedEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();
VkQueryControlFlags flags;
[&](){[&](){int temp_iyzDJOK;[&](){temp_iyzDJOK=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();
uint32_t index;
[&](){index=static_cast<uint32_t>(value_to<int>(json["index"]));}();

    PFN_vkCmdBeginQueryIndexedEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginQueryIndexedEXT)get_instance_proc_addr(parent,"vkCmdBeginQueryIndexedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginQueryIndexedEXT)get_device_proc_addr(parent,"vkCmdBeginQueryIndexedEXT");
    }  
    
{
call_function(commandBuffer, queryPool, query, flags, index);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){json["index"]=index;}();


        writeToConn(json);
    }

    void handle_vkCmdEndQueryIndexedEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();
uint32_t index;
[&](){index=static_cast<uint32_t>(value_to<int>(json["index"]));}();

    PFN_vkCmdEndQueryIndexedEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndQueryIndexedEXT)get_instance_proc_addr(parent,"vkCmdEndQueryIndexedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndQueryIndexedEXT)get_device_proc_addr(parent,"vkCmdEndQueryIndexedEXT");
    }  
    
{
call_function(commandBuffer, queryPool, query, index);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){json["index"]=index;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawIndirectByteCountEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t instanceCount;
[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
uint32_t firstInstance;
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();
VkBuffer counterBuffer;
[&](){deserialize_VkBuffer(json["counterBuffer"], counterBuffer);}();
VkDeviceSize counterBufferOffset;
[&](){uint64_t temp_AQwWAlK;[&](){temp_AQwWAlK=static_cast<uint64_t>(value_to<int>(json["counterBufferOffset"]));}();counterBufferOffset=(VkDeviceSize)temp_AQwWAlK;}();
uint32_t counterOffset;
[&](){counterOffset=static_cast<uint32_t>(value_to<int>(json["counterOffset"]));}();
uint32_t vertexStride;
[&](){vertexStride=static_cast<uint32_t>(value_to<int>(json["vertexStride"]));}();

    PFN_vkCmdDrawIndirectByteCountEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndirectByteCountEXT)get_instance_proc_addr(parent,"vkCmdDrawIndirectByteCountEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndirectByteCountEXT)get_device_proc_addr(parent,"vkCmdDrawIndirectByteCountEXT");
    }  
    
{
call_function(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){serialize_VkBuffer(json["counterBuffer"],counterBuffer);}();
[&](){[&](){json["counterBufferOffset"]=counterBufferOffset;}();}();
[&](){json["counterOffset"]=counterOffset;}();
[&](){json["vertexStride"]=vertexStride;}();


        writeToConn(json);
    }

    void handle_vkCmdSetExclusiveScissorNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstExclusiveScissor;
[&](){firstExclusiveScissor=static_cast<uint32_t>(value_to<int>(json["firstExclusiveScissor"]));}();
uint32_t exclusiveScissorCount;
[&](){exclusiveScissorCount=static_cast<uint32_t>(value_to<int>(json["exclusiveScissorCount"]));}();
VkRect2D* pExclusiveScissors;
[&](){ VkRect2D* temp_GmuOKdX[&](){
            if (json["pExclusiveScissors"].as_array().size()==0){
                temp_GmuOKdX=NULL;
            return; }temp_GmuOKdX=(VkRect2D*)malloc(exclusiveScissorCount*sizeof(VkRect2D));
        auto& arr_ZinqSQR=json["pExclusiveScissors"].as_array();
        for(int SkofLXN=0; SkofLXN < exclusiveScissorCount; SkofLXN++){
            [&](){
            auto& temp=arr_ZinqSQR[SkofLXN].as_object();
            deserialize_struct(temp,temp_GmuOKdX[SkofLXN]);
            }();
        }
        }();pExclusiveScissors=temp_GmuOKdX;}();

    PFN_vkCmdSetExclusiveScissorNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetExclusiveScissorNV)get_instance_proc_addr(parent,"vkCmdSetExclusiveScissorNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetExclusiveScissorNV)get_device_proc_addr(parent,"vkCmdSetExclusiveScissorNV");
    }  
    
{
call_function(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=firstExclusiveScissor;}();
[&](){json["exclusiveScissorCount"]=exclusiveScissorCount;}();
[&](){
            if (pExclusiveScissors==NULL){
                json["pExclusiveScissors"]=boost::json::array();
            return; }
        auto& arr_aPFLQnr=json["pExclusiveScissors"].emplace_array();
        for(int uoWCiOs=0; uoWCiOs < exclusiveScissorCount; uoWCiOs++){
            [&](){
            auto& temp=arr_aPFLQnr[uoWCiOs].emplace_object();
            return serialize_struct(temp, pExclusiveScissors[uoWCiOs]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetExclusiveScissorEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstExclusiveScissor;
[&](){firstExclusiveScissor=static_cast<uint32_t>(value_to<int>(json["firstExclusiveScissor"]));}();
uint32_t exclusiveScissorCount;
[&](){exclusiveScissorCount=static_cast<uint32_t>(value_to<int>(json["exclusiveScissorCount"]));}();
VkBool32* pExclusiveScissorEnables;
[&](){ VkBool32* temp_RHrSSfg[&](){
            if (json["pExclusiveScissorEnables"].as_array().size()==0){
                temp_RHrSSfg=NULL;
            return; }temp_RHrSSfg=(VkBool32*)malloc(exclusiveScissorCount*sizeof(VkBool32));
        auto& arr_gutsiaF=json["pExclusiveScissorEnables"].as_array();
        for(int DJnjHfh=0; DJnjHfh < exclusiveScissorCount; DJnjHfh++){
            [&](){uint32_t temp_gutsiaF;[&](){temp_gutsiaF=static_cast<uint32_t>(value_to<int>(arr_gutsiaF[DJnjHfh]));}();temp_RHrSSfg[DJnjHfh]=(VkBool32)temp_gutsiaF;}();
        }
        }();pExclusiveScissorEnables=temp_RHrSSfg;}();

    PFN_vkCmdSetExclusiveScissorEnableNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetExclusiveScissorEnableNV)get_instance_proc_addr(parent,"vkCmdSetExclusiveScissorEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetExclusiveScissorEnableNV)get_device_proc_addr(parent,"vkCmdSetExclusiveScissorEnableNV");
    }  
    
{
call_function(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=firstExclusiveScissor;}();
[&](){json["exclusiveScissorCount"]=exclusiveScissorCount;}();
[&](){
            if (pExclusiveScissorEnables==NULL){
                json["pExclusiveScissorEnables"]=boost::json::array();
            return; }
        auto& arr_xqHCjsr=json["pExclusiveScissorEnables"].emplace_array();
        for(int ZwZaOgk=0; ZwZaOgk < exclusiveScissorCount; ZwZaOgk++){
            [&](){[&](){arr_xqHCjsr[ZwZaOgk]=pExclusiveScissorEnables[ZwZaOgk];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBindShadingRateImageNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){temp_VgsvIeW=static_cast<int>(value_to<int>(json["imageLayout"]));}();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

    PFN_vkCmdBindShadingRateImageNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindShadingRateImageNV)get_instance_proc_addr(parent,"vkCmdBindShadingRateImageNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindShadingRateImageNV)get_device_proc_addr(parent,"vkCmdBindShadingRateImageNV");
    }  
    
{
call_function(commandBuffer, imageView, imageLayout);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetViewportShadingRatePaletteNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){firstViewport=static_cast<uint32_t>(value_to<int>(json["firstViewport"]));}();
uint32_t viewportCount;
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();
VkShadingRatePaletteNV* pShadingRatePalettes;
[&](){ VkShadingRatePaletteNV* temp_FveXKEl[&](){
            if (json["pShadingRatePalettes"].as_array().size()==0){
                temp_FveXKEl=NULL;
            return; }temp_FveXKEl=(VkShadingRatePaletteNV*)malloc(viewportCount*sizeof(VkShadingRatePaletteNV));
        auto& arr_wkMlexp=json["pShadingRatePalettes"].as_array();
        for(int SqzUOqM=0; SqzUOqM < viewportCount; SqzUOqM++){
            [&](){
            auto& temp=arr_wkMlexp[SqzUOqM].as_object();
            deserialize_struct(temp,temp_FveXKEl[SqzUOqM]);
            }();
        }
        }();pShadingRatePalettes=temp_FveXKEl;}();

    PFN_vkCmdSetViewportShadingRatePaletteNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportShadingRatePaletteNV)get_instance_proc_addr(parent,"vkCmdSetViewportShadingRatePaletteNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportShadingRatePaletteNV)get_device_proc_addr(parent,"vkCmdSetViewportShadingRatePaletteNV");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pShadingRatePalettes==NULL){
                json["pShadingRatePalettes"]=boost::json::array();
            return; }
        auto& arr_QGCIyPL=json["pShadingRatePalettes"].emplace_array();
        for(int iwmSeHU=0; iwmSeHU < viewportCount; iwmSeHU++){
            [&](){
            auto& temp=arr_QGCIyPL[iwmSeHU].emplace_object();
            return serialize_struct(temp, pShadingRatePalettes[iwmSeHU]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetCoarseSampleOrderNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCoarseSampleOrderTypeNV sampleOrderType;
[&](){[&](){int temp_iGYbmmy;[&](){temp_iGYbmmy=static_cast<int>(value_to<int>(json["sampleOrderType"]));}();sampleOrderType=(VkCoarseSampleOrderTypeNV)temp_iGYbmmy;}();}();
uint32_t customSampleOrderCount;
[&](){customSampleOrderCount=static_cast<uint32_t>(value_to<int>(json["customSampleOrderCount"]));}();
VkCoarseSampleOrderCustomNV* pCustomSampleOrders;
[&](){ VkCoarseSampleOrderCustomNV* temp_wKTqBQC[&](){
            if (json["pCustomSampleOrders"].as_array().size()==0){
                temp_wKTqBQC=NULL;
            return; }temp_wKTqBQC=(VkCoarseSampleOrderCustomNV*)malloc(customSampleOrderCount*sizeof(VkCoarseSampleOrderCustomNV));
        auto& arr_XDqsEzE=json["pCustomSampleOrders"].as_array();
        for(int MsAfwio=0; MsAfwio < customSampleOrderCount; MsAfwio++){
            [&](){
            auto& temp=arr_XDqsEzE[MsAfwio].as_object();
            deserialize_struct(temp,temp_wKTqBQC[MsAfwio]);
            }();
        }
        }();pCustomSampleOrders=temp_wKTqBQC;}();

    PFN_vkCmdSetCoarseSampleOrderNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoarseSampleOrderNV)get_instance_proc_addr(parent,"vkCmdSetCoarseSampleOrderNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoarseSampleOrderNV)get_device_proc_addr(parent,"vkCmdSetCoarseSampleOrderNV");
    }  
    
{
call_function(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["sampleOrderType"]=sampleOrderType;}();}();}();
[&](){json["customSampleOrderCount"]=customSampleOrderCount;}();
[&](){
            if (pCustomSampleOrders==NULL){
                json["pCustomSampleOrders"]=boost::json::array();
            return; }
        auto& arr_UoJKhih=json["pCustomSampleOrders"].emplace_array();
        for(int nBPVlSV=0; nBPVlSV < customSampleOrderCount; nBPVlSV++){
            [&](){
            auto& temp=arr_UoJKhih[nBPVlSV].emplace_object();
            return serialize_struct(temp, pCustomSampleOrders[nBPVlSV]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t taskCount;
[&](){taskCount=static_cast<uint32_t>(value_to<int>(json["taskCount"]));}();
uint32_t firstTask;
[&](){firstTask=static_cast<uint32_t>(value_to<int>(json["firstTask"]));}();

    PFN_vkCmdDrawMeshTasksNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksNV)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksNV)get_device_proc_addr(parent,"vkCmdDrawMeshTasksNV");
    }  
    
{
call_function(commandBuffer, taskCount, firstTask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["taskCount"]=taskCount;}();
[&](){json["firstTask"]=firstTask;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDrawMeshTasksIndirectNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectNV)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectNV)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectNV");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectCountNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){temp_JpaFKmS=static_cast<uint64_t>(value_to<int>(json["countBufferOffset"]));}();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){maxDrawCount=static_cast<uint32_t>(value_to<int>(json["maxDrawCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDrawMeshTasksIndirectCountNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountNV)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountNV)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountNV");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t groupCountX;
[&](){groupCountX=static_cast<uint32_t>(value_to<int>(json["groupCountX"]));}();
uint32_t groupCountY;
[&](){groupCountY=static_cast<uint32_t>(value_to<int>(json["groupCountY"]));}();
uint32_t groupCountZ;
[&](){groupCountZ=static_cast<uint32_t>(value_to<int>(json["groupCountZ"]));}();

    PFN_vkCmdDrawMeshTasksEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksEXT)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksEXT)get_device_proc_addr(parent,"vkCmdDrawMeshTasksEXT");
    }  
    
{
call_function(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDrawMeshTasksIndirectEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectEXT)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectEXT)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectEXT");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectCountEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){temp_JpaFKmS=static_cast<uint64_t>(value_to<int>(json["countBufferOffset"]));}();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){maxDrawCount=static_cast<uint32_t>(value_to<int>(json["maxDrawCount"]));}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDrawMeshTasksIndirectCountEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountEXT)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountEXT)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountEXT");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCompileDeferredNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t shader;
[&](){shader=static_cast<uint32_t>(value_to<int>(json["shader"]));}();

    PFN_vkCompileDeferredNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCompileDeferredNV)get_instance_proc_addr(parent,"vkCompileDeferredNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCompileDeferredNV)get_device_proc_addr(parent,"vkCompileDeferredNV");
    }  
    
{
auto result=call_function(device, pipeline, shader);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["shader"]=shader;}();


        writeToConn(json);
    }

    void handle_vkCreateAccelerationStructureNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureCreateInfoNV* pCreateInfo;
[&](){ VkAccelerationStructureCreateInfoNV* temp_EKmRHED[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_EKmRHED=NULL;
            return; }temp_EKmRHED=(VkAccelerationStructureCreateInfoNV*)malloc(1*sizeof(VkAccelerationStructureCreateInfoNV));
        auto& arr_CZnEXLZ=json["pCreateInfo"].as_array();
        for(int HkuZrvQ=0; HkuZrvQ < 1; HkuZrvQ++){
            [&](){
            auto& temp=arr_CZnEXLZ[HkuZrvQ].as_object();
            deserialize_struct(temp,temp_EKmRHED[HkuZrvQ]);
            }();
        }
        }();pCreateInfo=temp_EKmRHED;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkAccelerationStructureNV* pAccelerationStructure;
[&](){
            if (json["pAccelerationStructure"].as_array().size()==0){
                pAccelerationStructure=NULL;
            return; }pAccelerationStructure=(VkAccelerationStructureNV*)malloc(1*sizeof(VkAccelerationStructureNV));
        auto& arr_FUsucto=json["pAccelerationStructure"].as_array();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){deserialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM], pAccelerationStructure[tRSoAUM]);}();
        }
        }();

    PFN_vkCreateAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateAccelerationStructureNV)get_instance_proc_addr(parent,"vkCreateAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateAccelerationStructureNV)get_device_proc_addr(parent,"vkCreateAccelerationStructureNV");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_cRwwWhs=json["pCreateInfo"].emplace_array();
        for(int oEOLGTm=0; oEOLGTm < 1; oEOLGTm++){
            [&](){
            auto& temp=arr_cRwwWhs[oEOLGTm].emplace_object();
            return serialize_struct(temp, pCreateInfo[oEOLGTm]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=boost::json::array();
            return; }
        auto& arr_FUsucto=json["pAccelerationStructure"].emplace_array();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){serialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM],pAccelerationStructure[tRSoAUM]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBindInvocationMaskHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){temp_VgsvIeW=static_cast<int>(value_to<int>(json["imageLayout"]));}();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

    PFN_vkCmdBindInvocationMaskHUAWEI call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindInvocationMaskHUAWEI)get_instance_proc_addr(parent,"vkCmdBindInvocationMaskHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindInvocationMaskHUAWEI)get_device_proc_addr(parent,"vkCmdBindInvocationMaskHUAWEI");
    }  
    
{
call_function(commandBuffer, imageView, imageLayout);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();


        writeToConn(json);
    }

    void handle_vkDestroyAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureKHR accelerationStructure;
[&](){deserialize_VkAccelerationStructureKHR(json["accelerationStructure"], accelerationStructure);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyAccelerationStructureKHR)get_instance_proc_addr(parent,"vkDestroyAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyAccelerationStructureKHR)get_device_proc_addr(parent,"vkDestroyAccelerationStructureKHR");
    }  
    
{
call_function(device, accelerationStructure, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureKHR(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyAccelerationStructureNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureNV accelerationStructure;
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyAccelerationStructureNV)get_instance_proc_addr(parent,"vkDestroyAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyAccelerationStructureNV)get_device_proc_addr(parent,"vkDestroyAccelerationStructureNV");
    }  
    
{
call_function(device, accelerationStructure, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureMemoryRequirementsNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureMemoryRequirementsInfoNV* pInfo;
[&](){ VkAccelerationStructureMemoryRequirementsInfoNV* temp_Javeapk[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_Javeapk=NULL;
            return; }temp_Javeapk=(VkAccelerationStructureMemoryRequirementsInfoNV*)malloc(1*sizeof(VkAccelerationStructureMemoryRequirementsInfoNV));
        auto& arr_VDaHmqz=json["pInfo"].as_array();
        for(int wDTIoch=0; wDTIoch < 1; wDTIoch++){
            [&](){
            auto& temp=arr_VDaHmqz[wDTIoch].as_object();
            deserialize_struct(temp,temp_Javeapk[wDTIoch]);
            }();
        }
        }();pInfo=temp_Javeapk;}();
VkMemoryRequirements2KHR* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2KHR*)malloc(1*sizeof(VkMemoryRequirements2KHR));
        auto& arr_lzklPBG=json["pMemoryRequirements"].as_array();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto& temp=arr_lzklPBG[HmtSVPA].as_object();
            deserialize_struct(temp,pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();

    PFN_vkGetAccelerationStructureMemoryRequirementsNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureMemoryRequirementsNV)get_instance_proc_addr(parent,"vkGetAccelerationStructureMemoryRequirementsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureMemoryRequirementsNV)get_device_proc_addr(parent,"vkGetAccelerationStructureMemoryRequirementsNV");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_QKzjkmC=json["pInfo"].emplace_array();
        for(int eEDmZTf=0; eEDmZTf < 1; eEDmZTf++){
            [&](){
            auto& temp=arr_QKzjkmC[eEDmZTf].emplace_object();
            return serialize_struct(temp, pInfo[eEDmZTf]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_lzklPBG=json["pMemoryRequirements"].emplace_array();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto& temp=arr_lzklPBG[HmtSVPA].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBindAccelerationStructureMemoryNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t bindInfoCount;
[&](){bindInfoCount=static_cast<uint32_t>(value_to<int>(json["bindInfoCount"]));}();
VkBindAccelerationStructureMemoryInfoNV* pBindInfos;
[&](){ VkBindAccelerationStructureMemoryInfoNV* temp_lvzfIWG[&](){
            if (json["pBindInfos"].as_array().size()==0){
                temp_lvzfIWG=NULL;
            return; }temp_lvzfIWG=(VkBindAccelerationStructureMemoryInfoNV*)malloc(bindInfoCount*sizeof(VkBindAccelerationStructureMemoryInfoNV));
        auto& arr_AgWFhtE=json["pBindInfos"].as_array();
        for(int NpOYBOz=0; NpOYBOz < bindInfoCount; NpOYBOz++){
            [&](){
            auto& temp=arr_AgWFhtE[NpOYBOz].as_object();
            deserialize_struct(temp,temp_lvzfIWG[NpOYBOz]);
            }();
        }
        }();pBindInfos=temp_lvzfIWG;}();

    PFN_vkBindAccelerationStructureMemoryNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindAccelerationStructureMemoryNV)get_instance_proc_addr(parent,"vkBindAccelerationStructureMemoryNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindAccelerationStructureMemoryNV)get_device_proc_addr(parent,"vkBindAccelerationStructureMemoryNV");
    }  
    
{
auto result=call_function(device, bindInfoCount, pBindInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }
        auto& arr_rhzkvXd=json["pBindInfos"].emplace_array();
        for(int tRvmYFr=0; tRvmYFr < bindInfoCount; tRvmYFr++){
            [&](){
            auto& temp=arr_rhzkvXd[tRvmYFr].emplace_object();
            return serialize_struct(temp, pBindInfos[tRvmYFr]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyAccelerationStructureNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkAccelerationStructureNV dst;
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
VkAccelerationStructureNV src;
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
VkCopyAccelerationStructureModeKHR mode;
[&](){[&](){int temp_KfOqWqs;[&](){temp_KfOqWqs=static_cast<int>(value_to<int>(json["mode"]));}();mode=(VkCopyAccelerationStructureModeKHR)temp_KfOqWqs;}();}();

    PFN_vkCmdCopyAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyAccelerationStructureNV)get_instance_proc_addr(parent,"vkCmdCopyAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyAccelerationStructureNV)get_device_proc_addr(parent,"vkCmdCopyAccelerationStructureNV");
    }  
    
{
call_function(commandBuffer, dst, src, mode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){[&](){[&](){json["mode"]=mode;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdCopyAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyAccelerationStructureInfoKHR* pInfo;
[&](){ VkCopyAccelerationStructureInfoKHR* temp_jIAATHR[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_jIAATHR=NULL;
            return; }temp_jIAATHR=(VkCopyAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureInfoKHR));
        auto& arr_WSMeNoY=json["pInfo"].as_array();
        for(int qgjgiZh=0; qgjgiZh < 1; qgjgiZh++){
            [&](){
            auto& temp=arr_WSMeNoY[qgjgiZh].as_object();
            deserialize_struct(temp,temp_jIAATHR[qgjgiZh]);
            }();
        }
        }();pInfo=temp_jIAATHR;}();

    PFN_vkCmdCopyAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCmdCopyAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyAccelerationStructureKHR)get_device_proc_addr(parent,"vkCmdCopyAccelerationStructureKHR");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_mSSajtp=json["pInfo"].emplace_array();
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto& temp=arr_mSSajtp[ghvrBgW].emplace_object();
            return serialize_struct(temp, pInfo[ghvrBgW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCopyAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
VkCopyAccelerationStructureInfoKHR* pInfo;
[&](){ VkCopyAccelerationStructureInfoKHR* temp_jIAATHR[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_jIAATHR=NULL;
            return; }temp_jIAATHR=(VkCopyAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureInfoKHR));
        auto& arr_WSMeNoY=json["pInfo"].as_array();
        for(int qgjgiZh=0; qgjgiZh < 1; qgjgiZh++){
            [&](){
            auto& temp=arr_WSMeNoY[qgjgiZh].as_object();
            deserialize_struct(temp,temp_jIAATHR[qgjgiZh]);
            }();
        }
        }();pInfo=temp_jIAATHR;}();

    PFN_vkCopyAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCopyAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyAccelerationStructureKHR)get_device_proc_addr(parent,"vkCopyAccelerationStructureKHR");
    }  
    
{
auto result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_mSSajtp=json["pInfo"].emplace_array();
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto& temp=arr_mSSajtp[ghvrBgW].emplace_object();
            return serialize_struct(temp, pInfo[ghvrBgW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyAccelerationStructureToMemoryKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyAccelerationStructureToMemoryInfoKHR* pInfo;
[&](){ VkCopyAccelerationStructureToMemoryInfoKHR* temp_aUYRjub[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_aUYRjub=NULL;
            return; }temp_aUYRjub=(VkCopyAccelerationStructureToMemoryInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureToMemoryInfoKHR));
        auto& arr_lkaVawI=json["pInfo"].as_array();
        for(int qcYcnXp=0; qcYcnXp < 1; qcYcnXp++){
            [&](){
            auto& temp=arr_lkaVawI[qcYcnXp].as_object();
            deserialize_struct(temp,temp_aUYRjub[qcYcnXp]);
            }();
        }
        }();pInfo=temp_aUYRjub;}();

    PFN_vkCmdCopyAccelerationStructureToMemoryKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyAccelerationStructureToMemoryKHR)get_instance_proc_addr(parent,"vkCmdCopyAccelerationStructureToMemoryKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyAccelerationStructureToMemoryKHR)get_device_proc_addr(parent,"vkCmdCopyAccelerationStructureToMemoryKHR");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_MpzusRq=json["pInfo"].emplace_array();
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto& temp=arr_MpzusRq[hToWSKz].emplace_object();
            return serialize_struct(temp, pInfo[hToWSKz]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCopyAccelerationStructureToMemoryKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
VkCopyAccelerationStructureToMemoryInfoKHR* pInfo;
[&](){ VkCopyAccelerationStructureToMemoryInfoKHR* temp_aUYRjub[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_aUYRjub=NULL;
            return; }temp_aUYRjub=(VkCopyAccelerationStructureToMemoryInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureToMemoryInfoKHR));
        auto& arr_lkaVawI=json["pInfo"].as_array();
        for(int qcYcnXp=0; qcYcnXp < 1; qcYcnXp++){
            [&](){
            auto& temp=arr_lkaVawI[qcYcnXp].as_object();
            deserialize_struct(temp,temp_aUYRjub[qcYcnXp]);
            }();
        }
        }();pInfo=temp_aUYRjub;}();

    PFN_vkCopyAccelerationStructureToMemoryKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyAccelerationStructureToMemoryKHR)get_instance_proc_addr(parent,"vkCopyAccelerationStructureToMemoryKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyAccelerationStructureToMemoryKHR)get_device_proc_addr(parent,"vkCopyAccelerationStructureToMemoryKHR");
    }  
    
{
auto result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_MpzusRq=json["pInfo"].emplace_array();
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto& temp=arr_MpzusRq[hToWSKz].emplace_object();
            return serialize_struct(temp, pInfo[hToWSKz]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryToAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyMemoryToAccelerationStructureInfoKHR* pInfo;
[&](){ VkCopyMemoryToAccelerationStructureInfoKHR* temp_ftCDuhg[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_ftCDuhg=NULL;
            return; }temp_ftCDuhg=(VkCopyMemoryToAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyMemoryToAccelerationStructureInfoKHR));
        auto& arr_bZDMHqg=json["pInfo"].as_array();
        for(int exexFjs=0; exexFjs < 1; exexFjs++){
            [&](){
            auto& temp=arr_bZDMHqg[exexFjs].as_object();
            deserialize_struct(temp,temp_ftCDuhg[exexFjs]);
            }();
        }
        }();pInfo=temp_ftCDuhg;}();

    PFN_vkCmdCopyMemoryToAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMemoryToAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCmdCopyMemoryToAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMemoryToAccelerationStructureKHR)get_device_proc_addr(parent,"vkCmdCopyMemoryToAccelerationStructureKHR");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_yRNSaUF=json["pInfo"].emplace_array();
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto& temp=arr_yRNSaUF[ulOBYSb].emplace_object();
            return serialize_struct(temp, pInfo[ulOBYSb]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCopyMemoryToAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
VkCopyMemoryToAccelerationStructureInfoKHR* pInfo;
[&](){ VkCopyMemoryToAccelerationStructureInfoKHR* temp_ftCDuhg[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_ftCDuhg=NULL;
            return; }temp_ftCDuhg=(VkCopyMemoryToAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyMemoryToAccelerationStructureInfoKHR));
        auto& arr_bZDMHqg=json["pInfo"].as_array();
        for(int exexFjs=0; exexFjs < 1; exexFjs++){
            [&](){
            auto& temp=arr_bZDMHqg[exexFjs].as_object();
            deserialize_struct(temp,temp_ftCDuhg[exexFjs]);
            }();
        }
        }();pInfo=temp_ftCDuhg;}();

    PFN_vkCopyMemoryToAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMemoryToAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCopyMemoryToAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMemoryToAccelerationStructureKHR)get_device_proc_addr(parent,"vkCopyMemoryToAccelerationStructureKHR");
    }  
    
{
auto result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_yRNSaUF=json["pInfo"].emplace_array();
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto& temp=arr_yRNSaUF[ulOBYSb].emplace_object();
            return serialize_struct(temp, pInfo[ulOBYSb]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdWriteAccelerationStructuresPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t accelerationStructureCount;
[&](){accelerationStructureCount=static_cast<uint32_t>(value_to<int>(json["accelerationStructureCount"]));}();
VkAccelerationStructureKHR* pAccelerationStructures;
[&](){ VkAccelerationStructureKHR* temp_FxtZZQa[&](){
            if (json["pAccelerationStructures"].as_array().size()==0){
                temp_FxtZZQa=NULL;
            return; }temp_FxtZZQa=(VkAccelerationStructureKHR*)malloc(accelerationStructureCount*sizeof(VkAccelerationStructureKHR));
        auto& arr_QDDZeVb=json["pAccelerationStructures"].as_array();
        for(int dBhihII=0; dBhihII < accelerationStructureCount; dBhihII++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_QDDZeVb[dBhihII], temp_FxtZZQa[dBhihII]);}();
        }
        }();pAccelerationStructures=temp_FxtZZQa;}();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();

    PFN_vkCmdWriteAccelerationStructuresPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)get_instance_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)get_device_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesKHR");
    }  
    
{
call_function(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }
        auto& arr_oCGlcEh=json["pAccelerationStructures"].emplace_array();
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();


        writeToConn(json);
    }

    void handle_vkCmdWriteAccelerationStructuresPropertiesNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t accelerationStructureCount;
[&](){accelerationStructureCount=static_cast<uint32_t>(value_to<int>(json["accelerationStructureCount"]));}();
VkAccelerationStructureNV* pAccelerationStructures;
[&](){ VkAccelerationStructureNV* temp_tLplqmX[&](){
            if (json["pAccelerationStructures"].as_array().size()==0){
                temp_tLplqmX=NULL;
            return; }temp_tLplqmX=(VkAccelerationStructureNV*)malloc(accelerationStructureCount*sizeof(VkAccelerationStructureNV));
        auto& arr_jMdvwQK=json["pAccelerationStructures"].as_array();
        for(int lmeuIny=0; lmeuIny < accelerationStructureCount; lmeuIny++){
            [&](){deserialize_VkAccelerationStructureNV(arr_jMdvwQK[lmeuIny], temp_tLplqmX[lmeuIny]);}();
        }
        }();pAccelerationStructures=temp_tLplqmX;}();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();

    PFN_vkCmdWriteAccelerationStructuresPropertiesNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesNV)get_instance_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesNV)get_device_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesNV");
    }  
    
{
call_function(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }
        auto& arr_NSQEnJt=json["pAccelerationStructures"].emplace_array();
        for(int zIyqkBG=0; zIyqkBG < accelerationStructureCount; zIyqkBG++){
            [&](){serialize_VkAccelerationStructureNV(arr_NSQEnJt[zIyqkBG],pAccelerationStructures[zIyqkBG]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();


        writeToConn(json);
    }

    void handle_vkCmdBuildAccelerationStructureNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkAccelerationStructureInfoNV* pInfo;
[&](){ VkAccelerationStructureInfoNV* temp_onVmopW[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_onVmopW=NULL;
            return; }temp_onVmopW=(VkAccelerationStructureInfoNV*)malloc(1*sizeof(VkAccelerationStructureInfoNV));
        auto& arr_lerVBoc=json["pInfo"].as_array();
        for(int mMkuLVq=0; mMkuLVq < 1; mMkuLVq++){
            [&](){
            auto& temp=arr_lerVBoc[mMkuLVq].as_object();
            deserialize_struct(temp,temp_onVmopW[mMkuLVq]);
            }();
        }
        }();pInfo=temp_onVmopW;}();
VkBuffer instanceData;
[&](){deserialize_VkBuffer(json["instanceData"], instanceData);}();
VkDeviceSize instanceOffset;
[&](){uint64_t temp_sEYJico;[&](){temp_sEYJico=static_cast<uint64_t>(value_to<int>(json["instanceOffset"]));}();instanceOffset=(VkDeviceSize)temp_sEYJico;}();
VkBool32 update;
[&](){uint32_t temp_LpVZhJf;[&](){temp_LpVZhJf=static_cast<uint32_t>(value_to<int>(json["update"]));}();update=(VkBool32)temp_LpVZhJf;}();
VkAccelerationStructureNV dst;
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
VkAccelerationStructureNV src;
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
VkBuffer scratch;
[&](){deserialize_VkBuffer(json["scratch"], scratch);}();
VkDeviceSize scratchOffset;
[&](){uint64_t temp_rbfZpmL;[&](){temp_rbfZpmL=static_cast<uint64_t>(value_to<int>(json["scratchOffset"]));}();scratchOffset=(VkDeviceSize)temp_rbfZpmL;}();

    PFN_vkCmdBuildAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBuildAccelerationStructureNV)get_instance_proc_addr(parent,"vkCmdBuildAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBuildAccelerationStructureNV)get_device_proc_addr(parent,"vkCmdBuildAccelerationStructureNV");
    }  
    
{
call_function(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_GYyRhgo=json["pInfo"].emplace_array();
        for(int jJuvWAP=0; jJuvWAP < 1; jJuvWAP++){
            [&](){
            auto& temp=arr_GYyRhgo[jJuvWAP].emplace_object();
            return serialize_struct(temp, pInfo[jJuvWAP]);
            }();
        }
        }();
[&](){serialize_VkBuffer(json["instanceData"],instanceData);}();
[&](){[&](){json["instanceOffset"]=instanceOffset;}();}();
[&](){[&](){json["update"]=update;}();}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){serialize_VkBuffer(json["scratch"],scratch);}();
[&](){[&](){json["scratchOffset"]=scratchOffset;}();}();


        writeToConn(json);
    }

    void handle_vkWriteAccelerationStructuresPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t accelerationStructureCount;
[&](){accelerationStructureCount=static_cast<uint32_t>(value_to<int>(json["accelerationStructureCount"]));}();
VkAccelerationStructureKHR* pAccelerationStructures;
[&](){ VkAccelerationStructureKHR* temp_FxtZZQa[&](){
            if (json["pAccelerationStructures"].as_array().size()==0){
                temp_FxtZZQa=NULL;
            return; }temp_FxtZZQa=(VkAccelerationStructureKHR*)malloc(accelerationStructureCount*sizeof(VkAccelerationStructureKHR));
        auto& arr_QDDZeVb=json["pAccelerationStructures"].as_array();
        for(int dBhihII=0; dBhihII < accelerationStructureCount; dBhihII++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_QDDZeVb[dBhihII], temp_FxtZZQa[dBhihII]);}();
        }
        }();pAccelerationStructures=temp_FxtZZQa;}();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
size_t dataSize;
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();
size_t stride;
[&](){stride=static_cast<size_t>(value_to<int>(json["stride"]));}();

    PFN_vkWriteAccelerationStructuresPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWriteAccelerationStructuresPropertiesKHR)get_instance_proc_addr(parent,"vkWriteAccelerationStructuresPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWriteAccelerationStructuresPropertiesKHR)get_device_proc_addr(parent,"vkWriteAccelerationStructuresPropertiesKHR");
    }  
    
{
auto result=call_function(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }
        auto& arr_oCGlcEh=json["pAccelerationStructures"].emplace_array();
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCmdTraceRaysKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
[&](){ VkStridedDeviceAddressRegionKHR* temp_ybBfOsB[&](){
            if (json["pRaygenShaderBindingTable"].as_array().size()==0){
                temp_ybBfOsB=NULL;
            return; }temp_ybBfOsB=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_vmdxRLm=json["pRaygenShaderBindingTable"].as_array();
        for(int xvlAiIt=0; xvlAiIt < 1; xvlAiIt++){
            [&](){
            auto& temp=arr_vmdxRLm[xvlAiIt].as_object();
            deserialize_struct(temp,temp_ybBfOsB[xvlAiIt]);
            }();
        }
        }();pRaygenShaderBindingTable=temp_ybBfOsB;}();
VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
[&](){ VkStridedDeviceAddressRegionKHR* temp_JtxUbyV[&](){
            if (json["pMissShaderBindingTable"].as_array().size()==0){
                temp_JtxUbyV=NULL;
            return; }temp_JtxUbyV=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_aiNBoIa=json["pMissShaderBindingTable"].as_array();
        for(int fjwDbNz=0; fjwDbNz < 1; fjwDbNz++){
            [&](){
            auto& temp=arr_aiNBoIa[fjwDbNz].as_object();
            deserialize_struct(temp,temp_JtxUbyV[fjwDbNz]);
            }();
        }
        }();pMissShaderBindingTable=temp_JtxUbyV;}();
VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
[&](){ VkStridedDeviceAddressRegionKHR* temp_OcrBtYb[&](){
            if (json["pHitShaderBindingTable"].as_array().size()==0){
                temp_OcrBtYb=NULL;
            return; }temp_OcrBtYb=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_MsArahD=json["pHitShaderBindingTable"].as_array();
        for(int TYXtQRB=0; TYXtQRB < 1; TYXtQRB++){
            [&](){
            auto& temp=arr_MsArahD[TYXtQRB].as_object();
            deserialize_struct(temp,temp_OcrBtYb[TYXtQRB]);
            }();
        }
        }();pHitShaderBindingTable=temp_OcrBtYb;}();
VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
[&](){ VkStridedDeviceAddressRegionKHR* temp_UolJmIv[&](){
            if (json["pCallableShaderBindingTable"].as_array().size()==0){
                temp_UolJmIv=NULL;
            return; }temp_UolJmIv=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_ZxEGCDr=json["pCallableShaderBindingTable"].as_array();
        for(int rzAeWYt=0; rzAeWYt < 1; rzAeWYt++){
            [&](){
            auto& temp=arr_ZxEGCDr[rzAeWYt].as_object();
            deserialize_struct(temp,temp_UolJmIv[rzAeWYt]);
            }();
        }
        }();pCallableShaderBindingTable=temp_UolJmIv;}();
uint32_t width;
[&](){width=static_cast<uint32_t>(value_to<int>(json["width"]));}();
uint32_t height;
[&](){height=static_cast<uint32_t>(value_to<int>(json["height"]));}();
uint32_t depth;
[&](){depth=static_cast<uint32_t>(value_to<int>(json["depth"]));}();

    PFN_vkCmdTraceRaysKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdTraceRaysKHR)get_instance_proc_addr(parent,"vkCmdTraceRaysKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdTraceRaysKHR)get_device_proc_addr(parent,"vkCmdTraceRaysKHR");
    }  
    
{
call_function(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_SlnAEUX=json["pRaygenShaderBindingTable"].emplace_array();
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto& temp=arr_SlnAEUX[VKRuDIv].emplace_object();
            return serialize_struct(temp, pRaygenShaderBindingTable[VKRuDIv]);
            }();
        }
        }();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_vBQknzc=json["pMissShaderBindingTable"].emplace_array();
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto& temp=arr_vBQknzc[ZhvHpIX].emplace_object();
            return serialize_struct(temp, pMissShaderBindingTable[ZhvHpIX]);
            }();
        }
        }();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_IhHhjXk=json["pHitShaderBindingTable"].emplace_array();
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto& temp=arr_IhHhjXk[yriMdrU].emplace_object();
            return serialize_struct(temp, pHitShaderBindingTable[yriMdrU]);
            }();
        }
        }();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_EmEYSBY=json["pCallableShaderBindingTable"].emplace_array();
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto& temp=arr_EmEYSBY[TiOHiqW].emplace_object();
            return serialize_struct(temp, pCallableShaderBindingTable[TiOHiqW]);
            }();
        }
        }();
[&](){json["width"]=width;}();
[&](){json["height"]=height;}();
[&](){json["depth"]=depth;}();


        writeToConn(json);
    }

    void handle_vkCmdTraceRaysNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer raygenShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["raygenShaderBindingTableBuffer"], raygenShaderBindingTableBuffer);}();
VkDeviceSize raygenShaderBindingOffset;
[&](){uint64_t temp_nbAYEyt;[&](){temp_nbAYEyt=static_cast<uint64_t>(value_to<int>(json["raygenShaderBindingOffset"]));}();raygenShaderBindingOffset=(VkDeviceSize)temp_nbAYEyt;}();
VkBuffer missShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["missShaderBindingTableBuffer"], missShaderBindingTableBuffer);}();
VkDeviceSize missShaderBindingOffset;
[&](){uint64_t temp_ORIaXGF;[&](){temp_ORIaXGF=static_cast<uint64_t>(value_to<int>(json["missShaderBindingOffset"]));}();missShaderBindingOffset=(VkDeviceSize)temp_ORIaXGF;}();
VkDeviceSize missShaderBindingStride;
[&](){uint64_t temp_BOvfilr;[&](){temp_BOvfilr=static_cast<uint64_t>(value_to<int>(json["missShaderBindingStride"]));}();missShaderBindingStride=(VkDeviceSize)temp_BOvfilr;}();
VkBuffer hitShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["hitShaderBindingTableBuffer"], hitShaderBindingTableBuffer);}();
VkDeviceSize hitShaderBindingOffset;
[&](){uint64_t temp_oKlCsJj;[&](){temp_oKlCsJj=static_cast<uint64_t>(value_to<int>(json["hitShaderBindingOffset"]));}();hitShaderBindingOffset=(VkDeviceSize)temp_oKlCsJj;}();
VkDeviceSize hitShaderBindingStride;
[&](){uint64_t temp_qhwyGdu;[&](){temp_qhwyGdu=static_cast<uint64_t>(value_to<int>(json["hitShaderBindingStride"]));}();hitShaderBindingStride=(VkDeviceSize)temp_qhwyGdu;}();
VkBuffer callableShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["callableShaderBindingTableBuffer"], callableShaderBindingTableBuffer);}();
VkDeviceSize callableShaderBindingOffset;
[&](){uint64_t temp_WmjXZmz;[&](){temp_WmjXZmz=static_cast<uint64_t>(value_to<int>(json["callableShaderBindingOffset"]));}();callableShaderBindingOffset=(VkDeviceSize)temp_WmjXZmz;}();
VkDeviceSize callableShaderBindingStride;
[&](){uint64_t temp_giLAAVF;[&](){temp_giLAAVF=static_cast<uint64_t>(value_to<int>(json["callableShaderBindingStride"]));}();callableShaderBindingStride=(VkDeviceSize)temp_giLAAVF;}();
uint32_t width;
[&](){width=static_cast<uint32_t>(value_to<int>(json["width"]));}();
uint32_t height;
[&](){height=static_cast<uint32_t>(value_to<int>(json["height"]));}();
uint32_t depth;
[&](){depth=static_cast<uint32_t>(value_to<int>(json["depth"]));}();

    PFN_vkCmdTraceRaysNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdTraceRaysNV)get_instance_proc_addr(parent,"vkCmdTraceRaysNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdTraceRaysNV)get_device_proc_addr(parent,"vkCmdTraceRaysNV");
    }  
    
{
call_function(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["raygenShaderBindingTableBuffer"],raygenShaderBindingTableBuffer);}();
[&](){[&](){json["raygenShaderBindingOffset"]=raygenShaderBindingOffset;}();}();
[&](){serialize_VkBuffer(json["missShaderBindingTableBuffer"],missShaderBindingTableBuffer);}();
[&](){[&](){json["missShaderBindingOffset"]=missShaderBindingOffset;}();}();
[&](){[&](){json["missShaderBindingStride"]=missShaderBindingStride;}();}();
[&](){serialize_VkBuffer(json["hitShaderBindingTableBuffer"],hitShaderBindingTableBuffer);}();
[&](){[&](){json["hitShaderBindingOffset"]=hitShaderBindingOffset;}();}();
[&](){[&](){json["hitShaderBindingStride"]=hitShaderBindingStride;}();}();
[&](){serialize_VkBuffer(json["callableShaderBindingTableBuffer"],callableShaderBindingTableBuffer);}();
[&](){[&](){json["callableShaderBindingOffset"]=callableShaderBindingOffset;}();}();
[&](){[&](){json["callableShaderBindingStride"]=callableShaderBindingStride;}();}();
[&](){json["width"]=width;}();
[&](){json["height"]=height;}();
[&](){json["depth"]=depth;}();


        writeToConn(json);
    }

    void handle_vkGetRayTracingShaderGroupHandlesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t firstGroup;
[&](){firstGroup=static_cast<uint32_t>(value_to<int>(json["firstGroup"]));}();
uint32_t groupCount;
[&](){groupCount=static_cast<uint32_t>(value_to<int>(json["groupCount"]));}();
size_t dataSize;
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();

    PFN_vkGetRayTracingShaderGroupHandlesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRayTracingShaderGroupHandlesKHR)get_instance_proc_addr(parent,"vkGetRayTracingShaderGroupHandlesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRayTracingShaderGroupHandlesKHR)get_device_proc_addr(parent,"vkGetRayTracingShaderGroupHandlesKHR");
    }  
    
{
auto result=call_function(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=firstGroup;}();
[&](){json["groupCount"]=groupCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t firstGroup;
[&](){firstGroup=static_cast<uint32_t>(value_to<int>(json["firstGroup"]));}();
uint32_t groupCount;
[&](){groupCount=static_cast<uint32_t>(value_to<int>(json["groupCount"]));}();
size_t dataSize;
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();

    PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)get_instance_proc_addr(parent,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)get_device_proc_addr(parent,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
    }  
    
{
auto result=call_function(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=firstGroup;}();
[&](){json["groupCount"]=groupCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureHandleNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureNV accelerationStructure;
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();
size_t dataSize;
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();

    PFN_vkGetAccelerationStructureHandleNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureHandleNV)get_instance_proc_addr(parent,"vkGetAccelerationStructureHandleNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureHandleNV)get_device_proc_addr(parent,"vkGetAccelerationStructureHandleNV");
    }  
    
{
auto result=call_function(device, accelerationStructure, dataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkCreateRayTracingPipelinesNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();
VkRayTracingPipelineCreateInfoNV* pCreateInfos;
[&](){ VkRayTracingPipelineCreateInfoNV* temp_ThSDvQC[&](){
            if (json["pCreateInfos"].as_array().size()==0){
                temp_ThSDvQC=NULL;
            return; }temp_ThSDvQC=(VkRayTracingPipelineCreateInfoNV*)malloc(createInfoCount*sizeof(VkRayTracingPipelineCreateInfoNV));
        auto& arr_XJbewcz=json["pCreateInfos"].as_array();
        for(int OYHdDIG=0; OYHdDIG < createInfoCount; OYHdDIG++){
            [&](){
            auto& temp=arr_XJbewcz[OYHdDIG].as_object();
            deserialize_struct(temp,temp_ThSDvQC[OYHdDIG]);
            }();
        }
        }();pCreateInfos=temp_ThSDvQC;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].as_array().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));
        auto& arr_wuOYMDC=json["pPipelines"].as_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateRayTracingPipelinesNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateRayTracingPipelinesNV)get_instance_proc_addr(parent,"vkCreateRayTracingPipelinesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateRayTracingPipelinesNV)get_device_proc_addr(parent,"vkCreateRayTracingPipelinesNV");
    }  
    
{
auto result=call_function(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_bzMTsat=json["pCreateInfos"].emplace_array();
        for(int oRbABSQ=0; oRbABSQ < createInfoCount; oRbABSQ++){
            [&](){
            auto& temp=arr_bzMTsat[oRbABSQ].emplace_object();
            return serialize_struct(temp, pCreateInfos[oRbABSQ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].emplace_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateRayTracingPipelinesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();
VkRayTracingPipelineCreateInfoKHR* pCreateInfos;
[&](){ VkRayTracingPipelineCreateInfoKHR* temp_IzFVNeG[&](){
            if (json["pCreateInfos"].as_array().size()==0){
                temp_IzFVNeG=NULL;
            return; }temp_IzFVNeG=(VkRayTracingPipelineCreateInfoKHR*)malloc(createInfoCount*sizeof(VkRayTracingPipelineCreateInfoKHR));
        auto& arr_IiabYtV=json["pCreateInfos"].as_array();
        for(int NFMtVfO=0; NFMtVfO < createInfoCount; NFMtVfO++){
            [&](){
            auto& temp=arr_IiabYtV[NFMtVfO].as_object();
            deserialize_struct(temp,temp_IzFVNeG[NFMtVfO]);
            }();
        }
        }();pCreateInfos=temp_IzFVNeG;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].as_array().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));
        auto& arr_wuOYMDC=json["pPipelines"].as_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateRayTracingPipelinesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateRayTracingPipelinesKHR)get_instance_proc_addr(parent,"vkCreateRayTracingPipelinesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateRayTracingPipelinesKHR)get_device_proc_addr(parent,"vkCreateRayTracingPipelinesKHR");
    }  
    
{
auto result=call_function(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_zltFjJj=json["pCreateInfos"].emplace_array();
        for(int Szqaxlk=0; Szqaxlk < createInfoCount; Szqaxlk++){
            [&](){
            auto& temp=arr_zltFjJj[Szqaxlk].emplace_object();
            return serialize_struct(temp, pCreateInfos[Szqaxlk]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].emplace_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkCooperativeMatrixPropertiesNV* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkCooperativeMatrixPropertiesNV*)malloc(*pPropertyCount*sizeof(VkCooperativeMatrixPropertiesNV));
        auto& arr_kVfVVDF=json["pProperties"].as_array();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto& temp=arr_kVfVVDF[WfgOgPA].as_object();
            deserialize_struct(temp,pProperties[WfgOgPA]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
    }  
    
{
auto result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_kVfVVDF=json["pProperties"].emplace_array();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto& temp=arr_kVfVVDF[WfgOgPA].emplace_object();
            return serialize_struct(temp, pProperties[WfgOgPA]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdTraceRaysIndirectKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
[&](){ VkStridedDeviceAddressRegionKHR* temp_ybBfOsB[&](){
            if (json["pRaygenShaderBindingTable"].as_array().size()==0){
                temp_ybBfOsB=NULL;
            return; }temp_ybBfOsB=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_vmdxRLm=json["pRaygenShaderBindingTable"].as_array();
        for(int xvlAiIt=0; xvlAiIt < 1; xvlAiIt++){
            [&](){
            auto& temp=arr_vmdxRLm[xvlAiIt].as_object();
            deserialize_struct(temp,temp_ybBfOsB[xvlAiIt]);
            }();
        }
        }();pRaygenShaderBindingTable=temp_ybBfOsB;}();
VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
[&](){ VkStridedDeviceAddressRegionKHR* temp_JtxUbyV[&](){
            if (json["pMissShaderBindingTable"].as_array().size()==0){
                temp_JtxUbyV=NULL;
            return; }temp_JtxUbyV=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_aiNBoIa=json["pMissShaderBindingTable"].as_array();
        for(int fjwDbNz=0; fjwDbNz < 1; fjwDbNz++){
            [&](){
            auto& temp=arr_aiNBoIa[fjwDbNz].as_object();
            deserialize_struct(temp,temp_JtxUbyV[fjwDbNz]);
            }();
        }
        }();pMissShaderBindingTable=temp_JtxUbyV;}();
VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
[&](){ VkStridedDeviceAddressRegionKHR* temp_OcrBtYb[&](){
            if (json["pHitShaderBindingTable"].as_array().size()==0){
                temp_OcrBtYb=NULL;
            return; }temp_OcrBtYb=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_MsArahD=json["pHitShaderBindingTable"].as_array();
        for(int TYXtQRB=0; TYXtQRB < 1; TYXtQRB++){
            [&](){
            auto& temp=arr_MsArahD[TYXtQRB].as_object();
            deserialize_struct(temp,temp_OcrBtYb[TYXtQRB]);
            }();
        }
        }();pHitShaderBindingTable=temp_OcrBtYb;}();
VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
[&](){ VkStridedDeviceAddressRegionKHR* temp_UolJmIv[&](){
            if (json["pCallableShaderBindingTable"].as_array().size()==0){
                temp_UolJmIv=NULL;
            return; }temp_UolJmIv=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_ZxEGCDr=json["pCallableShaderBindingTable"].as_array();
        for(int rzAeWYt=0; rzAeWYt < 1; rzAeWYt++){
            [&](){
            auto& temp=arr_ZxEGCDr[rzAeWYt].as_object();
            deserialize_struct(temp,temp_UolJmIv[rzAeWYt]);
            }();
        }
        }();pCallableShaderBindingTable=temp_UolJmIv;}();
VkDeviceAddress indirectDeviceAddress;
[&](){uint64_t temp_QXnaHDk;[&](){temp_QXnaHDk=static_cast<uint64_t>(value_to<int>(json["indirectDeviceAddress"]));}();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

    PFN_vkCmdTraceRaysIndirectKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdTraceRaysIndirectKHR)get_instance_proc_addr(parent,"vkCmdTraceRaysIndirectKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdTraceRaysIndirectKHR)get_device_proc_addr(parent,"vkCmdTraceRaysIndirectKHR");
    }  
    
{
call_function(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_SlnAEUX=json["pRaygenShaderBindingTable"].emplace_array();
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto& temp=arr_SlnAEUX[VKRuDIv].emplace_object();
            return serialize_struct(temp, pRaygenShaderBindingTable[VKRuDIv]);
            }();
        }
        }();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_vBQknzc=json["pMissShaderBindingTable"].emplace_array();
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto& temp=arr_vBQknzc[ZhvHpIX].emplace_object();
            return serialize_struct(temp, pMissShaderBindingTable[ZhvHpIX]);
            }();
        }
        }();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_IhHhjXk=json["pHitShaderBindingTable"].emplace_array();
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto& temp=arr_IhHhjXk[yriMdrU].emplace_object();
            return serialize_struct(temp, pHitShaderBindingTable[yriMdrU]);
            }();
        }
        }();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_EmEYSBY=json["pCallableShaderBindingTable"].emplace_array();
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto& temp=arr_EmEYSBY[TiOHiqW].emplace_object();
            return serialize_struct(temp, pCallableShaderBindingTable[TiOHiqW]);
            }();
        }
        }();
[&](){[&](){json["indirectDeviceAddress"]=indirectDeviceAddress;}();}();


        writeToConn(json);
    }

    void handle_vkCmdTraceRaysIndirect2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress indirectDeviceAddress;
[&](){uint64_t temp_QXnaHDk;[&](){temp_QXnaHDk=static_cast<uint64_t>(value_to<int>(json["indirectDeviceAddress"]));}();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

    PFN_vkCmdTraceRaysIndirect2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdTraceRaysIndirect2KHR)get_instance_proc_addr(parent,"vkCmdTraceRaysIndirect2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdTraceRaysIndirect2KHR)get_device_proc_addr(parent,"vkCmdTraceRaysIndirect2KHR");
    }  
    
{
call_function(commandBuffer, indirectDeviceAddress);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectDeviceAddress"]=indirectDeviceAddress;}();}();


        writeToConn(json);
    }

    void handle_vkGetDeviceAccelerationStructureCompatibilityKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureVersionInfoKHR* pVersionInfo;
[&](){ VkAccelerationStructureVersionInfoKHR* temp_MiRKijG[&](){
            if (json["pVersionInfo"].as_array().size()==0){
                temp_MiRKijG=NULL;
            return; }temp_MiRKijG=(VkAccelerationStructureVersionInfoKHR*)malloc(1*sizeof(VkAccelerationStructureVersionInfoKHR));
        auto& arr_aFpiHMk=json["pVersionInfo"].as_array();
        for(int hlcodPX=0; hlcodPX < 1; hlcodPX++){
            [&](){
            auto& temp=arr_aFpiHMk[hlcodPX].as_object();
            deserialize_struct(temp,temp_MiRKijG[hlcodPX]);
            }();
        }
        }();pVersionInfo=temp_MiRKijG;}();
VkAccelerationStructureCompatibilityKHR* pCompatibility;
[&](){
            if (json["pCompatibility"].as_array().size()==0){
                pCompatibility=NULL;
            return; }pCompatibility=(VkAccelerationStructureCompatibilityKHR*)malloc(1*sizeof(VkAccelerationStructureCompatibilityKHR));
        auto& arr_dBMhFMX=json["pCompatibility"].as_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){temp_guVSKHd=static_cast<int>(value_to<int>(arr_dBMhFMX[nzOFTGF]));}();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

    PFN_vkGetDeviceAccelerationStructureCompatibilityKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)get_instance_proc_addr(parent,"vkGetDeviceAccelerationStructureCompatibilityKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)get_device_proc_addr(parent,"vkGetDeviceAccelerationStructureCompatibilityKHR");
    }  
    
{
call_function(device, pVersionInfo, pCompatibility);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=boost::json::array();
            return; }
        auto& arr_wbhdpeb=json["pVersionInfo"].emplace_array();
        for(int vhWWlwM=0; vhWWlwM < 1; vhWWlwM++){
            [&](){
            auto& temp=arr_wbhdpeb[vhWWlwM].emplace_object();
            return serialize_struct(temp, pVersionInfo[vhWWlwM]);
            }();
        }
        }();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=boost::json::array();
            return; }
        auto& arr_dBMhFMX=json["pCompatibility"].emplace_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=pCompatibility[nzOFTGF];}();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetRayTracingShaderGroupStackSizeKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t group;
[&](){group=static_cast<uint32_t>(value_to<int>(json["group"]));}();
VkShaderGroupShaderKHR groupShader;
[&](){[&](){int temp_EOWKSMj;[&](){temp_EOWKSMj=static_cast<int>(value_to<int>(json["groupShader"]));}();groupShader=(VkShaderGroupShaderKHR)temp_EOWKSMj;}();}();

    PFN_vkGetRayTracingShaderGroupStackSizeKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRayTracingShaderGroupStackSizeKHR)get_instance_proc_addr(parent,"vkGetRayTracingShaderGroupStackSizeKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRayTracingShaderGroupStackSizeKHR)get_device_proc_addr(parent,"vkGetRayTracingShaderGroupStackSizeKHR");
    }  
    
{
auto result=call_function(device, pipeline, group, groupShader);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["group"]=group;}();
[&](){[&](){[&](){json["groupShader"]=groupShader;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetRayTracingPipelineStackSizeKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t pipelineStackSize;
[&](){pipelineStackSize=static_cast<uint32_t>(value_to<int>(json["pipelineStackSize"]));}();

    PFN_vkCmdSetRayTracingPipelineStackSizeKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRayTracingPipelineStackSizeKHR)get_instance_proc_addr(parent,"vkCmdSetRayTracingPipelineStackSizeKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRayTracingPipelineStackSizeKHR)get_device_proc_addr(parent,"vkCmdSetRayTracingPipelineStackSizeKHR");
    }  
    
{
call_function(commandBuffer, pipelineStackSize);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["pipelineStackSize"]=pipelineStackSize;}();


        writeToConn(json);
    }

    void handle_vkGetImageViewHandleNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageViewHandleInfoNVX* pInfo;
[&](){ VkImageViewHandleInfoNVX* temp_vxZVBSA[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_vxZVBSA=NULL;
            return; }temp_vxZVBSA=(VkImageViewHandleInfoNVX*)malloc(1*sizeof(VkImageViewHandleInfoNVX));
        auto& arr_WPyvhGm=json["pInfo"].as_array();
        for(int WwmPLiZ=0; WwmPLiZ < 1; WwmPLiZ++){
            [&](){
            auto& temp=arr_WPyvhGm[WwmPLiZ].as_object();
            deserialize_struct(temp,temp_vxZVBSA[WwmPLiZ]);
            }();
        }
        }();pInfo=temp_vxZVBSA;}();

    PFN_vkGetImageViewHandleNVX call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageViewHandleNVX)get_instance_proc_addr(parent,"vkGetImageViewHandleNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageViewHandleNVX)get_device_proc_addr(parent,"vkGetImageViewHandleNVX");
    }  
    
{
auto result=call_function(device, pInfo);
}
json.clear();
[&](){json["result"]=result;}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_mfMZJfb=json["pInfo"].emplace_array();
        for(int dQabsff=0; dQabsff < 1; dQabsff++){
            [&](){
            auto& temp=arr_mfMZJfb[dQabsff].emplace_object();
            return serialize_struct(temp, pInfo[dQabsff]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetImageViewAddressNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkImageViewAddressPropertiesNVX* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkImageViewAddressPropertiesNVX*)malloc(1*sizeof(VkImageViewAddressPropertiesNVX));
        auto& arr_hveoAIn=json["pProperties"].as_array();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto& temp=arr_hveoAIn[FiVrJfn].as_object();
            deserialize_struct(temp,pProperties[FiVrJfn]);
            }();
        }
        }();

    PFN_vkGetImageViewAddressNVX call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageViewAddressNVX)get_instance_proc_addr(parent,"vkGetImageViewAddressNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageViewAddressNVX)get_device_proc_addr(parent,"vkGetImageViewAddressNVX");
    }  
    
{
auto result=call_function(device, imageView, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_hveoAIn=json["pProperties"].emplace_array();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto& temp=arr_hveoAIn[FiVrJfn].emplace_object();
            return serialize_struct(temp, pProperties[FiVrJfn]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
uint32_t* pCounterCount;
[&](){
            if (json["pCounterCount"].as_array().size()==0){
                pCounterCount=NULL;
            return; }pCounterCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QuwxWHd=json["pCounterCount"].as_array();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){pCounterCount[HDbVSFc]=static_cast<uint32_t>(value_to<int>(arr_QuwxWHd[HDbVSFc]));}();
        }
        }();
VkPerformanceCounterKHR* pCounters;
[&](){
            if (json["pCounters"].as_array().size()==0){
                pCounters=NULL;
            return; }pCounters=(VkPerformanceCounterKHR*)malloc(*pCounterCount*sizeof(VkPerformanceCounterKHR));
        auto& arr_vEVlsJt=json["pCounters"].as_array();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto& temp=arr_vEVlsJt[WmftXku].as_object();
            deserialize_struct(temp,pCounters[WmftXku]);
            }();
        }
        }();
VkPerformanceCounterDescriptionKHR* pCounterDescriptions;
[&](){
            if (json["pCounterDescriptions"].as_array().size()==0){
                pCounterDescriptions=NULL;
            return; }pCounterDescriptions=(VkPerformanceCounterDescriptionKHR*)malloc(*pCounterCount*sizeof(VkPerformanceCounterDescriptionKHR));
        auto& arr_znRZkzO=json["pCounterDescriptions"].as_array();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto& temp=arr_znRZkzO[GjxogPx].as_object();
            deserialize_struct(temp,pCounterDescriptions[GjxogPx]);
            }();
        }
        }();

    PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)get_instance_proc_addr(parent,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)get_device_proc_addr(parent,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
    }  
    
{
auto result=call_function(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (pCounterCount==NULL){
                json["pCounterCount"]=boost::json::array();
            return; }
        auto& arr_QuwxWHd=json["pCounterCount"].emplace_array();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){arr_QuwxWHd[HDbVSFc]=pCounterCount[HDbVSFc];}();
        }
        }();
[&](){
            if (pCounters==NULL){
                json["pCounters"]=boost::json::array();
            return; }
        auto& arr_vEVlsJt=json["pCounters"].emplace_array();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto& temp=arr_vEVlsJt[WmftXku].emplace_object();
            return serialize_struct(temp, pCounters[WmftXku]);
            }();
        }
        }();
[&](){
            if (pCounterDescriptions==NULL){
                json["pCounterDescriptions"]=boost::json::array();
            return; }
        auto& arr_znRZkzO=json["pCounterDescriptions"].emplace_array();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto& temp=arr_znRZkzO[GjxogPx].emplace_object();
            return serialize_struct(temp, pCounterDescriptions[GjxogPx]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo;
[&](){ VkQueryPoolPerformanceCreateInfoKHR* temp_eziwqNT[&](){
            if (json["pPerformanceQueryCreateInfo"].as_array().size()==0){
                temp_eziwqNT=NULL;
            return; }temp_eziwqNT=(VkQueryPoolPerformanceCreateInfoKHR*)malloc(1*sizeof(VkQueryPoolPerformanceCreateInfoKHR));
        auto& arr_WMdwLVX=json["pPerformanceQueryCreateInfo"].as_array();
        for(int wpxitrA=0; wpxitrA < 1; wpxitrA++){
            [&](){
            auto& temp=arr_WMdwLVX[wpxitrA].as_object();
            deserialize_struct(temp,temp_eziwqNT[wpxitrA]);
            }();
        }
        }();pPerformanceQueryCreateInfo=temp_eziwqNT;}();
uint32_t* pNumPasses;
[&](){
            if (json["pNumPasses"].as_array().size()==0){
                pNumPasses=NULL;
            return; }pNumPasses=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QgclfwI=json["pNumPasses"].as_array();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){pNumPasses[vyixxEg]=static_cast<uint32_t>(value_to<int>(arr_QgclfwI[vyixxEg]));}();
        }
        }();

    PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
    }  
    
{
call_function(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPerformanceQueryCreateInfo==NULL){
                json["pPerformanceQueryCreateInfo"]=boost::json::array();
            return; }
        auto& arr_HfbrSJi=json["pPerformanceQueryCreateInfo"].emplace_array();
        for(int aEYwfht=0; aEYwfht < 1; aEYwfht++){
            [&](){
            auto& temp=arr_HfbrSJi[aEYwfht].emplace_object();
            return serialize_struct(temp, pPerformanceQueryCreateInfo[aEYwfht]);
            }();
        }
        }();
[&](){
            if (pNumPasses==NULL){
                json["pNumPasses"]=boost::json::array();
            return; }
        auto& arr_QgclfwI=json["pNumPasses"].emplace_array();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){arr_QgclfwI[vyixxEg]=pNumPasses[vyixxEg];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkAcquireProfilingLockKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAcquireProfilingLockInfoKHR* pInfo;
[&](){ VkAcquireProfilingLockInfoKHR* temp_DEZHpqF[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_DEZHpqF=NULL;
            return; }temp_DEZHpqF=(VkAcquireProfilingLockInfoKHR*)malloc(1*sizeof(VkAcquireProfilingLockInfoKHR));
        auto& arr_cbbacNs=json["pInfo"].as_array();
        for(int ykaKCfg=0; ykaKCfg < 1; ykaKCfg++){
            [&](){
            auto& temp=arr_cbbacNs[ykaKCfg].as_object();
            deserialize_struct(temp,temp_DEZHpqF[ykaKCfg]);
            }();
        }
        }();pInfo=temp_DEZHpqF;}();

    PFN_vkAcquireProfilingLockKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquireProfilingLockKHR)get_instance_proc_addr(parent,"vkAcquireProfilingLockKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquireProfilingLockKHR)get_device_proc_addr(parent,"vkAcquireProfilingLockKHR");
    }  
    
{
auto result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_BslWEPE=json["pInfo"].emplace_array();
        for(int ZgSmBLm=0; ZgSmBLm < 1; ZgSmBLm++){
            [&](){
            auto& temp=arr_BslWEPE[ZgSmBLm].emplace_object();
            return serialize_struct(temp, pInfo[ZgSmBLm]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkReleaseProfilingLockKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();

    PFN_vkReleaseProfilingLockKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkReleaseProfilingLockKHR)get_instance_proc_addr(parent,"vkReleaseProfilingLockKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkReleaseProfilingLockKHR)get_device_proc_addr(parent,"vkReleaseProfilingLockKHR");
    }  
    
{
call_function(device);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();


        writeToConn(json);
    }

    void handle_vkGetImageDrmFormatModifierPropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageDrmFormatModifierPropertiesEXT* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkImageDrmFormatModifierPropertiesEXT*)malloc(1*sizeof(VkImageDrmFormatModifierPropertiesEXT));
        auto& arr_oxSUmzu=json["pProperties"].as_array();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto& temp=arr_oxSUmzu[JPWNMan].as_object();
            deserialize_struct(temp,pProperties[JPWNMan]);
            }();
        }
        }();

    PFN_vkGetImageDrmFormatModifierPropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageDrmFormatModifierPropertiesEXT)get_instance_proc_addr(parent,"vkGetImageDrmFormatModifierPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageDrmFormatModifierPropertiesEXT)get_device_proc_addr(parent,"vkGetImageDrmFormatModifierPropertiesEXT");
    }  
    
{
auto result=call_function(device, image, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_oxSUmzu=json["pProperties"].emplace_array();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto& temp=arr_oxSUmzu[JPWNMan].emplace_object();
            return serialize_struct(temp, pProperties[JPWNMan]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetBufferOpaqueCaptureAddress(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBufferDeviceAddressInfo* pInfo;
[&](){ VkBufferDeviceAddressInfo* temp_tIuYeSp[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_tIuYeSp=NULL;
            return; }temp_tIuYeSp=(VkBufferDeviceAddressInfo*)malloc(1*sizeof(VkBufferDeviceAddressInfo));
        auto& arr_Dpwjlow=json["pInfo"].as_array();
        for(int htSgjqN=0; htSgjqN < 1; htSgjqN++){
            [&](){
            auto& temp=arr_Dpwjlow[htSgjqN].as_object();
            deserialize_struct(temp,temp_tIuYeSp[htSgjqN]);
            }();
        }
        }();pInfo=temp_tIuYeSp;}();

    PFN_vkGetBufferOpaqueCaptureAddress call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferOpaqueCaptureAddress)get_instance_proc_addr(parent,"vkGetBufferOpaqueCaptureAddress");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferOpaqueCaptureAddress)get_device_proc_addr(parent,"vkGetBufferOpaqueCaptureAddress");
    }  
    
{
auto result=call_function(device, pInfo);
}
json.clear();
[&](){json["result"]=result;}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_LRSftdl=json["pInfo"].emplace_array();
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto& temp=arr_LRSftdl[CPHfQOs].emplace_object();
            return serialize_struct(temp, pInfo[CPHfQOs]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetBufferDeviceAddress(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBufferDeviceAddressInfo* pInfo;
[&](){ VkBufferDeviceAddressInfo* temp_tIuYeSp[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_tIuYeSp=NULL;
            return; }temp_tIuYeSp=(VkBufferDeviceAddressInfo*)malloc(1*sizeof(VkBufferDeviceAddressInfo));
        auto& arr_Dpwjlow=json["pInfo"].as_array();
        for(int htSgjqN=0; htSgjqN < 1; htSgjqN++){
            [&](){
            auto& temp=arr_Dpwjlow[htSgjqN].as_object();
            deserialize_struct(temp,temp_tIuYeSp[htSgjqN]);
            }();
        }
        }();pInfo=temp_tIuYeSp;}();

    PFN_vkGetBufferDeviceAddress call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferDeviceAddress)get_instance_proc_addr(parent,"vkGetBufferDeviceAddress");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferDeviceAddress)get_device_proc_addr(parent,"vkGetBufferDeviceAddress");
    }  
    
{
auto result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_LRSftdl=json["pInfo"].emplace_array();
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto& temp=arr_LRSftdl[CPHfQOs].emplace_object();
            return serialize_struct(temp, pInfo[CPHfQOs]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateHeadlessSurfaceEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkHeadlessSurfaceCreateInfoEXT* pCreateInfo;
[&](){ VkHeadlessSurfaceCreateInfoEXT* temp_oSUhWss[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_oSUhWss=NULL;
            return; }temp_oSUhWss=(VkHeadlessSurfaceCreateInfoEXT*)malloc(1*sizeof(VkHeadlessSurfaceCreateInfoEXT));
        auto& arr_ZPTPwbX=json["pCreateInfo"].as_array();
        for(int zfADAts=0; zfADAts < 1; zfADAts++){
            [&](){
            auto& temp=arr_ZPTPwbX[zfADAts].as_object();
            deserialize_struct(temp,temp_oSUhWss[zfADAts]);
            }();
        }
        }();pCreateInfo=temp_oSUhWss;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].as_array().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));
        auto& arr_zGtWguc=json["pSurface"].as_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateHeadlessSurfaceEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateHeadlessSurfaceEXT)get_instance_proc_addr(parent,"vkCreateHeadlessSurfaceEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateHeadlessSurfaceEXT)get_device_proc_addr(parent,"vkCreateHeadlessSurfaceEXT");
    }  
    
{
auto result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_yHbnuDf=json["pCreateInfo"].emplace_array();
        for(int CyHXDmy=0; CyHXDmy < 1; CyHXDmy++){
            [&](){
            auto& temp=arr_yHbnuDf[CyHXDmy].emplace_object();
            return serialize_struct(temp, pCreateInfo[CyHXDmy]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }
        auto& arr_zGtWguc=json["pSurface"].emplace_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pCombinationCount;
[&](){
            if (json["pCombinationCount"].as_array().size()==0){
                pCombinationCount=NULL;
            return; }pCombinationCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_VrJxAqY=json["pCombinationCount"].as_array();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){pCombinationCount[jKkiHUO]=static_cast<uint32_t>(value_to<int>(arr_VrJxAqY[jKkiHUO]));}();
        }
        }();
VkFramebufferMixedSamplesCombinationNV* pCombinations;
[&](){
            if (json["pCombinations"].as_array().size()==0){
                pCombinations=NULL;
            return; }pCombinations=(VkFramebufferMixedSamplesCombinationNV*)malloc(*pCombinationCount*sizeof(VkFramebufferMixedSamplesCombinationNV));
        auto& arr_aOIaDFM=json["pCombinations"].as_array();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto& temp=arr_aOIaDFM[oxJqbjP].as_object();
            deserialize_struct(temp,pCombinations[oxJqbjP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
    }  
    
{
auto result=call_function(physicalDevice, pCombinationCount, pCombinations);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCombinationCount==NULL){
                json["pCombinationCount"]=boost::json::array();
            return; }
        auto& arr_VrJxAqY=json["pCombinationCount"].emplace_array();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){arr_VrJxAqY[jKkiHUO]=pCombinationCount[jKkiHUO];}();
        }
        }();
[&](){
            if (pCombinations==NULL){
                json["pCombinations"]=boost::json::array();
            return; }
        auto& arr_aOIaDFM=json["pCombinations"].emplace_array();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto& temp=arr_aOIaDFM[oxJqbjP].emplace_object();
            return serialize_struct(temp, pCombinations[oxJqbjP]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkInitializePerformanceApiINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkInitializePerformanceApiInfoINTEL* pInitializeInfo;
[&](){ VkInitializePerformanceApiInfoINTEL* temp_WjhHZMq[&](){
            if (json["pInitializeInfo"].as_array().size()==0){
                temp_WjhHZMq=NULL;
            return; }temp_WjhHZMq=(VkInitializePerformanceApiInfoINTEL*)malloc(1*sizeof(VkInitializePerformanceApiInfoINTEL));
        auto& arr_cpZIIic=json["pInitializeInfo"].as_array();
        for(int BZrUSpL=0; BZrUSpL < 1; BZrUSpL++){
            [&](){
            auto& temp=arr_cpZIIic[BZrUSpL].as_object();
            deserialize_struct(temp,temp_WjhHZMq[BZrUSpL]);
            }();
        }
        }();pInitializeInfo=temp_WjhHZMq;}();

    PFN_vkInitializePerformanceApiINTEL call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkInitializePerformanceApiINTEL)get_instance_proc_addr(parent,"vkInitializePerformanceApiINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkInitializePerformanceApiINTEL)get_device_proc_addr(parent,"vkInitializePerformanceApiINTEL");
    }  
    
{
auto result=call_function(device, pInitializeInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInitializeInfo==NULL){
                json["pInitializeInfo"]=boost::json::array();
            return; }
        auto& arr_BGIuPda=json["pInitializeInfo"].emplace_array();
        for(int pMSNyrD=0; pMSNyrD < 1; pMSNyrD++){
            [&](){
            auto& temp=arr_BGIuPda[pMSNyrD].emplace_object();
            return serialize_struct(temp, pInitializeInfo[pMSNyrD]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkUninitializePerformanceApiINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();

    PFN_vkUninitializePerformanceApiINTEL call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUninitializePerformanceApiINTEL)get_instance_proc_addr(parent,"vkUninitializePerformanceApiINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUninitializePerformanceApiINTEL)get_device_proc_addr(parent,"vkUninitializePerformanceApiINTEL");
    }  
    
{
call_function(device);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();


        writeToConn(json);
    }

    void handle_vkCmdSetPerformanceMarkerINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPerformanceMarkerInfoINTEL* pMarkerInfo;
[&](){ VkPerformanceMarkerInfoINTEL* temp_WHGTBNl[&](){
            if (json["pMarkerInfo"].as_array().size()==0){
                temp_WHGTBNl=NULL;
            return; }temp_WHGTBNl=(VkPerformanceMarkerInfoINTEL*)malloc(1*sizeof(VkPerformanceMarkerInfoINTEL));
        auto& arr_mjbTuwx=json["pMarkerInfo"].as_array();
        for(int aadJAzE=0; aadJAzE < 1; aadJAzE++){
            [&](){
            auto& temp=arr_mjbTuwx[aadJAzE].as_object();
            deserialize_struct(temp,temp_WHGTBNl[aadJAzE]);
            }();
        }
        }();pMarkerInfo=temp_WHGTBNl;}();

    PFN_vkCmdSetPerformanceMarkerINTEL call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPerformanceMarkerINTEL)get_instance_proc_addr(parent,"vkCmdSetPerformanceMarkerINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPerformanceMarkerINTEL)get_device_proc_addr(parent,"vkCmdSetPerformanceMarkerINTEL");
    }  
    
{
auto result=call_function(commandBuffer, pMarkerInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }
        auto& arr_jnuNlGq=json["pMarkerInfo"].emplace_array();
        for(int zTzAESc=0; zTzAESc < 1; zTzAESc++){
            [&](){
            auto& temp=arr_jnuNlGq[zTzAESc].emplace_object();
            return serialize_struct(temp, pMarkerInfo[zTzAESc]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetPerformanceStreamMarkerINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo;
[&](){ VkPerformanceStreamMarkerInfoINTEL* temp_EbaLtIF[&](){
            if (json["pMarkerInfo"].as_array().size()==0){
                temp_EbaLtIF=NULL;
            return; }temp_EbaLtIF=(VkPerformanceStreamMarkerInfoINTEL*)malloc(1*sizeof(VkPerformanceStreamMarkerInfoINTEL));
        auto& arr_QvDzNEm=json["pMarkerInfo"].as_array();
        for(int ylzDRXy=0; ylzDRXy < 1; ylzDRXy++){
            [&](){
            auto& temp=arr_QvDzNEm[ylzDRXy].as_object();
            deserialize_struct(temp,temp_EbaLtIF[ylzDRXy]);
            }();
        }
        }();pMarkerInfo=temp_EbaLtIF;}();

    PFN_vkCmdSetPerformanceStreamMarkerINTEL call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPerformanceStreamMarkerINTEL)get_instance_proc_addr(parent,"vkCmdSetPerformanceStreamMarkerINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPerformanceStreamMarkerINTEL)get_device_proc_addr(parent,"vkCmdSetPerformanceStreamMarkerINTEL");
    }  
    
{
auto result=call_function(commandBuffer, pMarkerInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }
        auto& arr_MVQnSpz=json["pMarkerInfo"].emplace_array();
        for(int xfSMHfo=0; xfSMHfo < 1; xfSMHfo++){
            [&](){
            auto& temp=arr_MVQnSpz[xfSMHfo].emplace_object();
            return serialize_struct(temp, pMarkerInfo[xfSMHfo]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetPerformanceOverrideINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPerformanceOverrideInfoINTEL* pOverrideInfo;
[&](){ VkPerformanceOverrideInfoINTEL* temp_faMWIHH[&](){
            if (json["pOverrideInfo"].as_array().size()==0){
                temp_faMWIHH=NULL;
            return; }temp_faMWIHH=(VkPerformanceOverrideInfoINTEL*)malloc(1*sizeof(VkPerformanceOverrideInfoINTEL));
        auto& arr_ZThQunI=json["pOverrideInfo"].as_array();
        for(int VQeLutW=0; VQeLutW < 1; VQeLutW++){
            [&](){
            auto& temp=arr_ZThQunI[VQeLutW].as_object();
            deserialize_struct(temp,temp_faMWIHH[VQeLutW]);
            }();
        }
        }();pOverrideInfo=temp_faMWIHH;}();

    PFN_vkCmdSetPerformanceOverrideINTEL call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPerformanceOverrideINTEL)get_instance_proc_addr(parent,"vkCmdSetPerformanceOverrideINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPerformanceOverrideINTEL)get_device_proc_addr(parent,"vkCmdSetPerformanceOverrideINTEL");
    }  
    
{
auto result=call_function(commandBuffer, pOverrideInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pOverrideInfo==NULL){
                json["pOverrideInfo"]=boost::json::array();
            return; }
        auto& arr_LHSFuEM=json["pOverrideInfo"].emplace_array();
        for(int KZSCUHM=0; KZSCUHM < 1; KZSCUHM++){
            [&](){
            auto& temp=arr_LHSFuEM[KZSCUHM].emplace_object();
            return serialize_struct(temp, pOverrideInfo[KZSCUHM]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkAcquirePerformanceConfigurationINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo;
[&](){ VkPerformanceConfigurationAcquireInfoINTEL* temp_LLiFsPU[&](){
            if (json["pAcquireInfo"].as_array().size()==0){
                temp_LLiFsPU=NULL;
            return; }temp_LLiFsPU=(VkPerformanceConfigurationAcquireInfoINTEL*)malloc(1*sizeof(VkPerformanceConfigurationAcquireInfoINTEL));
        auto& arr_vfPlthd=json["pAcquireInfo"].as_array();
        for(int IYVMDgx=0; IYVMDgx < 1; IYVMDgx++){
            [&](){
            auto& temp=arr_vfPlthd[IYVMDgx].as_object();
            deserialize_struct(temp,temp_LLiFsPU[IYVMDgx]);
            }();
        }
        }();pAcquireInfo=temp_LLiFsPU;}();
VkPerformanceConfigurationINTEL* pConfiguration;
[&](){
            if (json["pConfiguration"].as_array().size()==0){
                pConfiguration=NULL;
            return; }pConfiguration=(VkPerformanceConfigurationINTEL*)malloc(1*sizeof(VkPerformanceConfigurationINTEL));
        auto& arr_zSRZrDS=json["pConfiguration"].as_array();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){deserialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA], pConfiguration[MTgkTDA]);}();
        }
        }();

    PFN_vkAcquirePerformanceConfigurationINTEL call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquirePerformanceConfigurationINTEL)get_instance_proc_addr(parent,"vkAcquirePerformanceConfigurationINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquirePerformanceConfigurationINTEL)get_device_proc_addr(parent,"vkAcquirePerformanceConfigurationINTEL");
    }  
    
{
auto result=call_function(device, pAcquireInfo, pConfiguration);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=boost::json::array();
            return; }
        auto& arr_ZyqvvlF=json["pAcquireInfo"].emplace_array();
        for(int RYEcOAO=0; RYEcOAO < 1; RYEcOAO++){
            [&](){
            auto& temp=arr_ZyqvvlF[RYEcOAO].emplace_object();
            return serialize_struct(temp, pAcquireInfo[RYEcOAO]);
            }();
        }
        }();
[&](){
            if (pConfiguration==NULL){
                json["pConfiguration"]=boost::json::array();
            return; }
        auto& arr_zSRZrDS=json["pConfiguration"].emplace_array();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){serialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA],pConfiguration[MTgkTDA]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkReleasePerformanceConfigurationINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPerformanceConfigurationINTEL configuration;
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();

    PFN_vkReleasePerformanceConfigurationINTEL call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkReleasePerformanceConfigurationINTEL)get_instance_proc_addr(parent,"vkReleasePerformanceConfigurationINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkReleasePerformanceConfigurationINTEL)get_device_proc_addr(parent,"vkReleasePerformanceConfigurationINTEL");
    }  
    
{
auto result=call_function(device, configuration);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();


        writeToConn(json);
    }

    void handle_vkQueueSetPerformanceConfigurationINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
VkPerformanceConfigurationINTEL configuration;
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();

    PFN_vkQueueSetPerformanceConfigurationINTEL call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueSetPerformanceConfigurationINTEL)get_instance_proc_addr(parent,"vkQueueSetPerformanceConfigurationINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueSetPerformanceConfigurationINTEL)get_device_proc_addr(parent,"vkQueueSetPerformanceConfigurationINTEL");
    }  
    
{
auto result=call_function(queue, configuration);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();


        writeToConn(json);
    }

    void handle_vkGetPerformanceParameterINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPerformanceParameterTypeINTEL parameter;
[&](){[&](){int temp_TQususa;[&](){temp_TQususa=static_cast<int>(value_to<int>(json["parameter"]));}();parameter=(VkPerformanceParameterTypeINTEL)temp_TQususa;}();}();
VkPerformanceValueINTEL* pValue;
[&](){
            if (json["pValue"].as_array().size()==0){
                pValue=NULL;
            return; }pValue=(VkPerformanceValueINTEL*)malloc(1*sizeof(VkPerformanceValueINTEL));
        auto& arr_hOmaGpc=json["pValue"].as_array();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto& temp=arr_hOmaGpc[lyxuUNd].as_object();
            deserialize_struct(temp,pValue[lyxuUNd]);
            }();
        }
        }();

    PFN_vkGetPerformanceParameterINTEL call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPerformanceParameterINTEL)get_instance_proc_addr(parent,"vkGetPerformanceParameterINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPerformanceParameterINTEL)get_device_proc_addr(parent,"vkGetPerformanceParameterINTEL");
    }  
    
{
auto result=call_function(device, parameter, pValue);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["parameter"]=parameter;}();}();}();
[&](){
            if (pValue==NULL){
                json["pValue"]=boost::json::array();
            return; }
        auto& arr_hOmaGpc=json["pValue"].emplace_array();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto& temp=arr_hOmaGpc[lyxuUNd].emplace_object();
            return serialize_struct(temp, pValue[lyxuUNd]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceMemoryOpaqueCaptureAddress(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo;
[&](){ VkDeviceMemoryOpaqueCaptureAddressInfo* temp_RzwOpvc[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_RzwOpvc=NULL;
            return; }temp_RzwOpvc=(VkDeviceMemoryOpaqueCaptureAddressInfo*)malloc(1*sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo));
        auto& arr_AaiLWsP=json["pInfo"].as_array();
        for(int PJKtAPm=0; PJKtAPm < 1; PJKtAPm++){
            [&](){
            auto& temp=arr_AaiLWsP[PJKtAPm].as_object();
            deserialize_struct(temp,temp_RzwOpvc[PJKtAPm]);
            }();
        }
        }();pInfo=temp_RzwOpvc;}();

    PFN_vkGetDeviceMemoryOpaqueCaptureAddress call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceMemoryOpaqueCaptureAddress)get_instance_proc_addr(parent,"vkGetDeviceMemoryOpaqueCaptureAddress");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceMemoryOpaqueCaptureAddress)get_device_proc_addr(parent,"vkGetDeviceMemoryOpaqueCaptureAddress");
    }  
    
{
auto result=call_function(device, pInfo);
}
json.clear();
[&](){json["result"]=result;}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_hjweGct=json["pInfo"].emplace_array();
        for(int vcZpbuB=0; vcZpbuB < 1; vcZpbuB++){
            [&](){
            auto& temp=arr_hjweGct[vcZpbuB].emplace_object();
            return serialize_struct(temp, pInfo[vcZpbuB]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPipelineExecutablePropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineInfoKHR* pPipelineInfo;
[&](){ VkPipelineInfoKHR* temp_bCSfDoR[&](){
            if (json["pPipelineInfo"].as_array().size()==0){
                temp_bCSfDoR=NULL;
            return; }temp_bCSfDoR=(VkPipelineInfoKHR*)malloc(1*sizeof(VkPipelineInfoKHR));
        auto& arr_TqFxxbV=json["pPipelineInfo"].as_array();
        for(int yiBzToE=0; yiBzToE < 1; yiBzToE++){
            [&](){
            auto& temp=arr_TqFxxbV[yiBzToE].as_object();
            deserialize_struct(temp,temp_bCSfDoR[yiBzToE]);
            }();
        }
        }();pPipelineInfo=temp_bCSfDoR;}();
uint32_t* pExecutableCount;
[&](){
            if (json["pExecutableCount"].as_array().size()==0){
                pExecutableCount=NULL;
            return; }pExecutableCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_tlXPSPh=json["pExecutableCount"].as_array();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(value_to<int>(arr_tlXPSPh[ZFmbkCm]));}();
        }
        }();
VkPipelineExecutablePropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkPipelineExecutablePropertiesKHR*)malloc(*pExecutableCount*sizeof(VkPipelineExecutablePropertiesKHR));
        auto& arr_vtfdUfF=json["pProperties"].as_array();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto& temp=arr_vtfdUfF[uPFqrVz].as_object();
            deserialize_struct(temp,pProperties[uPFqrVz]);
            }();
        }
        }();

    PFN_vkGetPipelineExecutablePropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineExecutablePropertiesKHR)get_instance_proc_addr(parent,"vkGetPipelineExecutablePropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineExecutablePropertiesKHR)get_device_proc_addr(parent,"vkGetPipelineExecutablePropertiesKHR");
    }  
    
{
auto result=call_function(device, pPipelineInfo, pExecutableCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=boost::json::array();
            return; }
        auto& arr_SxuxUqw=json["pPipelineInfo"].emplace_array();
        for(int mwoMxRp=0; mwoMxRp < 1; mwoMxRp++){
            [&](){
            auto& temp=arr_SxuxUqw[mwoMxRp].emplace_object();
            return serialize_struct(temp, pPipelineInfo[mwoMxRp]);
            }();
        }
        }();
[&](){
            if (pExecutableCount==NULL){
                json["pExecutableCount"]=boost::json::array();
            return; }
        auto& arr_tlXPSPh=json["pExecutableCount"].emplace_array();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){arr_tlXPSPh[ZFmbkCm]=pExecutableCount[ZFmbkCm];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_vtfdUfF=json["pProperties"].emplace_array();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto& temp=arr_vtfdUfF[uPFqrVz].emplace_object();
            return serialize_struct(temp, pProperties[uPFqrVz]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPipelineExecutableStatisticsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineExecutableInfoKHR* pExecutableInfo;
[&](){ VkPipelineExecutableInfoKHR* temp_fqWWUgC[&](){
            if (json["pExecutableInfo"].as_array().size()==0){
                temp_fqWWUgC=NULL;
            return; }temp_fqWWUgC=(VkPipelineExecutableInfoKHR*)malloc(1*sizeof(VkPipelineExecutableInfoKHR));
        auto& arr_NilRUQP=json["pExecutableInfo"].as_array();
        for(int bxhNcYs=0; bxhNcYs < 1; bxhNcYs++){
            [&](){
            auto& temp=arr_NilRUQP[bxhNcYs].as_object();
            deserialize_struct(temp,temp_fqWWUgC[bxhNcYs]);
            }();
        }
        }();pExecutableInfo=temp_fqWWUgC;}();
uint32_t* pStatisticCount;
[&](){
            if (json["pStatisticCount"].as_array().size()==0){
                pStatisticCount=NULL;
            return; }pStatisticCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_BIkbvee=json["pStatisticCount"].as_array();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){pStatisticCount[MiieuSo]=static_cast<uint32_t>(value_to<int>(arr_BIkbvee[MiieuSo]));}();
        }
        }();
VkPipelineExecutableStatisticKHR* pStatistics;
[&](){
            if (json["pStatistics"].as_array().size()==0){
                pStatistics=NULL;
            return; }pStatistics=(VkPipelineExecutableStatisticKHR*)malloc(*pStatisticCount*sizeof(VkPipelineExecutableStatisticKHR));
        auto& arr_cGybyJf=json["pStatistics"].as_array();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto& temp=arr_cGybyJf[ktSOZGx].as_object();
            deserialize_struct(temp,pStatistics[ktSOZGx]);
            }();
        }
        }();

    PFN_vkGetPipelineExecutableStatisticsKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineExecutableStatisticsKHR)get_instance_proc_addr(parent,"vkGetPipelineExecutableStatisticsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineExecutableStatisticsKHR)get_device_proc_addr(parent,"vkGetPipelineExecutableStatisticsKHR");
    }  
    
{
auto result=call_function(device, pExecutableInfo, pStatisticCount, pStatistics);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=boost::json::array();
            return; }
        auto& arr_xbHlsCc=json["pExecutableInfo"].emplace_array();
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto& temp=arr_xbHlsCc[JTDfcCv].emplace_object();
            return serialize_struct(temp, pExecutableInfo[JTDfcCv]);
            }();
        }
        }();
[&](){
            if (pStatisticCount==NULL){
                json["pStatisticCount"]=boost::json::array();
            return; }
        auto& arr_BIkbvee=json["pStatisticCount"].emplace_array();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){arr_BIkbvee[MiieuSo]=pStatisticCount[MiieuSo];}();
        }
        }();
[&](){
            if (pStatistics==NULL){
                json["pStatistics"]=boost::json::array();
            return; }
        auto& arr_cGybyJf=json["pStatistics"].emplace_array();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto& temp=arr_cGybyJf[ktSOZGx].emplace_object();
            return serialize_struct(temp, pStatistics[ktSOZGx]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPipelineExecutableInternalRepresentationsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineExecutableInfoKHR* pExecutableInfo;
[&](){ VkPipelineExecutableInfoKHR* temp_fqWWUgC[&](){
            if (json["pExecutableInfo"].as_array().size()==0){
                temp_fqWWUgC=NULL;
            return; }temp_fqWWUgC=(VkPipelineExecutableInfoKHR*)malloc(1*sizeof(VkPipelineExecutableInfoKHR));
        auto& arr_NilRUQP=json["pExecutableInfo"].as_array();
        for(int bxhNcYs=0; bxhNcYs < 1; bxhNcYs++){
            [&](){
            auto& temp=arr_NilRUQP[bxhNcYs].as_object();
            deserialize_struct(temp,temp_fqWWUgC[bxhNcYs]);
            }();
        }
        }();pExecutableInfo=temp_fqWWUgC;}();
uint32_t* pInternalRepresentationCount;
[&](){
            if (json["pInternalRepresentationCount"].as_array().size()==0){
                pInternalRepresentationCount=NULL;
            return; }pInternalRepresentationCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_bVgggzH=json["pInternalRepresentationCount"].as_array();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(value_to<int>(arr_bVgggzH[urjNjhc]));}();
        }
        }();
VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations;
[&](){
            if (json["pInternalRepresentations"].as_array().size()==0){
                pInternalRepresentations=NULL;
            return; }pInternalRepresentations=(VkPipelineExecutableInternalRepresentationKHR*)malloc(*pInternalRepresentationCount*sizeof(VkPipelineExecutableInternalRepresentationKHR));
        auto& arr_yqajgdo=json["pInternalRepresentations"].as_array();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto& temp=arr_yqajgdo[OdpgULc].as_object();
            deserialize_struct(temp,pInternalRepresentations[OdpgULc]);
            }();
        }
        }();

    PFN_vkGetPipelineExecutableInternalRepresentationsKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineExecutableInternalRepresentationsKHR)get_instance_proc_addr(parent,"vkGetPipelineExecutableInternalRepresentationsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineExecutableInternalRepresentationsKHR)get_device_proc_addr(parent,"vkGetPipelineExecutableInternalRepresentationsKHR");
    }  
    
{
auto result=call_function(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=boost::json::array();
            return; }
        auto& arr_xbHlsCc=json["pExecutableInfo"].emplace_array();
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto& temp=arr_xbHlsCc[JTDfcCv].emplace_object();
            return serialize_struct(temp, pExecutableInfo[JTDfcCv]);
            }();
        }
        }();
[&](){
            if (pInternalRepresentationCount==NULL){
                json["pInternalRepresentationCount"]=boost::json::array();
            return; }
        auto& arr_bVgggzH=json["pInternalRepresentationCount"].emplace_array();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){arr_bVgggzH[urjNjhc]=pInternalRepresentationCount[urjNjhc];}();
        }
        }();
[&](){
            if (pInternalRepresentations==NULL){
                json["pInternalRepresentations"]=boost::json::array();
            return; }
        auto& arr_yqajgdo=json["pInternalRepresentations"].emplace_array();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto& temp=arr_yqajgdo[OdpgULc].emplace_object();
            return serialize_struct(temp, pInternalRepresentations[OdpgULc]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetLineStippleEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t lineStippleFactor;
[&](){lineStippleFactor=static_cast<uint32_t>(value_to<int>(json["lineStippleFactor"]));}();
uint16_t lineStipplePattern;
[&](){lineStipplePattern=static_cast<uint16_t>(value_to<int>(json["lineStipplePattern"]));}();

    PFN_vkCmdSetLineStippleEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLineStippleEXT)get_instance_proc_addr(parent,"vkCmdSetLineStippleEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLineStippleEXT)get_device_proc_addr(parent,"vkCmdSetLineStippleEXT");
    }  
    
{
call_function(commandBuffer, lineStippleFactor, lineStipplePattern);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineStippleFactor"]=lineStippleFactor;}();
[&](){json["lineStipplePattern"]=lineStipplePattern;}();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceToolProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pToolCount;
[&](){
            if (json["pToolCount"].as_array().size()==0){
                pToolCount=NULL;
            return; }pToolCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_PNAKwfC=json["pToolCount"].as_array();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){pToolCount[iRGIIgT]=static_cast<uint32_t>(value_to<int>(arr_PNAKwfC[iRGIIgT]));}();
        }
        }();
VkPhysicalDeviceToolProperties* pToolProperties;
[&](){
            if (json["pToolProperties"].as_array().size()==0){
                pToolProperties=NULL;
            return; }pToolProperties=(VkPhysicalDeviceToolProperties*)malloc(*pToolCount*sizeof(VkPhysicalDeviceToolProperties));
        auto& arr_OYowiCQ=json["pToolProperties"].as_array();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto& temp=arr_OYowiCQ[dlPXJcQ].as_object();
            deserialize_struct(temp,pToolProperties[dlPXJcQ]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceToolProperties call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceToolProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceToolProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceToolProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceToolProperties");
    }  
    
{
auto result=call_function(physicalDevice, pToolCount, pToolProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pToolCount==NULL){
                json["pToolCount"]=boost::json::array();
            return; }
        auto& arr_PNAKwfC=json["pToolCount"].emplace_array();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){arr_PNAKwfC[iRGIIgT]=pToolCount[iRGIIgT];}();
        }
        }();
[&](){
            if (pToolProperties==NULL){
                json["pToolProperties"]=boost::json::array();
            return; }
        auto& arr_OYowiCQ=json["pToolProperties"].emplace_array();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto& temp=arr_OYowiCQ[dlPXJcQ].emplace_object();
            return serialize_struct(temp, pToolProperties[dlPXJcQ]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureCreateInfoKHR* pCreateInfo;
[&](){ VkAccelerationStructureCreateInfoKHR* temp_ByTTUcg[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_ByTTUcg=NULL;
            return; }temp_ByTTUcg=(VkAccelerationStructureCreateInfoKHR*)malloc(1*sizeof(VkAccelerationStructureCreateInfoKHR));
        auto& arr_rLnSCOE=json["pCreateInfo"].as_array();
        for(int tKisKdf=0; tKisKdf < 1; tKisKdf++){
            [&](){
            auto& temp=arr_rLnSCOE[tKisKdf].as_object();
            deserialize_struct(temp,temp_ByTTUcg[tKisKdf]);
            }();
        }
        }();pCreateInfo=temp_ByTTUcg;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkAccelerationStructureKHR* pAccelerationStructure;
[&](){
            if (json["pAccelerationStructure"].as_array().size()==0){
                pAccelerationStructure=NULL;
            return; }pAccelerationStructure=(VkAccelerationStructureKHR*)malloc(1*sizeof(VkAccelerationStructureKHR));
        auto& arr_vKbZGTA=json["pAccelerationStructure"].as_array();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb], pAccelerationStructure[YRzkUOb]);}();
        }
        }();

    PFN_vkCreateAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCreateAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateAccelerationStructureKHR)get_device_proc_addr(parent,"vkCreateAccelerationStructureKHR");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_XoURuCS=json["pCreateInfo"].emplace_array();
        for(int bGUDBRC=0; bGUDBRC < 1; bGUDBRC++){
            [&](){
            auto& temp=arr_XoURuCS[bGUDBRC].emplace_object();
            return serialize_struct(temp, pCreateInfo[bGUDBRC]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=boost::json::array();
            return; }
        auto& arr_vKbZGTA=json["pAccelerationStructure"].emplace_array();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){serialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb],pAccelerationStructure[YRzkUOb]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBuildAccelerationStructuresKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t infoCount;
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();
VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
[&](){ VkAccelerationStructureBuildGeometryInfoKHR* temp_driNJAJ[&](){
            if (json["pInfos"].as_array().size()==0){
                temp_driNJAJ=NULL;
            return; }temp_driNJAJ=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
        auto& arr_pLxHocT=json["pInfos"].as_array();
        for(int iIAEWFy=0; iIAEWFy < infoCount; iIAEWFy++){
            [&](){
            auto& temp=arr_pLxHocT[iIAEWFy].as_object();
            deserialize_struct(temp,temp_driNJAJ[iIAEWFy]);
            }();
        }
        }();pInfos=temp_driNJAJ;}();
VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos;
[&](){ VkAccelerationStructureBuildRangeInfoKHR* * temp_XqDyztq[&](){
            if (json["ppBuildRangeInfos"].as_array().size()==0){
                temp_XqDyztq=NULL;
            return; }temp_XqDyztq=(VkAccelerationStructureBuildRangeInfoKHR**)malloc(1*sizeof(VkAccelerationStructureBuildRangeInfoKHR*));
        auto& arr_LOFGJKx=json["ppBuildRangeInfos"].as_array();
        for(int gLEYTdh=0; gLEYTdh < 1; gLEYTdh++){
            [&](){
            if (arr_LOFGJKx[gLEYTdh].as_array().size()==0){
                temp_XqDyztq[gLEYTdh]=NULL;
            return; }temp_XqDyztq[gLEYTdh]=(VkAccelerationStructureBuildRangeInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildRangeInfoKHR));
        auto& arr_HqQzokg=arr_LOFGJKx[gLEYTdh].as_array();
        for(int TwVqYHk=0; TwVqYHk < infoCount; TwVqYHk++){
            [&](){
            auto& temp=arr_HqQzokg[TwVqYHk].as_object();
            deserialize_struct(temp,temp_XqDyztq[gLEYTdh][TwVqYHk]);
            }();
        }
        }();
        }
        }();ppBuildRangeInfos=temp_XqDyztq;}();

    PFN_vkCmdBuildAccelerationStructuresKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBuildAccelerationStructuresKHR)get_instance_proc_addr(parent,"vkCmdBuildAccelerationStructuresKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBuildAccelerationStructuresKHR)get_device_proc_addr(parent,"vkCmdBuildAccelerationStructuresKHR");
    }  
    
{
call_function(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_lswJvjt=json["pInfos"].emplace_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=boost::json::array();
            return; }
        auto& arr_FMxYLmq=json["ppBuildRangeInfos"].emplace_array();
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=boost::json::array();
            return; }
        auto& arr_PKxEvVS=arr_FMxYLmq[CRaOjpb].emplace_array();
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto& temp=arr_PKxEvVS[IUJrDJF].emplace_object();
            return serialize_struct(temp, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            }();
        }
        }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBuildAccelerationStructuresIndirectKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t infoCount;
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();
VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
[&](){ VkAccelerationStructureBuildGeometryInfoKHR* temp_driNJAJ[&](){
            if (json["pInfos"].as_array().size()==0){
                temp_driNJAJ=NULL;
            return; }temp_driNJAJ=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
        auto& arr_pLxHocT=json["pInfos"].as_array();
        for(int iIAEWFy=0; iIAEWFy < infoCount; iIAEWFy++){
            [&](){
            auto& temp=arr_pLxHocT[iIAEWFy].as_object();
            deserialize_struct(temp,temp_driNJAJ[iIAEWFy]);
            }();
        }
        }();pInfos=temp_driNJAJ;}();
VkDeviceAddress* pIndirectDeviceAddresses;
[&](){ VkDeviceAddress* temp_BGrggsP[&](){
            if (json["pIndirectDeviceAddresses"].as_array().size()==0){
                temp_BGrggsP=NULL;
            return; }temp_BGrggsP=(VkDeviceAddress*)malloc(infoCount*sizeof(VkDeviceAddress));
        auto& arr_qqxgmPw=json["pIndirectDeviceAddresses"].as_array();
        for(int mphFFLu=0; mphFFLu < infoCount; mphFFLu++){
            [&](){uint64_t temp_qqxgmPw;[&](){temp_qqxgmPw=static_cast<uint64_t>(value_to<int>(arr_qqxgmPw[mphFFLu]));}();temp_BGrggsP[mphFFLu]=(VkDeviceAddress)temp_qqxgmPw;}();
        }
        }();pIndirectDeviceAddresses=temp_BGrggsP;}();
uint32_t* pIndirectStrides;
[&](){ uint32_t* temp_ZsInipe[&](){
            if (json["pIndirectStrides"].as_array().size()==0){
                temp_ZsInipe=NULL;
            return; }temp_ZsInipe=(uint32_t*)malloc(infoCount*sizeof(uint32_t));
        auto& arr_JoqNqic=json["pIndirectStrides"].as_array();
        for(int TCKTxsQ=0; TCKTxsQ < infoCount; TCKTxsQ++){
            [&](){temp_ZsInipe[TCKTxsQ]=static_cast<uint32_t>(value_to<int>(arr_JoqNqic[TCKTxsQ]));}();
        }
        }();pIndirectStrides=temp_ZsInipe;}();
uint32_t* const* ppMaxPrimitiveCounts;
[&](){ uint32_t* * temp_MQrjcVS[&](){
            if (json["ppMaxPrimitiveCounts"].as_array().size()==0){
                temp_MQrjcVS=NULL;
            return; }temp_MQrjcVS=(uint32_t**)malloc(1*sizeof(uint32_t*));
        auto& arr_lnbIzaN=json["ppMaxPrimitiveCounts"].as_array();
        for(int DtQfWPT=0; DtQfWPT < 1; DtQfWPT++){
            [&](){
            if (arr_lnbIzaN[DtQfWPT].as_array().size()==0){
                temp_MQrjcVS[DtQfWPT]=NULL;
            return; }temp_MQrjcVS[DtQfWPT]=(uint32_t*)malloc(infoCount*sizeof(uint32_t));
        auto& arr_RluStPH=arr_lnbIzaN[DtQfWPT].as_array();
        for(int SaLgIYu=0; SaLgIYu < infoCount; SaLgIYu++){
            [&](){temp_MQrjcVS[DtQfWPT][SaLgIYu]=static_cast<uint32_t>(value_to<int>(arr_RluStPH[SaLgIYu]));}();
        }
        }();
        }
        }();ppMaxPrimitiveCounts=temp_MQrjcVS;}();

    PFN_vkCmdBuildAccelerationStructuresIndirectKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBuildAccelerationStructuresIndirectKHR)get_instance_proc_addr(parent,"vkCmdBuildAccelerationStructuresIndirectKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBuildAccelerationStructuresIndirectKHR)get_device_proc_addr(parent,"vkCmdBuildAccelerationStructuresIndirectKHR");
    }  
    
{
call_function(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_lswJvjt=json["pInfos"].emplace_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (pIndirectDeviceAddresses==NULL){
                json["pIndirectDeviceAddresses"]=boost::json::array();
            return; }
        auto& arr_YkBEqzj=json["pIndirectDeviceAddresses"].emplace_array();
        for(int tMAuxlx=0; tMAuxlx < infoCount; tMAuxlx++){
            [&](){[&](){arr_YkBEqzj[tMAuxlx]=pIndirectDeviceAddresses[tMAuxlx];}();}();
        }
        }();
[&](){
            if (pIndirectStrides==NULL){
                json["pIndirectStrides"]=boost::json::array();
            return; }
        auto& arr_Helprzq=json["pIndirectStrides"].emplace_array();
        for(int IXUUYlr=0; IXUUYlr < infoCount; IXUUYlr++){
            [&](){arr_Helprzq[IXUUYlr]=pIndirectStrides[IXUUYlr];}();
        }
        }();
[&](){
            if (ppMaxPrimitiveCounts==NULL){
                json["ppMaxPrimitiveCounts"]=boost::json::array();
            return; }
        auto& arr_DfsqJWs=json["ppMaxPrimitiveCounts"].emplace_array();
        for(int TyNkaSn=0; TyNkaSn < 1; TyNkaSn++){
            [&](){
            if (ppMaxPrimitiveCounts[TyNkaSn]==NULL){
                arr_DfsqJWs[TyNkaSn]=boost::json::array();
            return; }
        auto& arr_kfQrDXL=arr_DfsqJWs[TyNkaSn].emplace_array();
        for(int SABezVP=0; SABezVP < infoCount; SABezVP++){
            [&](){arr_kfQrDXL[SABezVP]=ppMaxPrimitiveCounts[TyNkaSn][SABezVP];}();
        }
        }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBuildAccelerationStructuresKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
uint32_t infoCount;
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();
VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
[&](){ VkAccelerationStructureBuildGeometryInfoKHR* temp_driNJAJ[&](){
            if (json["pInfos"].as_array().size()==0){
                temp_driNJAJ=NULL;
            return; }temp_driNJAJ=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
        auto& arr_pLxHocT=json["pInfos"].as_array();
        for(int iIAEWFy=0; iIAEWFy < infoCount; iIAEWFy++){
            [&](){
            auto& temp=arr_pLxHocT[iIAEWFy].as_object();
            deserialize_struct(temp,temp_driNJAJ[iIAEWFy]);
            }();
        }
        }();pInfos=temp_driNJAJ;}();
VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos;
[&](){ VkAccelerationStructureBuildRangeInfoKHR* * temp_XqDyztq[&](){
            if (json["ppBuildRangeInfos"].as_array().size()==0){
                temp_XqDyztq=NULL;
            return; }temp_XqDyztq=(VkAccelerationStructureBuildRangeInfoKHR**)malloc(1*sizeof(VkAccelerationStructureBuildRangeInfoKHR*));
        auto& arr_LOFGJKx=json["ppBuildRangeInfos"].as_array();
        for(int gLEYTdh=0; gLEYTdh < 1; gLEYTdh++){
            [&](){
            if (arr_LOFGJKx[gLEYTdh].as_array().size()==0){
                temp_XqDyztq[gLEYTdh]=NULL;
            return; }temp_XqDyztq[gLEYTdh]=(VkAccelerationStructureBuildRangeInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildRangeInfoKHR));
        auto& arr_HqQzokg=arr_LOFGJKx[gLEYTdh].as_array();
        for(int TwVqYHk=0; TwVqYHk < infoCount; TwVqYHk++){
            [&](){
            auto& temp=arr_HqQzokg[TwVqYHk].as_object();
            deserialize_struct(temp,temp_XqDyztq[gLEYTdh][TwVqYHk]);
            }();
        }
        }();
        }
        }();ppBuildRangeInfos=temp_XqDyztq;}();

    PFN_vkBuildAccelerationStructuresKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBuildAccelerationStructuresKHR)get_instance_proc_addr(parent,"vkBuildAccelerationStructuresKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBuildAccelerationStructuresKHR)get_device_proc_addr(parent,"vkBuildAccelerationStructuresKHR");
    }  
    
{
auto result=call_function(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_lswJvjt=json["pInfos"].emplace_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=boost::json::array();
            return; }
        auto& arr_FMxYLmq=json["ppBuildRangeInfos"].emplace_array();
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=boost::json::array();
            return; }
        auto& arr_PKxEvVS=arr_FMxYLmq[CRaOjpb].emplace_array();
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto& temp=arr_PKxEvVS[IUJrDJF].emplace_object();
            return serialize_struct(temp, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            }();
        }
        }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureDeviceAddressKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureDeviceAddressInfoKHR* pInfo;
[&](){ VkAccelerationStructureDeviceAddressInfoKHR* temp_ijpoyhG[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_ijpoyhG=NULL;
            return; }temp_ijpoyhG=(VkAccelerationStructureDeviceAddressInfoKHR*)malloc(1*sizeof(VkAccelerationStructureDeviceAddressInfoKHR));
        auto& arr_hewpWGr=json["pInfo"].as_array();
        for(int XQgcVWG=0; XQgcVWG < 1; XQgcVWG++){
            [&](){
            auto& temp=arr_hewpWGr[XQgcVWG].as_object();
            deserialize_struct(temp,temp_ijpoyhG[XQgcVWG]);
            }();
        }
        }();pInfo=temp_ijpoyhG;}();

    PFN_vkGetAccelerationStructureDeviceAddressKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureDeviceAddressKHR)get_instance_proc_addr(parent,"vkGetAccelerationStructureDeviceAddressKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureDeviceAddressKHR)get_device_proc_addr(parent,"vkGetAccelerationStructureDeviceAddressKHR");
    }  
    
{
auto result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_CAfLmMn=json["pInfo"].emplace_array();
        for(int DozYfEa=0; DozYfEa < 1; DozYfEa++){
            [&](){
            auto& temp=arr_CAfLmMn[DozYfEa].emplace_object();
            return serialize_struct(temp, pInfo[DozYfEa]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateDeferredOperationKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkDeferredOperationKHR* pDeferredOperation;
[&](){
            if (json["pDeferredOperation"].as_array().size()==0){
                pDeferredOperation=NULL;
            return; }pDeferredOperation=(VkDeferredOperationKHR*)malloc(1*sizeof(VkDeferredOperationKHR));
        auto& arr_fPVilHH=json["pDeferredOperation"].as_array();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){deserialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX], pDeferredOperation[BrrtHdX]);}();
        }
        }();

    PFN_vkCreateDeferredOperationKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDeferredOperationKHR)get_instance_proc_addr(parent,"vkCreateDeferredOperationKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDeferredOperationKHR)get_device_proc_addr(parent,"vkCreateDeferredOperationKHR");
    }  
    
{
auto result=call_function(device, pAllocator, pDeferredOperation);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDeferredOperation==NULL){
                json["pDeferredOperation"]=boost::json::array();
            return; }
        auto& arr_fPVilHH=json["pDeferredOperation"].emplace_array();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){serialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX],pDeferredOperation[BrrtHdX]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyDeferredOperationKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyDeferredOperationKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDeferredOperationKHR)get_instance_proc_addr(parent,"vkDestroyDeferredOperationKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDeferredOperationKHR)get_device_proc_addr(parent,"vkDestroyDeferredOperationKHR");
    }  
    
{
call_function(device, operation, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeferredOperationMaxConcurrencyKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();

    PFN_vkGetDeferredOperationMaxConcurrencyKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeferredOperationMaxConcurrencyKHR)get_instance_proc_addr(parent,"vkGetDeferredOperationMaxConcurrencyKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeferredOperationMaxConcurrencyKHR)get_device_proc_addr(parent,"vkGetDeferredOperationMaxConcurrencyKHR");
    }  
    
{
auto result=call_function(device, operation);
}
json.clear();
[&](){json["result"]=result;}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();


        writeToConn(json);
    }

    void handle_vkGetDeferredOperationResultKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();

    PFN_vkGetDeferredOperationResultKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeferredOperationResultKHR)get_instance_proc_addr(parent,"vkGetDeferredOperationResultKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeferredOperationResultKHR)get_device_proc_addr(parent,"vkGetDeferredOperationResultKHR");
    }  
    
{
auto result=call_function(device, operation);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();


        writeToConn(json);
    }

    void handle_vkDeferredOperationJoinKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();

    PFN_vkDeferredOperationJoinKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDeferredOperationJoinKHR)get_instance_proc_addr(parent,"vkDeferredOperationJoinKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDeferredOperationJoinKHR)get_device_proc_addr(parent,"vkDeferredOperationJoinKHR");
    }  
    
{
auto result=call_function(device, operation);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();


        writeToConn(json);
    }

    void handle_vkGetPipelineIndirectMemoryRequirementsNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkComputePipelineCreateInfo* pCreateInfo;
[&](){ VkComputePipelineCreateInfo* temp_mNFivMr[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_mNFivMr=NULL;
            return; }temp_mNFivMr=(VkComputePipelineCreateInfo*)malloc(1*sizeof(VkComputePipelineCreateInfo));
        auto& arr_IIYnuXe=json["pCreateInfo"].as_array();
        for(int LOABkrY=0; LOABkrY < 1; LOABkrY++){
            [&](){
            auto& temp=arr_IIYnuXe[LOABkrY].as_object();
            deserialize_struct(temp,temp_mNFivMr[LOABkrY]);
            }();
        }
        }();pCreateInfo=temp_mNFivMr;}();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetPipelineIndirectMemoryRequirementsNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineIndirectMemoryRequirementsNV)get_instance_proc_addr(parent,"vkGetPipelineIndirectMemoryRequirementsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineIndirectMemoryRequirementsNV)get_device_proc_addr(parent,"vkGetPipelineIndirectMemoryRequirementsNV");
    }  
    
{
call_function(device, pCreateInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_XLStDVY=json["pCreateInfo"].emplace_array();
        for(int FoBxBjF=0; FoBxBjF < 1; FoBxBjF++){
            [&](){
            auto& temp=arr_XLStDVY[FoBxBjF].emplace_object();
            return serialize_struct(temp, pCreateInfo[FoBxBjF]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPipelineIndirectDeviceAddressNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineIndirectDeviceAddressInfoNV* pInfo;
[&](){ VkPipelineIndirectDeviceAddressInfoNV* temp_CAWPabX[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_CAWPabX=NULL;
            return; }temp_CAWPabX=(VkPipelineIndirectDeviceAddressInfoNV*)malloc(1*sizeof(VkPipelineIndirectDeviceAddressInfoNV));
        auto& arr_nyTOzHx=json["pInfo"].as_array();
        for(int fovHdtg=0; fovHdtg < 1; fovHdtg++){
            [&](){
            auto& temp=arr_nyTOzHx[fovHdtg].as_object();
            deserialize_struct(temp,temp_CAWPabX[fovHdtg]);
            }();
        }
        }();pInfo=temp_CAWPabX;}();

    PFN_vkGetPipelineIndirectDeviceAddressNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineIndirectDeviceAddressNV)get_instance_proc_addr(parent,"vkGetPipelineIndirectDeviceAddressNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineIndirectDeviceAddressNV)get_device_proc_addr(parent,"vkGetPipelineIndirectDeviceAddressNV");
    }  
    
{
auto result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_iNXSdlN=json["pInfo"].emplace_array();
        for(int EeNdDDD=0; EeNdDDD < 1; EeNdDDD++){
            [&](){
            auto& temp=arr_iNXSdlN[EeNdDDD].emplace_object();
            return serialize_struct(temp, pInfo[EeNdDDD]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetCullMode(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCullModeFlags cullMode;
[&](){[&](){int temp_JocwJIC;[&](){temp_JocwJIC=static_cast<int>(value_to<int>(json["cullMode"]));}();cullMode=(VkCullModeFlags)temp_JocwJIC;}();}();

    PFN_vkCmdSetCullMode call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCullMode)get_instance_proc_addr(parent,"vkCmdSetCullMode");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCullMode)get_device_proc_addr(parent,"vkCmdSetCullMode");
    }  
    
{
call_function(commandBuffer, cullMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["cullMode"]=cullMode;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetFrontFace(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkFrontFace frontFace;
[&](){[&](){int temp_ZBubEzp;[&](){temp_ZBubEzp=static_cast<int>(value_to<int>(json["frontFace"]));}();frontFace=(VkFrontFace)temp_ZBubEzp;}();}();

    PFN_vkCmdSetFrontFace call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetFrontFace)get_instance_proc_addr(parent,"vkCmdSetFrontFace");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetFrontFace)get_device_proc_addr(parent,"vkCmdSetFrontFace");
    }  
    
{
call_function(commandBuffer, frontFace);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["frontFace"]=frontFace;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetPrimitiveTopology(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPrimitiveTopology primitiveTopology;
[&](){[&](){int temp_jzAnfAA;[&](){temp_jzAnfAA=static_cast<int>(value_to<int>(json["primitiveTopology"]));}();primitiveTopology=(VkPrimitiveTopology)temp_jzAnfAA;}();}();

    PFN_vkCmdSetPrimitiveTopology call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPrimitiveTopology)get_instance_proc_addr(parent,"vkCmdSetPrimitiveTopology");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPrimitiveTopology)get_device_proc_addr(parent,"vkCmdSetPrimitiveTopology");
    }  
    
{
call_function(commandBuffer, primitiveTopology);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["primitiveTopology"]=primitiveTopology;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetViewportWithCount(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t viewportCount;
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();
VkViewport* pViewports;
[&](){ VkViewport* temp_NINOLjT[&](){
            if (json["pViewports"].as_array().size()==0){
                temp_NINOLjT=NULL;
            return; }temp_NINOLjT=(VkViewport*)malloc(viewportCount*sizeof(VkViewport));
        auto& arr_NYoDqxX=json["pViewports"].as_array();
        for(int SjlAQpy=0; SjlAQpy < viewportCount; SjlAQpy++){
            [&](){
            auto& temp=arr_NYoDqxX[SjlAQpy].as_object();
            deserialize_struct(temp,temp_NINOLjT[SjlAQpy]);
            }();
        }
        }();pViewports=temp_NINOLjT;}();

    PFN_vkCmdSetViewportWithCount call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportWithCount)get_instance_proc_addr(parent,"vkCmdSetViewportWithCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportWithCount)get_device_proc_addr(parent,"vkCmdSetViewportWithCount");
    }  
    
{
call_function(commandBuffer, viewportCount, pViewports);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=boost::json::array();
            return; }
        auto& arr_SyYryUE=json["pViewports"].emplace_array();
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto& temp=arr_SyYryUE[HAuJlzw].emplace_object();
            return serialize_struct(temp, pViewports[HAuJlzw]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetScissorWithCount(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t scissorCount;
[&](){scissorCount=static_cast<uint32_t>(value_to<int>(json["scissorCount"]));}();
VkRect2D* pScissors;
[&](){ VkRect2D* temp_FCRcmyF[&](){
            if (json["pScissors"].as_array().size()==0){
                temp_FCRcmyF=NULL;
            return; }temp_FCRcmyF=(VkRect2D*)malloc(scissorCount*sizeof(VkRect2D));
        auto& arr_bIRAuhj=json["pScissors"].as_array();
        for(int QukNmCZ=0; QukNmCZ < scissorCount; QukNmCZ++){
            [&](){
            auto& temp=arr_bIRAuhj[QukNmCZ].as_object();
            deserialize_struct(temp,temp_FCRcmyF[QukNmCZ]);
            }();
        }
        }();pScissors=temp_FCRcmyF;}();

    PFN_vkCmdSetScissorWithCount call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetScissorWithCount)get_instance_proc_addr(parent,"vkCmdSetScissorWithCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetScissorWithCount)get_device_proc_addr(parent,"vkCmdSetScissorWithCount");
    }  
    
{
call_function(commandBuffer, scissorCount, pScissors);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["scissorCount"]=scissorCount;}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=boost::json::array();
            return; }
        auto& arr_RpUaBcS=json["pScissors"].emplace_array();
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto& temp=arr_RpUaBcS[XBYGvVT].emplace_object();
            return serialize_struct(temp, pScissors[XBYGvVT]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBindIndexBuffer2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
VkDeviceSize size;
[&](){uint64_t temp_PlNcOBd;[&](){temp_PlNcOBd=static_cast<uint64_t>(value_to<int>(json["size"]));}();size=(VkDeviceSize)temp_PlNcOBd;}();
VkIndexType indexType;
[&](){[&](){int temp_GdrXdVh;[&](){temp_GdrXdVh=static_cast<int>(value_to<int>(json["indexType"]));}();indexType=(VkIndexType)temp_GdrXdVh;}();}();

    PFN_vkCmdBindIndexBuffer2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindIndexBuffer2KHR)get_instance_proc_addr(parent,"vkCmdBindIndexBuffer2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindIndexBuffer2KHR)get_device_proc_addr(parent,"vkCmdBindIndexBuffer2KHR");
    }  
    
{
call_function(commandBuffer, buffer, offset, size, indexType);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){[&](){[&](){json["indexType"]=indexType;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdBindVertexBuffers2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstBinding;
[&](){firstBinding=static_cast<uint32_t>(value_to<int>(json["firstBinding"]));}();
uint32_t bindingCount;
[&](){bindingCount=static_cast<uint32_t>(value_to<int>(json["bindingCount"]));}();
VkBuffer* pBuffers;
[&](){ VkBuffer* temp_XooJXwK[&](){
            if (json["pBuffers"].as_array().size()==0){
                temp_XooJXwK=NULL;
            return; }temp_XooJXwK=(VkBuffer*)malloc(bindingCount*sizeof(VkBuffer));
        auto& arr_ShVTBbp=json["pBuffers"].as_array();
        for(int loSrvWd=0; loSrvWd < bindingCount; loSrvWd++){
            [&](){deserialize_VkBuffer(arr_ShVTBbp[loSrvWd], temp_XooJXwK[loSrvWd]);}();
        }
        }();pBuffers=temp_XooJXwK;}();
VkDeviceSize* pOffsets;
[&](){ VkDeviceSize* temp_rsVsAoT[&](){
            if (json["pOffsets"].as_array().size()==0){
                temp_rsVsAoT=NULL;
            return; }temp_rsVsAoT=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_uWdiGtF=json["pOffsets"].as_array();
        for(int ELYQTNF=0; ELYQTNF < bindingCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){temp_uWdiGtF=static_cast<uint64_t>(value_to<int>(arr_uWdiGtF[ELYQTNF]));}();temp_rsVsAoT[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();pOffsets=temp_rsVsAoT;}();
VkDeviceSize* pSizes;
[&](){ VkDeviceSize* temp_VbqhwxK[&](){
            if (json["pSizes"].as_array().size()==0){
                temp_VbqhwxK=NULL;
            return; }temp_VbqhwxK=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_cHIDMyb=json["pSizes"].as_array();
        for(int yLUmhkZ=0; yLUmhkZ < bindingCount; yLUmhkZ++){
            [&](){uint64_t temp_cHIDMyb;[&](){temp_cHIDMyb=static_cast<uint64_t>(value_to<int>(arr_cHIDMyb[yLUmhkZ]));}();temp_VbqhwxK[yLUmhkZ]=(VkDeviceSize)temp_cHIDMyb;}();
        }
        }();pSizes=temp_VbqhwxK;}();
VkDeviceSize* pStrides;
[&](){ VkDeviceSize* temp_zEzqsaE[&](){
            if (json["pStrides"].as_array().size()==0){
                temp_zEzqsaE=NULL;
            return; }temp_zEzqsaE=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_FOKmrCn=json["pStrides"].as_array();
        for(int ByEZqEy=0; ByEZqEy < bindingCount; ByEZqEy++){
            [&](){uint64_t temp_FOKmrCn;[&](){temp_FOKmrCn=static_cast<uint64_t>(value_to<int>(arr_FOKmrCn[ByEZqEy]));}();temp_zEzqsaE[ByEZqEy]=(VkDeviceSize)temp_FOKmrCn;}();
        }
        }();pStrides=temp_zEzqsaE;}();

    PFN_vkCmdBindVertexBuffers2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindVertexBuffers2)get_instance_proc_addr(parent,"vkCmdBindVertexBuffers2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindVertexBuffers2)get_device_proc_addr(parent,"vkCmdBindVertexBuffers2");
    }  
    
{
call_function(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }
        auto& arr_ENtnMTo=json["pBuffers"].emplace_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }
        auto& arr_YvpyTDd=json["pOffsets"].emplace_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=boost::json::array();
            return; }
        auto& arr_OwyEmcF=json["pSizes"].emplace_array();
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=pSizes[YFhxzVl];}();}();
        }
        }();
[&](){
            if (pStrides==NULL){
                json["pStrides"]=boost::json::array();
            return; }
        auto& arr_YFLMtWg=json["pStrides"].emplace_array();
        for(int qlkJtZj=0; qlkJtZj < bindingCount; qlkJtZj++){
            [&](){[&](){arr_YFLMtWg[qlkJtZj]=pStrides[qlkJtZj];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthTestEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthTestEnable;
[&](){uint32_t temp_WLSKeYp;[&](){temp_WLSKeYp=static_cast<uint32_t>(value_to<int>(json["depthTestEnable"]));}();depthTestEnable=(VkBool32)temp_WLSKeYp;}();

    PFN_vkCmdSetDepthTestEnable call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthTestEnable)get_instance_proc_addr(parent,"vkCmdSetDepthTestEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthTestEnable)get_device_proc_addr(parent,"vkCmdSetDepthTestEnable");
    }  
    
{
call_function(commandBuffer, depthTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthTestEnable"]=depthTestEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthWriteEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthWriteEnable;
[&](){uint32_t temp_qztdWhG;[&](){temp_qztdWhG=static_cast<uint32_t>(value_to<int>(json["depthWriteEnable"]));}();depthWriteEnable=(VkBool32)temp_qztdWhG;}();

    PFN_vkCmdSetDepthWriteEnable call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthWriteEnable)get_instance_proc_addr(parent,"vkCmdSetDepthWriteEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthWriteEnable)get_device_proc_addr(parent,"vkCmdSetDepthWriteEnable");
    }  
    
{
call_function(commandBuffer, depthWriteEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthWriteEnable"]=depthWriteEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthCompareOp(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCompareOp depthCompareOp;
[&](){[&](){int temp_GommENv;[&](){temp_GommENv=static_cast<int>(value_to<int>(json["depthCompareOp"]));}();depthCompareOp=(VkCompareOp)temp_GommENv;}();}();

    PFN_vkCmdSetDepthCompareOp call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthCompareOp)get_instance_proc_addr(parent,"vkCmdSetDepthCompareOp");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthCompareOp)get_device_proc_addr(parent,"vkCmdSetDepthCompareOp");
    }  
    
{
call_function(commandBuffer, depthCompareOp);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["depthCompareOp"]=depthCompareOp;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthBoundsTestEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthBoundsTestEnable;
[&](){uint32_t temp_qmudcyJ;[&](){temp_qmudcyJ=static_cast<uint32_t>(value_to<int>(json["depthBoundsTestEnable"]));}();depthBoundsTestEnable=(VkBool32)temp_qmudcyJ;}();

    PFN_vkCmdSetDepthBoundsTestEnable call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBoundsTestEnable)get_instance_proc_addr(parent,"vkCmdSetDepthBoundsTestEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBoundsTestEnable)get_device_proc_addr(parent,"vkCmdSetDepthBoundsTestEnable");
    }  
    
{
call_function(commandBuffer, depthBoundsTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBoundsTestEnable"]=depthBoundsTestEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetStencilTestEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 stencilTestEnable;
[&](){uint32_t temp_qPvOEDS;[&](){temp_qPvOEDS=static_cast<uint32_t>(value_to<int>(json["stencilTestEnable"]));}();stencilTestEnable=(VkBool32)temp_qPvOEDS;}();

    PFN_vkCmdSetStencilTestEnable call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilTestEnable)get_instance_proc_addr(parent,"vkCmdSetStencilTestEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilTestEnable)get_device_proc_addr(parent,"vkCmdSetStencilTestEnable");
    }  
    
{
call_function(commandBuffer, stencilTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stencilTestEnable"]=stencilTestEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetStencilOp(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){temp_VFXTqgy=static_cast<int>(value_to<int>(json["faceMask"]));}();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
VkStencilOp failOp;
[&](){[&](){int temp_lKXncFy;[&](){temp_lKXncFy=static_cast<int>(value_to<int>(json["failOp"]));}();failOp=(VkStencilOp)temp_lKXncFy;}();}();
VkStencilOp passOp;
[&](){[&](){int temp_SPMLjKg;[&](){temp_SPMLjKg=static_cast<int>(value_to<int>(json["passOp"]));}();passOp=(VkStencilOp)temp_SPMLjKg;}();}();
VkStencilOp depthFailOp;
[&](){[&](){int temp_TdIKNtG;[&](){temp_TdIKNtG=static_cast<int>(value_to<int>(json["depthFailOp"]));}();depthFailOp=(VkStencilOp)temp_TdIKNtG;}();}();
VkCompareOp compareOp;
[&](){[&](){int temp_NLoCySV;[&](){temp_NLoCySV=static_cast<int>(value_to<int>(json["compareOp"]));}();compareOp=(VkCompareOp)temp_NLoCySV;}();}();

    PFN_vkCmdSetStencilOp call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilOp)get_instance_proc_addr(parent,"vkCmdSetStencilOp");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilOp)get_device_proc_addr(parent,"vkCmdSetStencilOp");
    }  
    
{
call_function(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){[&](){[&](){json["failOp"]=failOp;}();}();}();
[&](){[&](){[&](){json["passOp"]=passOp;}();}();}();
[&](){[&](){[&](){json["depthFailOp"]=depthFailOp;}();}();}();
[&](){[&](){[&](){json["compareOp"]=compareOp;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetPatchControlPointsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t patchControlPoints;
[&](){patchControlPoints=static_cast<uint32_t>(value_to<int>(json["patchControlPoints"]));}();

    PFN_vkCmdSetPatchControlPointsEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPatchControlPointsEXT)get_instance_proc_addr(parent,"vkCmdSetPatchControlPointsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPatchControlPointsEXT)get_device_proc_addr(parent,"vkCmdSetPatchControlPointsEXT");
    }  
    
{
call_function(commandBuffer, patchControlPoints);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["patchControlPoints"]=patchControlPoints;}();


        writeToConn(json);
    }

    void handle_vkCmdSetRasterizerDiscardEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 rasterizerDiscardEnable;
[&](){uint32_t temp_bdbWnok;[&](){temp_bdbWnok=static_cast<uint32_t>(value_to<int>(json["rasterizerDiscardEnable"]));}();rasterizerDiscardEnable=(VkBool32)temp_bdbWnok;}();

    PFN_vkCmdSetRasterizerDiscardEnable call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRasterizerDiscardEnable)get_instance_proc_addr(parent,"vkCmdSetRasterizerDiscardEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRasterizerDiscardEnable)get_device_proc_addr(parent,"vkCmdSetRasterizerDiscardEnable");
    }  
    
{
call_function(commandBuffer, rasterizerDiscardEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["rasterizerDiscardEnable"]=rasterizerDiscardEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthBiasEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthBiasEnable;
[&](){uint32_t temp_ewcVkBi;[&](){temp_ewcVkBi=static_cast<uint32_t>(value_to<int>(json["depthBiasEnable"]));}();depthBiasEnable=(VkBool32)temp_ewcVkBi;}();

    PFN_vkCmdSetDepthBiasEnable call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBiasEnable)get_instance_proc_addr(parent,"vkCmdSetDepthBiasEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBiasEnable)get_device_proc_addr(parent,"vkCmdSetDepthBiasEnable");
    }  
    
{
call_function(commandBuffer, depthBiasEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBiasEnable"]=depthBiasEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetLogicOpEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkLogicOp logicOp;
[&](){[&](){int temp_KRaggtp;[&](){temp_KRaggtp=static_cast<int>(value_to<int>(json["logicOp"]));}();logicOp=(VkLogicOp)temp_KRaggtp;}();}();

    PFN_vkCmdSetLogicOpEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLogicOpEXT)get_instance_proc_addr(parent,"vkCmdSetLogicOpEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLogicOpEXT)get_device_proc_addr(parent,"vkCmdSetLogicOpEXT");
    }  
    
{
call_function(commandBuffer, logicOp);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["logicOp"]=logicOp;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetPrimitiveRestartEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 primitiveRestartEnable;
[&](){uint32_t temp_mDszbuh;[&](){temp_mDszbuh=static_cast<uint32_t>(value_to<int>(json["primitiveRestartEnable"]));}();primitiveRestartEnable=(VkBool32)temp_mDszbuh;}();

    PFN_vkCmdSetPrimitiveRestartEnable call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPrimitiveRestartEnable)get_instance_proc_addr(parent,"vkCmdSetPrimitiveRestartEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPrimitiveRestartEnable)get_device_proc_addr(parent,"vkCmdSetPrimitiveRestartEnable");
    }  
    
{
call_function(commandBuffer, primitiveRestartEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["primitiveRestartEnable"]=primitiveRestartEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetTessellationDomainOriginEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkTessellationDomainOrigin domainOrigin;
[&](){[&](){int temp_MhaRSZf;[&](){temp_MhaRSZf=static_cast<int>(value_to<int>(json["domainOrigin"]));}();domainOrigin=(VkTessellationDomainOrigin)temp_MhaRSZf;}();}();

    PFN_vkCmdSetTessellationDomainOriginEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetTessellationDomainOriginEXT)get_instance_proc_addr(parent,"vkCmdSetTessellationDomainOriginEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetTessellationDomainOriginEXT)get_device_proc_addr(parent,"vkCmdSetTessellationDomainOriginEXT");
    }  
    
{
call_function(commandBuffer, domainOrigin);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["domainOrigin"]=domainOrigin;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthClampEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthClampEnable;
[&](){uint32_t temp_DzsSqgr;[&](){temp_DzsSqgr=static_cast<uint32_t>(value_to<int>(json["depthClampEnable"]));}();depthClampEnable=(VkBool32)temp_DzsSqgr;}();

    PFN_vkCmdSetDepthClampEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthClampEnableEXT)get_instance_proc_addr(parent,"vkCmdSetDepthClampEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthClampEnableEXT)get_device_proc_addr(parent,"vkCmdSetDepthClampEnableEXT");
    }  
    
{
call_function(commandBuffer, depthClampEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClampEnable"]=depthClampEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetPolygonModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPolygonMode polygonMode;
[&](){[&](){int temp_XzCpfxJ;[&](){temp_XzCpfxJ=static_cast<int>(value_to<int>(json["polygonMode"]));}();polygonMode=(VkPolygonMode)temp_XzCpfxJ;}();}();

    PFN_vkCmdSetPolygonModeEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPolygonModeEXT)get_instance_proc_addr(parent,"vkCmdSetPolygonModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPolygonModeEXT)get_device_proc_addr(parent,"vkCmdSetPolygonModeEXT");
    }  
    
{
call_function(commandBuffer, polygonMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["polygonMode"]=polygonMode;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetRasterizationSamplesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSampleCountFlagBits rasterizationSamples;
[&](){[&](){int temp_YCyLybT;[&](){temp_YCyLybT=static_cast<int>(value_to<int>(json["rasterizationSamples"]));}();rasterizationSamples=(VkSampleCountFlagBits)temp_YCyLybT;}();}();

    PFN_vkCmdSetRasterizationSamplesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRasterizationSamplesEXT)get_instance_proc_addr(parent,"vkCmdSetRasterizationSamplesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRasterizationSamplesEXT)get_device_proc_addr(parent,"vkCmdSetRasterizationSamplesEXT");
    }  
    
{
call_function(commandBuffer, rasterizationSamples);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["rasterizationSamples"]=rasterizationSamples;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetSampleMaskEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSampleCountFlagBits samples;
[&](){[&](){int temp_lbKgbKj;[&](){temp_lbKgbKj=static_cast<int>(value_to<int>(json["samples"]));}();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
VkSampleMask* pSampleMask;
[&](){ VkSampleMask* temp_QmlqOpQ[&](){
            if (json["pSampleMask"].as_array().size()==0){
                temp_QmlqOpQ=NULL;
            return; }temp_QmlqOpQ=(VkSampleMask*)malloc((samples + 31) / 32*sizeof(VkSampleMask));
        auto& arr_FGuLlff=json["pSampleMask"].as_array();
        for(int BCMPGHn=0; BCMPGHn < (samples + 31) / 32; BCMPGHn++){
            [&](){uint32_t temp_FGuLlff;[&](){temp_FGuLlff=static_cast<uint32_t>(value_to<int>(arr_FGuLlff[BCMPGHn]));}();temp_QmlqOpQ[BCMPGHn]=(VkSampleMask)temp_FGuLlff;}();
        }
        }();pSampleMask=temp_QmlqOpQ;}();

    PFN_vkCmdSetSampleMaskEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetSampleMaskEXT)get_instance_proc_addr(parent,"vkCmdSetSampleMaskEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetSampleMaskEXT)get_device_proc_addr(parent,"vkCmdSetSampleMaskEXT");
    }  
    
{
call_function(commandBuffer, samples, pSampleMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){
            if (pSampleMask==NULL){
                json["pSampleMask"]=boost::json::array();
            return; }
        auto& arr_nepOVVF=json["pSampleMask"].emplace_array();
        for(int ASCUBEW=0; ASCUBEW < (samples + 31) / 32; ASCUBEW++){
            [&](){[&](){arr_nepOVVF[ASCUBEW]=pSampleMask[ASCUBEW];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetAlphaToCoverageEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 alphaToCoverageEnable;
[&](){uint32_t temp_GXlPpxl;[&](){temp_GXlPpxl=static_cast<uint32_t>(value_to<int>(json["alphaToCoverageEnable"]));}();alphaToCoverageEnable=(VkBool32)temp_GXlPpxl;}();

    PFN_vkCmdSetAlphaToCoverageEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetAlphaToCoverageEnableEXT)get_instance_proc_addr(parent,"vkCmdSetAlphaToCoverageEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetAlphaToCoverageEnableEXT)get_device_proc_addr(parent,"vkCmdSetAlphaToCoverageEnableEXT");
    }  
    
{
call_function(commandBuffer, alphaToCoverageEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToCoverageEnable"]=alphaToCoverageEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetAlphaToOneEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 alphaToOneEnable;
[&](){uint32_t temp_vIViDmy;[&](){temp_vIViDmy=static_cast<uint32_t>(value_to<int>(json["alphaToOneEnable"]));}();alphaToOneEnable=(VkBool32)temp_vIViDmy;}();

    PFN_vkCmdSetAlphaToOneEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetAlphaToOneEnableEXT)get_instance_proc_addr(parent,"vkCmdSetAlphaToOneEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetAlphaToOneEnableEXT)get_device_proc_addr(parent,"vkCmdSetAlphaToOneEnableEXT");
    }  
    
{
call_function(commandBuffer, alphaToOneEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToOneEnable"]=alphaToOneEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetLogicOpEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 logicOpEnable;
[&](){uint32_t temp_efIIzNf;[&](){temp_efIIzNf=static_cast<uint32_t>(value_to<int>(json["logicOpEnable"]));}();logicOpEnable=(VkBool32)temp_efIIzNf;}();

    PFN_vkCmdSetLogicOpEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLogicOpEnableEXT)get_instance_proc_addr(parent,"vkCmdSetLogicOpEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLogicOpEnableEXT)get_device_proc_addr(parent,"vkCmdSetLogicOpEnableEXT");
    }  
    
{
call_function(commandBuffer, logicOpEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["logicOpEnable"]=logicOpEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetColorBlendEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){firstAttachment=static_cast<uint32_t>(value_to<int>(json["firstAttachment"]));}();
uint32_t attachmentCount;
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();
VkBool32* pColorBlendEnables;
[&](){ VkBool32* temp_FcJwDni[&](){
            if (json["pColorBlendEnables"].as_array().size()==0){
                temp_FcJwDni=NULL;
            return; }temp_FcJwDni=(VkBool32*)malloc(attachmentCount*sizeof(VkBool32));
        auto& arr_lHzNiUd=json["pColorBlendEnables"].as_array();
        for(int wbANAKE=0; wbANAKE < attachmentCount; wbANAKE++){
            [&](){uint32_t temp_lHzNiUd;[&](){temp_lHzNiUd=static_cast<uint32_t>(value_to<int>(arr_lHzNiUd[wbANAKE]));}();temp_FcJwDni[wbANAKE]=(VkBool32)temp_lHzNiUd;}();
        }
        }();pColorBlendEnables=temp_FcJwDni;}();

    PFN_vkCmdSetColorBlendEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorBlendEnableEXT)get_instance_proc_addr(parent,"vkCmdSetColorBlendEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorBlendEnableEXT)get_device_proc_addr(parent,"vkCmdSetColorBlendEnableEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendEnables==NULL){
                json["pColorBlendEnables"]=boost::json::array();
            return; }
        auto& arr_saqDhTV=json["pColorBlendEnables"].emplace_array();
        for(int VGuJXMd=0; VGuJXMd < attachmentCount; VGuJXMd++){
            [&](){[&](){arr_saqDhTV[VGuJXMd]=pColorBlendEnables[VGuJXMd];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetColorBlendEquationEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){firstAttachment=static_cast<uint32_t>(value_to<int>(json["firstAttachment"]));}();
uint32_t attachmentCount;
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();
VkColorBlendEquationEXT* pColorBlendEquations;
[&](){ VkColorBlendEquationEXT* temp_yHwJIPK[&](){
            if (json["pColorBlendEquations"].as_array().size()==0){
                temp_yHwJIPK=NULL;
            return; }temp_yHwJIPK=(VkColorBlendEquationEXT*)malloc(attachmentCount*sizeof(VkColorBlendEquationEXT));
        auto& arr_EqkVhnu=json["pColorBlendEquations"].as_array();
        for(int fbdCMaT=0; fbdCMaT < attachmentCount; fbdCMaT++){
            [&](){
            auto& temp=arr_EqkVhnu[fbdCMaT].as_object();
            deserialize_struct(temp,temp_yHwJIPK[fbdCMaT]);
            }();
        }
        }();pColorBlendEquations=temp_yHwJIPK;}();

    PFN_vkCmdSetColorBlendEquationEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorBlendEquationEXT)get_instance_proc_addr(parent,"vkCmdSetColorBlendEquationEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorBlendEquationEXT)get_device_proc_addr(parent,"vkCmdSetColorBlendEquationEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendEquations==NULL){
                json["pColorBlendEquations"]=boost::json::array();
            return; }
        auto& arr_hKUQljx=json["pColorBlendEquations"].emplace_array();
        for(int EHggOtN=0; EHggOtN < attachmentCount; EHggOtN++){
            [&](){
            auto& temp=arr_hKUQljx[EHggOtN].emplace_object();
            return serialize_struct(temp, pColorBlendEquations[EHggOtN]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetColorWriteMaskEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){firstAttachment=static_cast<uint32_t>(value_to<int>(json["firstAttachment"]));}();
uint32_t attachmentCount;
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();
VkColorComponentFlags* pColorWriteMasks;
[&](){ VkColorComponentFlags* temp_czaocVX[&](){
            if (json["pColorWriteMasks"].as_array().size()==0){
                temp_czaocVX=NULL;
            return; }temp_czaocVX=(VkColorComponentFlags*)malloc(attachmentCount*sizeof(VkColorComponentFlags));
        auto& arr_EqZFwIM=json["pColorWriteMasks"].as_array();
        for(int ieFAddx=0; ieFAddx < attachmentCount; ieFAddx++){
            [&](){[&](){int temp_eGfaWyY;[&](){temp_eGfaWyY=static_cast<int>(value_to<int>(arr_EqZFwIM[ieFAddx]));}();temp_czaocVX[ieFAddx]=(VkColorComponentFlags)temp_eGfaWyY;}();}();
        }
        }();pColorWriteMasks=temp_czaocVX;}();

    PFN_vkCmdSetColorWriteMaskEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorWriteMaskEXT)get_instance_proc_addr(parent,"vkCmdSetColorWriteMaskEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorWriteMaskEXT)get_device_proc_addr(parent,"vkCmdSetColorWriteMaskEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorWriteMasks==NULL){
                json["pColorWriteMasks"]=boost::json::array();
            return; }
        auto& arr_VFhepws=json["pColorWriteMasks"].emplace_array();
        for(int PbQLtdZ=0; PbQLtdZ < attachmentCount; PbQLtdZ++){
            [&](){[&](){[&](){arr_VFhepws[PbQLtdZ]=pColorWriteMasks[PbQLtdZ];}();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetRasterizationStreamEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t rasterizationStream;
[&](){rasterizationStream=static_cast<uint32_t>(value_to<int>(json["rasterizationStream"]));}();

    PFN_vkCmdSetRasterizationStreamEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRasterizationStreamEXT)get_instance_proc_addr(parent,"vkCmdSetRasterizationStreamEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRasterizationStreamEXT)get_device_proc_addr(parent,"vkCmdSetRasterizationStreamEXT");
    }  
    
{
call_function(commandBuffer, rasterizationStream);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["rasterizationStream"]=rasterizationStream;}();


        writeToConn(json);
    }

    void handle_vkCmdSetConservativeRasterizationModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkConservativeRasterizationModeEXT conservativeRasterizationMode;
[&](){[&](){int temp_foXltQC;[&](){temp_foXltQC=static_cast<int>(value_to<int>(json["conservativeRasterizationMode"]));}();conservativeRasterizationMode=(VkConservativeRasterizationModeEXT)temp_foXltQC;}();}();

    PFN_vkCmdSetConservativeRasterizationModeEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetConservativeRasterizationModeEXT)get_instance_proc_addr(parent,"vkCmdSetConservativeRasterizationModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetConservativeRasterizationModeEXT)get_device_proc_addr(parent,"vkCmdSetConservativeRasterizationModeEXT");
    }  
    
{
call_function(commandBuffer, conservativeRasterizationMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["conservativeRasterizationMode"]=conservativeRasterizationMode;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetExtraPrimitiveOverestimationSizeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float extraPrimitiveOverestimationSize;
[&](){extraPrimitiveOverestimationSize=static_cast<float>(value_to<int>(json["extraPrimitiveOverestimationSize"]));}();

    PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)get_instance_proc_addr(parent,"vkCmdSetExtraPrimitiveOverestimationSizeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)get_device_proc_addr(parent,"vkCmdSetExtraPrimitiveOverestimationSizeEXT");
    }  
    
{
call_function(commandBuffer, extraPrimitiveOverestimationSize);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["extraPrimitiveOverestimationSize"]=extraPrimitiveOverestimationSize;}();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthClipEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthClipEnable;
[&](){uint32_t temp_xexuvpr;[&](){temp_xexuvpr=static_cast<uint32_t>(value_to<int>(json["depthClipEnable"]));}();depthClipEnable=(VkBool32)temp_xexuvpr;}();

    PFN_vkCmdSetDepthClipEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthClipEnableEXT)get_instance_proc_addr(parent,"vkCmdSetDepthClipEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthClipEnableEXT)get_device_proc_addr(parent,"vkCmdSetDepthClipEnableEXT");
    }  
    
{
call_function(commandBuffer, depthClipEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClipEnable"]=depthClipEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetSampleLocationsEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 sampleLocationsEnable;
[&](){uint32_t temp_dFVPXvO;[&](){temp_dFVPXvO=static_cast<uint32_t>(value_to<int>(json["sampleLocationsEnable"]));}();sampleLocationsEnable=(VkBool32)temp_dFVPXvO;}();

    PFN_vkCmdSetSampleLocationsEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetSampleLocationsEnableEXT)get_instance_proc_addr(parent,"vkCmdSetSampleLocationsEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetSampleLocationsEnableEXT)get_device_proc_addr(parent,"vkCmdSetSampleLocationsEnableEXT");
    }  
    
{
call_function(commandBuffer, sampleLocationsEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["sampleLocationsEnable"]=sampleLocationsEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetColorBlendAdvancedEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){firstAttachment=static_cast<uint32_t>(value_to<int>(json["firstAttachment"]));}();
uint32_t attachmentCount;
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();
VkColorBlendAdvancedEXT* pColorBlendAdvanced;
[&](){ VkColorBlendAdvancedEXT* temp_AyLStxT[&](){
            if (json["pColorBlendAdvanced"].as_array().size()==0){
                temp_AyLStxT=NULL;
            return; }temp_AyLStxT=(VkColorBlendAdvancedEXT*)malloc(attachmentCount*sizeof(VkColorBlendAdvancedEXT));
        auto& arr_CGYbnEQ=json["pColorBlendAdvanced"].as_array();
        for(int apDMrcx=0; apDMrcx < attachmentCount; apDMrcx++){
            [&](){
            auto& temp=arr_CGYbnEQ[apDMrcx].as_object();
            deserialize_struct(temp,temp_AyLStxT[apDMrcx]);
            }();
        }
        }();pColorBlendAdvanced=temp_AyLStxT;}();

    PFN_vkCmdSetColorBlendAdvancedEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorBlendAdvancedEXT)get_instance_proc_addr(parent,"vkCmdSetColorBlendAdvancedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorBlendAdvancedEXT)get_device_proc_addr(parent,"vkCmdSetColorBlendAdvancedEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendAdvanced==NULL){
                json["pColorBlendAdvanced"]=boost::json::array();
            return; }
        auto& arr_VhJvkCW=json["pColorBlendAdvanced"].emplace_array();
        for(int rBcMzuv=0; rBcMzuv < attachmentCount; rBcMzuv++){
            [&](){
            auto& temp=arr_VhJvkCW[rBcMzuv].emplace_object();
            return serialize_struct(temp, pColorBlendAdvanced[rBcMzuv]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetProvokingVertexModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkProvokingVertexModeEXT provokingVertexMode;
[&](){[&](){int temp_unvGJcm;[&](){temp_unvGJcm=static_cast<int>(value_to<int>(json["provokingVertexMode"]));}();provokingVertexMode=(VkProvokingVertexModeEXT)temp_unvGJcm;}();}();

    PFN_vkCmdSetProvokingVertexModeEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetProvokingVertexModeEXT)get_instance_proc_addr(parent,"vkCmdSetProvokingVertexModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetProvokingVertexModeEXT)get_device_proc_addr(parent,"vkCmdSetProvokingVertexModeEXT");
    }  
    
{
call_function(commandBuffer, provokingVertexMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["provokingVertexMode"]=provokingVertexMode;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetLineRasterizationModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkLineRasterizationModeEXT lineRasterizationMode;
[&](){[&](){int temp_TzHFAEB;[&](){temp_TzHFAEB=static_cast<int>(value_to<int>(json["lineRasterizationMode"]));}();lineRasterizationMode=(VkLineRasterizationModeEXT)temp_TzHFAEB;}();}();

    PFN_vkCmdSetLineRasterizationModeEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLineRasterizationModeEXT)get_instance_proc_addr(parent,"vkCmdSetLineRasterizationModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLineRasterizationModeEXT)get_device_proc_addr(parent,"vkCmdSetLineRasterizationModeEXT");
    }  
    
{
call_function(commandBuffer, lineRasterizationMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["lineRasterizationMode"]=lineRasterizationMode;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetLineStippleEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 stippledLineEnable;
[&](){uint32_t temp_lOgURYj;[&](){temp_lOgURYj=static_cast<uint32_t>(value_to<int>(json["stippledLineEnable"]));}();stippledLineEnable=(VkBool32)temp_lOgURYj;}();

    PFN_vkCmdSetLineStippleEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLineStippleEnableEXT)get_instance_proc_addr(parent,"vkCmdSetLineStippleEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLineStippleEnableEXT)get_device_proc_addr(parent,"vkCmdSetLineStippleEnableEXT");
    }  
    
{
call_function(commandBuffer, stippledLineEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stippledLineEnable"]=stippledLineEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthClipNegativeOneToOneEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 negativeOneToOne;
[&](){uint32_t temp_KbgfkEI;[&](){temp_KbgfkEI=static_cast<uint32_t>(value_to<int>(json["negativeOneToOne"]));}();negativeOneToOne=(VkBool32)temp_KbgfkEI;}();

    PFN_vkCmdSetDepthClipNegativeOneToOneEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthClipNegativeOneToOneEXT)get_instance_proc_addr(parent,"vkCmdSetDepthClipNegativeOneToOneEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthClipNegativeOneToOneEXT)get_device_proc_addr(parent,"vkCmdSetDepthClipNegativeOneToOneEXT");
    }  
    
{
call_function(commandBuffer, negativeOneToOne);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["negativeOneToOne"]=negativeOneToOne;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetViewportWScalingEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 viewportWScalingEnable;
[&](){uint32_t temp_FBvKoOa;[&](){temp_FBvKoOa=static_cast<uint32_t>(value_to<int>(json["viewportWScalingEnable"]));}();viewportWScalingEnable=(VkBool32)temp_FBvKoOa;}();

    PFN_vkCmdSetViewportWScalingEnableNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportWScalingEnableNV)get_instance_proc_addr(parent,"vkCmdSetViewportWScalingEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportWScalingEnableNV)get_device_proc_addr(parent,"vkCmdSetViewportWScalingEnableNV");
    }  
    
{
call_function(commandBuffer, viewportWScalingEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["viewportWScalingEnable"]=viewportWScalingEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetViewportSwizzleNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){firstViewport=static_cast<uint32_t>(value_to<int>(json["firstViewport"]));}();
uint32_t viewportCount;
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();
VkViewportSwizzleNV* pViewportSwizzles;
[&](){ VkViewportSwizzleNV* temp_KnyDwdB[&](){
            if (json["pViewportSwizzles"].as_array().size()==0){
                temp_KnyDwdB=NULL;
            return; }temp_KnyDwdB=(VkViewportSwizzleNV*)malloc(viewportCount*sizeof(VkViewportSwizzleNV));
        auto& arr_ZPCbbeZ=json["pViewportSwizzles"].as_array();
        for(int dONOTlj=0; dONOTlj < viewportCount; dONOTlj++){
            [&](){
            auto& temp=arr_ZPCbbeZ[dONOTlj].as_object();
            deserialize_struct(temp,temp_KnyDwdB[dONOTlj]);
            }();
        }
        }();pViewportSwizzles=temp_KnyDwdB;}();

    PFN_vkCmdSetViewportSwizzleNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportSwizzleNV)get_instance_proc_addr(parent,"vkCmdSetViewportSwizzleNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportSwizzleNV)get_device_proc_addr(parent,"vkCmdSetViewportSwizzleNV");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewportSwizzles==NULL){
                json["pViewportSwizzles"]=boost::json::array();
            return; }
        auto& arr_mlTjeMw=json["pViewportSwizzles"].emplace_array();
        for(int jvBpVNx=0; jvBpVNx < viewportCount; jvBpVNx++){
            [&](){
            auto& temp=arr_mlTjeMw[jvBpVNx].emplace_object();
            return serialize_struct(temp, pViewportSwizzles[jvBpVNx]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetCoverageToColorEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 coverageToColorEnable;
[&](){uint32_t temp_StrBHxz;[&](){temp_StrBHxz=static_cast<uint32_t>(value_to<int>(json["coverageToColorEnable"]));}();coverageToColorEnable=(VkBool32)temp_StrBHxz;}();

    PFN_vkCmdSetCoverageToColorEnableNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageToColorEnableNV)get_instance_proc_addr(parent,"vkCmdSetCoverageToColorEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageToColorEnableNV)get_device_proc_addr(parent,"vkCmdSetCoverageToColorEnableNV");
    }  
    
{
call_function(commandBuffer, coverageToColorEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageToColorEnable"]=coverageToColorEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetCoverageToColorLocationNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t coverageToColorLocation;
[&](){coverageToColorLocation=static_cast<uint32_t>(value_to<int>(json["coverageToColorLocation"]));}();

    PFN_vkCmdSetCoverageToColorLocationNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageToColorLocationNV)get_instance_proc_addr(parent,"vkCmdSetCoverageToColorLocationNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageToColorLocationNV)get_device_proc_addr(parent,"vkCmdSetCoverageToColorLocationNV");
    }  
    
{
call_function(commandBuffer, coverageToColorLocation);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageToColorLocation"]=coverageToColorLocation;}();


        writeToConn(json);
    }

    void handle_vkCmdSetCoverageModulationModeNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCoverageModulationModeNV coverageModulationMode;
[&](){[&](){int temp_BTSRuJL;[&](){temp_BTSRuJL=static_cast<int>(value_to<int>(json["coverageModulationMode"]));}();coverageModulationMode=(VkCoverageModulationModeNV)temp_BTSRuJL;}();}();

    PFN_vkCmdSetCoverageModulationModeNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageModulationModeNV)get_instance_proc_addr(parent,"vkCmdSetCoverageModulationModeNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageModulationModeNV)get_device_proc_addr(parent,"vkCmdSetCoverageModulationModeNV");
    }  
    
{
call_function(commandBuffer, coverageModulationMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageModulationMode"]=coverageModulationMode;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetCoverageModulationTableEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 coverageModulationTableEnable;
[&](){uint32_t temp_lmSvUmH;[&](){temp_lmSvUmH=static_cast<uint32_t>(value_to<int>(json["coverageModulationTableEnable"]));}();coverageModulationTableEnable=(VkBool32)temp_lmSvUmH;}();

    PFN_vkCmdSetCoverageModulationTableEnableNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageModulationTableEnableNV)get_instance_proc_addr(parent,"vkCmdSetCoverageModulationTableEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageModulationTableEnableNV)get_device_proc_addr(parent,"vkCmdSetCoverageModulationTableEnableNV");
    }  
    
{
call_function(commandBuffer, coverageModulationTableEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageModulationTableEnable"]=coverageModulationTableEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetCoverageModulationTableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t coverageModulationTableCount;
[&](){coverageModulationTableCount=static_cast<uint32_t>(value_to<int>(json["coverageModulationTableCount"]));}();
float* pCoverageModulationTable;
[&](){ float* temp_VxYyEVf[&](){
            if (json["pCoverageModulationTable"].as_array().size()==0){
                temp_VxYyEVf=NULL;
            return; }temp_VxYyEVf=(float*)malloc(coverageModulationTableCount*sizeof(float));
        auto& arr_PUYynJq=json["pCoverageModulationTable"].as_array();
        for(int uNkPtIy=0; uNkPtIy < coverageModulationTableCount; uNkPtIy++){
            [&](){temp_VxYyEVf[uNkPtIy]=static_cast<float>(value_to<int>(arr_PUYynJq[uNkPtIy]));}();
        }
        }();pCoverageModulationTable=temp_VxYyEVf;}();

    PFN_vkCmdSetCoverageModulationTableNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageModulationTableNV)get_instance_proc_addr(parent,"vkCmdSetCoverageModulationTableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageModulationTableNV)get_device_proc_addr(parent,"vkCmdSetCoverageModulationTableNV");
    }  
    
{
call_function(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageModulationTableCount"]=coverageModulationTableCount;}();
[&](){
            if (pCoverageModulationTable==NULL){
                json["pCoverageModulationTable"]=boost::json::array();
            return; }
        auto& arr_FKEHfYD=json["pCoverageModulationTable"].emplace_array();
        for(int pMqhQqL=0; pMqhQqL < coverageModulationTableCount; pMqhQqL++){
            [&](){arr_FKEHfYD[pMqhQqL]=pCoverageModulationTable[pMqhQqL];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetShadingRateImageEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 shadingRateImageEnable;
[&](){uint32_t temp_BQfvSQF;[&](){temp_BQfvSQF=static_cast<uint32_t>(value_to<int>(json["shadingRateImageEnable"]));}();shadingRateImageEnable=(VkBool32)temp_BQfvSQF;}();

    PFN_vkCmdSetShadingRateImageEnableNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetShadingRateImageEnableNV)get_instance_proc_addr(parent,"vkCmdSetShadingRateImageEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetShadingRateImageEnableNV)get_device_proc_addr(parent,"vkCmdSetShadingRateImageEnableNV");
    }  
    
{
call_function(commandBuffer, shadingRateImageEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["shadingRateImageEnable"]=shadingRateImageEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetCoverageReductionModeNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCoverageReductionModeNV coverageReductionMode;
[&](){[&](){int temp_MbjGgOv;[&](){temp_MbjGgOv=static_cast<int>(value_to<int>(json["coverageReductionMode"]));}();coverageReductionMode=(VkCoverageReductionModeNV)temp_MbjGgOv;}();}();

    PFN_vkCmdSetCoverageReductionModeNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageReductionModeNV)get_instance_proc_addr(parent,"vkCmdSetCoverageReductionModeNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageReductionModeNV)get_device_proc_addr(parent,"vkCmdSetCoverageReductionModeNV");
    }  
    
{
call_function(commandBuffer, coverageReductionMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageReductionMode"]=coverageReductionMode;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdSetRepresentativeFragmentTestEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 representativeFragmentTestEnable;
[&](){uint32_t temp_VmtUEuY;[&](){temp_VmtUEuY=static_cast<uint32_t>(value_to<int>(json["representativeFragmentTestEnable"]));}();representativeFragmentTestEnable=(VkBool32)temp_VmtUEuY;}();

    PFN_vkCmdSetRepresentativeFragmentTestEnableNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRepresentativeFragmentTestEnableNV)get_instance_proc_addr(parent,"vkCmdSetRepresentativeFragmentTestEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRepresentativeFragmentTestEnableNV)get_device_proc_addr(parent,"vkCmdSetRepresentativeFragmentTestEnableNV");
    }  
    
{
call_function(commandBuffer, representativeFragmentTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["representativeFragmentTestEnable"]=representativeFragmentTestEnable;}();}();


        writeToConn(json);
    }

    void handle_vkCreatePrivateDataSlot(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPrivateDataSlotCreateInfo* pCreateInfo;
[&](){ VkPrivateDataSlotCreateInfo* temp_MDKPlFj[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_MDKPlFj=NULL;
            return; }temp_MDKPlFj=(VkPrivateDataSlotCreateInfo*)malloc(1*sizeof(VkPrivateDataSlotCreateInfo));
        auto& arr_NidbGih=json["pCreateInfo"].as_array();
        for(int ZNynneh=0; ZNynneh < 1; ZNynneh++){
            [&](){
            auto& temp=arr_NidbGih[ZNynneh].as_object();
            deserialize_struct(temp,temp_MDKPlFj[ZNynneh]);
            }();
        }
        }();pCreateInfo=temp_MDKPlFj;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkPrivateDataSlot* pPrivateDataSlot;
[&](){
            if (json["pPrivateDataSlot"].as_array().size()==0){
                pPrivateDataSlot=NULL;
            return; }pPrivateDataSlot=(VkPrivateDataSlot*)malloc(1*sizeof(VkPrivateDataSlot));
        auto& arr_EOSkjPn=json["pPrivateDataSlot"].as_array();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){deserialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt], pPrivateDataSlot[QtkHhpt]);}();
        }
        }();

    PFN_vkCreatePrivateDataSlot call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreatePrivateDataSlot)get_instance_proc_addr(parent,"vkCreatePrivateDataSlot");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreatePrivateDataSlot)get_device_proc_addr(parent,"vkCreatePrivateDataSlot");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_OhzuPlW=json["pCreateInfo"].emplace_array();
        for(int KUjUcQv=0; KUjUcQv < 1; KUjUcQv++){
            [&](){
            auto& temp=arr_OhzuPlW[KUjUcQv].emplace_object();
            return serialize_struct(temp, pCreateInfo[KUjUcQv]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPrivateDataSlot==NULL){
                json["pPrivateDataSlot"]=boost::json::array();
            return; }
        auto& arr_EOSkjPn=json["pPrivateDataSlot"].emplace_array();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){serialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt],pPrivateDataSlot[QtkHhpt]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyPrivateDataSlot(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPrivateDataSlot privateDataSlot;
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyPrivateDataSlot call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyPrivateDataSlot)get_instance_proc_addr(parent,"vkDestroyPrivateDataSlot");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyPrivateDataSlot)get_device_proc_addr(parent,"vkDestroyPrivateDataSlot");
    }  
    
{
call_function(device, privateDataSlot, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkSetPrivateData(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkObjectType objectType;
[&](){[&](){int temp_xzhtvEi;[&](){temp_xzhtvEi=static_cast<int>(value_to<int>(json["objectType"]));}();objectType=(VkObjectType)temp_xzhtvEi;}();}();
uint64_t objectHandle;
[&](){objectHandle=static_cast<uint64_t>(value_to<int>(json["objectHandle"]));}();
VkPrivateDataSlot privateDataSlot;
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
uint64_t data;
[&](){data=static_cast<uint64_t>(value_to<int>(json["data"]));}();

    PFN_vkSetPrivateData call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetPrivateData)get_instance_proc_addr(parent,"vkSetPrivateData");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetPrivateData)get_device_proc_addr(parent,"vkSetPrivateData");
    }  
    
{
auto result=call_function(device, objectType, objectHandle, privateDataSlot, data);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["objectHandle"]=objectHandle;}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){json["data"]=data;}();


        writeToConn(json);
    }

    void handle_vkGetPrivateData(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkObjectType objectType;
[&](){[&](){int temp_xzhtvEi;[&](){temp_xzhtvEi=static_cast<int>(value_to<int>(json["objectType"]));}();objectType=(VkObjectType)temp_xzhtvEi;}();}();
uint64_t objectHandle;
[&](){objectHandle=static_cast<uint64_t>(value_to<int>(json["objectHandle"]));}();
VkPrivateDataSlot privateDataSlot;
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
uint64_t* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }pData=(uint64_t*)malloc(1*sizeof(uint64_t));
        auto& arr_niIcbqy=json["pData"].as_array();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){pData[rXHtNoy]=static_cast<uint64_t>(value_to<int>(arr_niIcbqy[rXHtNoy]));}();
        }
        }();

    PFN_vkGetPrivateData call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPrivateData)get_instance_proc_addr(parent,"vkGetPrivateData");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPrivateData)get_device_proc_addr(parent,"vkGetPrivateData");
    }  
    
{
call_function(device, objectType, objectHandle, privateDataSlot, pData);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["objectHandle"]=objectHandle;}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_niIcbqy=json["pData"].emplace_array();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){arr_niIcbqy[rXHtNoy]=pData[rXHtNoy];}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyBuffer2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyBufferInfo2* pCopyBufferInfo;
[&](){ VkCopyBufferInfo2* temp_wdLFuER[&](){
            if (json["pCopyBufferInfo"].as_array().size()==0){
                temp_wdLFuER=NULL;
            return; }temp_wdLFuER=(VkCopyBufferInfo2*)malloc(1*sizeof(VkCopyBufferInfo2));
        auto& arr_zibazFk=json["pCopyBufferInfo"].as_array();
        for(int BLWMzyy=0; BLWMzyy < 1; BLWMzyy++){
            [&](){
            auto& temp=arr_zibazFk[BLWMzyy].as_object();
            deserialize_struct(temp,temp_wdLFuER[BLWMzyy]);
            }();
        }
        }();pCopyBufferInfo=temp_wdLFuER;}();

    PFN_vkCmdCopyBuffer2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyBuffer2)get_instance_proc_addr(parent,"vkCmdCopyBuffer2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyBuffer2)get_device_proc_addr(parent,"vkCmdCopyBuffer2");
    }  
    
{
call_function(commandBuffer, pCopyBufferInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferInfo==NULL){
                json["pCopyBufferInfo"]=boost::json::array();
            return; }
        auto& arr_RrXlJAO=json["pCopyBufferInfo"].emplace_array();
        for(int tCibIjb=0; tCibIjb < 1; tCibIjb++){
            [&](){
            auto& temp=arr_RrXlJAO[tCibIjb].emplace_object();
            return serialize_struct(temp, pCopyBufferInfo[tCibIjb]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyImage2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyImageInfo2* pCopyImageInfo;
[&](){ VkCopyImageInfo2* temp_raFQDKs[&](){
            if (json["pCopyImageInfo"].as_array().size()==0){
                temp_raFQDKs=NULL;
            return; }temp_raFQDKs=(VkCopyImageInfo2*)malloc(1*sizeof(VkCopyImageInfo2));
        auto& arr_QunWVoT=json["pCopyImageInfo"].as_array();
        for(int aRJdnXE=0; aRJdnXE < 1; aRJdnXE++){
            [&](){
            auto& temp=arr_QunWVoT[aRJdnXE].as_object();
            deserialize_struct(temp,temp_raFQDKs[aRJdnXE]);
            }();
        }
        }();pCopyImageInfo=temp_raFQDKs;}();

    PFN_vkCmdCopyImage2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyImage2)get_instance_proc_addr(parent,"vkCmdCopyImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyImage2)get_device_proc_addr(parent,"vkCmdCopyImage2");
    }  
    
{
call_function(commandBuffer, pCopyImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageInfo==NULL){
                json["pCopyImageInfo"]=boost::json::array();
            return; }
        auto& arr_fhmwDMM=json["pCopyImageInfo"].emplace_array();
        for(int vtScDqF=0; vtScDqF < 1; vtScDqF++){
            [&](){
            auto& temp=arr_fhmwDMM[vtScDqF].emplace_object();
            return serialize_struct(temp, pCopyImageInfo[vtScDqF]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBlitImage2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBlitImageInfo2* pBlitImageInfo;
[&](){ VkBlitImageInfo2* temp_TfirKkB[&](){
            if (json["pBlitImageInfo"].as_array().size()==0){
                temp_TfirKkB=NULL;
            return; }temp_TfirKkB=(VkBlitImageInfo2*)malloc(1*sizeof(VkBlitImageInfo2));
        auto& arr_WcZAFFY=json["pBlitImageInfo"].as_array();
        for(int ippZCip=0; ippZCip < 1; ippZCip++){
            [&](){
            auto& temp=arr_WcZAFFY[ippZCip].as_object();
            deserialize_struct(temp,temp_TfirKkB[ippZCip]);
            }();
        }
        }();pBlitImageInfo=temp_TfirKkB;}();

    PFN_vkCmdBlitImage2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBlitImage2)get_instance_proc_addr(parent,"vkCmdBlitImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBlitImage2)get_device_proc_addr(parent,"vkCmdBlitImage2");
    }  
    
{
call_function(commandBuffer, pBlitImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBlitImageInfo==NULL){
                json["pBlitImageInfo"]=boost::json::array();
            return; }
        auto& arr_uMZBSOh=json["pBlitImageInfo"].emplace_array();
        for(int mMDYqpe=0; mMDYqpe < 1; mMDYqpe++){
            [&](){
            auto& temp=arr_uMZBSOh[mMDYqpe].emplace_object();
            return serialize_struct(temp, pBlitImageInfo[mMDYqpe]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyBufferToImage2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyBufferToImageInfo2* pCopyBufferToImageInfo;
[&](){ VkCopyBufferToImageInfo2* temp_BEVHFsC[&](){
            if (json["pCopyBufferToImageInfo"].as_array().size()==0){
                temp_BEVHFsC=NULL;
            return; }temp_BEVHFsC=(VkCopyBufferToImageInfo2*)malloc(1*sizeof(VkCopyBufferToImageInfo2));
        auto& arr_HtvMvbo=json["pCopyBufferToImageInfo"].as_array();
        for(int tWBWvbF=0; tWBWvbF < 1; tWBWvbF++){
            [&](){
            auto& temp=arr_HtvMvbo[tWBWvbF].as_object();
            deserialize_struct(temp,temp_BEVHFsC[tWBWvbF]);
            }();
        }
        }();pCopyBufferToImageInfo=temp_BEVHFsC;}();

    PFN_vkCmdCopyBufferToImage2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyBufferToImage2)get_instance_proc_addr(parent,"vkCmdCopyBufferToImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyBufferToImage2)get_device_proc_addr(parent,"vkCmdCopyBufferToImage2");
    }  
    
{
call_function(commandBuffer, pCopyBufferToImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferToImageInfo==NULL){
                json["pCopyBufferToImageInfo"]=boost::json::array();
            return; }
        auto& arr_GgxIzVF=json["pCopyBufferToImageInfo"].emplace_array();
        for(int kZlUXOa=0; kZlUXOa < 1; kZlUXOa++){
            [&](){
            auto& temp=arr_GgxIzVF[kZlUXOa].emplace_object();
            return serialize_struct(temp, pCopyBufferToImageInfo[kZlUXOa]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyImageToBuffer2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyImageToBufferInfo2* pCopyImageToBufferInfo;
[&](){ VkCopyImageToBufferInfo2* temp_AtGDWRu[&](){
            if (json["pCopyImageToBufferInfo"].as_array().size()==0){
                temp_AtGDWRu=NULL;
            return; }temp_AtGDWRu=(VkCopyImageToBufferInfo2*)malloc(1*sizeof(VkCopyImageToBufferInfo2));
        auto& arr_NyCJVfx=json["pCopyImageToBufferInfo"].as_array();
        for(int NLyWULP=0; NLyWULP < 1; NLyWULP++){
            [&](){
            auto& temp=arr_NyCJVfx[NLyWULP].as_object();
            deserialize_struct(temp,temp_AtGDWRu[NLyWULP]);
            }();
        }
        }();pCopyImageToBufferInfo=temp_AtGDWRu;}();

    PFN_vkCmdCopyImageToBuffer2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyImageToBuffer2)get_instance_proc_addr(parent,"vkCmdCopyImageToBuffer2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyImageToBuffer2)get_device_proc_addr(parent,"vkCmdCopyImageToBuffer2");
    }  
    
{
call_function(commandBuffer, pCopyImageToBufferInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageToBufferInfo==NULL){
                json["pCopyImageToBufferInfo"]=boost::json::array();
            return; }
        auto& arr_dKwPEQq=json["pCopyImageToBufferInfo"].emplace_array();
        for(int SXwhnUi=0; SXwhnUi < 1; SXwhnUi++){
            [&](){
            auto& temp=arr_dKwPEQq[SXwhnUi].emplace_object();
            return serialize_struct(temp, pCopyImageToBufferInfo[SXwhnUi]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdResolveImage2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkResolveImageInfo2* pResolveImageInfo;
[&](){ VkResolveImageInfo2* temp_vwHpWWm[&](){
            if (json["pResolveImageInfo"].as_array().size()==0){
                temp_vwHpWWm=NULL;
            return; }temp_vwHpWWm=(VkResolveImageInfo2*)malloc(1*sizeof(VkResolveImageInfo2));
        auto& arr_IZrxKgk=json["pResolveImageInfo"].as_array();
        for(int LpoaGzd=0; LpoaGzd < 1; LpoaGzd++){
            [&](){
            auto& temp=arr_IZrxKgk[LpoaGzd].as_object();
            deserialize_struct(temp,temp_vwHpWWm[LpoaGzd]);
            }();
        }
        }();pResolveImageInfo=temp_vwHpWWm;}();

    PFN_vkCmdResolveImage2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResolveImage2)get_instance_proc_addr(parent,"vkCmdResolveImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResolveImage2)get_device_proc_addr(parent,"vkCmdResolveImage2");
    }  
    
{
call_function(commandBuffer, pResolveImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pResolveImageInfo==NULL){
                json["pResolveImageInfo"]=boost::json::array();
            return; }
        auto& arr_WXEMxut=json["pResolveImageInfo"].emplace_array();
        for(int oSccZaz=0; oSccZaz < 1; oSccZaz++){
            [&](){
            auto& temp=arr_WXEMxut[oSccZaz].emplace_object();
            return serialize_struct(temp, pResolveImageInfo[oSccZaz]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetFragmentShadingRateKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkExtent2D* pFragmentSize;
[&](){ VkExtent2D* temp_zjiDwuw[&](){
            if (json["pFragmentSize"].as_array().size()==0){
                temp_zjiDwuw=NULL;
            return; }temp_zjiDwuw=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));
        auto& arr_eIGxtNV=json["pFragmentSize"].as_array();
        for(int eByenzl=0; eByenzl < 1; eByenzl++){
            [&](){
            auto& temp=arr_eIGxtNV[eByenzl].as_object();
            deserialize_struct(temp,temp_zjiDwuw[eByenzl]);
            }();
        }
        }();pFragmentSize=temp_zjiDwuw;}();
VkFragmentShadingRateCombinerOpKHR combinerOps[2];
[&](){
        auto& arr_jtjRLJW=json["combinerOps"].as_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){ VkFragmentShadingRateCombinerOpKHR temp_jtjRLJW[2][&](){[&](){int temp_QlmJXea;[&](){temp_QlmJXea=static_cast<int>(value_to<int>(arr_jtjRLJW[uBsarms]));}();temp_jtjRLJW=(VkFragmentShadingRateCombinerOpKHR)temp_QlmJXea;}();}();combinerOps[uBsarms]=temp_jtjRLJW;}();
        }
        }();

    PFN_vkCmdSetFragmentShadingRateKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetFragmentShadingRateKHR)get_instance_proc_addr(parent,"vkCmdSetFragmentShadingRateKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetFragmentShadingRateKHR)get_device_proc_addr(parent,"vkCmdSetFragmentShadingRateKHR");
    }  
    
{
call_function(commandBuffer, pFragmentSize, combinerOps);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pFragmentSize==NULL){
                json["pFragmentSize"]=boost::json::array();
            return; }
        auto& arr_RBQYqfx=json["pFragmentSize"].emplace_array();
        for(int rHAqvQQ=0; rHAqvQQ < 1; rHAqvQQ++){
            [&](){
            auto& temp=arr_RBQYqfx[rHAqvQQ].emplace_object();
            return serialize_struct(temp, pFragmentSize[rHAqvQQ]);
            }();
        }
        }();
[&](){
        auto& arr_jtjRLJW=json["combinerOps"].emplace_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_jtjRLJW[uBsarms]=combinerOps[uBsarms];}();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFragmentShadingRatesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pFragmentShadingRateCount;
[&](){
            if (json["pFragmentShadingRateCount"].as_array().size()==0){
                pFragmentShadingRateCount=NULL;
            return; }pFragmentShadingRateCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_CjAZByp=json["pFragmentShadingRateCount"].as_array();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(value_to<int>(arr_CjAZByp[vQwTqIV]));}();
        }
        }();
VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates;
[&](){
            if (json["pFragmentShadingRates"].as_array().size()==0){
                pFragmentShadingRates=NULL;
            return; }pFragmentShadingRates=(VkPhysicalDeviceFragmentShadingRateKHR*)malloc(*pFragmentShadingRateCount*sizeof(VkPhysicalDeviceFragmentShadingRateKHR));
        auto& arr_UdwJpYv=json["pFragmentShadingRates"].as_array();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto& temp=arr_UdwJpYv[bVRSXYW].as_object();
            deserialize_struct(temp,pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFragmentShadingRatesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceFragmentShadingRatesKHR");
    }  
    
{
auto result=call_function(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFragmentShadingRateCount==NULL){
                json["pFragmentShadingRateCount"]=boost::json::array();
            return; }
        auto& arr_CjAZByp=json["pFragmentShadingRateCount"].emplace_array();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){arr_CjAZByp[vQwTqIV]=pFragmentShadingRateCount[vQwTqIV];}();
        }
        }();
[&](){
            if (pFragmentShadingRates==NULL){
                json["pFragmentShadingRates"]=boost::json::array();
            return; }
        auto& arr_UdwJpYv=json["pFragmentShadingRates"].emplace_array();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto& temp=arr_UdwJpYv[bVRSXYW].emplace_object();
            return serialize_struct(temp, pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetFragmentShadingRateEnumNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkFragmentShadingRateNV shadingRate;
[&](){[&](){int temp_CqLMxeN;[&](){temp_CqLMxeN=static_cast<int>(value_to<int>(json["shadingRate"]));}();shadingRate=(VkFragmentShadingRateNV)temp_CqLMxeN;}();}();
VkFragmentShadingRateCombinerOpKHR combinerOps[2];
[&](){
        auto& arr_jtjRLJW=json["combinerOps"].as_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){ VkFragmentShadingRateCombinerOpKHR temp_jtjRLJW[2][&](){[&](){int temp_QlmJXea;[&](){temp_QlmJXea=static_cast<int>(value_to<int>(arr_jtjRLJW[uBsarms]));}();temp_jtjRLJW=(VkFragmentShadingRateCombinerOpKHR)temp_QlmJXea;}();}();combinerOps[uBsarms]=temp_jtjRLJW;}();
        }
        }();

    PFN_vkCmdSetFragmentShadingRateEnumNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetFragmentShadingRateEnumNV)get_instance_proc_addr(parent,"vkCmdSetFragmentShadingRateEnumNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetFragmentShadingRateEnumNV)get_device_proc_addr(parent,"vkCmdSetFragmentShadingRateEnumNV");
    }  
    
{
call_function(commandBuffer, shadingRate, combinerOps);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["shadingRate"]=shadingRate;}();}();}();
[&](){
        auto& arr_jtjRLJW=json["combinerOps"].emplace_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_jtjRLJW[uBsarms]=combinerOps[uBsarms];}();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureBuildSizesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureBuildTypeKHR buildType;
[&](){[&](){int temp_XouAsBI;[&](){temp_XouAsBI=static_cast<int>(value_to<int>(json["buildType"]));}();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();
VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo;
[&](){ VkAccelerationStructureBuildGeometryInfoKHR* temp_BCfqWJQ[&](){
            if (json["pBuildInfo"].as_array().size()==0){
                temp_BCfqWJQ=NULL;
            return; }temp_BCfqWJQ=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(1*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
        auto& arr_plZlnwA=json["pBuildInfo"].as_array();
        for(int PtWSBOy=0; PtWSBOy < 1; PtWSBOy++){
            [&](){
            auto& temp=arr_plZlnwA[PtWSBOy].as_object();
            deserialize_struct(temp,temp_BCfqWJQ[PtWSBOy]);
            }();
        }
        }();pBuildInfo=temp_BCfqWJQ;}();
uint32_t* pMaxPrimitiveCounts;
[&](){ uint32_t* temp_uQEkKfL[&](){
            if (json["pMaxPrimitiveCounts"].as_array().size()==0){
                temp_uQEkKfL=NULL;
            return; }temp_uQEkKfL=(uint32_t*)malloc(pBuildInfo->geometryCount*sizeof(uint32_t));
        auto& arr_crHuORX=json["pMaxPrimitiveCounts"].as_array();
        for(int JfSxsJb=0; JfSxsJb < pBuildInfo->geometryCount; JfSxsJb++){
            [&](){temp_uQEkKfL[JfSxsJb]=static_cast<uint32_t>(value_to<int>(arr_crHuORX[JfSxsJb]));}();
        }
        }();pMaxPrimitiveCounts=temp_uQEkKfL;}();
VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo;
[&](){
            if (json["pSizeInfo"].as_array().size()==0){
                pSizeInfo=NULL;
            return; }pSizeInfo=(VkAccelerationStructureBuildSizesInfoKHR*)malloc(1*sizeof(VkAccelerationStructureBuildSizesInfoKHR));
        auto& arr_aJATMZS=json["pSizeInfo"].as_array();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto& temp=arr_aJATMZS[pwtSWhd].as_object();
            deserialize_struct(temp,pSizeInfo[pwtSWhd]);
            }();
        }
        }();

    PFN_vkGetAccelerationStructureBuildSizesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureBuildSizesKHR)get_instance_proc_addr(parent,"vkGetAccelerationStructureBuildSizesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureBuildSizesKHR)get_device_proc_addr(parent,"vkGetAccelerationStructureBuildSizesKHR");
    }  
    
{
call_function(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=buildType;}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=boost::json::array();
            return; }
        auto& arr_rNWxDog=json["pBuildInfo"].emplace_array();
        for(int DpqeGQs=0; DpqeGQs < 1; DpqeGQs++){
            [&](){
            auto& temp=arr_rNWxDog[DpqeGQs].emplace_object();
            return serialize_struct(temp, pBuildInfo[DpqeGQs]);
            }();
        }
        }();
[&](){
            if (pMaxPrimitiveCounts==NULL){
                json["pMaxPrimitiveCounts"]=boost::json::array();
            return; }
        auto& arr_vNFCnZs=json["pMaxPrimitiveCounts"].emplace_array();
        for(int KHWuVmo=0; KHWuVmo < pBuildInfo->geometryCount; KHWuVmo++){
            [&](){arr_vNFCnZs[KHWuVmo]=pMaxPrimitiveCounts[KHWuVmo];}();
        }
        }();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=boost::json::array();
            return; }
        auto& arr_aJATMZS=json["pSizeInfo"].emplace_array();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto& temp=arr_aJATMZS[pwtSWhd].emplace_object();
            return serialize_struct(temp, pSizeInfo[pwtSWhd]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetVertexInputEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t vertexBindingDescriptionCount;
[&](){vertexBindingDescriptionCount=static_cast<uint32_t>(value_to<int>(json["vertexBindingDescriptionCount"]));}();
VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions;
[&](){ VkVertexInputBindingDescription2EXT* temp_mnrvCzp[&](){
            if (json["pVertexBindingDescriptions"].as_array().size()==0){
                temp_mnrvCzp=NULL;
            return; }temp_mnrvCzp=(VkVertexInputBindingDescription2EXT*)malloc(vertexBindingDescriptionCount*sizeof(VkVertexInputBindingDescription2EXT));
        auto& arr_ZGQrPce=json["pVertexBindingDescriptions"].as_array();
        for(int RbuAKHw=0; RbuAKHw < vertexBindingDescriptionCount; RbuAKHw++){
            [&](){
            auto& temp=arr_ZGQrPce[RbuAKHw].as_object();
            deserialize_struct(temp,temp_mnrvCzp[RbuAKHw]);
            }();
        }
        }();pVertexBindingDescriptions=temp_mnrvCzp;}();
uint32_t vertexAttributeDescriptionCount;
[&](){vertexAttributeDescriptionCount=static_cast<uint32_t>(value_to<int>(json["vertexAttributeDescriptionCount"]));}();
VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions;
[&](){ VkVertexInputAttributeDescription2EXT* temp_jfTEhSC[&](){
            if (json["pVertexAttributeDescriptions"].as_array().size()==0){
                temp_jfTEhSC=NULL;
            return; }temp_jfTEhSC=(VkVertexInputAttributeDescription2EXT*)malloc(vertexAttributeDescriptionCount*sizeof(VkVertexInputAttributeDescription2EXT));
        auto& arr_CiNLRoW=json["pVertexAttributeDescriptions"].as_array();
        for(int OKcAyyi=0; OKcAyyi < vertexAttributeDescriptionCount; OKcAyyi++){
            [&](){
            auto& temp=arr_CiNLRoW[OKcAyyi].as_object();
            deserialize_struct(temp,temp_jfTEhSC[OKcAyyi]);
            }();
        }
        }();pVertexAttributeDescriptions=temp_jfTEhSC;}();

    PFN_vkCmdSetVertexInputEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetVertexInputEXT)get_instance_proc_addr(parent,"vkCmdSetVertexInputEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetVertexInputEXT)get_device_proc_addr(parent,"vkCmdSetVertexInputEXT");
    }  
    
{
call_function(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexBindingDescriptionCount"]=vertexBindingDescriptionCount;}();
[&](){
            if (pVertexBindingDescriptions==NULL){
                json["pVertexBindingDescriptions"]=boost::json::array();
            return; }
        auto& arr_CLcpEBv=json["pVertexBindingDescriptions"].emplace_array();
        for(int BlSYyCp=0; BlSYyCp < vertexBindingDescriptionCount; BlSYyCp++){
            [&](){
            auto& temp=arr_CLcpEBv[BlSYyCp].emplace_object();
            return serialize_struct(temp, pVertexBindingDescriptions[BlSYyCp]);
            }();
        }
        }();
[&](){json["vertexAttributeDescriptionCount"]=vertexAttributeDescriptionCount;}();
[&](){
            if (pVertexAttributeDescriptions==NULL){
                json["pVertexAttributeDescriptions"]=boost::json::array();
            return; }
        auto& arr_nigNRkL=json["pVertexAttributeDescriptions"].emplace_array();
        for(int UWEyBUU=0; UWEyBUU < vertexAttributeDescriptionCount; UWEyBUU++){
            [&](){
            auto& temp=arr_nigNRkL[UWEyBUU].emplace_object();
            return serialize_struct(temp, pVertexAttributeDescriptions[UWEyBUU]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetColorWriteEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t attachmentCount;
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();
VkBool32* pColorWriteEnables;
[&](){ VkBool32* temp_pvsxOXt[&](){
            if (json["pColorWriteEnables"].as_array().size()==0){
                temp_pvsxOXt=NULL;
            return; }temp_pvsxOXt=(VkBool32*)malloc(attachmentCount*sizeof(VkBool32));
        auto& arr_KEXhgIr=json["pColorWriteEnables"].as_array();
        for(int vEjtLXo=0; vEjtLXo < attachmentCount; vEjtLXo++){
            [&](){uint32_t temp_KEXhgIr;[&](){temp_KEXhgIr=static_cast<uint32_t>(value_to<int>(arr_KEXhgIr[vEjtLXo]));}();temp_pvsxOXt[vEjtLXo]=(VkBool32)temp_KEXhgIr;}();
        }
        }();pColorWriteEnables=temp_pvsxOXt;}();

    PFN_vkCmdSetColorWriteEnableEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorWriteEnableEXT)get_instance_proc_addr(parent,"vkCmdSetColorWriteEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorWriteEnableEXT)get_device_proc_addr(parent,"vkCmdSetColorWriteEnableEXT");
    }  
    
{
call_function(commandBuffer, attachmentCount, pColorWriteEnables);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorWriteEnables==NULL){
                json["pColorWriteEnables"]=boost::json::array();
            return; }
        auto& arr_jmtmyTP=json["pColorWriteEnables"].emplace_array();
        for(int yHXwpvy=0; yHXwpvy < attachmentCount; yHXwpvy++){
            [&](){[&](){arr_jmtmyTP[yHXwpvy]=pColorWriteEnables[yHXwpvy];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetEvent2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkDependencyInfo* pDependencyInfo;
[&](){ VkDependencyInfo* temp_ANnuVHA[&](){
            if (json["pDependencyInfo"].as_array().size()==0){
                temp_ANnuVHA=NULL;
            return; }temp_ANnuVHA=(VkDependencyInfo*)malloc(1*sizeof(VkDependencyInfo));
        auto& arr_rdDuAVo=json["pDependencyInfo"].as_array();
        for(int WSueWEw=0; WSueWEw < 1; WSueWEw++){
            [&](){
            auto& temp=arr_rdDuAVo[WSueWEw].as_object();
            deserialize_struct(temp,temp_ANnuVHA[WSueWEw]);
            }();
        }
        }();pDependencyInfo=temp_ANnuVHA;}();

    PFN_vkCmdSetEvent2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetEvent2)get_instance_proc_addr(parent,"vkCmdSetEvent2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetEvent2)get_device_proc_addr(parent,"vkCmdSetEvent2");
    }  
    
{
call_function(commandBuffer, event, pDependencyInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=boost::json::array();
            return; }
        auto& arr_RUiZhht=json["pDependencyInfo"].emplace_array();
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto& temp=arr_RUiZhht[rtSvYgr].emplace_object();
            return serialize_struct(temp, pDependencyInfo[rtSvYgr]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdResetEvent2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkPipelineStageFlags2 stageMask;
[&](){[&](){int temp_bRKcCBq;[&](){temp_bRKcCBq=static_cast<int>(value_to<int>(json["stageMask"]));}();stageMask=(VkPipelineStageFlags2)temp_bRKcCBq;}();}();

    PFN_vkCmdResetEvent2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResetEvent2)get_instance_proc_addr(parent,"vkCmdResetEvent2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResetEvent2)get_device_proc_addr(parent,"vkCmdResetEvent2");
    }  
    
{
call_function(commandBuffer, event, stageMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdWaitEvents2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t eventCount;
[&](){eventCount=static_cast<uint32_t>(value_to<int>(json["eventCount"]));}();
VkEvent* pEvents;
[&](){ VkEvent* temp_DnisCCa[&](){
            if (json["pEvents"].as_array().size()==0){
                temp_DnisCCa=NULL;
            return; }temp_DnisCCa=(VkEvent*)malloc(eventCount*sizeof(VkEvent));
        auto& arr_QYtHNne=json["pEvents"].as_array();
        for(int RuhNVwi=0; RuhNVwi < eventCount; RuhNVwi++){
            [&](){deserialize_VkEvent(arr_QYtHNne[RuhNVwi], temp_DnisCCa[RuhNVwi]);}();
        }
        }();pEvents=temp_DnisCCa;}();
VkDependencyInfo* pDependencyInfos;
[&](){ VkDependencyInfo* temp_bQpYnoe[&](){
            if (json["pDependencyInfos"].as_array().size()==0){
                temp_bQpYnoe=NULL;
            return; }temp_bQpYnoe=(VkDependencyInfo*)malloc(eventCount*sizeof(VkDependencyInfo));
        auto& arr_ldOSlic=json["pDependencyInfos"].as_array();
        for(int aTqXMab=0; aTqXMab < eventCount; aTqXMab++){
            [&](){
            auto& temp=arr_ldOSlic[aTqXMab].as_object();
            deserialize_struct(temp,temp_bQpYnoe[aTqXMab]);
            }();
        }
        }();pDependencyInfos=temp_bQpYnoe;}();

    PFN_vkCmdWaitEvents2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWaitEvents2)get_instance_proc_addr(parent,"vkCmdWaitEvents2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWaitEvents2)get_device_proc_addr(parent,"vkCmdWaitEvents2");
    }  
    
{
call_function(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=eventCount;}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=boost::json::array();
            return; }
        auto& arr_tUuyOPJ=json["pEvents"].emplace_array();
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        }();
[&](){
            if (pDependencyInfos==NULL){
                json["pDependencyInfos"]=boost::json::array();
            return; }
        auto& arr_ZVkfhDe=json["pDependencyInfos"].emplace_array();
        for(int jvYalYw=0; jvYalYw < eventCount; jvYalYw++){
            [&](){
            auto& temp=arr_ZVkfhDe[jvYalYw].emplace_object();
            return serialize_struct(temp, pDependencyInfos[jvYalYw]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdPipelineBarrier2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDependencyInfo* pDependencyInfo;
[&](){ VkDependencyInfo* temp_ANnuVHA[&](){
            if (json["pDependencyInfo"].as_array().size()==0){
                temp_ANnuVHA=NULL;
            return; }temp_ANnuVHA=(VkDependencyInfo*)malloc(1*sizeof(VkDependencyInfo));
        auto& arr_rdDuAVo=json["pDependencyInfo"].as_array();
        for(int WSueWEw=0; WSueWEw < 1; WSueWEw++){
            [&](){
            auto& temp=arr_rdDuAVo[WSueWEw].as_object();
            deserialize_struct(temp,temp_ANnuVHA[WSueWEw]);
            }();
        }
        }();pDependencyInfo=temp_ANnuVHA;}();

    PFN_vkCmdPipelineBarrier2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPipelineBarrier2)get_instance_proc_addr(parent,"vkCmdPipelineBarrier2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPipelineBarrier2)get_device_proc_addr(parent,"vkCmdPipelineBarrier2");
    }  
    
{
call_function(commandBuffer, pDependencyInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=boost::json::array();
            return; }
        auto& arr_RUiZhht=json["pDependencyInfo"].emplace_array();
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto& temp=arr_RUiZhht[rtSvYgr].emplace_object();
            return serialize_struct(temp, pDependencyInfo[rtSvYgr]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkQueueSubmit2(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t submitCount;
[&](){submitCount=static_cast<uint32_t>(value_to<int>(json["submitCount"]));}();
VkSubmitInfo2* pSubmits;
[&](){ VkSubmitInfo2* temp_zRsIHWq[&](){
            if (json["pSubmits"].as_array().size()==0){
                temp_zRsIHWq=NULL;
            return; }temp_zRsIHWq=(VkSubmitInfo2*)malloc(submitCount*sizeof(VkSubmitInfo2));
        auto& arr_mzfyWou=json["pSubmits"].as_array();
        for(int ozkbIJW=0; ozkbIJW < submitCount; ozkbIJW++){
            [&](){
            auto& temp=arr_mzfyWou[ozkbIJW].as_object();
            deserialize_struct(temp,temp_zRsIHWq[ozkbIJW]);
            }();
        }
        }();pSubmits=temp_zRsIHWq;}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkQueueSubmit2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueSubmit2)get_instance_proc_addr(parent,"vkQueueSubmit2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueSubmit2)get_device_proc_addr(parent,"vkQueueSubmit2");
    }  
    
{
auto result=call_function(queue, submitCount, pSubmits, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=submitCount;}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=boost::json::array();
            return; }
        auto& arr_shQKWeV=json["pSubmits"].emplace_array();
        for(int uwYUklT=0; uwYUklT < submitCount; uwYUklT++){
            [&](){
            auto& temp=arr_shQKWeV[uwYUklT].emplace_object();
            return serialize_struct(temp, pSubmits[uwYUklT]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();


        writeToConn(json);
    }

    void handle_vkCmdWriteTimestamp2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlags2 stage;
[&](){[&](){int temp_XkgNLEZ;[&](){temp_XkgNLEZ=static_cast<int>(value_to<int>(json["stage"]));}();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();

    PFN_vkCmdWriteTimestamp2 call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteTimestamp2)get_instance_proc_addr(parent,"vkCmdWriteTimestamp2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteTimestamp2)get_device_proc_addr(parent,"vkCmdWriteTimestamp2");
    }  
    
{
call_function(commandBuffer, stage, queryPool, query);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=stage;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();


        writeToConn(json);
    }

    void handle_vkCmdWriteBufferMarker2AMD(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlags2 stage;
[&](){[&](){int temp_XkgNLEZ;[&](){temp_XkgNLEZ=static_cast<int>(value_to<int>(json["stage"]));}();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
uint32_t marker;
[&](){marker=static_cast<uint32_t>(value_to<int>(json["marker"]));}();

    PFN_vkCmdWriteBufferMarker2AMD call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteBufferMarker2AMD)get_instance_proc_addr(parent,"vkCmdWriteBufferMarker2AMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteBufferMarker2AMD)get_device_proc_addr(parent,"vkCmdWriteBufferMarker2AMD");
    }  
    
{
call_function(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=stage;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){json["marker"]=marker;}();


        writeToConn(json);
    }

    void handle_vkGetQueueCheckpointData2NV(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t* pCheckpointDataCount;
[&](){
            if (json["pCheckpointDataCount"].as_array().size()==0){
                pCheckpointDataCount=NULL;
            return; }pCheckpointDataCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].as_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(value_to<int>(arr_LsYqVIK[lgasnOP]));}();
        }
        }();
VkCheckpointData2NV* pCheckpointData;
[&](){
            if (json["pCheckpointData"].as_array().size()==0){
                pCheckpointData=NULL;
            return; }pCheckpointData=(VkCheckpointData2NV*)malloc(*pCheckpointDataCount*sizeof(VkCheckpointData2NV));
        auto& arr_jIvYyZg=json["pCheckpointData"].as_array();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto& temp=arr_jIvYyZg[yGwfptp].as_object();
            deserialize_struct(temp,pCheckpointData[yGwfptp]);
            }();
        }
        }();

    PFN_vkGetQueueCheckpointData2NV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetQueueCheckpointData2NV)get_instance_proc_addr(parent,"vkGetQueueCheckpointData2NV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetQueueCheckpointData2NV)get_device_proc_addr(parent,"vkGetQueueCheckpointData2NV");
    }  
    
{
call_function(queue, pCheckpointDataCount, pCheckpointData);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=boost::json::array();
            return; }
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].emplace_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=pCheckpointDataCount[lgasnOP];}();
        }
        }();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=boost::json::array();
            return; }
        auto& arr_jIvYyZg=json["pCheckpointData"].emplace_array();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto& temp=arr_jIvYyZg[yGwfptp].emplace_object();
            return serialize_struct(temp, pCheckpointData[yGwfptp]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCopyMemoryToImageEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo;
[&](){ VkCopyMemoryToImageInfoEXT* temp_czYuFVd[&](){
            if (json["pCopyMemoryToImageInfo"].as_array().size()==0){
                temp_czYuFVd=NULL;
            return; }temp_czYuFVd=(VkCopyMemoryToImageInfoEXT*)malloc(1*sizeof(VkCopyMemoryToImageInfoEXT));
        auto& arr_uGpCetH=json["pCopyMemoryToImageInfo"].as_array();
        for(int LeBHPTF=0; LeBHPTF < 1; LeBHPTF++){
            [&](){
            auto& temp=arr_uGpCetH[LeBHPTF].as_object();
            deserialize_struct(temp,temp_czYuFVd[LeBHPTF]);
            }();
        }
        }();pCopyMemoryToImageInfo=temp_czYuFVd;}();

    PFN_vkCopyMemoryToImageEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMemoryToImageEXT)get_instance_proc_addr(parent,"vkCopyMemoryToImageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMemoryToImageEXT)get_device_proc_addr(parent,"vkCopyMemoryToImageEXT");
    }  
    
{
auto result=call_function(device, pCopyMemoryToImageInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyMemoryToImageInfo==NULL){
                json["pCopyMemoryToImageInfo"]=boost::json::array();
            return; }
        auto& arr_VVrQQGW=json["pCopyMemoryToImageInfo"].emplace_array();
        for(int pVINPWa=0; pVINPWa < 1; pVINPWa++){
            [&](){
            auto& temp=arr_VVrQQGW[pVINPWa].emplace_object();
            return serialize_struct(temp, pCopyMemoryToImageInfo[pVINPWa]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCopyImageToMemoryEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo;
[&](){ VkCopyImageToMemoryInfoEXT* temp_eSmguRR[&](){
            if (json["pCopyImageToMemoryInfo"].as_array().size()==0){
                temp_eSmguRR=NULL;
            return; }temp_eSmguRR=(VkCopyImageToMemoryInfoEXT*)malloc(1*sizeof(VkCopyImageToMemoryInfoEXT));
        auto& arr_JjXseiq=json["pCopyImageToMemoryInfo"].as_array();
        for(int zMfiotL=0; zMfiotL < 1; zMfiotL++){
            [&](){
            auto& temp=arr_JjXseiq[zMfiotL].as_object();
            deserialize_struct(temp,temp_eSmguRR[zMfiotL]);
            }();
        }
        }();pCopyImageToMemoryInfo=temp_eSmguRR;}();

    PFN_vkCopyImageToMemoryEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyImageToMemoryEXT)get_instance_proc_addr(parent,"vkCopyImageToMemoryEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyImageToMemoryEXT)get_device_proc_addr(parent,"vkCopyImageToMemoryEXT");
    }  
    
{
auto result=call_function(device, pCopyImageToMemoryInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToMemoryInfo==NULL){
                json["pCopyImageToMemoryInfo"]=boost::json::array();
            return; }
        auto& arr_uAVSOVI=json["pCopyImageToMemoryInfo"].emplace_array();
        for(int vveMAPG=0; vveMAPG < 1; vveMAPG++){
            [&](){
            auto& temp=arr_uAVSOVI[vveMAPG].emplace_object();
            return serialize_struct(temp, pCopyImageToMemoryInfo[vveMAPG]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCopyImageToImageEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCopyImageToImageInfoEXT* pCopyImageToImageInfo;
[&](){ VkCopyImageToImageInfoEXT* temp_ocaImgM[&](){
            if (json["pCopyImageToImageInfo"].as_array().size()==0){
                temp_ocaImgM=NULL;
            return; }temp_ocaImgM=(VkCopyImageToImageInfoEXT*)malloc(1*sizeof(VkCopyImageToImageInfoEXT));
        auto& arr_WKQiAFF=json["pCopyImageToImageInfo"].as_array();
        for(int kaVefuU=0; kaVefuU < 1; kaVefuU++){
            [&](){
            auto& temp=arr_WKQiAFF[kaVefuU].as_object();
            deserialize_struct(temp,temp_ocaImgM[kaVefuU]);
            }();
        }
        }();pCopyImageToImageInfo=temp_ocaImgM;}();

    PFN_vkCopyImageToImageEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyImageToImageEXT)get_instance_proc_addr(parent,"vkCopyImageToImageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyImageToImageEXT)get_device_proc_addr(parent,"vkCopyImageToImageEXT");
    }  
    
{
auto result=call_function(device, pCopyImageToImageInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToImageInfo==NULL){
                json["pCopyImageToImageInfo"]=boost::json::array();
            return; }
        auto& arr_mMvIKFh=json["pCopyImageToImageInfo"].emplace_array();
        for(int vOMFrGb=0; vOMFrGb < 1; vOMFrGb++){
            [&](){
            auto& temp=arr_mMvIKFh[vOMFrGb].emplace_object();
            return serialize_struct(temp, pCopyImageToImageInfo[vOMFrGb]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkTransitionImageLayoutEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t transitionCount;
[&](){transitionCount=static_cast<uint32_t>(value_to<int>(json["transitionCount"]));}();
VkHostImageLayoutTransitionInfoEXT* pTransitions;
[&](){ VkHostImageLayoutTransitionInfoEXT* temp_trVvZZY[&](){
            if (json["pTransitions"].as_array().size()==0){
                temp_trVvZZY=NULL;
            return; }temp_trVvZZY=(VkHostImageLayoutTransitionInfoEXT*)malloc(transitionCount*sizeof(VkHostImageLayoutTransitionInfoEXT));
        auto& arr_kGKdcAG=json["pTransitions"].as_array();
        for(int mCqQGEL=0; mCqQGEL < transitionCount; mCqQGEL++){
            [&](){
            auto& temp=arr_kGKdcAG[mCqQGEL].as_object();
            deserialize_struct(temp,temp_trVvZZY[mCqQGEL]);
            }();
        }
        }();pTransitions=temp_trVvZZY;}();

    PFN_vkTransitionImageLayoutEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkTransitionImageLayoutEXT)get_instance_proc_addr(parent,"vkTransitionImageLayoutEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkTransitionImageLayoutEXT)get_device_proc_addr(parent,"vkTransitionImageLayoutEXT");
    }  
    
{
auto result=call_function(device, transitionCount, pTransitions);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["transitionCount"]=transitionCount;}();
[&](){
            if (pTransitions==NULL){
                json["pTransitions"]=boost::json::array();
            return; }
        auto& arr_KQaENWu=json["pTransitions"].emplace_array();
        for(int EeppCgm=0; EeppCgm < transitionCount; EeppCgm++){
            [&](){
            auto& temp=arr_KQaENWu[EeppCgm].emplace_object();
            return serialize_struct(temp, pTransitions[EeppCgm]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceVideoCapabilitiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkVideoProfileInfoKHR* pVideoProfile;
[&](){ VkVideoProfileInfoKHR* temp_jRYVPfH[&](){
            if (json["pVideoProfile"].as_array().size()==0){
                temp_jRYVPfH=NULL;
            return; }temp_jRYVPfH=(VkVideoProfileInfoKHR*)malloc(1*sizeof(VkVideoProfileInfoKHR));
        auto& arr_LQJyXAW=json["pVideoProfile"].as_array();
        for(int AyTOixj=0; AyTOixj < 1; AyTOixj++){
            [&](){
            auto& temp=arr_LQJyXAW[AyTOixj].as_object();
            deserialize_struct(temp,temp_jRYVPfH[AyTOixj]);
            }();
        }
        }();pVideoProfile=temp_jRYVPfH;}();
VkVideoCapabilitiesKHR* pCapabilities;
[&](){
            if (json["pCapabilities"].as_array().size()==0){
                pCapabilities=NULL;
            return; }pCapabilities=(VkVideoCapabilitiesKHR*)malloc(1*sizeof(VkVideoCapabilitiesKHR));
        auto& arr_rprZzlH=json["pCapabilities"].as_array();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto& temp=arr_rprZzlH[NPLkdlm].as_object();
            deserialize_struct(temp,pCapabilities[NPLkdlm]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceVideoCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceVideoCapabilitiesKHR");
    }  
    
{
auto result=call_function(physicalDevice, pVideoProfile, pCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoProfile==NULL){
                json["pVideoProfile"]=boost::json::array();
            return; }
        auto& arr_eFObkVe=json["pVideoProfile"].emplace_array();
        for(int YJbJtas=0; YJbJtas < 1; YJbJtas++){
            [&](){
            auto& temp=arr_eFObkVe[YJbJtas].emplace_object();
            return serialize_struct(temp, pVideoProfile[YJbJtas]);
            }();
        }
        }();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }
        auto& arr_rprZzlH=json["pCapabilities"].emplace_array();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto& temp=arr_rprZzlH[NPLkdlm].emplace_object();
            return serialize_struct(temp, pCapabilities[NPLkdlm]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceVideoFormatPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo;
[&](){ VkPhysicalDeviceVideoFormatInfoKHR* temp_HMvmjPo[&](){
            if (json["pVideoFormatInfo"].as_array().size()==0){
                temp_HMvmjPo=NULL;
            return; }temp_HMvmjPo=(VkPhysicalDeviceVideoFormatInfoKHR*)malloc(1*sizeof(VkPhysicalDeviceVideoFormatInfoKHR));
        auto& arr_JCeubLO=json["pVideoFormatInfo"].as_array();
        for(int aVxBrFp=0; aVxBrFp < 1; aVxBrFp++){
            [&](){
            auto& temp=arr_JCeubLO[aVxBrFp].as_object();
            deserialize_struct(temp,temp_HMvmjPo[aVxBrFp]);
            }();
        }
        }();pVideoFormatInfo=temp_HMvmjPo;}();
uint32_t* pVideoFormatPropertyCount;
[&](){
            if (json["pVideoFormatPropertyCount"].as_array().size()==0){
                pVideoFormatPropertyCount=NULL;
            return; }pVideoFormatPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].as_array();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(value_to<int>(arr_kJoqfTP[hCeCDXk]));}();
        }
        }();
VkVideoFormatPropertiesKHR* pVideoFormatProperties;
[&](){
            if (json["pVideoFormatProperties"].as_array().size()==0){
                pVideoFormatProperties=NULL;
            return; }pVideoFormatProperties=(VkVideoFormatPropertiesKHR*)malloc(*pVideoFormatPropertyCount*sizeof(VkVideoFormatPropertiesKHR));
        auto& arr_GhjQGHj=json["pVideoFormatProperties"].as_array();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto& temp=arr_GhjQGHj[mUXWOpX].as_object();
            deserialize_struct(temp,pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceVideoFormatPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceVideoFormatPropertiesKHR");
    }  
    
{
auto result=call_function(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoFormatInfo==NULL){
                json["pVideoFormatInfo"]=boost::json::array();
            return; }
        auto& arr_JJWKnHz=json["pVideoFormatInfo"].emplace_array();
        for(int FIocPZR=0; FIocPZR < 1; FIocPZR++){
            [&](){
            auto& temp=arr_JJWKnHz[FIocPZR].emplace_object();
            return serialize_struct(temp, pVideoFormatInfo[FIocPZR]);
            }();
        }
        }();
[&](){
            if (pVideoFormatPropertyCount==NULL){
                json["pVideoFormatPropertyCount"]=boost::json::array();
            return; }
        auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].emplace_array();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){arr_kJoqfTP[hCeCDXk]=pVideoFormatPropertyCount[hCeCDXk];}();
        }
        }();
[&](){
            if (pVideoFormatProperties==NULL){
                json["pVideoFormatProperties"]=boost::json::array();
            return; }
        auto& arr_GhjQGHj=json["pVideoFormatProperties"].emplace_array();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto& temp=arr_GhjQGHj[mUXWOpX].emplace_object();
            return serialize_struct(temp, pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateVideoSessionKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionCreateInfoKHR* pCreateInfo;
[&](){ VkVideoSessionCreateInfoKHR* temp_GSTOFkn[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_GSTOFkn=NULL;
            return; }temp_GSTOFkn=(VkVideoSessionCreateInfoKHR*)malloc(1*sizeof(VkVideoSessionCreateInfoKHR));
        auto& arr_wPbwQCK=json["pCreateInfo"].as_array();
        for(int YSXcLgo=0; YSXcLgo < 1; YSXcLgo++){
            [&](){
            auto& temp=arr_wPbwQCK[YSXcLgo].as_object();
            deserialize_struct(temp,temp_GSTOFkn[YSXcLgo]);
            }();
        }
        }();pCreateInfo=temp_GSTOFkn;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkVideoSessionKHR* pVideoSession;
[&](){
            if (json["pVideoSession"].as_array().size()==0){
                pVideoSession=NULL;
            return; }pVideoSession=(VkVideoSessionKHR*)malloc(1*sizeof(VkVideoSessionKHR));
        auto& arr_YUuHYdT=json["pVideoSession"].as_array();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){deserialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX], pVideoSession[SJFoYbX]);}();
        }
        }();

    PFN_vkCreateVideoSessionKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateVideoSessionKHR)get_instance_proc_addr(parent,"vkCreateVideoSessionKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateVideoSessionKHR)get_device_proc_addr(parent,"vkCreateVideoSessionKHR");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pVideoSession);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_mCuZMrp=json["pCreateInfo"].emplace_array();
        for(int tsYbFnY=0; tsYbFnY < 1; tsYbFnY++){
            [&](){
            auto& temp=arr_mCuZMrp[tsYbFnY].emplace_object();
            return serialize_struct(temp, pCreateInfo[tsYbFnY]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pVideoSession==NULL){
                json["pVideoSession"]=boost::json::array();
            return; }
        auto& arr_YUuHYdT=json["pVideoSession"].emplace_array();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){serialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX],pVideoSession[SJFoYbX]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyVideoSessionKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionKHR videoSession;
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyVideoSessionKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyVideoSessionKHR)get_instance_proc_addr(parent,"vkDestroyVideoSessionKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyVideoSessionKHR)get_device_proc_addr(parent,"vkDestroyVideoSessionKHR");
    }  
    
{
call_function(device, videoSession, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateVideoSessionParametersKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionParametersCreateInfoKHR* pCreateInfo;
[&](){ VkVideoSessionParametersCreateInfoKHR* temp_TeFAIZF[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_TeFAIZF=NULL;
            return; }temp_TeFAIZF=(VkVideoSessionParametersCreateInfoKHR*)malloc(1*sizeof(VkVideoSessionParametersCreateInfoKHR));
        auto& arr_orBbBzS=json["pCreateInfo"].as_array();
        for(int BFSvJhy=0; BFSvJhy < 1; BFSvJhy++){
            [&](){
            auto& temp=arr_orBbBzS[BFSvJhy].as_object();
            deserialize_struct(temp,temp_TeFAIZF[BFSvJhy]);
            }();
        }
        }();pCreateInfo=temp_TeFAIZF;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkVideoSessionParametersKHR* pVideoSessionParameters;
[&](){
            if (json["pVideoSessionParameters"].as_array().size()==0){
                pVideoSessionParameters=NULL;
            return; }pVideoSessionParameters=(VkVideoSessionParametersKHR*)malloc(1*sizeof(VkVideoSessionParametersKHR));
        auto& arr_drxJQhO=json["pVideoSessionParameters"].as_array();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){deserialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP], pVideoSessionParameters[VQDtlbP]);}();
        }
        }();

    PFN_vkCreateVideoSessionParametersKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateVideoSessionParametersKHR)get_instance_proc_addr(parent,"vkCreateVideoSessionParametersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateVideoSessionParametersKHR)get_device_proc_addr(parent,"vkCreateVideoSessionParametersKHR");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pVideoSessionParameters);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_PbbIaMM=json["pCreateInfo"].emplace_array();
        for(int uFIOrHK=0; uFIOrHK < 1; uFIOrHK++){
            [&](){
            auto& temp=arr_PbbIaMM[uFIOrHK].emplace_object();
            return serialize_struct(temp, pCreateInfo[uFIOrHK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pVideoSessionParameters==NULL){
                json["pVideoSessionParameters"]=boost::json::array();
            return; }
        auto& arr_drxJQhO=json["pVideoSessionParameters"].emplace_array();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){serialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP],pVideoSessionParameters[VQDtlbP]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkUpdateVideoSessionParametersKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionParametersKHR videoSessionParameters;
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();
VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo;
[&](){ VkVideoSessionParametersUpdateInfoKHR* temp_epoZYqK[&](){
            if (json["pUpdateInfo"].as_array().size()==0){
                temp_epoZYqK=NULL;
            return; }temp_epoZYqK=(VkVideoSessionParametersUpdateInfoKHR*)malloc(1*sizeof(VkVideoSessionParametersUpdateInfoKHR));
        auto& arr_ErkRXpw=json["pUpdateInfo"].as_array();
        for(int wrcSXFx=0; wrcSXFx < 1; wrcSXFx++){
            [&](){
            auto& temp=arr_ErkRXpw[wrcSXFx].as_object();
            deserialize_struct(temp,temp_epoZYqK[wrcSXFx]);
            }();
        }
        }();pUpdateInfo=temp_epoZYqK;}();

    PFN_vkUpdateVideoSessionParametersKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUpdateVideoSessionParametersKHR)get_instance_proc_addr(parent,"vkUpdateVideoSessionParametersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUpdateVideoSessionParametersKHR)get_device_proc_addr(parent,"vkUpdateVideoSessionParametersKHR");
    }  
    
{
auto result=call_function(device, videoSessionParameters, pUpdateInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pUpdateInfo==NULL){
                json["pUpdateInfo"]=boost::json::array();
            return; }
        auto& arr_miOYaCQ=json["pUpdateInfo"].emplace_array();
        for(int gnypMkA=0; gnypMkA < 1; gnypMkA++){
            [&](){
            auto& temp=arr_miOYaCQ[gnypMkA].emplace_object();
            return serialize_struct(temp, pUpdateInfo[gnypMkA]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyVideoSessionParametersKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionParametersKHR videoSessionParameters;
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyVideoSessionParametersKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyVideoSessionParametersKHR)get_instance_proc_addr(parent,"vkDestroyVideoSessionParametersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyVideoSessionParametersKHR)get_device_proc_addr(parent,"vkDestroyVideoSessionParametersKHR");
    }  
    
{
call_function(device, videoSessionParameters, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetVideoSessionMemoryRequirementsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionKHR videoSession;
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
uint32_t* pMemoryRequirementsCount;
[&](){
            if (json["pMemoryRequirementsCount"].as_array().size()==0){
                pMemoryRequirementsCount=NULL;
            return; }pMemoryRequirementsCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_pJPineF=json["pMemoryRequirementsCount"].as_array();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(value_to<int>(arr_pJPineF[NMpDmPR]));}();
        }
        }();
VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkVideoSessionMemoryRequirementsKHR*)malloc(*pMemoryRequirementsCount*sizeof(VkVideoSessionMemoryRequirementsKHR));
        auto& arr_UuJQZUu=json["pMemoryRequirements"].as_array();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto& temp=arr_UuJQZUu[FfNBlzG].as_object();
            deserialize_struct(temp,pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();

    PFN_vkGetVideoSessionMemoryRequirementsKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetVideoSessionMemoryRequirementsKHR)get_instance_proc_addr(parent,"vkGetVideoSessionMemoryRequirementsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetVideoSessionMemoryRequirementsKHR)get_device_proc_addr(parent,"vkGetVideoSessionMemoryRequirementsKHR");
    }  
    
{
auto result=call_function(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pMemoryRequirementsCount==NULL){
                json["pMemoryRequirementsCount"]=boost::json::array();
            return; }
        auto& arr_pJPineF=json["pMemoryRequirementsCount"].emplace_array();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){arr_pJPineF[NMpDmPR]=pMemoryRequirementsCount[NMpDmPR];}();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_UuJQZUu=json["pMemoryRequirements"].emplace_array();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto& temp=arr_UuJQZUu[FfNBlzG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBindVideoSessionMemoryKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionKHR videoSession;
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
uint32_t bindSessionMemoryInfoCount;
[&](){bindSessionMemoryInfoCount=static_cast<uint32_t>(value_to<int>(json["bindSessionMemoryInfoCount"]));}();
VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos;
[&](){ VkBindVideoSessionMemoryInfoKHR* temp_UuNkUKY[&](){
            if (json["pBindSessionMemoryInfos"].as_array().size()==0){
                temp_UuNkUKY=NULL;
            return; }temp_UuNkUKY=(VkBindVideoSessionMemoryInfoKHR*)malloc(bindSessionMemoryInfoCount*sizeof(VkBindVideoSessionMemoryInfoKHR));
        auto& arr_TbzDfjI=json["pBindSessionMemoryInfos"].as_array();
        for(int XHgqGRS=0; XHgqGRS < bindSessionMemoryInfoCount; XHgqGRS++){
            [&](){
            auto& temp=arr_TbzDfjI[XHgqGRS].as_object();
            deserialize_struct(temp,temp_UuNkUKY[XHgqGRS]);
            }();
        }
        }();pBindSessionMemoryInfos=temp_UuNkUKY;}();

    PFN_vkBindVideoSessionMemoryKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindVideoSessionMemoryKHR)get_instance_proc_addr(parent,"vkBindVideoSessionMemoryKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindVideoSessionMemoryKHR)get_device_proc_addr(parent,"vkBindVideoSessionMemoryKHR");
    }  
    
{
auto result=call_function(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){json["bindSessionMemoryInfoCount"]=bindSessionMemoryInfoCount;}();
[&](){
            if (pBindSessionMemoryInfos==NULL){
                json["pBindSessionMemoryInfos"]=boost::json::array();
            return; }
        auto& arr_XamFtca=json["pBindSessionMemoryInfos"].emplace_array();
        for(int bWiRCGV=0; bWiRCGV < bindSessionMemoryInfoCount; bWiRCGV++){
            [&](){
            auto& temp=arr_XamFtca[bWiRCGV].emplace_object();
            return serialize_struct(temp, pBindSessionMemoryInfos[bWiRCGV]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDecodeVideoKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkVideoDecodeInfoKHR* pDecodeInfo;
[&](){ VkVideoDecodeInfoKHR* temp_SieakPn[&](){
            if (json["pDecodeInfo"].as_array().size()==0){
                temp_SieakPn=NULL;
            return; }temp_SieakPn=(VkVideoDecodeInfoKHR*)malloc(1*sizeof(VkVideoDecodeInfoKHR));
        auto& arr_ewdOprb=json["pDecodeInfo"].as_array();
        for(int PPOqwvx=0; PPOqwvx < 1; PPOqwvx++){
            [&](){
            auto& temp=arr_ewdOprb[PPOqwvx].as_object();
            deserialize_struct(temp,temp_SieakPn[PPOqwvx]);
            }();
        }
        }();pDecodeInfo=temp_SieakPn;}();

    PFN_vkCmdDecodeVideoKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDecodeVideoKHR)get_instance_proc_addr(parent,"vkCmdDecodeVideoKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDecodeVideoKHR)get_device_proc_addr(parent,"vkCmdDecodeVideoKHR");
    }  
    
{
call_function(commandBuffer, pDecodeInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDecodeInfo==NULL){
                json["pDecodeInfo"]=boost::json::array();
            return; }
        auto& arr_FUuNCSo=json["pDecodeInfo"].emplace_array();
        for(int jmrOltD=0; jmrOltD < 1; jmrOltD++){
            [&](){
            auto& temp=arr_FUuNCSo[jmrOltD].emplace_object();
            return serialize_struct(temp, pDecodeInfo[jmrOltD]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBeginVideoCodingKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkVideoBeginCodingInfoKHR* pBeginInfo;
[&](){ VkVideoBeginCodingInfoKHR* temp_CpOOMpI[&](){
            if (json["pBeginInfo"].as_array().size()==0){
                temp_CpOOMpI=NULL;
            return; }temp_CpOOMpI=(VkVideoBeginCodingInfoKHR*)malloc(1*sizeof(VkVideoBeginCodingInfoKHR));
        auto& arr_YgojtMV=json["pBeginInfo"].as_array();
        for(int gEGjmEh=0; gEGjmEh < 1; gEGjmEh++){
            [&](){
            auto& temp=arr_YgojtMV[gEGjmEh].as_object();
            deserialize_struct(temp,temp_CpOOMpI[gEGjmEh]);
            }();
        }
        }();pBeginInfo=temp_CpOOMpI;}();

    PFN_vkCmdBeginVideoCodingKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginVideoCodingKHR)get_instance_proc_addr(parent,"vkCmdBeginVideoCodingKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginVideoCodingKHR)get_device_proc_addr(parent,"vkCmdBeginVideoCodingKHR");
    }  
    
{
call_function(commandBuffer, pBeginInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=boost::json::array();
            return; }
        auto& arr_pSWbqZw=json["pBeginInfo"].emplace_array();
        for(int tVSxYNW=0; tVSxYNW < 1; tVSxYNW++){
            [&](){
            auto& temp=arr_pSWbqZw[tVSxYNW].emplace_object();
            return serialize_struct(temp, pBeginInfo[tVSxYNW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdControlVideoCodingKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkVideoCodingControlInfoKHR* pCodingControlInfo;
[&](){ VkVideoCodingControlInfoKHR* temp_ynOVlWW[&](){
            if (json["pCodingControlInfo"].as_array().size()==0){
                temp_ynOVlWW=NULL;
            return; }temp_ynOVlWW=(VkVideoCodingControlInfoKHR*)malloc(1*sizeof(VkVideoCodingControlInfoKHR));
        auto& arr_QVObPIP=json["pCodingControlInfo"].as_array();
        for(int LMgTacT=0; LMgTacT < 1; LMgTacT++){
            [&](){
            auto& temp=arr_QVObPIP[LMgTacT].as_object();
            deserialize_struct(temp,temp_ynOVlWW[LMgTacT]);
            }();
        }
        }();pCodingControlInfo=temp_ynOVlWW;}();

    PFN_vkCmdControlVideoCodingKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdControlVideoCodingKHR)get_instance_proc_addr(parent,"vkCmdControlVideoCodingKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdControlVideoCodingKHR)get_device_proc_addr(parent,"vkCmdControlVideoCodingKHR");
    }  
    
{
call_function(commandBuffer, pCodingControlInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCodingControlInfo==NULL){
                json["pCodingControlInfo"]=boost::json::array();
            return; }
        auto& arr_vJmaWsp=json["pCodingControlInfo"].emplace_array();
        for(int MLwaMsn=0; MLwaMsn < 1; MLwaMsn++){
            [&](){
            auto& temp=arr_vJmaWsp[MLwaMsn].emplace_object();
            return serialize_struct(temp, pCodingControlInfo[MLwaMsn]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdEndVideoCodingKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkVideoEndCodingInfoKHR* pEndCodingInfo;
[&](){ VkVideoEndCodingInfoKHR* temp_CTywrGu[&](){
            if (json["pEndCodingInfo"].as_array().size()==0){
                temp_CTywrGu=NULL;
            return; }temp_CTywrGu=(VkVideoEndCodingInfoKHR*)malloc(1*sizeof(VkVideoEndCodingInfoKHR));
        auto& arr_ErbGsyK=json["pEndCodingInfo"].as_array();
        for(int QjqRiFV=0; QjqRiFV < 1; QjqRiFV++){
            [&](){
            auto& temp=arr_ErbGsyK[QjqRiFV].as_object();
            deserialize_struct(temp,temp_CTywrGu[QjqRiFV]);
            }();
        }
        }();pEndCodingInfo=temp_CTywrGu;}();

    PFN_vkCmdEndVideoCodingKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndVideoCodingKHR)get_instance_proc_addr(parent,"vkCmdEndVideoCodingKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndVideoCodingKHR)get_device_proc_addr(parent,"vkCmdEndVideoCodingKHR");
    }  
    
{
call_function(commandBuffer, pEndCodingInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pEndCodingInfo==NULL){
                json["pEndCodingInfo"]=boost::json::array();
            return; }
        auto& arr_OpexQSo=json["pEndCodingInfo"].emplace_array();
        for(int KxwYkSG=0; KxwYkSG < 1; KxwYkSG++){
            [&](){
            auto& temp=arr_OpexQSo[KxwYkSG].emplace_object();
            return serialize_struct(temp, pEndCodingInfo[KxwYkSG]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDecompressMemoryNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t decompressRegionCount;
[&](){decompressRegionCount=static_cast<uint32_t>(value_to<int>(json["decompressRegionCount"]));}();
VkDecompressMemoryRegionNV* pDecompressMemoryRegions;
[&](){ VkDecompressMemoryRegionNV* temp_LfXQByJ[&](){
            if (json["pDecompressMemoryRegions"].as_array().size()==0){
                temp_LfXQByJ=NULL;
            return; }temp_LfXQByJ=(VkDecompressMemoryRegionNV*)malloc(decompressRegionCount*sizeof(VkDecompressMemoryRegionNV));
        auto& arr_VAyqSbG=json["pDecompressMemoryRegions"].as_array();
        for(int EZVrxlF=0; EZVrxlF < decompressRegionCount; EZVrxlF++){
            [&](){
            auto& temp=arr_VAyqSbG[EZVrxlF].as_object();
            deserialize_struct(temp,temp_LfXQByJ[EZVrxlF]);
            }();
        }
        }();pDecompressMemoryRegions=temp_LfXQByJ;}();

    PFN_vkCmdDecompressMemoryNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDecompressMemoryNV)get_instance_proc_addr(parent,"vkCmdDecompressMemoryNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDecompressMemoryNV)get_device_proc_addr(parent,"vkCmdDecompressMemoryNV");
    }  
    
{
call_function(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["decompressRegionCount"]=decompressRegionCount;}();
[&](){
            if (pDecompressMemoryRegions==NULL){
                json["pDecompressMemoryRegions"]=boost::json::array();
            return; }
        auto& arr_oMszjDS=json["pDecompressMemoryRegions"].emplace_array();
        for(int PnFzdhd=0; PnFzdhd < decompressRegionCount; PnFzdhd++){
            [&](){
            auto& temp=arr_oMszjDS[PnFzdhd].emplace_object();
            return serialize_struct(temp, pDecompressMemoryRegions[PnFzdhd]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdDecompressMemoryIndirectCountNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress indirectCommandsAddress;
[&](){uint64_t temp_nwmsRdL;[&](){temp_nwmsRdL=static_cast<uint64_t>(value_to<int>(json["indirectCommandsAddress"]));}();indirectCommandsAddress=(VkDeviceAddress)temp_nwmsRdL;}();
VkDeviceAddress indirectCommandsCountAddress;
[&](){uint64_t temp_TcxQHrV;[&](){temp_TcxQHrV=static_cast<uint64_t>(value_to<int>(json["indirectCommandsCountAddress"]));}();indirectCommandsCountAddress=(VkDeviceAddress)temp_TcxQHrV;}();
uint32_t stride;
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

    PFN_vkCmdDecompressMemoryIndirectCountNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDecompressMemoryIndirectCountNV)get_instance_proc_addr(parent,"vkCmdDecompressMemoryIndirectCountNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDecompressMemoryIndirectCountNV)get_device_proc_addr(parent,"vkCmdDecompressMemoryIndirectCountNV");
    }  
    
{
call_function(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectCommandsAddress"]=indirectCommandsAddress;}();}();
[&](){[&](){json["indirectCommandsCountAddress"]=indirectCommandsCountAddress;}();}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkCreateCuModuleNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCuModuleCreateInfoNVX* pCreateInfo;
[&](){ VkCuModuleCreateInfoNVX* temp_JUpJYYI[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_JUpJYYI=NULL;
            return; }temp_JUpJYYI=(VkCuModuleCreateInfoNVX*)malloc(1*sizeof(VkCuModuleCreateInfoNVX));
        auto& arr_hMoVXkn=json["pCreateInfo"].as_array();
        for(int cihZnwL=0; cihZnwL < 1; cihZnwL++){
            [&](){
            auto& temp=arr_hMoVXkn[cihZnwL].as_object();
            deserialize_struct(temp,temp_JUpJYYI[cihZnwL]);
            }();
        }
        }();pCreateInfo=temp_JUpJYYI;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkCuModuleNVX* pModule;
[&](){
            if (json["pModule"].as_array().size()==0){
                pModule=NULL;
            return; }pModule=(VkCuModuleNVX*)malloc(1*sizeof(VkCuModuleNVX));
        auto& arr_FnQIexZ=json["pModule"].as_array();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){deserialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko], pModule[ozltKko]);}();
        }
        }();

    PFN_vkCreateCuModuleNVX call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateCuModuleNVX)get_instance_proc_addr(parent,"vkCreateCuModuleNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateCuModuleNVX)get_device_proc_addr(parent,"vkCreateCuModuleNVX");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pModule);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_FjdqPXh=json["pCreateInfo"].emplace_array();
        for(int TUVhIjf=0; TUVhIjf < 1; TUVhIjf++){
            [&](){
            auto& temp=arr_FjdqPXh[TUVhIjf].emplace_object();
            return serialize_struct(temp, pCreateInfo[TUVhIjf]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pModule==NULL){
                json["pModule"]=boost::json::array();
            return; }
        auto& arr_FnQIexZ=json["pModule"].emplace_array();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){serialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko],pModule[ozltKko]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateCuFunctionNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCuFunctionCreateInfoNVX* pCreateInfo;
[&](){ VkCuFunctionCreateInfoNVX* temp_LHyWZBO[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_LHyWZBO=NULL;
            return; }temp_LHyWZBO=(VkCuFunctionCreateInfoNVX*)malloc(1*sizeof(VkCuFunctionCreateInfoNVX));
        auto& arr_gHmsOsA=json["pCreateInfo"].as_array();
        for(int EbWStVn=0; EbWStVn < 1; EbWStVn++){
            [&](){
            auto& temp=arr_gHmsOsA[EbWStVn].as_object();
            deserialize_struct(temp,temp_LHyWZBO[EbWStVn]);
            }();
        }
        }();pCreateInfo=temp_LHyWZBO;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkCuFunctionNVX* pFunction;
[&](){
            if (json["pFunction"].as_array().size()==0){
                pFunction=NULL;
            return; }pFunction=(VkCuFunctionNVX*)malloc(1*sizeof(VkCuFunctionNVX));
        auto& arr_TrIYEcP=json["pFunction"].as_array();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){deserialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF], pFunction[zzRpTQF]);}();
        }
        }();

    PFN_vkCreateCuFunctionNVX call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateCuFunctionNVX)get_instance_proc_addr(parent,"vkCreateCuFunctionNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateCuFunctionNVX)get_device_proc_addr(parent,"vkCreateCuFunctionNVX");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pFunction);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_XkBojZi=json["pCreateInfo"].emplace_array();
        for(int twsSgji=0; twsSgji < 1; twsSgji++){
            [&](){
            auto& temp=arr_XkBojZi[twsSgji].emplace_object();
            return serialize_struct(temp, pCreateInfo[twsSgji]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFunction==NULL){
                json["pFunction"]=boost::json::array();
            return; }
        auto& arr_TrIYEcP=json["pFunction"].emplace_array();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){serialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF],pFunction[zzRpTQF]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyCuModuleNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCuModuleNVX module;
[&](){deserialize_VkCuModuleNVX(json["module"], module);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyCuModuleNVX call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyCuModuleNVX)get_instance_proc_addr(parent,"vkDestroyCuModuleNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyCuModuleNVX)get_device_proc_addr(parent,"vkDestroyCuModuleNVX");
    }  
    
{
call_function(device, module, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuModuleNVX(json["module"],module);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyCuFunctionNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCuFunctionNVX function;
[&](){deserialize_VkCuFunctionNVX(json["function"], function);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyCuFunctionNVX call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyCuFunctionNVX)get_instance_proc_addr(parent,"vkDestroyCuFunctionNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyCuFunctionNVX)get_device_proc_addr(parent,"vkDestroyCuFunctionNVX");
    }  
    
{
call_function(device, function, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuFunctionNVX(json["function"],function);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCuLaunchKernelNVX(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCuLaunchInfoNVX* pLaunchInfo;
[&](){ VkCuLaunchInfoNVX* temp_mOenQMw[&](){
            if (json["pLaunchInfo"].as_array().size()==0){
                temp_mOenQMw=NULL;
            return; }temp_mOenQMw=(VkCuLaunchInfoNVX*)malloc(1*sizeof(VkCuLaunchInfoNVX));
        auto& arr_KytmXlj=json["pLaunchInfo"].as_array();
        for(int TnDRcbg=0; TnDRcbg < 1; TnDRcbg++){
            [&](){
            auto& temp=arr_KytmXlj[TnDRcbg].as_object();
            deserialize_struct(temp,temp_mOenQMw[TnDRcbg]);
            }();
        }
        }();pLaunchInfo=temp_mOenQMw;}();

    PFN_vkCmdCuLaunchKernelNVX call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCuLaunchKernelNVX)get_instance_proc_addr(parent,"vkCmdCuLaunchKernelNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCuLaunchKernelNVX)get_device_proc_addr(parent,"vkCmdCuLaunchKernelNVX");
    }  
    
{
call_function(commandBuffer, pLaunchInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLaunchInfo==NULL){
                json["pLaunchInfo"]=boost::json::array();
            return; }
        auto& arr_UKYVund=json["pLaunchInfo"].emplace_array();
        for(int eUSpbRB=0; eUSpbRB < 1; eUSpbRB++){
            [&](){
            auto& temp=arr_UKYVund[eUSpbRB].emplace_object();
            return serialize_struct(temp, pLaunchInfo[eUSpbRB]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutSizeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayout layout;
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
VkDeviceSize* pLayoutSizeInBytes;
[&](){
            if (json["pLayoutSizeInBytes"].as_array().size()==0){
                pLayoutSizeInBytes=NULL;
            return; }pLayoutSizeInBytes=(VkDeviceSize*)malloc(1*sizeof(VkDeviceSize));
        auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].as_array();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){uint64_t temp_xOYiCiO;[&](){temp_xOYiCiO=static_cast<uint64_t>(value_to<int>(arr_xOYiCiO[QcQjmSi]));}();pLayoutSizeInBytes[QcQjmSi]=(VkDeviceSize)temp_xOYiCiO;}();
        }
        }();

    PFN_vkGetDescriptorSetLayoutSizeEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutSizeEXT)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutSizeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetLayoutSizeEXT)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutSizeEXT");
    }  
    
{
call_function(device, layout, pLayoutSizeInBytes);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){
            if (pLayoutSizeInBytes==NULL){
                json["pLayoutSizeInBytes"]=boost::json::array();
            return; }
        auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].emplace_array();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){[&](){arr_xOYiCiO[QcQjmSi]=pLayoutSizeInBytes[QcQjmSi];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutBindingOffsetEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayout layout;
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
uint32_t binding;
[&](){binding=static_cast<uint32_t>(value_to<int>(json["binding"]));}();
VkDeviceSize* pOffset;
[&](){
            if (json["pOffset"].as_array().size()==0){
                pOffset=NULL;
            return; }pOffset=(VkDeviceSize*)malloc(1*sizeof(VkDeviceSize));
        auto& arr_dquZgZN=json["pOffset"].as_array();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){uint64_t temp_dquZgZN;[&](){temp_dquZgZN=static_cast<uint64_t>(value_to<int>(arr_dquZgZN[LNetLnu]));}();pOffset[LNetLnu]=(VkDeviceSize)temp_dquZgZN;}();
        }
        }();

    PFN_vkGetDescriptorSetLayoutBindingOffsetEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutBindingOffsetEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutBindingOffsetEXT");
    }  
    
{
call_function(device, layout, binding, pOffset);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){json["binding"]=binding;}();
[&](){
            if (pOffset==NULL){
                json["pOffset"]=boost::json::array();
            return; }
        auto& arr_dquZgZN=json["pOffset"].emplace_array();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){[&](){arr_dquZgZN[LNetLnu]=pOffset[LNetLnu];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDescriptorEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorGetInfoEXT* pDescriptorInfo;
[&](){ VkDescriptorGetInfoEXT* temp_JaqMKvj[&](){
            if (json["pDescriptorInfo"].as_array().size()==0){
                temp_JaqMKvj=NULL;
            return; }temp_JaqMKvj=(VkDescriptorGetInfoEXT*)malloc(1*sizeof(VkDescriptorGetInfoEXT));
        auto& arr_PhsrvQH=json["pDescriptorInfo"].as_array();
        for(int HBOsibB=0; HBOsibB < 1; HBOsibB++){
            [&](){
            auto& temp=arr_PhsrvQH[HBOsibB].as_object();
            deserialize_struct(temp,temp_JaqMKvj[HBOsibB]);
            }();
        }
        }();pDescriptorInfo=temp_JaqMKvj;}();
size_t dataSize;
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
void* pDescriptor;
[&](){
            if (json["pDescriptor"].as_array().size()==0){
                pDescriptor=NULL;
            return; }char* temp_mEHYUhJ;[&](){
            if (json["pDescriptor"].as_array().size()==0){
                temp_mEHYUhJ=NULL;
            return; }temp_mEHYUhJ=(char*)malloc(dataSize*sizeof(char));
        auto& arr_LMyOepF=json["pDescriptor"].as_array();
        for(int FBuPGmd=0; FBuPGmd < dataSize; FBuPGmd++){
            [&](){temp_mEHYUhJ[FBuPGmd]=static_cast<char>(value_to<int>(arr_LMyOepF[FBuPGmd]));}();
        }
        }();pDescriptor=temp_mEHYUhJ;}();

    PFN_vkGetDescriptorEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorEXT)get_instance_proc_addr(parent,"vkGetDescriptorEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorEXT)get_device_proc_addr(parent,"vkGetDescriptorEXT");
    }  
    
{
call_function(device, pDescriptorInfo, dataSize, pDescriptor);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDescriptorInfo==NULL){
                json["pDescriptorInfo"]=boost::json::array();
            return; }
        auto& arr_RGgHhwd=json["pDescriptorInfo"].emplace_array();
        for(int cdcTeyn=0; cdcTeyn < 1; cdcTeyn++){
            [&](){
            auto& temp=arr_RGgHhwd[cdcTeyn].emplace_object();
            return serialize_struct(temp, pDescriptorInfo[cdcTeyn]);
            }();
        }
        }();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pDescriptor==NULL){
                json["pDescriptor"]=boost::json::array();
            return; }[&](){
            if (((char*)(pDescriptor))==NULL){
                json["pDescriptor"]=boost::json::array();
            return; }
        auto& arr_LMyOepF=json["pDescriptor"].emplace_array();
        for(int FBuPGmd=0; FBuPGmd < dataSize; FBuPGmd++){
            [&](){arr_LMyOepF[FBuPGmd]=((char*)(pDescriptor))[FBuPGmd];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkCmdBindDescriptorBuffersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t bufferCount;
[&](){bufferCount=static_cast<uint32_t>(value_to<int>(json["bufferCount"]));}();
VkDescriptorBufferBindingInfoEXT* pBindingInfos;
[&](){ VkDescriptorBufferBindingInfoEXT* temp_VvhDvsB[&](){
            if (json["pBindingInfos"].as_array().size()==0){
                temp_VvhDvsB=NULL;
            return; }temp_VvhDvsB=(VkDescriptorBufferBindingInfoEXT*)malloc(bufferCount*sizeof(VkDescriptorBufferBindingInfoEXT));
        auto& arr_xBOCrqU=json["pBindingInfos"].as_array();
        for(int VnwAoIb=0; VnwAoIb < bufferCount; VnwAoIb++){
            [&](){
            auto& temp=arr_xBOCrqU[VnwAoIb].as_object();
            deserialize_struct(temp,temp_VvhDvsB[VnwAoIb]);
            }();
        }
        }();pBindingInfos=temp_VvhDvsB;}();

    PFN_vkCmdBindDescriptorBuffersEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindDescriptorBuffersEXT)get_instance_proc_addr(parent,"vkCmdBindDescriptorBuffersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindDescriptorBuffersEXT)get_device_proc_addr(parent,"vkCmdBindDescriptorBuffersEXT");
    }  
    
{
call_function(commandBuffer, bufferCount, pBindingInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["bufferCount"]=bufferCount;}();
[&](){
            if (pBindingInfos==NULL){
                json["pBindingInfos"]=boost::json::array();
            return; }
        auto& arr_guwgqGC=json["pBindingInfos"].emplace_array();
        for(int btgeqwi=0; btgeqwi < bufferCount; btgeqwi++){
            [&](){
            auto& temp=arr_guwgqGC[btgeqwi].emplace_object();
            return serialize_struct(temp, pBindingInfos[btgeqwi]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetDescriptorBufferOffsetsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t firstSet;
[&](){firstSet=static_cast<uint32_t>(value_to<int>(json["firstSet"]));}();
uint32_t setCount;
[&](){setCount=static_cast<uint32_t>(value_to<int>(json["setCount"]));}();
uint32_t* pBufferIndices;
[&](){ uint32_t* temp_VfkaonJ[&](){
            if (json["pBufferIndices"].as_array().size()==0){
                temp_VfkaonJ=NULL;
            return; }temp_VfkaonJ=(uint32_t*)malloc(setCount*sizeof(uint32_t));
        auto& arr_PTuYzHc=json["pBufferIndices"].as_array();
        for(int sDNFOkx=0; sDNFOkx < setCount; sDNFOkx++){
            [&](){temp_VfkaonJ[sDNFOkx]=static_cast<uint32_t>(value_to<int>(arr_PTuYzHc[sDNFOkx]));}();
        }
        }();pBufferIndices=temp_VfkaonJ;}();
VkDeviceSize* pOffsets;
[&](){ VkDeviceSize* temp_MZzhchn[&](){
            if (json["pOffsets"].as_array().size()==0){
                temp_MZzhchn=NULL;
            return; }temp_MZzhchn=(VkDeviceSize*)malloc(setCount*sizeof(VkDeviceSize));
        auto& arr_uWdiGtF=json["pOffsets"].as_array();
        for(int ELYQTNF=0; ELYQTNF < setCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){temp_uWdiGtF=static_cast<uint64_t>(value_to<int>(arr_uWdiGtF[ELYQTNF]));}();temp_MZzhchn[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();pOffsets=temp_MZzhchn;}();

    PFN_vkCmdSetDescriptorBufferOffsetsEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDescriptorBufferOffsetsEXT)get_instance_proc_addr(parent,"vkCmdSetDescriptorBufferOffsetsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDescriptorBufferOffsetsEXT)get_device_proc_addr(parent,"vkCmdSetDescriptorBufferOffsetsEXT");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=firstSet;}();
[&](){json["setCount"]=setCount;}();
[&](){
            if (pBufferIndices==NULL){
                json["pBufferIndices"]=boost::json::array();
            return; }
        auto& arr_zejaAgt=json["pBufferIndices"].emplace_array();
        for(int tuuKbsL=0; tuuKbsL < setCount; tuuKbsL++){
            [&](){arr_zejaAgt[tuuKbsL]=pBufferIndices[tuuKbsL];}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }
        auto& arr_YvpyTDd=json["pOffsets"].emplace_array();
        for(int ySwhvse=0; ySwhvse < setCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t set;
[&](){set=static_cast<uint32_t>(value_to<int>(json["set"]));}();

    PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)get_instance_proc_addr(parent,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)get_device_proc_addr(parent,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, set);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();


        writeToConn(json);
    }

    void handle_vkGetBufferOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBufferCaptureDescriptorDataInfoEXT* pInfo;
[&](){ VkBufferCaptureDescriptorDataInfoEXT* temp_rEgVYLu[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_rEgVYLu=NULL;
            return; }temp_rEgVYLu=(VkBufferCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkBufferCaptureDescriptorDataInfoEXT));
        auto& arr_VqsZREG=json["pInfo"].as_array();
        for(int dxQHpNQ=0; dxQHpNQ < 1; dxQHpNQ++){
            [&](){
            auto& temp=arr_VqsZREG[dxQHpNQ].as_object();
            deserialize_struct(temp,temp_rEgVYLu[dxQHpNQ]);
            }();
        }
        }();pInfo=temp_rEgVYLu;}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_array().size()*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetBufferOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetBufferOpaqueCaptureDescriptorDataEXT");
    }  
    
{
auto result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_Hxvezrr=json["pInfo"].emplace_array();
        for(int VgzeNwX=0; VgzeNwX < 1; VgzeNwX++){
            [&](){
            auto& temp=arr_Hxvezrr[VgzeNwX].emplace_object();
            return serialize_struct(temp, pInfo[VgzeNwX]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkGetImageOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageCaptureDescriptorDataInfoEXT* pInfo;
[&](){ VkImageCaptureDescriptorDataInfoEXT* temp_RPYpnXY[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_RPYpnXY=NULL;
            return; }temp_RPYpnXY=(VkImageCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkImageCaptureDescriptorDataInfoEXT));
        auto& arr_YRCGcVr=json["pInfo"].as_array();
        for(int VOFqAJf=0; VOFqAJf < 1; VOFqAJf++){
            [&](){
            auto& temp=arr_YRCGcVr[VOFqAJf].as_object();
            deserialize_struct(temp,temp_RPYpnXY[VOFqAJf]);
            }();
        }
        }();pInfo=temp_RPYpnXY;}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_array().size()*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetImageOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetImageOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetImageOpaqueCaptureDescriptorDataEXT");
    }  
    
{
auto result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_vrxBIsi=json["pInfo"].emplace_array();
        for(int swRpuDc=0; swRpuDc < 1; swRpuDc++){
            [&](){
            auto& temp=arr_vrxBIsi[swRpuDc].emplace_object();
            return serialize_struct(temp, pInfo[swRpuDc]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkGetImageViewOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageViewCaptureDescriptorDataInfoEXT* pInfo;
[&](){ VkImageViewCaptureDescriptorDataInfoEXT* temp_jGAgAei[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_jGAgAei=NULL;
            return; }temp_jGAgAei=(VkImageViewCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkImageViewCaptureDescriptorDataInfoEXT));
        auto& arr_eRxFxUj=json["pInfo"].as_array();
        for(int QcuObSb=0; QcuObSb < 1; QcuObSb++){
            [&](){
            auto& temp=arr_eRxFxUj[QcuObSb].as_object();
            deserialize_struct(temp,temp_jGAgAei[QcuObSb]);
            }();
        }
        }();pInfo=temp_jGAgAei;}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_array().size()*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetImageViewOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetImageViewOpaqueCaptureDescriptorDataEXT");
    }  
    
{
auto result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_CYlSaQv=json["pInfo"].emplace_array();
        for(int pmdADqD=0; pmdADqD < 1; pmdADqD++){
            [&](){
            auto& temp=arr_CYlSaQv[pmdADqD].emplace_object();
            return serialize_struct(temp, pInfo[pmdADqD]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkGetSamplerOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSamplerCaptureDescriptorDataInfoEXT* pInfo;
[&](){ VkSamplerCaptureDescriptorDataInfoEXT* temp_MPuBGCU[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_MPuBGCU=NULL;
            return; }temp_MPuBGCU=(VkSamplerCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkSamplerCaptureDescriptorDataInfoEXT));
        auto& arr_MRsSLnb=json["pInfo"].as_array();
        for(int VTYniUZ=0; VTYniUZ < 1; VTYniUZ++){
            [&](){
            auto& temp=arr_MRsSLnb[VTYniUZ].as_object();
            deserialize_struct(temp,temp_MPuBGCU[VTYniUZ]);
            }();
        }
        }();pInfo=temp_MPuBGCU;}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_array().size()*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetSamplerOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetSamplerOpaqueCaptureDescriptorDataEXT");
    }  
    
{
auto result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_RMPxsVS=json["pInfo"].emplace_array();
        for(int SScNLQN=0; SScNLQN < 1; SScNLQN++){
            [&](){
            auto& temp=arr_RMPxsVS[SScNLQN].emplace_object();
            return serialize_struct(temp, pInfo[SScNLQN]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo;
[&](){ VkAccelerationStructureCaptureDescriptorDataInfoEXT* temp_YSWfcBp[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_YSWfcBp=NULL;
            return; }temp_YSWfcBp=(VkAccelerationStructureCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkAccelerationStructureCaptureDescriptorDataInfoEXT));
        auto& arr_IpvCogf=json["pInfo"].as_array();
        for(int rufTsHO=0; rufTsHO < 1; rufTsHO++){
            [&](){
            auto& temp=arr_IpvCogf[rufTsHO].as_object();
            deserialize_struct(temp,temp_YSWfcBp[rufTsHO]);
            }();
        }
        }();pInfo=temp_YSWfcBp;}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_array().size()*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
    }  
    
{
auto result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_iLnHGmk=json["pInfo"].emplace_array();
        for(int kbTuVMH=0; kbTuVMH < 1; kbTuVMH++){
            [&](){
            auto& temp=arr_iLnHGmk[kbTuVMH].emplace_object();
            return serialize_struct(temp, pInfo[kbTuVMH]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkSetDeviceMemoryPriorityEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
float priority;
[&](){priority=static_cast<float>(value_to<int>(json["priority"]));}();

    PFN_vkSetDeviceMemoryPriorityEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetDeviceMemoryPriorityEXT)get_instance_proc_addr(parent,"vkSetDeviceMemoryPriorityEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetDeviceMemoryPriorityEXT)get_device_proc_addr(parent,"vkSetDeviceMemoryPriorityEXT");
    }  
    
{
call_function(device, memory, priority);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){json["priority"]=priority;}();


        writeToConn(json);
    }

    void handle_vkAcquireDrmDisplayEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
int32_t drmFd;
[&](){drmFd=static_cast<int32_t>(value_to<int>(json["drmFd"]));}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();

    PFN_vkAcquireDrmDisplayEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquireDrmDisplayEXT)get_instance_proc_addr(parent,"vkAcquireDrmDisplayEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquireDrmDisplayEXT)get_device_proc_addr(parent,"vkAcquireDrmDisplayEXT");
    }  
    
{
auto result=call_function(physicalDevice, drmFd, display);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=drmFd;}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();


        writeToConn(json);
    }

    void handle_vkGetDrmDisplayEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
int32_t drmFd;
[&](){drmFd=static_cast<int32_t>(value_to<int>(json["drmFd"]));}();
uint32_t connectorId;
[&](){connectorId=static_cast<uint32_t>(value_to<int>(json["connectorId"]));}();
VkDisplayKHR* display;
[&](){
            if (json["display"].as_array().size()==0){
                display=NULL;
            return; }display=(VkDisplayKHR*)malloc(1*sizeof(VkDisplayKHR));
        auto& arr_DpFHFgI=json["display"].as_array();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){deserialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA], display[AVVxOCA]);}();
        }
        }();

    PFN_vkGetDrmDisplayEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDrmDisplayEXT)get_instance_proc_addr(parent,"vkGetDrmDisplayEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDrmDisplayEXT)get_device_proc_addr(parent,"vkGetDrmDisplayEXT");
    }  
    
{
auto result=call_function(physicalDevice, drmFd, connectorId, display);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=drmFd;}();
[&](){json["connectorId"]=connectorId;}();
[&](){
            if (display==NULL){
                json["display"]=boost::json::array();
            return; }
        auto& arr_DpFHFgI=json["display"].emplace_array();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){serialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA],display[AVVxOCA]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkWaitForPresentKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint64_t presentId;
[&](){presentId=static_cast<uint64_t>(value_to<int>(json["presentId"]));}();
uint64_t timeout;
[&](){timeout=static_cast<uint64_t>(value_to<int>(json["timeout"]));}();

    PFN_vkWaitForPresentKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWaitForPresentKHR)get_instance_proc_addr(parent,"vkWaitForPresentKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWaitForPresentKHR)get_device_proc_addr(parent,"vkWaitForPresentKHR");
    }  
    
{
auto result=call_function(device, swapchain, presentId, timeout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["presentId"]=presentId;}();
[&](){json["timeout"]=timeout;}();


        writeToConn(json);
    }

    void handle_vkCmdBeginRendering(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkRenderingInfo* pRenderingInfo;
[&](){ VkRenderingInfo* temp_ySbRVvm[&](){
            if (json["pRenderingInfo"].as_array().size()==0){
                temp_ySbRVvm=NULL;
            return; }temp_ySbRVvm=(VkRenderingInfo*)malloc(1*sizeof(VkRenderingInfo));
        auto& arr_IEHUXzQ=json["pRenderingInfo"].as_array();
        for(int oIBIqTv=0; oIBIqTv < 1; oIBIqTv++){
            [&](){
            auto& temp=arr_IEHUXzQ[oIBIqTv].as_object();
            deserialize_struct(temp,temp_ySbRVvm[oIBIqTv]);
            }();
        }
        }();pRenderingInfo=temp_ySbRVvm;}();

    PFN_vkCmdBeginRendering call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginRendering)get_instance_proc_addr(parent,"vkCmdBeginRendering");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginRendering)get_device_proc_addr(parent,"vkCmdBeginRendering");
    }  
    
{
call_function(commandBuffer, pRenderingInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=boost::json::array();
            return; }
        auto& arr_DOEgrev=json["pRenderingInfo"].emplace_array();
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto& temp=arr_DOEgrev[dAqQfxy].emplace_object();
            return serialize_struct(temp, pRenderingInfo[dAqQfxy]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdEndRendering(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndRendering call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndRendering)get_instance_proc_addr(parent,"vkCmdEndRendering");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndRendering)get_device_proc_addr(parent,"vkCmdEndRendering");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutHostMappingInfoVALVE(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetBindingReferenceVALVE* pBindingReference;
[&](){ VkDescriptorSetBindingReferenceVALVE* temp_mGUsizF[&](){
            if (json["pBindingReference"].as_array().size()==0){
                temp_mGUsizF=NULL;
            return; }temp_mGUsizF=(VkDescriptorSetBindingReferenceVALVE*)malloc(1*sizeof(VkDescriptorSetBindingReferenceVALVE));
        auto& arr_swAzjIz=json["pBindingReference"].as_array();
        for(int dYYQsmf=0; dYYQsmf < 1; dYYQsmf++){
            [&](){
            auto& temp=arr_swAzjIz[dYYQsmf].as_object();
            deserialize_struct(temp,temp_mGUsizF[dYYQsmf]);
            }();
        }
        }();pBindingReference=temp_mGUsizF;}();
VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping;
[&](){
            if (json["pHostMapping"].as_array().size()==0){
                pHostMapping=NULL;
            return; }pHostMapping=(VkDescriptorSetLayoutHostMappingInfoVALVE*)malloc(1*sizeof(VkDescriptorSetLayoutHostMappingInfoVALVE));
        auto& arr_zODJzpL=json["pHostMapping"].as_array();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto& temp=arr_zODJzpL[jHGvhna].as_object();
            deserialize_struct(temp,pHostMapping[jHGvhna]);
            }();
        }
        }();

    PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutHostMappingInfoVALVE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutHostMappingInfoVALVE");
    }  
    
{
call_function(device, pBindingReference, pHostMapping);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pBindingReference==NULL){
                json["pBindingReference"]=boost::json::array();
            return; }
        auto& arr_JTmPGZt=json["pBindingReference"].emplace_array();
        for(int OEumPxJ=0; OEumPxJ < 1; OEumPxJ++){
            [&](){
            auto& temp=arr_JTmPGZt[OEumPxJ].emplace_object();
            return serialize_struct(temp, pBindingReference[OEumPxJ]);
            }();
        }
        }();
[&](){
            if (pHostMapping==NULL){
                json["pHostMapping"]=boost::json::array();
            return; }
        auto& arr_zODJzpL=json["pHostMapping"].emplace_array();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto& temp=arr_zODJzpL[jHGvhna].emplace_object();
            return serialize_struct(temp, pHostMapping[jHGvhna]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDescriptorSetHostMappingVALVE(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSet descriptorSet;
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
void** ppData;
[&](){
            if (json["ppData"].as_array().size()==0){
                ppData=NULL;
            return; }ppData=(void**)malloc(1*sizeof(void*));
        auto& arr_JgRLJSK=json["ppData"].as_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].as_array().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].as_array().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].as_array().size()*sizeof(char));
        auto& arr_yHvgdEb=arr_JgRLJSK[NsRFkBj].as_array();
        for(int vgxltbA=0; vgxltbA < arr_JgRLJSK[NsRFkBj].as_array().size(); vgxltbA++){
            [&](){temp_JgRLJSK[vgxltbA]=static_cast<char>(value_to<int>(arr_yHvgdEb[vgxltbA]));}();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();

    PFN_vkGetDescriptorSetHostMappingVALVE call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetHostMappingVALVE)get_instance_proc_addr(parent,"vkGetDescriptorSetHostMappingVALVE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetHostMappingVALVE)get_device_proc_addr(parent,"vkGetDescriptorSetHostMappingVALVE");
    }  
    
{
call_function(device, descriptorSet, ppData);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }
        auto& arr_JgRLJSK=json["ppData"].emplace_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }
        auto& arr_yHvgdEb=arr_JgRLJSK[NsRFkBj].emplace_array();
        for(int vgxltbA=0; vgxltbA < strlen(((char*)(ppData[NsRFkBj])))+1; vgxltbA++){
            [&](){arr_yHvgdEb[vgxltbA]=((char*)(ppData[NsRFkBj]))[vgxltbA];}();
        }
        }();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMicromapCreateInfoEXT* pCreateInfo;
[&](){ VkMicromatemp_bOYNUYKEXT* temp_bOYNUYK[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_bOYNUYK=NULL;
            return; }temp_bOYNUYK=(VkMicromapCreateInfoEXT*)malloc(1*sizeof(VkMicromapCreateInfoEXT));
        auto& arr_XnWTHFD=json["pCreateInfo"].as_array();
        for(int SlvdLyP=0; SlvdLyP < 1; SlvdLyP++){
            [&](){
            auto& temp=arr_XnWTHFD[SlvdLyP].as_object();
            deserialize_struct(temp,temp_bOYNUYK[SlvdLyP]);
            }();
        }
        }();pCreateInfo=temp_bOYNUYK;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkMicromapEXT* pMicromap;
[&](){
            if (json["pMicromap"].as_array().size()==0){
                pMicromap=NULL;
            return; }pMicromap=(VkMicromapEXT*)malloc(1*sizeof(VkMicromapEXT));
        auto& arr_mHmzwPX=json["pMicromap"].as_array();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){deserialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm], pMicromap[vcxNgSm]);}();
        }
        }();

    PFN_vkCreateMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateMicromapEXT)get_instance_proc_addr(parent,"vkCreateMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateMicromapEXT)get_device_proc_addr(parent,"vkCreateMicromapEXT");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pMicromap);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_vrQtrYo=json["pCreateInfo"].emplace_array();
        for(int cfhYIUK=0; cfhYIUK < 1; cfhYIUK++){
            [&](){
            auto& temp=arr_vrQtrYo[cfhYIUK].emplace_object();
            return serialize_struct(temp, pCreateInfo[cfhYIUK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMicromap==NULL){
                json["pMicromap"]=boost::json::array();
            return; }
        auto& arr_mHmzwPX=json["pMicromap"].emplace_array();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){serialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm],pMicromap[vcxNgSm]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdBuildMicromapsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t infoCount;
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();
VkMicromapBuildInfoEXT* pInfos;
[&](){ VkMicromapBuildInfoEXT* temp_jEppnfV[&](){
            if (json["pInfos"].as_array().size()==0){
                temp_jEppnfV=NULL;
            return; }temp_jEppnfV=(VkMicromapBuildInfoEXT*)malloc(infoCount*sizeof(VkMicromapBuildInfoEXT));
        auto& arr_pOhxygW=json["pInfos"].as_array();
        for(int UnBcPOz=0; UnBcPOz < infoCount; UnBcPOz++){
            [&](){
            auto& temp=arr_pOhxygW[UnBcPOz].as_object();
            deserialize_struct(temp,temp_jEppnfV[UnBcPOz]);
            }();
        }
        }();pInfos=temp_jEppnfV;}();

    PFN_vkCmdBuildMicromapsEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBuildMicromapsEXT)get_instance_proc_addr(parent,"vkCmdBuildMicromapsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBuildMicromapsEXT)get_device_proc_addr(parent,"vkCmdBuildMicromapsEXT");
    }  
    
{
call_function(commandBuffer, infoCount, pInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_KdoluBZ=json["pInfos"].emplace_array();
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto& temp=arr_KdoluBZ[bfMWBOA].emplace_object();
            return serialize_struct(temp, pInfos[bfMWBOA]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBuildMicromapsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
uint32_t infoCount;
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();
VkMicromapBuildInfoEXT* pInfos;
[&](){ VkMicromapBuildInfoEXT* temp_jEppnfV[&](){
            if (json["pInfos"].as_array().size()==0){
                temp_jEppnfV=NULL;
            return; }temp_jEppnfV=(VkMicromapBuildInfoEXT*)malloc(infoCount*sizeof(VkMicromapBuildInfoEXT));
        auto& arr_pOhxygW=json["pInfos"].as_array();
        for(int UnBcPOz=0; UnBcPOz < infoCount; UnBcPOz++){
            [&](){
            auto& temp=arr_pOhxygW[UnBcPOz].as_object();
            deserialize_struct(temp,temp_jEppnfV[UnBcPOz]);
            }();
        }
        }();pInfos=temp_jEppnfV;}();

    PFN_vkBuildMicromapsEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBuildMicromapsEXT)get_instance_proc_addr(parent,"vkBuildMicromapsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBuildMicromapsEXT)get_device_proc_addr(parent,"vkBuildMicromapsEXT");
    }  
    
{
auto result=call_function(device, deferredOperation, infoCount, pInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_KdoluBZ=json["pInfos"].emplace_array();
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto& temp=arr_KdoluBZ[bfMWBOA].emplace_object();
            return serialize_struct(temp, pInfos[bfMWBOA]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMicromapEXT micromap;
[&](){deserialize_VkMicromapEXT(json["micromap"], micromap);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyMicromapEXT)get_instance_proc_addr(parent,"vkDestroyMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyMicromapEXT)get_device_proc_addr(parent,"vkDestroyMicromapEXT");
    }  
    
{
call_function(device, micromap, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkMicromapEXT(json["micromap"],micromap);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyMicromapInfoEXT* pInfo;
[&](){ VkCopyMicromatemp_vfmXVBbEXT* temp_vfmXVBb[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_vfmXVBb=NULL;
            return; }temp_vfmXVBb=(VkCopyMicromapInfoEXT*)malloc(1*sizeof(VkCopyMicromapInfoEXT));
        auto& arr_JTPzqPn=json["pInfo"].as_array();
        for(int rzDjQUu=0; rzDjQUu < 1; rzDjQUu++){
            [&](){
            auto& temp=arr_JTPzqPn[rzDjQUu].as_object();
            deserialize_struct(temp,temp_vfmXVBb[rzDjQUu]);
            }();
        }
        }();pInfo=temp_vfmXVBb;}();

    PFN_vkCmdCopyMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMicromapEXT)get_instance_proc_addr(parent,"vkCmdCopyMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMicromapEXT)get_device_proc_addr(parent,"vkCmdCopyMicromapEXT");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_UIlbXxp=json["pInfo"].emplace_array();
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto& temp=arr_UIlbXxp[vDMleIo].emplace_object();
            return serialize_struct(temp, pInfo[vDMleIo]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCopyMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
VkCopyMicromapInfoEXT* pInfo;
[&](){ VkCopyMicromatemp_vfmXVBbEXT* temp_vfmXVBb[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_vfmXVBb=NULL;
            return; }temp_vfmXVBb=(VkCopyMicromapInfoEXT*)malloc(1*sizeof(VkCopyMicromapInfoEXT));
        auto& arr_JTPzqPn=json["pInfo"].as_array();
        for(int rzDjQUu=0; rzDjQUu < 1; rzDjQUu++){
            [&](){
            auto& temp=arr_JTPzqPn[rzDjQUu].as_object();
            deserialize_struct(temp,temp_vfmXVBb[rzDjQUu]);
            }();
        }
        }();pInfo=temp_vfmXVBb;}();

    PFN_vkCopyMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMicromapEXT)get_instance_proc_addr(parent,"vkCopyMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMicromapEXT)get_device_proc_addr(parent,"vkCopyMicromapEXT");
    }  
    
{
auto result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_UIlbXxp=json["pInfo"].emplace_array();
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto& temp=arr_UIlbXxp[vDMleIo].emplace_object();
            return serialize_struct(temp, pInfo[vDMleIo]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyMicromapToMemoryEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyMicromapToMemoryInfoEXT* pInfo;
[&](){ VkCopyMicromapToMemoryInfoEXT* temp_mwWgsLI[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_mwWgsLI=NULL;
            return; }temp_mwWgsLI=(VkCopyMicromapToMemoryInfoEXT*)malloc(1*sizeof(VkCopyMicromapToMemoryInfoEXT));
        auto& arr_yvWkCxr=json["pInfo"].as_array();
        for(int LolGOkG=0; LolGOkG < 1; LolGOkG++){
            [&](){
            auto& temp=arr_yvWkCxr[LolGOkG].as_object();
            deserialize_struct(temp,temp_mwWgsLI[LolGOkG]);
            }();
        }
        }();pInfo=temp_mwWgsLI;}();

    PFN_vkCmdCopyMicromapToMemoryEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMicromapToMemoryEXT)get_instance_proc_addr(parent,"vkCmdCopyMicromapToMemoryEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMicromapToMemoryEXT)get_device_proc_addr(parent,"vkCmdCopyMicromapToMemoryEXT");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_EiLirbT=json["pInfo"].emplace_array();
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto& temp=arr_EiLirbT[dzsAOWF].emplace_object();
            return serialize_struct(temp, pInfo[dzsAOWF]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCopyMicromapToMemoryEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
VkCopyMicromapToMemoryInfoEXT* pInfo;
[&](){ VkCopyMicromapToMemoryInfoEXT* temp_mwWgsLI[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_mwWgsLI=NULL;
            return; }temp_mwWgsLI=(VkCopyMicromapToMemoryInfoEXT*)malloc(1*sizeof(VkCopyMicromapToMemoryInfoEXT));
        auto& arr_yvWkCxr=json["pInfo"].as_array();
        for(int LolGOkG=0; LolGOkG < 1; LolGOkG++){
            [&](){
            auto& temp=arr_yvWkCxr[LolGOkG].as_object();
            deserialize_struct(temp,temp_mwWgsLI[LolGOkG]);
            }();
        }
        }();pInfo=temp_mwWgsLI;}();

    PFN_vkCopyMicromapToMemoryEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMicromapToMemoryEXT)get_instance_proc_addr(parent,"vkCopyMicromapToMemoryEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMicromapToMemoryEXT)get_device_proc_addr(parent,"vkCopyMicromapToMemoryEXT");
    }  
    
{
auto result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_EiLirbT=json["pInfo"].emplace_array();
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto& temp=arr_EiLirbT[dzsAOWF].emplace_object();
            return serialize_struct(temp, pInfo[dzsAOWF]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryToMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCopyMemoryToMicromapInfoEXT* pInfo;
[&](){ VkCopyMemoryToMicromatemp_AHZCCojEXT* temp_AHZCCoj[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_AHZCCoj=NULL;
            return; }temp_AHZCCoj=(VkCopyMemoryToMicromapInfoEXT*)malloc(1*sizeof(VkCopyMemoryToMicromapInfoEXT));
        auto& arr_JkoWJSQ=json["pInfo"].as_array();
        for(int HyJmoQR=0; HyJmoQR < 1; HyJmoQR++){
            [&](){
            auto& temp=arr_JkoWJSQ[HyJmoQR].as_object();
            deserialize_struct(temp,temp_AHZCCoj[HyJmoQR]);
            }();
        }
        }();pInfo=temp_AHZCCoj;}();

    PFN_vkCmdCopyMemoryToMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMemoryToMicromapEXT)get_instance_proc_addr(parent,"vkCmdCopyMemoryToMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMemoryToMicromapEXT)get_device_proc_addr(parent,"vkCmdCopyMemoryToMicromapEXT");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_QufOGLT=json["pInfo"].emplace_array();
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto& temp=arr_QufOGLT[semZpgt].emplace_object();
            return serialize_struct(temp, pInfo[semZpgt]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCopyMemoryToMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
VkCopyMemoryToMicromapInfoEXT* pInfo;
[&](){ VkCopyMemoryToMicromatemp_AHZCCojEXT* temp_AHZCCoj[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_AHZCCoj=NULL;
            return; }temp_AHZCCoj=(VkCopyMemoryToMicromapInfoEXT*)malloc(1*sizeof(VkCopyMemoryToMicromapInfoEXT));
        auto& arr_JkoWJSQ=json["pInfo"].as_array();
        for(int HyJmoQR=0; HyJmoQR < 1; HyJmoQR++){
            [&](){
            auto& temp=arr_JkoWJSQ[HyJmoQR].as_object();
            deserialize_struct(temp,temp_AHZCCoj[HyJmoQR]);
            }();
        }
        }();pInfo=temp_AHZCCoj;}();

    PFN_vkCopyMemoryToMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMemoryToMicromapEXT)get_instance_proc_addr(parent,"vkCopyMemoryToMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMemoryToMicromapEXT)get_device_proc_addr(parent,"vkCopyMemoryToMicromapEXT");
    }  
    
{
auto result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_QufOGLT=json["pInfo"].emplace_array();
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto& temp=arr_QufOGLT[semZpgt].emplace_object();
            return serialize_struct(temp, pInfo[semZpgt]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdWriteMicromapsPropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t micromapCount;
[&](){micromapCount=static_cast<uint32_t>(value_to<int>(json["micromapCount"]));}();
VkMicromapEXT* pMicromaps;
[&](){ VkMicromapEXT* temp_DooGQPs[&](){
            if (json["pMicromaps"].as_array().size()==0){
                temp_DooGQPs=NULL;
            return; }temp_DooGQPs=(VkMicromapEXT*)malloc(micromapCount*sizeof(VkMicromapEXT));
        auto& arr_gjzjRBu=json["pMicromaps"].as_array();
        for(int XuxNkjt=0; XuxNkjt < micromapCount; XuxNkjt++){
            [&](){deserialize_VkMicromapEXT(arr_gjzjRBu[XuxNkjt], temp_DooGQPs[XuxNkjt]);}();
        }
        }();pMicromaps=temp_DooGQPs;}();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();

    PFN_vkCmdWriteMicromapsPropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteMicromapsPropertiesEXT)get_instance_proc_addr(parent,"vkCmdWriteMicromapsPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteMicromapsPropertiesEXT)get_device_proc_addr(parent,"vkCmdWriteMicromapsPropertiesEXT");
    }  
    
{
call_function(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["micromapCount"]=micromapCount;}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=boost::json::array();
            return; }
        auto& arr_NriAFXg=json["pMicromaps"].emplace_array();
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();


        writeToConn(json);
    }

    void handle_vkWriteMicromapsPropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t micromapCount;
[&](){micromapCount=static_cast<uint32_t>(value_to<int>(json["micromapCount"]));}();
VkMicromapEXT* pMicromaps;
[&](){ VkMicromapEXT* temp_DooGQPs[&](){
            if (json["pMicromaps"].as_array().size()==0){
                temp_DooGQPs=NULL;
            return; }temp_DooGQPs=(VkMicromapEXT*)malloc(micromapCount*sizeof(VkMicromapEXT));
        auto& arr_gjzjRBu=json["pMicromaps"].as_array();
        for(int XuxNkjt=0; XuxNkjt < micromapCount; XuxNkjt++){
            [&](){deserialize_VkMicromapEXT(arr_gjzjRBu[XuxNkjt], temp_DooGQPs[XuxNkjt]);}();
        }
        }();pMicromaps=temp_DooGQPs;}();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
size_t dataSize;
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();
size_t stride;
[&](){stride=static_cast<size_t>(value_to<int>(json["stride"]));}();

    PFN_vkWriteMicromapsPropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWriteMicromapsPropertiesEXT)get_instance_proc_addr(parent,"vkWriteMicromapsPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWriteMicromapsPropertiesEXT)get_device_proc_addr(parent,"vkWriteMicromapsPropertiesEXT");
    }  
    
{
auto result=call_function(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["micromapCount"]=micromapCount;}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=boost::json::array();
            return; }
        auto& arr_NriAFXg=json["pMicromaps"].emplace_array();
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
[&](){json["stride"]=stride;}();


        writeToConn(json);
    }

    void handle_vkGetDeviceMicromapCompatibilityEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMicromapVersionInfoEXT* pVersionInfo;
[&](){ VkMicromatemp_YXAaWJMEXT* temp_YXAaWJM[&](){
            if (json["pVersionInfo"].as_array().size()==0){
                temp_YXAaWJM=NULL;
            return; }temp_YXAaWJM=(VkMicromapVersionInfoEXT*)malloc(1*sizeof(VkMicromapVersionInfoEXT));
        auto& arr_FlJdkUQ=json["pVersionInfo"].as_array();
        for(int GMLSjyq=0; GMLSjyq < 1; GMLSjyq++){
            [&](){
            auto& temp=arr_FlJdkUQ[GMLSjyq].as_object();
            deserialize_struct(temp,temp_YXAaWJM[GMLSjyq]);
            }();
        }
        }();pVersionInfo=temp_YXAaWJM;}();
VkAccelerationStructureCompatibilityKHR* pCompatibility;
[&](){
            if (json["pCompatibility"].as_array().size()==0){
                pCompatibility=NULL;
            return; }pCompatibility=(VkAccelerationStructureCompatibilityKHR*)malloc(1*sizeof(VkAccelerationStructureCompatibilityKHR));
        auto& arr_dBMhFMX=json["pCompatibility"].as_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){temp_guVSKHd=static_cast<int>(value_to<int>(arr_dBMhFMX[nzOFTGF]));}();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

    PFN_vkGetDeviceMicromapCompatibilityEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceMicromapCompatibilityEXT)get_instance_proc_addr(parent,"vkGetDeviceMicromapCompatibilityEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceMicromapCompatibilityEXT)get_device_proc_addr(parent,"vkGetDeviceMicromapCompatibilityEXT");
    }  
    
{
call_function(device, pVersionInfo, pCompatibility);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=boost::json::array();
            return; }
        auto& arr_PYqUGEM=json["pVersionInfo"].emplace_array();
        for(int odfXDEI=0; odfXDEI < 1; odfXDEI++){
            [&](){
            auto& temp=arr_PYqUGEM[odfXDEI].emplace_object();
            return serialize_struct(temp, pVersionInfo[odfXDEI]);
            }();
        }
        }();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=boost::json::array();
            return; }
        auto& arr_dBMhFMX=json["pCompatibility"].emplace_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=pCompatibility[nzOFTGF];}();}();}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetMicromapBuildSizesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureBuildTypeKHR buildType;
[&](){[&](){int temp_XouAsBI;[&](){temp_XouAsBI=static_cast<int>(value_to<int>(json["buildType"]));}();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();
VkMicromapBuildInfoEXT* pBuildInfo;
[&](){ VkMicromatemp_SkrWSNxEXT* temp_SkrWSNx[&](){
            if (json["pBuildInfo"].as_array().size()==0){
                temp_SkrWSNx=NULL;
            return; }temp_SkrWSNx=(VkMicromapBuildInfoEXT*)malloc(1*sizeof(VkMicromapBuildInfoEXT));
        auto& arr_oNQjwLj=json["pBuildInfo"].as_array();
        for(int ALWsyDT=0; ALWsyDT < 1; ALWsyDT++){
            [&](){
            auto& temp=arr_oNQjwLj[ALWsyDT].as_object();
            deserialize_struct(temp,temp_SkrWSNx[ALWsyDT]);
            }();
        }
        }();pBuildInfo=temp_SkrWSNx;}();
VkMicromapBuildSizesInfoEXT* pSizeInfo;
[&](){
            if (json["pSizeInfo"].as_array().size()==0){
                pSizeInfo=NULL;
            return; }pSizeInfo=(VkMicromapBuildSizesInfoEXT*)malloc(1*sizeof(VkMicromapBuildSizesInfoEXT));
        auto& arr_fJKSsZw=json["pSizeInfo"].as_array();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto& temp=arr_fJKSsZw[XgjgtXU].as_object();
            deserialize_struct(temp,pSizeInfo[XgjgtXU]);
            }();
        }
        }();

    PFN_vkGetMicromapBuildSizesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMicromapBuildSizesEXT)get_instance_proc_addr(parent,"vkGetMicromapBuildSizesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMicromapBuildSizesEXT)get_device_proc_addr(parent,"vkGetMicromapBuildSizesEXT");
    }  
    
{
call_function(device, buildType, pBuildInfo, pSizeInfo);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=buildType;}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=boost::json::array();
            return; }
        auto& arr_lREHNwp=json["pBuildInfo"].emplace_array();
        for(int nPItxru=0; nPItxru < 1; nPItxru++){
            [&](){
            auto& temp=arr_lREHNwp[nPItxru].emplace_object();
            return serialize_struct(temp, pBuildInfo[nPItxru]);
            }();
        }
        }();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=boost::json::array();
            return; }
        auto& arr_fJKSsZw=json["pSizeInfo"].emplace_array();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto& temp=arr_fJKSsZw[XgjgtXU].emplace_object();
            return serialize_struct(temp, pSizeInfo[XgjgtXU]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetShaderModuleIdentifierEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderModule shaderModule;
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();
VkShaderModuleIdentifierEXT* pIdentifier;
[&](){
            if (json["pIdentifier"].as_array().size()==0){
                pIdentifier=NULL;
            return; }pIdentifier=(VkShaderModuleIdentifierEXT*)malloc(1*sizeof(VkShaderModuleIdentifierEXT));
        auto& arr_ICaFqGG=json["pIdentifier"].as_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].as_object();
            deserialize_struct(temp,pIdentifier[DSBkSwY]);
            }();
        }
        }();

    PFN_vkGetShaderModuleIdentifierEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetShaderModuleIdentifierEXT)get_instance_proc_addr(parent,"vkGetShaderModuleIdentifierEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetShaderModuleIdentifierEXT)get_device_proc_addr(parent,"vkGetShaderModuleIdentifierEXT");
    }  
    
{
call_function(device, shaderModule, pIdentifier);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=boost::json::array();
            return; }
        auto& arr_ICaFqGG=json["pIdentifier"].emplace_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].emplace_object();
            return serialize_struct(temp, pIdentifier[DSBkSwY]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetShaderModuleCreateInfoIdentifierEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderModuleCreateInfo* pCreateInfo;
[&](){ VkShaderModuleCreateInfo* temp_VfXsFIV[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_VfXsFIV=NULL;
            return; }temp_VfXsFIV=(VkShaderModuleCreateInfo*)malloc(1*sizeof(VkShaderModuleCreateInfo));
        auto& arr_GtIQgds=json["pCreateInfo"].as_array();
        for(int PbmosKP=0; PbmosKP < 1; PbmosKP++){
            [&](){
            auto& temp=arr_GtIQgds[PbmosKP].as_object();
            deserialize_struct(temp,temp_VfXsFIV[PbmosKP]);
            }();
        }
        }();pCreateInfo=temp_VfXsFIV;}();
VkShaderModuleIdentifierEXT* pIdentifier;
[&](){
            if (json["pIdentifier"].as_array().size()==0){
                pIdentifier=NULL;
            return; }pIdentifier=(VkShaderModuleIdentifierEXT*)malloc(1*sizeof(VkShaderModuleIdentifierEXT));
        auto& arr_ICaFqGG=json["pIdentifier"].as_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].as_object();
            deserialize_struct(temp,pIdentifier[DSBkSwY]);
            }();
        }
        }();

    PFN_vkGetShaderModuleCreateInfoIdentifierEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetShaderModuleCreateInfoIdentifierEXT)get_instance_proc_addr(parent,"vkGetShaderModuleCreateInfoIdentifierEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetShaderModuleCreateInfoIdentifierEXT)get_device_proc_addr(parent,"vkGetShaderModuleCreateInfoIdentifierEXT");
    }  
    
{
call_function(device, pCreateInfo, pIdentifier);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_iSZUILM=json["pCreateInfo"].emplace_array();
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto& temp=arr_iSZUILM[dKxemXH].emplace_object();
            return serialize_struct(temp, pCreateInfo[dKxemXH]);
            }();
        }
        }();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=boost::json::array();
            return; }
        auto& arr_ICaFqGG=json["pIdentifier"].emplace_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].emplace_object();
            return serialize_struct(temp, pIdentifier[DSBkSwY]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetImageSubresourceLayout2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageSubresource2KHR* pSubresource;
[&](){ VkImageSubresource2KHR* temp_vxrcXgU[&](){
            if (json["pSubresource"].as_array().size()==0){
                temp_vxrcXgU=NULL;
            return; }temp_vxrcXgU=(VkImageSubresource2KHR*)malloc(1*sizeof(VkImageSubresource2KHR));
        auto& arr_oUQSxrb=json["pSubresource"].as_array();
        for(int HhQHZaA=0; HhQHZaA < 1; HhQHZaA++){
            [&](){
            auto& temp=arr_oUQSxrb[HhQHZaA].as_object();
            deserialize_struct(temp,temp_vxrcXgU[HhQHZaA]);
            }();
        }
        }();pSubresource=temp_vxrcXgU;}();
VkSubresourceLayout2KHR* pLayout;
[&](){
            if (json["pLayout"].as_array().size()==0){
                pLayout=NULL;
            return; }pLayout=(VkSubresourceLayout2KHR*)malloc(1*sizeof(VkSubresourceLayout2KHR));
        auto& arr_JxnVeqW=json["pLayout"].as_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].as_object();
            deserialize_struct(temp,pLayout[jEkaLQP]);
            }();
        }
        }();

    PFN_vkGetImageSubresourceLayout2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageSubresourceLayout2KHR)get_instance_proc_addr(parent,"vkGetImageSubresourceLayout2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageSubresourceLayout2KHR)get_device_proc_addr(parent,"vkGetImageSubresourceLayout2KHR");
    }  
    
{
call_function(device, image, pSubresource, pLayout);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=boost::json::array();
            return; }
        auto& arr_xtdYssI=json["pSubresource"].emplace_array();
        for(int HvvKvoL=0; HvvKvoL < 1; HvvKvoL++){
            [&](){
            auto& temp=arr_xtdYssI[HvvKvoL].emplace_object();
            return serialize_struct(temp, pSubresource[HvvKvoL]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }
        auto& arr_JxnVeqW=json["pLayout"].emplace_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].emplace_object();
            return serialize_struct(temp, pLayout[jEkaLQP]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPipelinePropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineInfoEXT* pPipelineInfo;
[&](){ VkPipelineInfoEXT* temp_YQbjUzB[&](){
            if (json["pPipelineInfo"].as_array().size()==0){
                temp_YQbjUzB=NULL;
            return; }temp_YQbjUzB=(VkPipelineInfoEXT*)malloc(1*sizeof(VkPipelineInfoEXT));
        auto& arr_PhjfoeL=json["pPipelineInfo"].as_array();
        for(int tiAojvv=0; tiAojvv < 1; tiAojvv++){
            [&](){
            auto& temp=arr_PhjfoeL[tiAojvv].as_object();
            deserialize_struct(temp,temp_YQbjUzB[tiAojvv]);
            }();
        }
        }();pPipelineInfo=temp_YQbjUzB;}();
VkBaseOutStructure* pPipelineProperties;
[&](){
            if (json["pPipelineProperties"].as_array().size()==0){
                pPipelineProperties=NULL;
            return; }pPipelineProperties=(VkBaseOutStructure*)malloc(1*sizeof(VkBaseOutStructure));
        auto& arr_eMgMlNc=json["pPipelineProperties"].as_array();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto& temp=arr_eMgMlNc[cJpCXwz].as_object();
            deserialize_struct(temp,pPipelineProperties[cJpCXwz]);
            }();
        }
        }();

    PFN_vkGetPipelinePropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelinePropertiesEXT)get_instance_proc_addr(parent,"vkGetPipelinePropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelinePropertiesEXT)get_device_proc_addr(parent,"vkGetPipelinePropertiesEXT");
    }  
    
{
auto result=call_function(device, pPipelineInfo, pPipelineProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=boost::json::array();
            return; }
        auto& arr_eGbOPJq=json["pPipelineInfo"].emplace_array();
        for(int iUjmOrp=0; iUjmOrp < 1; iUjmOrp++){
            [&](){
            auto& temp=arr_eGbOPJq[iUjmOrp].emplace_object();
            return serialize_struct(temp, pPipelineInfo[iUjmOrp]);
            }();
        }
        }();
[&](){
            if (pPipelineProperties==NULL){
                json["pPipelineProperties"]=boost::json::array();
            return; }
        auto& arr_eMgMlNc=json["pPipelineProperties"].emplace_array();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto& temp=arr_eMgMlNc[cJpCXwz].emplace_object();
            return serialize_struct(temp, pPipelineProperties[cJpCXwz]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetFramebufferTilePropertiesQCOM(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFramebuffer framebuffer;
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();
uint32_t* pPropertiesCount;
[&](){
            if (json["pPropertiesCount"].as_array().size()==0){
                pPropertiesCount=NULL;
            return; }pPropertiesCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_vUkyKfO=json["pPropertiesCount"].as_array();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(value_to<int>(arr_vUkyKfO[YhfeqPW]));}();
        }
        }();
VkTilePropertiesQCOM* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkTilePropertiesQCOM*)malloc(*pPropertiesCount*sizeof(VkTilePropertiesQCOM));
        auto& arr_hYNBodF=json["pProperties"].as_array();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].as_object();
            deserialize_struct(temp,pProperties[oGElcJh]);
            }();
        }
        }();

    PFN_vkGetFramebufferTilePropertiesQCOM call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetFramebufferTilePropertiesQCOM)get_instance_proc_addr(parent,"vkGetFramebufferTilePropertiesQCOM");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetFramebufferTilePropertiesQCOM)get_device_proc_addr(parent,"vkGetFramebufferTilePropertiesQCOM");
    }  
    
{
auto result=call_function(device, framebuffer, pPropertiesCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pPropertiesCount==NULL){
                json["pPropertiesCount"]=boost::json::array();
            return; }
        auto& arr_vUkyKfO=json["pPropertiesCount"].emplace_array();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){arr_vUkyKfO[YhfeqPW]=pPropertiesCount[YhfeqPW];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_hYNBodF=json["pProperties"].emplace_array();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].emplace_object();
            return serialize_struct(temp, pProperties[oGElcJh]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDynamicRenderingTilePropertiesQCOM(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderingInfo* pRenderingInfo;
[&](){ VkRenderingInfo* temp_ySbRVvm[&](){
            if (json["pRenderingInfo"].as_array().size()==0){
                temp_ySbRVvm=NULL;
            return; }temp_ySbRVvm=(VkRenderingInfo*)malloc(1*sizeof(VkRenderingInfo));
        auto& arr_IEHUXzQ=json["pRenderingInfo"].as_array();
        for(int oIBIqTv=0; oIBIqTv < 1; oIBIqTv++){
            [&](){
            auto& temp=arr_IEHUXzQ[oIBIqTv].as_object();
            deserialize_struct(temp,temp_ySbRVvm[oIBIqTv]);
            }();
        }
        }();pRenderingInfo=temp_ySbRVvm;}();
VkTilePropertiesQCOM* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkTilePropertiesQCOM*)malloc(1*sizeof(VkTilePropertiesQCOM));
        auto& arr_hYNBodF=json["pProperties"].as_array();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].as_object();
            deserialize_struct(temp,pProperties[oGElcJh]);
            }();
        }
        }();

    PFN_vkGetDynamicRenderingTilePropertiesQCOM call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDynamicRenderingTilePropertiesQCOM)get_instance_proc_addr(parent,"vkGetDynamicRenderingTilePropertiesQCOM");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDynamicRenderingTilePropertiesQCOM)get_device_proc_addr(parent,"vkGetDynamicRenderingTilePropertiesQCOM");
    }  
    
{
auto result=call_function(device, pRenderingInfo, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=boost::json::array();
            return; }
        auto& arr_DOEgrev=json["pRenderingInfo"].emplace_array();
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto& temp=arr_DOEgrev[dAqQfxy].emplace_object();
            return serialize_struct(temp, pRenderingInfo[dAqQfxy]);
            }();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_hYNBodF=json["pProperties"].emplace_array();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].emplace_object();
            return serialize_struct(temp, pProperties[oGElcJh]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo;
[&](){ VkOpticalFlowImageFormatInfoNV* temp_TVgrGQC[&](){
            if (json["pOpticalFlowImageFormatInfo"].as_array().size()==0){
                temp_TVgrGQC=NULL;
            return; }temp_TVgrGQC=(VkOpticalFlowImageFormatInfoNV*)malloc(1*sizeof(VkOpticalFlowImageFormatInfoNV));
        auto& arr_bHRLrfx=json["pOpticalFlowImageFormatInfo"].as_array();
        for(int oBdVYyf=0; oBdVYyf < 1; oBdVYyf++){
            [&](){
            auto& temp=arr_bHRLrfx[oBdVYyf].as_object();
            deserialize_struct(temp,temp_TVgrGQC[oBdVYyf]);
            }();
        }
        }();pOpticalFlowImageFormatInfo=temp_TVgrGQC;}();
uint32_t* pFormatCount;
[&](){
            if (json["pFormatCount"].as_array().size()==0){
                pFormatCount=NULL;
            return; }pFormatCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_OWVxAsX=json["pFormatCount"].as_array();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){pFormatCount[AvMKjKj]=static_cast<uint32_t>(value_to<int>(arr_OWVxAsX[AvMKjKj]));}();
        }
        }();
VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties;
[&](){
            if (json["pImageFormatProperties"].as_array().size()==0){
                pImageFormatProperties=NULL;
            return; }pImageFormatProperties=(VkOpticalFlowImageFormatPropertiesNV*)malloc(*pFormatCount*sizeof(VkOpticalFlowImageFormatPropertiesNV));
        auto& arr_oZncgpa=json["pImageFormatProperties"].as_array();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto& temp=arr_oZncgpa[gkJgIzP].as_object();
            deserialize_struct(temp,pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
    }  
    
{
auto result=call_function(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pOpticalFlowImageFormatInfo==NULL){
                json["pOpticalFlowImageFormatInfo"]=boost::json::array();
            return; }
        auto& arr_oyPfnWV=json["pOpticalFlowImageFormatInfo"].emplace_array();
        for(int HqzITOl=0; HqzITOl < 1; HqzITOl++){
            [&](){
            auto& temp=arr_oyPfnWV[HqzITOl].emplace_object();
            return serialize_struct(temp, pOpticalFlowImageFormatInfo[HqzITOl]);
            }();
        }
        }();
[&](){
            if (pFormatCount==NULL){
                json["pFormatCount"]=boost::json::array();
            return; }
        auto& arr_OWVxAsX=json["pFormatCount"].emplace_array();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){arr_OWVxAsX[AvMKjKj]=pFormatCount[AvMKjKj];}();
        }
        }();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }
        auto& arr_oZncgpa=json["pImageFormatProperties"].emplace_array();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto& temp=arr_oZncgpa[gkJgIzP].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateOpticalFlowSessionNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkOpticalFlowSessionCreateInfoNV* pCreateInfo;
[&](){ VkOpticalFlowSessionCreateInfoNV* temp_VWtegVz[&](){
            if (json["pCreateInfo"].as_array().size()==0){
                temp_VWtegVz=NULL;
            return; }temp_VWtegVz=(VkOpticalFlowSessionCreateInfoNV*)malloc(1*sizeof(VkOpticalFlowSessionCreateInfoNV));
        auto& arr_sIplIPh=json["pCreateInfo"].as_array();
        for(int OLjhukd=0; OLjhukd < 1; OLjhukd++){
            [&](){
            auto& temp=arr_sIplIPh[OLjhukd].as_object();
            deserialize_struct(temp,temp_VWtegVz[OLjhukd]);
            }();
        }
        }();pCreateInfo=temp_VWtegVz;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkOpticalFlowSessionNV* pSession;
[&](){
            if (json["pSession"].as_array().size()==0){
                pSession=NULL;
            return; }pSession=(VkOpticalFlowSessionNV*)malloc(1*sizeof(VkOpticalFlowSessionNV));
        auto& arr_PyNQerY=json["pSession"].as_array();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){deserialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ], pSession[FnADpyZ]);}();
        }
        }();

    PFN_vkCreateOpticalFlowSessionNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateOpticalFlowSessionNV)get_instance_proc_addr(parent,"vkCreateOpticalFlowSessionNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateOpticalFlowSessionNV)get_device_proc_addr(parent,"vkCreateOpticalFlowSessionNV");
    }  
    
{
auto result=call_function(device, pCreateInfo, pAllocator, pSession);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_dKVOiZE=json["pCreateInfo"].emplace_array();
        for(int LaeeodD=0; LaeeodD < 1; LaeeodD++){
            [&](){
            auto& temp=arr_dKVOiZE[LaeeodD].emplace_object();
            return serialize_struct(temp, pCreateInfo[LaeeodD]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSession==NULL){
                json["pSession"]=boost::json::array();
            return; }
        auto& arr_PyNQerY=json["pSession"].emplace_array();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){serialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ],pSession[FnADpyZ]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyOpticalFlowSessionNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkOpticalFlowSessionNV session;
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyOpticalFlowSessionNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyOpticalFlowSessionNV)get_instance_proc_addr(parent,"vkDestroyOpticalFlowSessionNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyOpticalFlowSessionNV)get_device_proc_addr(parent,"vkDestroyOpticalFlowSessionNV");
    }  
    
{
call_function(device, session, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkBindOpticalFlowSessionImageNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkOpticalFlowSessionNV session;
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
VkOpticalFlowSessionBindingPointNV bindingPoint;
[&](){[&](){int temp_dqYOkbF;[&](){temp_dqYOkbF=static_cast<int>(value_to<int>(json["bindingPoint"]));}();bindingPoint=(VkOpticalFlowSessionBindingPointNV)temp_dqYOkbF;}();}();
VkImageView view;
[&](){deserialize_VkImageView(json["view"], view);}();
VkImageLayout layout;
[&](){[&](){int temp_IaQZtFR;[&](){temp_IaQZtFR=static_cast<int>(value_to<int>(json["layout"]));}();layout=(VkImageLayout)temp_IaQZtFR;}();}();

    PFN_vkBindOpticalFlowSessionImageNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindOpticalFlowSessionImageNV)get_instance_proc_addr(parent,"vkBindOpticalFlowSessionImageNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindOpticalFlowSessionImageNV)get_device_proc_addr(parent,"vkBindOpticalFlowSessionImageNV");
    }  
    
{
auto result=call_function(device, session, bindingPoint, view, layout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){[&](){[&](){json["bindingPoint"]=bindingPoint;}();}();}();
[&](){serialize_VkImageView(json["view"],view);}();
[&](){[&](){[&](){json["layout"]=layout;}();}();}();


        writeToConn(json);
    }

    void handle_vkCmdOpticalFlowExecuteNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkOpticalFlowSessionNV session;
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
VkOpticalFlowExecuteInfoNV* pExecuteInfo;
[&](){ VkOpticalFlowExecuteInfoNV* temp_nGtFNDj[&](){
            if (json["pExecuteInfo"].as_array().size()==0){
                temp_nGtFNDj=NULL;
            return; }temp_nGtFNDj=(VkOpticalFlowExecuteInfoNV*)malloc(1*sizeof(VkOpticalFlowExecuteInfoNV));
        auto& arr_tbUOmHi=json["pExecuteInfo"].as_array();
        for(int HcarBbt=0; HcarBbt < 1; HcarBbt++){
            [&](){
            auto& temp=arr_tbUOmHi[HcarBbt].as_object();
            deserialize_struct(temp,temp_nGtFNDj[HcarBbt]);
            }();
        }
        }();pExecuteInfo=temp_nGtFNDj;}();

    PFN_vkCmdOpticalFlowExecuteNV call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdOpticalFlowExecuteNV)get_instance_proc_addr(parent,"vkCmdOpticalFlowExecuteNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdOpticalFlowExecuteNV)get_device_proc_addr(parent,"vkCmdOpticalFlowExecuteNV");
    }  
    
{
call_function(commandBuffer, session, pExecuteInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pExecuteInfo==NULL){
                json["pExecuteInfo"]=boost::json::array();
            return; }
        auto& arr_CyySpro=json["pExecuteInfo"].emplace_array();
        for(int XLHKKBA=0; XLHKKBA < 1; XLHKKBA++){
            [&](){
            auto& temp=arr_CyySpro[XLHKKBA].emplace_object();
            return serialize_struct(temp, pExecuteInfo[XLHKKBA]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceFaultInfoEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceFaultCountsEXT* pFaultCounts;
[&](){
            if (json["pFaultCounts"].as_array().size()==0){
                pFaultCounts=NULL;
            return; }pFaultCounts=(VkDeviceFaultCountsEXT*)malloc(1*sizeof(VkDeviceFaultCountsEXT));
        auto& arr_LWLqmdd=json["pFaultCounts"].as_array();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto& temp=arr_LWLqmdd[RexMRxZ].as_object();
            deserialize_struct(temp,pFaultCounts[RexMRxZ]);
            }();
        }
        }();
VkDeviceFaultInfoEXT* pFaultInfo;
[&](){
            if (json["pFaultInfo"].as_array().size()==0){
                pFaultInfo=NULL;
            return; }pFaultInfo=(VkDeviceFaultInfoEXT*)malloc(1*sizeof(VkDeviceFaultInfoEXT));
        auto& arr_CRNBZxs=json["pFaultInfo"].as_array();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto& temp=arr_CRNBZxs[AHHHhvb].as_object();
            deserialize_struct(temp,pFaultInfo[AHHHhvb]);
            }();
        }
        }();

    PFN_vkGetDeviceFaultInfoEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceFaultInfoEXT)get_instance_proc_addr(parent,"vkGetDeviceFaultInfoEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceFaultInfoEXT)get_device_proc_addr(parent,"vkGetDeviceFaultInfoEXT");
    }  
    
{
auto result=call_function(device, pFaultCounts, pFaultInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pFaultCounts==NULL){
                json["pFaultCounts"]=boost::json::array();
            return; }
        auto& arr_LWLqmdd=json["pFaultCounts"].emplace_array();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto& temp=arr_LWLqmdd[RexMRxZ].emplace_object();
            return serialize_struct(temp, pFaultCounts[RexMRxZ]);
            }();
        }
        }();
[&](){
            if (pFaultInfo==NULL){
                json["pFaultInfo"]=boost::json::array();
            return; }
        auto& arr_CRNBZxs=json["pFaultInfo"].emplace_array();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto& temp=arr_CRNBZxs[AHHHhvb].emplace_object();
            return serialize_struct(temp, pFaultInfo[AHHHhvb]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCmdSetDepthBias2EXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDepthBiasInfoEXT* pDepthBiasInfo;
[&](){ VkDepthBiasInfoEXT* temp_WDAjpjc[&](){
            if (json["pDepthBiasInfo"].as_array().size()==0){
                temp_WDAjpjc=NULL;
            return; }temp_WDAjpjc=(VkDepthBiasInfoEXT*)malloc(1*sizeof(VkDepthBiasInfoEXT));
        auto& arr_DfdCGqY=json["pDepthBiasInfo"].as_array();
        for(int xSRWdSz=0; xSRWdSz < 1; xSRWdSz++){
            [&](){
            auto& temp=arr_DfdCGqY[xSRWdSz].as_object();
            deserialize_struct(temp,temp_WDAjpjc[xSRWdSz]);
            }();
        }
        }();pDepthBiasInfo=temp_WDAjpjc;}();

    PFN_vkCmdSetDepthBias2EXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBias2EXT)get_instance_proc_addr(parent,"vkCmdSetDepthBias2EXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBias2EXT)get_device_proc_addr(parent,"vkCmdSetDepthBias2EXT");
    }  
    
{
call_function(commandBuffer, pDepthBiasInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDepthBiasInfo==NULL){
                json["pDepthBiasInfo"]=boost::json::array();
            return; }
        auto& arr_AKZgFGf=json["pDepthBiasInfo"].emplace_array();
        for(int kGsXYsB=0; kGsXYsB < 1; kGsXYsB++){
            [&](){
            auto& temp=arr_AKZgFGf[kGsXYsB].emplace_object();
            return serialize_struct(temp, pDepthBiasInfo[kGsXYsB]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkReleaseSwapchainImagesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkReleaseSwapchainImagesInfoEXT* pReleaseInfo;
[&](){ VkReleaseSwapchainImagesInfoEXT* temp_AsTZPVa[&](){
            if (json["pReleaseInfo"].as_array().size()==0){
                temp_AsTZPVa=NULL;
            return; }temp_AsTZPVa=(VkReleaseSwapchainImagesInfoEXT*)malloc(1*sizeof(VkReleaseSwapchainImagesInfoEXT));
        auto& arr_jqKJdwU=json["pReleaseInfo"].as_array();
        for(int fqZXHcz=0; fqZXHcz < 1; fqZXHcz++){
            [&](){
            auto& temp=arr_jqKJdwU[fqZXHcz].as_object();
            deserialize_struct(temp,temp_AsTZPVa[fqZXHcz]);
            }();
        }
        }();pReleaseInfo=temp_AsTZPVa;}();

    PFN_vkReleaseSwapchainImagesEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkReleaseSwapchainImagesEXT)get_instance_proc_addr(parent,"vkReleaseSwapchainImagesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkReleaseSwapchainImagesEXT)get_device_proc_addr(parent,"vkReleaseSwapchainImagesEXT");
    }  
    
{
auto result=call_function(device, pReleaseInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pReleaseInfo==NULL){
                json["pReleaseInfo"]=boost::json::array();
            return; }
        auto& arr_jcnZDBn=json["pReleaseInfo"].emplace_array();
        for(int dRtPqPF=0; dRtPqPF < 1; dRtPqPF++){
            [&](){
            auto& temp=arr_jcnZDBn[dRtPqPF].emplace_object();
            return serialize_struct(temp, pReleaseInfo[dRtPqPF]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetDeviceImageSubresourceLayoutKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceImageSubresourceInfoKHR* pInfo;
[&](){ VkDeviceImageSubresourceInfoKHR* temp_jRKIxst[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_jRKIxst=NULL;
            return; }temp_jRKIxst=(VkDeviceImageSubresourceInfoKHR*)malloc(1*sizeof(VkDeviceImageSubresourceInfoKHR));
        auto& arr_TDGjppd=json["pInfo"].as_array();
        for(int irOmazS=0; irOmazS < 1; irOmazS++){
            [&](){
            auto& temp=arr_TDGjppd[irOmazS].as_object();
            deserialize_struct(temp,temp_jRKIxst[irOmazS]);
            }();
        }
        }();pInfo=temp_jRKIxst;}();
VkSubresourceLayout2KHR* pLayout;
[&](){
            if (json["pLayout"].as_array().size()==0){
                pLayout=NULL;
            return; }pLayout=(VkSubresourceLayout2KHR*)malloc(1*sizeof(VkSubresourceLayout2KHR));
        auto& arr_JxnVeqW=json["pLayout"].as_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].as_object();
            deserialize_struct(temp,pLayout[jEkaLQP]);
            }();
        }
        }();

    PFN_vkGetDeviceImageSubresourceLayoutKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceImageSubresourceLayoutKHR)get_instance_proc_addr(parent,"vkGetDeviceImageSubresourceLayoutKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceImageSubresourceLayoutKHR)get_device_proc_addr(parent,"vkGetDeviceImageSubresourceLayoutKHR");
    }  
    
{
call_function(device, pInfo, pLayout);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_SwRDgPP=json["pInfo"].emplace_array();
        for(int wxoktPv=0; wxoktPv < 1; wxoktPv++){
            [&](){
            auto& temp=arr_SwRDgPP[wxoktPv].emplace_object();
            return serialize_struct(temp, pInfo[wxoktPv]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }
        auto& arr_JxnVeqW=json["pLayout"].emplace_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].emplace_object();
            return serialize_struct(temp, pLayout[jEkaLQP]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkMapMemory2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMemoryMapInfoKHR* pMemoryMapInfo;
[&](){ VkMemoryMapInfoKHR* temp_rEewDht[&](){
            if (json["pMemoryMapInfo"].as_array().size()==0){
                temp_rEewDht=NULL;
            return; }temp_rEewDht=(VkMemoryMapInfoKHR*)malloc(1*sizeof(VkMemoryMapInfoKHR));
        auto& arr_RTzyDuY=json["pMemoryMapInfo"].as_array();
        for(int cnbdFzc=0; cnbdFzc < 1; cnbdFzc++){
            [&](){
            auto& temp=arr_RTzyDuY[cnbdFzc].as_object();
            deserialize_struct(temp,temp_rEewDht[cnbdFzc]);
            }();
        }
        }();pMemoryMapInfo=temp_rEewDht;}();
void** ppData;
[&](){
            if (json["ppData"].as_array().size()==0){
                ppData=NULL;
            return; }ppData=(void**)malloc(1*sizeof(void*));
        auto& arr_JgRLJSK=json["ppData"].as_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].as_array().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].as_array().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].as_array().size()*sizeof(char));
        auto& arr_yHvgdEb=arr_JgRLJSK[NsRFkBj].as_array();
        for(int vgxltbA=0; vgxltbA < arr_JgRLJSK[NsRFkBj].as_array().size(); vgxltbA++){
            [&](){temp_JgRLJSK[vgxltbA]=static_cast<char>(value_to<int>(arr_yHvgdEb[vgxltbA]));}();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();

    PFN_vkMapMemory2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkMapMemory2KHR)get_instance_proc_addr(parent,"vkMapMemory2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkMapMemory2KHR)get_device_proc_addr(parent,"vkMapMemory2KHR");
    }  
    
{
auto result=call_function(device, pMemoryMapInfo, ppData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryMapInfo==NULL){
                json["pMemoryMapInfo"]=boost::json::array();
            return; }
        auto& arr_udcndbe=json["pMemoryMapInfo"].emplace_array();
        for(int iwSaLAe=0; iwSaLAe < 1; iwSaLAe++){
            [&](){
            auto& temp=arr_udcndbe[iwSaLAe].emplace_object();
            return serialize_struct(temp, pMemoryMapInfo[iwSaLAe]);
            }();
        }
        }();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }
        auto& arr_JgRLJSK=json["ppData"].emplace_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }
        auto& arr_yHvgdEb=arr_JgRLJSK[NsRFkBj].emplace_array();
        for(int vgxltbA=0; vgxltbA < strlen(((char*)(ppData[NsRFkBj])))+1; vgxltbA++){
            [&](){arr_yHvgdEb[vgxltbA]=((char*)(ppData[NsRFkBj]))[vgxltbA];}();
        }
        }();}();
        }
        }();

        boost::json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, pMemoryMapInfo->memory);
        
        auto server_memory=value_to<uintptr_t>(server_memory_json); 
        
        *ppData=registerDeviceMemoryMap(server_memory, pMemoryMapInfo->memory,pMemoryMapInfo->size,*ppData,(uintptr_t)(*ppData));
        
        #ifndef CLIENT
            json["mem"]=(uintptr_t)(*ppData);
        #endif
        

        writeToConn(json);
    }

    void handle_vkUnmapMemory2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMemoryUnmapInfoKHR* pMemoryUnmapInfo;
[&](){ VkMemoryUnmapInfoKHR* temp_ZjXXkAF[&](){
            if (json["pMemoryUnmapInfo"].as_array().size()==0){
                temp_ZjXXkAF=NULL;
            return; }temp_ZjXXkAF=(VkMemoryUnmapInfoKHR*)malloc(1*sizeof(VkMemoryUnmapInfoKHR));
        auto& arr_bpXegaD=json["pMemoryUnmapInfo"].as_array();
        for(int cntXsPf=0; cntXsPf < 1; cntXsPf++){
            [&](){
            auto& temp=arr_bpXegaD[cntXsPf].as_object();
            deserialize_struct(temp,temp_ZjXXkAF[cntXsPf]);
            }();
        }
        }();pMemoryUnmapInfo=temp_ZjXXkAF;}();

    PFN_vkUnmapMemory2KHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUnmapMemory2KHR)get_instance_proc_addr(parent,"vkUnmapMemory2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUnmapMemory2KHR)get_device_proc_addr(parent,"vkUnmapMemory2KHR");
    }  
    
{
auto result=call_function(device, pMemoryUnmapInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryUnmapInfo==NULL){
                json["pMemoryUnmapInfo"]=boost::json::array();
            return; }
        auto& arr_hZlnXPf=json["pMemoryUnmapInfo"].emplace_array();
        for(int caczdhq=0; caczdhq < 1; caczdhq++){
            [&](){
            auto& temp=arr_hZlnXPf[caczdhq].emplace_object();
            return serialize_struct(temp, pMemoryUnmapInfo[caczdhq]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkCreateShadersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t createInfoCount;
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();
VkShaderCreateInfoEXT* pCreateInfos;
[&](){ VkShaderCreateInfoEXT* temp_USOpaUP[&](){
            if (json["pCreateInfos"].as_array().size()==0){
                temp_USOpaUP=NULL;
            return; }temp_USOpaUP=(VkShaderCreateInfoEXT*)malloc(createInfoCount*sizeof(VkShaderCreateInfoEXT));
        auto& arr_aNFxtFM=json["pCreateInfos"].as_array();
        for(int IEFkbzS=0; IEFkbzS < createInfoCount; IEFkbzS++){
            [&](){
            auto& temp=arr_aNFxtFM[IEFkbzS].as_object();
            deserialize_struct(temp,temp_USOpaUP[IEFkbzS]);
            }();
        }
        }();pCreateInfos=temp_USOpaUP;}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();
VkShaderEXT* pShaders;
[&](){
            if (json["pShaders"].as_array().size()==0){
                pShaders=NULL;
            return; }pShaders=(VkShaderEXT*)malloc(createInfoCount*sizeof(VkShaderEXT));
        auto& arr_ndnxxFm=json["pShaders"].as_array();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){deserialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN], pShaders[NwhTkPN]);}();
        }
        }();

    PFN_vkCreateShadersEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateShadersEXT)get_instance_proc_addr(parent,"vkCreateShadersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateShadersEXT)get_device_proc_addr(parent,"vkCreateShadersEXT");
    }  
    
{
auto result=call_function(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_mOfZnnW=json["pCreateInfos"].emplace_array();
        for(int bOiKywR=0; bOiKywR < createInfoCount; bOiKywR++){
            [&](){
            auto& temp=arr_mOfZnnW[bOiKywR].emplace_object();
            return serialize_struct(temp, pCreateInfos[bOiKywR]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=boost::json::array();
            return; }
        auto& arr_ndnxxFm=json["pShaders"].emplace_array();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){serialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN],pShaders[NwhTkPN]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkDestroyShaderEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderEXT shader;
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();
VkAllocationCallbacks* pAllocator;
[&](){ VkAllocationCallbacks* temp_bdXXnmE[&](){
            if (json["pAllocator"].as_array().size()==0){
                temp_bdXXnmE=NULL;
            return; }temp_bdXXnmE=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].as_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].as_object();
            deserialize_struct(temp,temp_bdXXnmE[YRPmyai]);
            }();
        }
        }();pAllocator=temp_bdXXnmE;}();

    PFN_vkDestroyShaderEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyShaderEXT)get_instance_proc_addr(parent,"vkDestroyShaderEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyShaderEXT)get_device_proc_addr(parent,"vkDestroyShaderEXT");
    }  
    
{
call_function(device, shader, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetShaderBinaryDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderEXT shader;
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();
size_t* pDataSize;
[&](){
            if (json["pDataSize"].as_array().size()==0){
                pDataSize=NULL;
            return; }pDataSize=(size_t*)malloc(1*sizeof(size_t));
        auto& arr_Zcusyfw=json["pDataSize"].as_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){pDataSize[HCzJfGC]=static_cast<size_t>(value_to<int>(arr_Zcusyfw[HCzJfGC]));}();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){temp_ZtBEjVJ[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_ZtBEjVJ;}();

    PFN_vkGetShaderBinaryDataEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetShaderBinaryDataEXT)get_instance_proc_addr(parent,"vkGetShaderBinaryDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetShaderBinaryDataEXT)get_device_proc_addr(parent,"vkGetShaderBinaryDataEXT");
    }  
    
{
auto result=call_function(device, shader, pDataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].emplace_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();


        writeToConn(json);
    }

    void handle_vkCmdBindShadersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t stageCount;
[&](){stageCount=static_cast<uint32_t>(value_to<int>(json["stageCount"]));}();
VkShaderStageFlagBits* pStages;
[&](){ VkShaderStageFlagBits* temp_yBowAmc[&](){
            if (json["pStages"].as_array().size()==0){
                temp_yBowAmc=NULL;
            return; }temp_yBowAmc=(VkShaderStageFlagBits*)malloc(stageCount*sizeof(VkShaderStageFlagBits));
        auto& arr_qbDLWnb=json["pStages"].as_array();
        for(int FzJYCiP=0; FzJYCiP < stageCount; FzJYCiP++){
            [&](){[&](){int temp_IwfnGxi;[&](){temp_IwfnGxi=static_cast<int>(value_to<int>(arr_qbDLWnb[FzJYCiP]));}();temp_yBowAmc[FzJYCiP]=(VkShaderStageFlagBits)temp_IwfnGxi;}();}();
        }
        }();pStages=temp_yBowAmc;}();
VkShaderEXT* pShaders;
[&](){ VkShaderEXT* temp_kcLPriN[&](){
            if (json["pShaders"].as_array().size()==0){
                temp_kcLPriN=NULL;
            return; }temp_kcLPriN=(VkShaderEXT*)malloc(stageCount*sizeof(VkShaderEXT));
        auto& arr_lXkCGqI=json["pShaders"].as_array();
        for(int DXMUrFp=0; DXMUrFp < stageCount; DXMUrFp++){
            [&](){deserialize_VkShaderEXT(arr_lXkCGqI[DXMUrFp], temp_kcLPriN[DXMUrFp]);}();
        }
        }();pShaders=temp_kcLPriN;}();

    PFN_vkCmdBindShadersEXT call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindShadersEXT)get_instance_proc_addr(parent,"vkCmdBindShadersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindShadersEXT)get_device_proc_addr(parent,"vkCmdBindShadersEXT");
    }  
    
{
call_function(commandBuffer, stageCount, pStages, pShaders);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["stageCount"]=stageCount;}();
[&](){
            if (pStages==NULL){
                json["pStages"]=boost::json::array();
            return; }
        auto& arr_phXrzxO=json["pStages"].emplace_array();
        for(int uFucfxh=0; uFucfxh < stageCount; uFucfxh++){
            [&](){[&](){[&](){arr_phXrzxO[uFucfxh]=pStages[uFucfxh];}();}();}();
        }
        }();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=boost::json::array();
            return; }
        auto& arr_ZjERyql=json["pShaders"].emplace_array();
        for(int DxWTbGC=0; DxWTbGC < stageCount; DxWTbGC++){
            [&](){serialize_VkShaderEXT(arr_ZjERyql[DxWTbGC],pShaders[DxWTbGC]);}();
        }
        }();


        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
VkCooperativeMatrixPropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkCooperativeMatrixPropertiesKHR*)malloc(*pPropertyCount*sizeof(VkCooperativeMatrixPropertiesKHR));
        auto& arr_PEzgESc=json["pProperties"].as_array();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto& temp=arr_PEzgESc[iTGjLCh].as_object();
            deserialize_struct(temp,pProperties[iTGjLCh]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
    }  
    
{
auto result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_PEzgESc=json["pProperties"].emplace_array();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto& temp=arr_PEzgESc[iTGjLCh].emplace_object();
            return serialize_struct(temp, pProperties[iTGjLCh]);
            }();
        }
        }();


        writeToConn(json);
    }

void handle_command(boost::json::object json){
//Will only be called by the server

switch (value_to<Command>(json["enum"])){


        case (VKCREATEINSTANCE):
            handle_command(json);
            return;
    

        case (VKDESTROYINSTANCE):
            handle_command(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICES):
            handle_command(json);
            return;
    

        case (VKGETDEVICEPROCADDR):
            handle_command(json);
            return;
    

        case (VKGETINSTANCEPROCADDR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEMEMORYPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEFEATURES):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEFORMATPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES):
            handle_command(json);
            return;
    

        case (VKCREATEDEVICE):
            handle_command(json);
            return;
    

        case (VKDESTROYDEVICE):
            handle_command(json);
            return;
    

        case (VKENUMERATEINSTANCEVERSION):
            handle_command(json);
            return;
    

        case (VKENUMERATEINSTANCELAYERPROPERTIES):
            handle_command(json);
            return;
    

        case (VKENUMERATEINSTANCEEXTENSIONPROPERTIES):
            handle_command(json);
            return;
    

        case (VKENUMERATEDEVICELAYERPROPERTIES):
            handle_command(json);
            return;
    

        case (VKENUMERATEDEVICEEXTENSIONPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETDEVICEQUEUE):
            handle_command(json);
            return;
    

        case (VKQUEUESUBMIT):
            handle_command(json);
            return;
    

        case (VKQUEUEWAITIDLE):
            handle_command(json);
            return;
    

        case (VKDEVICEWAITIDLE):
            handle_command(json);
            return;
    

        case (VKALLOCATEMEMORY):
            handle_command(json);
            return;
    

        case (VKFREEMEMORY):
            handle_command(json);
            return;
    

        case (VKMAPMEMORY):
            handle_command(json);
            return;
    

        case (VKUNMAPMEMORY):
            handle_command(json);
            return;
    

        case (VKFLUSHMAPPEDMEMORYRANGES):
            handle_command(json);
            return;
    

        case (VKINVALIDATEMAPPEDMEMORYRANGES):
            handle_command(json);
            return;
    

        case (VKGETDEVICEMEMORYCOMMITMENT):
            handle_command(json);
            return;
    

        case (VKGETBUFFERMEMORYREQUIREMENTS):
            handle_command(json);
            return;
    

        case (VKBINDBUFFERMEMORY):
            handle_command(json);
            return;
    

        case (VKGETIMAGEMEMORYREQUIREMENTS):
            handle_command(json);
            return;
    

        case (VKBINDIMAGEMEMORY):
            handle_command(json);
            return;
    

        case (VKGETIMAGESPARSEMEMORYREQUIREMENTS):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES):
            handle_command(json);
            return;
    

        case (VKQUEUEBINDSPARSE):
            handle_command(json);
            return;
    

        case (VKCREATEFENCE):
            handle_command(json);
            return;
    

        case (VKDESTROYFENCE):
            handle_command(json);
            return;
    

        case (VKRESETFENCES):
            handle_command(json);
            return;
    

        case (VKGETFENCESTATUS):
            handle_command(json);
            return;
    

        case (VKWAITFORFENCES):
            handle_command(json);
            return;
    

        case (VKCREATESEMAPHORE):
            handle_command(json);
            return;
    

        case (VKDESTROYSEMAPHORE):
            handle_command(json);
            return;
    

        case (VKCREATEEVENT):
            handle_command(json);
            return;
    

        case (VKDESTROYEVENT):
            handle_command(json);
            return;
    

        case (VKGETEVENTSTATUS):
            handle_command(json);
            return;
    

        case (VKSETEVENT):
            handle_command(json);
            return;
    

        case (VKRESETEVENT):
            handle_command(json);
            return;
    

        case (VKCREATEQUERYPOOL):
            handle_command(json);
            return;
    

        case (VKDESTROYQUERYPOOL):
            handle_command(json);
            return;
    

        case (VKGETQUERYPOOLRESULTS):
            handle_command(json);
            return;
    

        case (VKRESETQUERYPOOL):
            handle_command(json);
            return;
    

        case (VKRESETQUERYPOOL):
            handle_command(json);
            return;
    

        case (VKCREATEBUFFER):
            handle_command(json);
            return;
    

        case (VKDESTROYBUFFER):
            handle_command(json);
            return;
    

        case (VKCREATEBUFFERVIEW):
            handle_command(json);
            return;
    

        case (VKDESTROYBUFFERVIEW):
            handle_command(json);
            return;
    

        case (VKCREATEIMAGE):
            handle_command(json);
            return;
    

        case (VKDESTROYIMAGE):
            handle_command(json);
            return;
    

        case (VKGETIMAGESUBRESOURCELAYOUT):
            handle_command(json);
            return;
    

        case (VKCREATEIMAGEVIEW):
            handle_command(json);
            return;
    

        case (VKDESTROYIMAGEVIEW):
            handle_command(json);
            return;
    

        case (VKCREATESHADERMODULE):
            handle_command(json);
            return;
    

        case (VKDESTROYSHADERMODULE):
            handle_command(json);
            return;
    

        case (VKCREATEPIPELINECACHE):
            handle_command(json);
            return;
    

        case (VKDESTROYPIPELINECACHE):
            handle_command(json);
            return;
    

        case (VKGETPIPELINECACHEDATA):
            handle_command(json);
            return;
    

        case (VKMERGEPIPELINECACHES):
            handle_command(json);
            return;
    

        case (VKCREATEGRAPHICSPIPELINES):
            handle_command(json);
            return;
    

        case (VKCREATECOMPUTEPIPELINES):
            handle_command(json);
            return;
    

        case (VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI):
            handle_command(json);
            return;
    

        case (VKDESTROYPIPELINE):
            handle_command(json);
            return;
    

        case (VKCREATEPIPELINELAYOUT):
            handle_command(json);
            return;
    

        case (VKDESTROYPIPELINELAYOUT):
            handle_command(json);
            return;
    

        case (VKCREATESAMPLER):
            handle_command(json);
            return;
    

        case (VKDESTROYSAMPLER):
            handle_command(json);
            return;
    

        case (VKCREATEDESCRIPTORSETLAYOUT):
            handle_command(json);
            return;
    

        case (VKDESTROYDESCRIPTORSETLAYOUT):
            handle_command(json);
            return;
    

        case (VKCREATEDESCRIPTORPOOL):
            handle_command(json);
            return;
    

        case (VKDESTROYDESCRIPTORPOOL):
            handle_command(json);
            return;
    

        case (VKRESETDESCRIPTORPOOL):
            handle_command(json);
            return;
    

        case (VKALLOCATEDESCRIPTORSETS):
            handle_command(json);
            return;
    

        case (VKFREEDESCRIPTORSETS):
            handle_command(json);
            return;
    

        case (VKUPDATEDESCRIPTORSETS):
            handle_command(json);
            return;
    

        case (VKCREATEFRAMEBUFFER):
            handle_command(json);
            return;
    

        case (VKDESTROYFRAMEBUFFER):
            handle_command(json);
            return;
    

        case (VKCREATERENDERPASS):
            handle_command(json);
            return;
    

        case (VKDESTROYRENDERPASS):
            handle_command(json);
            return;
    

        case (VKGETRENDERAREAGRANULARITY):
            handle_command(json);
            return;
    

        case (VKGETRENDERINGAREAGRANULARITYKHR):
            handle_command(json);
            return;
    

        case (VKCREATECOMMANDPOOL):
            handle_command(json);
            return;
    

        case (VKDESTROYCOMMANDPOOL):
            handle_command(json);
            return;
    

        case (VKRESETCOMMANDPOOL):
            handle_command(json);
            return;
    

        case (VKALLOCATECOMMANDBUFFERS):
            handle_command(json);
            return;
    

        case (VKFREECOMMANDBUFFERS):
            handle_command(json);
            return;
    

        case (VKBEGINCOMMANDBUFFER):
            handle_command(json);
            return;
    

        case (VKENDCOMMANDBUFFER):
            handle_command(json);
            return;
    

        case (VKRESETCOMMANDBUFFER):
            handle_command(json);
            return;
    

        case (VKCMDBINDPIPELINE):
            handle_command(json);
            return;
    

        case (VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETVIEWPORT):
            handle_command(json);
            return;
    

        case (VKCMDSETSCISSOR):
            handle_command(json);
            return;
    

        case (VKCMDSETLINEWIDTH):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHBIAS):
            handle_command(json);
            return;
    

        case (VKCMDSETBLENDCONSTANTS):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHBOUNDS):
            handle_command(json);
            return;
    

        case (VKCMDSETSTENCILCOMPAREMASK):
            handle_command(json);
            return;
    

        case (VKCMDSETSTENCILWRITEMASK):
            handle_command(json);
            return;
    

        case (VKCMDSETSTENCILREFERENCE):
            handle_command(json);
            return;
    

        case (VKCMDBINDDESCRIPTORSETS):
            handle_command(json);
            return;
    

        case (VKCMDBINDINDEXBUFFER):
            handle_command(json);
            return;
    

        case (VKCMDBINDVERTEXBUFFERS):
            handle_command(json);
            return;
    

        case (VKCMDDRAW):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDEXED):
            handle_command(json);
            return;
    

        case (VKCMDDRAWMULTIEXT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWMULTIINDEXEDEXT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDIRECT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDEXEDINDIRECT):
            handle_command(json);
            return;
    

        case (VKCMDDISPATCH):
            handle_command(json);
            return;
    

        case (VKCMDDISPATCHINDIRECT):
            handle_command(json);
            return;
    

        case (VKCMDSUBPASSSHADINGHUAWEI):
            handle_command(json);
            return;
    

        case (VKCMDDRAWCLUSTERHUAWEI):
            handle_command(json);
            return;
    

        case (VKCMDDRAWCLUSTERINDIRECTHUAWEI):
            handle_command(json);
            return;
    

        case (VKCMDUPDATEPIPELINEINDIRECTBUFFERNV):
            handle_command(json);
            return;
    

        case (VKCMDCOPYBUFFER):
            handle_command(json);
            return;
    

        case (VKCMDCOPYIMAGE):
            handle_command(json);
            return;
    

        case (VKCMDBLITIMAGE):
            handle_command(json);
            return;
    

        case (VKCMDCOPYBUFFERTOIMAGE):
            handle_command(json);
            return;
    

        case (VKCMDCOPYIMAGETOBUFFER):
            handle_command(json);
            return;
    

        case (VKCMDCOPYMEMORYINDIRECTNV):
            handle_command(json);
            return;
    

        case (VKCMDCOPYMEMORYTOIMAGEINDIRECTNV):
            handle_command(json);
            return;
    

        case (VKCMDUPDATEBUFFER):
            handle_command(json);
            return;
    

        case (VKCMDFILLBUFFER):
            handle_command(json);
            return;
    

        case (VKCMDCLEARCOLORIMAGE):
            handle_command(json);
            return;
    

        case (VKCMDCLEARDEPTHSTENCILIMAGE):
            handle_command(json);
            return;
    

        case (VKCMDCLEARATTACHMENTS):
            handle_command(json);
            return;
    

        case (VKCMDRESOLVEIMAGE):
            handle_command(json);
            return;
    

        case (VKCMDSETEVENT):
            handle_command(json);
            return;
    

        case (VKCMDRESETEVENT):
            handle_command(json);
            return;
    

        case (VKCMDWAITEVENTS):
            handle_command(json);
            return;
    

        case (VKCMDPIPELINEBARRIER):
            handle_command(json);
            return;
    

        case (VKCMDBEGINQUERY):
            handle_command(json);
            return;
    

        case (VKCMDENDQUERY):
            handle_command(json);
            return;
    

        case (VKCMDBEGINCONDITIONALRENDERINGEXT):
            handle_command(json);
            return;
    

        case (VKCMDENDCONDITIONALRENDERINGEXT):
            handle_command(json);
            return;
    

        case (VKCMDRESETQUERYPOOL):
            handle_command(json);
            return;
    

        case (VKCMDWRITETIMESTAMP):
            handle_command(json);
            return;
    

        case (VKCMDCOPYQUERYPOOLRESULTS):
            handle_command(json);
            return;
    

        case (VKCMDPUSHCONSTANTS):
            handle_command(json);
            return;
    

        case (VKCMDBEGINRENDERPASS):
            handle_command(json);
            return;
    

        case (VKCMDNEXTSUBPASS):
            handle_command(json);
            return;
    

        case (VKCMDENDRENDERPASS):
            handle_command(json);
            return;
    

        case (VKCMDEXECUTECOMMANDS):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR):
            handle_command(json);
            return;
    

        case (VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR):
            handle_command(json);
            return;
    

        case (VKGETDISPLAYMODEPROPERTIESKHR):
            handle_command(json);
            return;
    

        case (VKCREATEDISPLAYMODEKHR):
            handle_command(json);
            return;
    

        case (VKGETDISPLAYPLANECAPABILITIESKHR):
            handle_command(json);
            return;
    

        case (VKCREATEDISPLAYPLANESURFACEKHR):
            handle_command(json);
            return;
    

        case (VKCREATESHAREDSWAPCHAINSKHR):
            handle_command(json);
            return;
    

        case (VKDESTROYSURFACEKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACESUPPORTKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACECAPABILITIESKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACEFORMATSKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR):
            handle_command(json);
            return;
    

        case (VKCREATESWAPCHAINKHR):
            handle_command(json);
            return;
    

        case (VKDESTROYSWAPCHAINKHR):
            handle_command(json);
            return;
    

        case (VKGETSWAPCHAINIMAGESKHR):
            handle_command(json);
            return;
    

        case (VKACQUIRENEXTIMAGEKHR):
            handle_command(json);
            return;
    

        case (VKQUEUEPRESENTKHR):
            handle_command(json);
            return;
    

        case (VKCREATEXLIBSURFACEKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR):
            handle_command(json);
            return;
    

        case (VKCREATEXCBSURFACEKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR):
            handle_command(json);
            return;
    

        case (VKCREATEDEBUGREPORTCALLBACKEXT):
            handle_command(json);
            return;
    

        case (VKDESTROYDEBUGREPORTCALLBACKEXT):
            handle_command(json);
            return;
    

        case (VKDEBUGREPORTMESSAGEEXT):
            handle_command(json);
            return;
    

        case (VKDEBUGMARKERSETOBJECTNAMEEXT):
            handle_command(json);
            return;
    

        case (VKDEBUGMARKERSETOBJECTTAGEXT):
            handle_command(json);
            return;
    

        case (VKCMDDEBUGMARKERBEGINEXT):
            handle_command(json);
            return;
    

        case (VKCMDDEBUGMARKERENDEXT):
            handle_command(json);
            return;
    

        case (VKCMDDEBUGMARKERINSERTEXT):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV):
            handle_command(json);
            return;
    

        case (VKCMDEXECUTEGENERATEDCOMMANDSNV):
            handle_command(json);
            return;
    

        case (VKCMDPREPROCESSGENERATEDCOMMANDSNV):
            handle_command(json);
            return;
    

        case (VKCMDBINDPIPELINESHADERGROUPNV):
            handle_command(json);
            return;
    

        case (VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV):
            handle_command(json);
            return;
    

        case (VKCREATEINDIRECTCOMMANDSLAYOUTNV):
            handle_command(json);
            return;
    

        case (VKDESTROYINDIRECTCOMMANDSLAYOUTNV):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEFEATURES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEFEATURES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEFORMATPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEFORMATPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEMEMORYPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEMEMORYPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2):
            handle_command(json);
            return;
    

        case (VKCMDPUSHDESCRIPTORSETKHR):
            handle_command(json);
            return;
    

        case (VKTRIMCOMMANDPOOL):
            handle_command(json);
            return;
    

        case (VKTRIMCOMMANDPOOL):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETMEMORYFDKHR):
            handle_command(json);
            return;
    

        case (VKGETMEMORYFDPROPERTIESKHR):
            handle_command(json);
            return;
    

        case (VKGETMEMORYREMOTEADDRESSNV):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETSEMAPHOREFDKHR):
            handle_command(json);
            return;
    

        case (VKIMPORTSEMAPHOREFDKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETFENCEFDKHR):
            handle_command(json);
            return;
    

        case (VKIMPORTFENCEFDKHR):
            handle_command(json);
            return;
    

        case (VKRELEASEDISPLAYEXT):
            handle_command(json);
            return;
    

        case (VKDISPLAYPOWERCONTROLEXT):
            handle_command(json);
            return;
    

        case (VKREGISTERDEVICEEVENTEXT):
            handle_command(json);
            return;
    

        case (VKREGISTERDISPLAYEVENTEXT):
            handle_command(json);
            return;
    

        case (VKGETSWAPCHAINCOUNTEREXT):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT):
            handle_command(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICEGROUPS):
            handle_command(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICEGROUPS):
            handle_command(json);
            return;
    

        case (VKGETDEVICEGROUPPEERMEMORYFEATURES):
            handle_command(json);
            return;
    

        case (VKGETDEVICEGROUPPEERMEMORYFEATURES):
            handle_command(json);
            return;
    

        case (VKBINDBUFFERMEMORY2):
            handle_command(json);
            return;
    

        case (VKBINDBUFFERMEMORY2):
            handle_command(json);
            return;
    

        case (VKBINDIMAGEMEMORY2):
            handle_command(json);
            return;
    

        case (VKBINDIMAGEMEMORY2):
            handle_command(json);
            return;
    

        case (VKCMDSETDEVICEMASK):
            handle_command(json);
            return;
    

        case (VKCMDSETDEVICEMASK):
            handle_command(json);
            return;
    

        case (VKGETDEVICEGROUPPRESENTCAPABILITIESKHR):
            handle_command(json);
            return;
    

        case (VKGETDEVICEGROUPSURFACEPRESENTMODESKHR):
            handle_command(json);
            return;
    

        case (VKACQUIRENEXTIMAGE2KHR):
            handle_command(json);
            return;
    

        case (VKCMDDISPATCHBASE):
            handle_command(json);
            return;
    

        case (VKCMDDISPATCHBASE):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR):
            handle_command(json);
            return;
    

        case (VKCREATEDESCRIPTORUPDATETEMPLATE):
            handle_command(json);
            return;
    

        case (VKCREATEDESCRIPTORUPDATETEMPLATE):
            handle_command(json);
            return;
    

        case (VKDESTROYDESCRIPTORUPDATETEMPLATE):
            handle_command(json);
            return;
    

        case (VKDESTROYDESCRIPTORUPDATETEMPLATE):
            handle_command(json);
            return;
    

        case (VKUPDATEDESCRIPTORSETWITHTEMPLATE):
            handle_command(json);
            return;
    

        case (VKUPDATEDESCRIPTORSETWITHTEMPLATE):
            handle_command(json);
            return;
    

        case (VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR):
            handle_command(json);
            return;
    

        case (VKSETHDRMETADATAEXT):
            handle_command(json);
            return;
    

        case (VKGETSWAPCHAINSTATUSKHR):
            handle_command(json);
            return;
    

        case (VKGETREFRESHCYCLEDURATIONGOOGLE):
            handle_command(json);
            return;
    

        case (VKGETPASTPRESENTATIONTIMINGGOOGLE):
            handle_command(json);
            return;
    

        case (VKCMDSETVIEWPORTWSCALINGNV):
            handle_command(json);
            return;
    

        case (VKCMDSETDISCARDRECTANGLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETDISCARDRECTANGLEENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETDISCARDRECTANGLEMODEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETSAMPLELOCATIONSEXT):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACEFORMATS2KHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR):
            handle_command(json);
            return;
    

        case (VKGETDISPLAYMODEPROPERTIES2KHR):
            handle_command(json);
            return;
    

        case (VKGETDISPLAYPLANECAPABILITIES2KHR):
            handle_command(json);
            return;
    

        case (VKGETBUFFERMEMORYREQUIREMENTS2):
            handle_command(json);
            return;
    

        case (VKGETBUFFERMEMORYREQUIREMENTS2):
            handle_command(json);
            return;
    

        case (VKGETIMAGEMEMORYREQUIREMENTS2):
            handle_command(json);
            return;
    

        case (VKGETIMAGEMEMORYREQUIREMENTS2):
            handle_command(json);
            return;
    

        case (VKGETIMAGESPARSEMEMORYREQUIREMENTS2):
            handle_command(json);
            return;
    

        case (VKGETIMAGESPARSEMEMORYREQUIREMENTS2):
            handle_command(json);
            return;
    

        case (VKGETDEVICEBUFFERMEMORYREQUIREMENTS):
            handle_command(json);
            return;
    

        case (VKGETDEVICEBUFFERMEMORYREQUIREMENTS):
            handle_command(json);
            return;
    

        case (VKGETDEVICEIMAGEMEMORYREQUIREMENTS):
            handle_command(json);
            return;
    

        case (VKGETDEVICEIMAGEMEMORYREQUIREMENTS):
            handle_command(json);
            return;
    

        case (VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS):
            handle_command(json);
            return;
    

        case (VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS):
            handle_command(json);
            return;
    

        case (VKCREATESAMPLERYCBCRCONVERSION):
            handle_command(json);
            return;
    

        case (VKCREATESAMPLERYCBCRCONVERSION):
            handle_command(json);
            return;
    

        case (VKDESTROYSAMPLERYCBCRCONVERSION):
            handle_command(json);
            return;
    

        case (VKDESTROYSAMPLERYCBCRCONVERSION):
            handle_command(json);
            return;
    

        case (VKGETDEVICEQUEUE2):
            handle_command(json);
            return;
    

        case (VKCREATEVALIDATIONCACHEEXT):
            handle_command(json);
            return;
    

        case (VKDESTROYVALIDATIONCACHEEXT):
            handle_command(json);
            return;
    

        case (VKGETVALIDATIONCACHEDATAEXT):
            handle_command(json);
            return;
    

        case (VKMERGEVALIDATIONCACHESEXT):
            handle_command(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTSUPPORT):
            handle_command(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTSUPPORT):
            handle_command(json);
            return;
    

        case (VKGETSHADERINFOAMD):
            handle_command(json);
            return;
    

        case (VKSETLOCALDIMMINGAMD):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT):
            handle_command(json);
            return;
    

        case (VKGETCALIBRATEDTIMESTAMPSEXT):
            handle_command(json);
            return;
    

        case (VKSETDEBUGUTILSOBJECTNAMEEXT):
            handle_command(json);
            return;
    

        case (VKSETDEBUGUTILSOBJECTTAGEXT):
            handle_command(json);
            return;
    

        case (VKQUEUEBEGINDEBUGUTILSLABELEXT):
            handle_command(json);
            return;
    

        case (VKQUEUEENDDEBUGUTILSLABELEXT):
            handle_command(json);
            return;
    

        case (VKQUEUEINSERTDEBUGUTILSLABELEXT):
            handle_command(json);
            return;
    

        case (VKCMDBEGINDEBUGUTILSLABELEXT):
            handle_command(json);
            return;
    

        case (VKCMDENDDEBUGUTILSLABELEXT):
            handle_command(json);
            return;
    

        case (VKCMDINSERTDEBUGUTILSLABELEXT):
            handle_command(json);
            return;
    

        case (VKCREATEDEBUGUTILSMESSENGEREXT):
            handle_command(json);
            return;
    

        case (VKDESTROYDEBUGUTILSMESSENGEREXT):
            handle_command(json);
            return;
    

        case (VKSUBMITDEBUGUTILSMESSAGEEXT):
            handle_command(json);
            return;
    

        case (VKGETMEMORYHOSTPOINTERPROPERTIESEXT):
            handle_command(json);
            return;
    

        case (VKCMDWRITEBUFFERMARKERAMD):
            handle_command(json);
            return;
    

        case (VKCREATERENDERPASS2):
            handle_command(json);
            return;
    

        case (VKCREATERENDERPASS2):
            handle_command(json);
            return;
    

        case (VKCMDBEGINRENDERPASS2):
            handle_command(json);
            return;
    

        case (VKCMDBEGINRENDERPASS2):
            handle_command(json);
            return;
    

        case (VKCMDNEXTSUBPASS2):
            handle_command(json);
            return;
    

        case (VKCMDNEXTSUBPASS2):
            handle_command(json);
            return;
    

        case (VKCMDENDRENDERPASS2):
            handle_command(json);
            return;
    

        case (VKCMDENDRENDERPASS2):
            handle_command(json);
            return;
    

        case (VKGETSEMAPHORECOUNTERVALUE):
            handle_command(json);
            return;
    

        case (VKGETSEMAPHORECOUNTERVALUE):
            handle_command(json);
            return;
    

        case (VKWAITSEMAPHORES):
            handle_command(json);
            return;
    

        case (VKWAITSEMAPHORES):
            handle_command(json);
            return;
    

        case (VKSIGNALSEMAPHORE):
            handle_command(json);
            return;
    

        case (VKSIGNALSEMAPHORE):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDIRECTCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDIRECTCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDIRECTCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDEXEDINDIRECTCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDEXEDINDIRECTCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDEXEDINDIRECTCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDSETCHECKPOINTNV):
            handle_command(json);
            return;
    

        case (VKGETQUEUECHECKPOINTDATANV):
            handle_command(json);
            return;
    

        case (VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT):
            handle_command(json);
            return;
    

        case (VKCMDBEGINTRANSFORMFEEDBACKEXT):
            handle_command(json);
            return;
    

        case (VKCMDENDTRANSFORMFEEDBACKEXT):
            handle_command(json);
            return;
    

        case (VKCMDBEGINQUERYINDEXEDEXT):
            handle_command(json);
            return;
    

        case (VKCMDENDQUERYINDEXEDEXT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWINDIRECTBYTECOUNTEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETEXCLUSIVESCISSORNV):
            handle_command(json);
            return;
    

        case (VKCMDSETEXCLUSIVESCISSORENABLENV):
            handle_command(json);
            return;
    

        case (VKCMDBINDSHADINGRATEIMAGENV):
            handle_command(json);
            return;
    

        case (VKCMDSETVIEWPORTSHADINGRATEPALETTENV):
            handle_command(json);
            return;
    

        case (VKCMDSETCOARSESAMPLEORDERNV):
            handle_command(json);
            return;
    

        case (VKCMDDRAWMESHTASKSNV):
            handle_command(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTNV):
            handle_command(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTCOUNTNV):
            handle_command(json);
            return;
    

        case (VKCMDDRAWMESHTASKSEXT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTEXT):
            handle_command(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT):
            handle_command(json);
            return;
    

        case (VKCOMPILEDEFERREDNV):
            handle_command(json);
            return;
    

        case (VKCREATEACCELERATIONSTRUCTURENV):
            handle_command(json);
            return;
    

        case (VKCMDBINDINVOCATIONMASKHUAWEI):
            handle_command(json);
            return;
    

        case (VKDESTROYACCELERATIONSTRUCTUREKHR):
            handle_command(json);
            return;
    

        case (VKDESTROYACCELERATIONSTRUCTURENV):
            handle_command(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV):
            handle_command(json);
            return;
    

        case (VKBINDACCELERATIONSTRUCTUREMEMORYNV):
            handle_command(json);
            return;
    

        case (VKCMDCOPYACCELERATIONSTRUCTURENV):
            handle_command(json);
            return;
    

        case (VKCMDCOPYACCELERATIONSTRUCTUREKHR):
            handle_command(json);
            return;
    

        case (VKCOPYACCELERATIONSTRUCTUREKHR):
            handle_command(json);
            return;
    

        case (VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
            handle_command(json);
            return;
    

        case (VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
            handle_command(json);
            return;
    

        case (VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
            handle_command(json);
            return;
    

        case (VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
            handle_command(json);
            return;
    

        case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
            handle_command(json);
            return;
    

        case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV):
            handle_command(json);
            return;
    

        case (VKCMDBUILDACCELERATIONSTRUCTURENV):
            handle_command(json);
            return;
    

        case (VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
            handle_command(json);
            return;
    

        case (VKCMDTRACERAYSKHR):
            handle_command(json);
            return;
    

        case (VKCMDTRACERAYSNV):
            handle_command(json);
            return;
    

        case (VKGETRAYTRACINGSHADERGROUPHANDLESKHR):
            handle_command(json);
            return;
    

        case (VKGETRAYTRACINGSHADERGROUPHANDLESKHR):
            handle_command(json);
            return;
    

        case (VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR):
            handle_command(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREHANDLENV):
            handle_command(json);
            return;
    

        case (VKCREATERAYTRACINGPIPELINESNV):
            handle_command(json);
            return;
    

        case (VKCREATERAYTRACINGPIPELINESKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV):
            handle_command(json);
            return;
    

        case (VKCMDTRACERAYSINDIRECTKHR):
            handle_command(json);
            return;
    

        case (VKCMDTRACERAYSINDIRECT2KHR):
            handle_command(json);
            return;
    

        case (VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR):
            handle_command(json);
            return;
    

        case (VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR):
            handle_command(json);
            return;
    

        case (VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR):
            handle_command(json);
            return;
    

        case (VKGETIMAGEVIEWHANDLENVX):
            handle_command(json);
            return;
    

        case (VKGETIMAGEVIEWADDRESSNVX):
            handle_command(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR):
            handle_command(json);
            return;
    

        case (VKACQUIREPROFILINGLOCKKHR):
            handle_command(json);
            return;
    

        case (VKRELEASEPROFILINGLOCKKHR):
            handle_command(json);
            return;
    

        case (VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT):
            handle_command(json);
            return;
    

        case (VKGETBUFFEROPAQUECAPTUREADDRESS):
            handle_command(json);
            return;
    

        case (VKGETBUFFEROPAQUECAPTUREADDRESS):
            handle_command(json);
            return;
    

        case (VKGETBUFFERDEVICEADDRESS):
            handle_command(json);
            return;
    

        case (VKGETBUFFERDEVICEADDRESS):
            handle_command(json);
            return;
    

        case (VKGETBUFFERDEVICEADDRESS):
            handle_command(json);
            return;
    

        case (VKCREATEHEADLESSSURFACEEXT):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV):
            handle_command(json);
            return;
    

        case (VKINITIALIZEPERFORMANCEAPIINTEL):
            handle_command(json);
            return;
    

        case (VKUNINITIALIZEPERFORMANCEAPIINTEL):
            handle_command(json);
            return;
    

        case (VKCMDSETPERFORMANCEMARKERINTEL):
            handle_command(json);
            return;
    

        case (VKCMDSETPERFORMANCESTREAMMARKERINTEL):
            handle_command(json);
            return;
    

        case (VKCMDSETPERFORMANCEOVERRIDEINTEL):
            handle_command(json);
            return;
    

        case (VKACQUIREPERFORMANCECONFIGURATIONINTEL):
            handle_command(json);
            return;
    

        case (VKRELEASEPERFORMANCECONFIGURATIONINTEL):
            handle_command(json);
            return;
    

        case (VKQUEUESETPERFORMANCECONFIGURATIONINTEL):
            handle_command(json);
            return;
    

        case (VKGETPERFORMANCEPARAMETERINTEL):
            handle_command(json);
            return;
    

        case (VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS):
            handle_command(json);
            return;
    

        case (VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS):
            handle_command(json);
            return;
    

        case (VKGETPIPELINEEXECUTABLEPROPERTIESKHR):
            handle_command(json);
            return;
    

        case (VKGETPIPELINEEXECUTABLESTATISTICSKHR):
            handle_command(json);
            return;
    

        case (VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR):
            handle_command(json);
            return;
    

        case (VKCMDSETLINESTIPPLEEXT):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICETOOLPROPERTIES):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICETOOLPROPERTIES):
            handle_command(json);
            return;
    

        case (VKCREATEACCELERATIONSTRUCTUREKHR):
            handle_command(json);
            return;
    

        case (VKCMDBUILDACCELERATIONSTRUCTURESKHR):
            handle_command(json);
            return;
    

        case (VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR):
            handle_command(json);
            return;
    

        case (VKBUILDACCELERATIONSTRUCTURESKHR):
            handle_command(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR):
            handle_command(json);
            return;
    

        case (VKCREATEDEFERREDOPERATIONKHR):
            handle_command(json);
            return;
    

        case (VKDESTROYDEFERREDOPERATIONKHR):
            handle_command(json);
            return;
    

        case (VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR):
            handle_command(json);
            return;
    

        case (VKGETDEFERREDOPERATIONRESULTKHR):
            handle_command(json);
            return;
    

        case (VKDEFERREDOPERATIONJOINKHR):
            handle_command(json);
            return;
    

        case (VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV):
            handle_command(json);
            return;
    

        case (VKGETPIPELINEINDIRECTDEVICEADDRESSNV):
            handle_command(json);
            return;
    

        case (VKCMDSETCULLMODE):
            handle_command(json);
            return;
    

        case (VKCMDSETCULLMODE):
            handle_command(json);
            return;
    

        case (VKCMDSETFRONTFACE):
            handle_command(json);
            return;
    

        case (VKCMDSETFRONTFACE):
            handle_command(json);
            return;
    

        case (VKCMDSETPRIMITIVETOPOLOGY):
            handle_command(json);
            return;
    

        case (VKCMDSETPRIMITIVETOPOLOGY):
            handle_command(json);
            return;
    

        case (VKCMDSETVIEWPORTWITHCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDSETVIEWPORTWITHCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDSETSCISSORWITHCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDSETSCISSORWITHCOUNT):
            handle_command(json);
            return;
    

        case (VKCMDBINDINDEXBUFFER2KHR):
            handle_command(json);
            return;
    

        case (VKCMDBINDVERTEXBUFFERS2):
            handle_command(json);
            return;
    

        case (VKCMDBINDVERTEXBUFFERS2):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHTESTENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHTESTENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHWRITEENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHWRITEENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHCOMPAREOP):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHCOMPAREOP):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHBOUNDSTESTENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHBOUNDSTESTENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETSTENCILTESTENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETSTENCILTESTENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETSTENCILOP):
            handle_command(json);
            return;
    

        case (VKCMDSETSTENCILOP):
            handle_command(json);
            return;
    

        case (VKCMDSETPATCHCONTROLPOINTSEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETRASTERIZERDISCARDENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETRASTERIZERDISCARDENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHBIASENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHBIASENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETLOGICOPEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETPRIMITIVERESTARTENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETPRIMITIVERESTARTENABLE):
            handle_command(json);
            return;
    

        case (VKCMDSETTESSELLATIONDOMAINORIGINEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHCLAMPENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETPOLYGONMODEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETRASTERIZATIONSAMPLESEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETSAMPLEMASKEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETALPHATOCOVERAGEENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETALPHATOONEENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETLOGICOPENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETCOLORBLENDENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETCOLORBLENDEQUATIONEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETCOLORWRITEMASKEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETRASTERIZATIONSTREAMEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHCLIPENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETSAMPLELOCATIONSENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETCOLORBLENDADVANCEDEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETPROVOKINGVERTEXMODEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETLINERASTERIZATIONMODEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETLINESTIPPLEENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETVIEWPORTWSCALINGENABLENV):
            handle_command(json);
            return;
    

        case (VKCMDSETVIEWPORTSWIZZLENV):
            handle_command(json);
            return;
    

        case (VKCMDSETCOVERAGETOCOLORENABLENV):
            handle_command(json);
            return;
    

        case (VKCMDSETCOVERAGETOCOLORLOCATIONNV):
            handle_command(json);
            return;
    

        case (VKCMDSETCOVERAGEMODULATIONMODENV):
            handle_command(json);
            return;
    

        case (VKCMDSETCOVERAGEMODULATIONTABLEENABLENV):
            handle_command(json);
            return;
    

        case (VKCMDSETCOVERAGEMODULATIONTABLENV):
            handle_command(json);
            return;
    

        case (VKCMDSETSHADINGRATEIMAGEENABLENV):
            handle_command(json);
            return;
    

        case (VKCMDSETCOVERAGEREDUCTIONMODENV):
            handle_command(json);
            return;
    

        case (VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV):
            handle_command(json);
            return;
    

        case (VKCREATEPRIVATEDATASLOT):
            handle_command(json);
            return;
    

        case (VKCREATEPRIVATEDATASLOT):
            handle_command(json);
            return;
    

        case (VKDESTROYPRIVATEDATASLOT):
            handle_command(json);
            return;
    

        case (VKDESTROYPRIVATEDATASLOT):
            handle_command(json);
            return;
    

        case (VKSETPRIVATEDATA):
            handle_command(json);
            return;
    

        case (VKSETPRIVATEDATA):
            handle_command(json);
            return;
    

        case (VKGETPRIVATEDATA):
            handle_command(json);
            return;
    

        case (VKGETPRIVATEDATA):
            handle_command(json);
            return;
    

        case (VKCMDCOPYBUFFER2):
            handle_command(json);
            return;
    

        case (VKCMDCOPYBUFFER2):
            handle_command(json);
            return;
    

        case (VKCMDCOPYIMAGE2):
            handle_command(json);
            return;
    

        case (VKCMDCOPYIMAGE2):
            handle_command(json);
            return;
    

        case (VKCMDBLITIMAGE2):
            handle_command(json);
            return;
    

        case (VKCMDBLITIMAGE2):
            handle_command(json);
            return;
    

        case (VKCMDCOPYBUFFERTOIMAGE2):
            handle_command(json);
            return;
    

        case (VKCMDCOPYBUFFERTOIMAGE2):
            handle_command(json);
            return;
    

        case (VKCMDCOPYIMAGETOBUFFER2):
            handle_command(json);
            return;
    

        case (VKCMDCOPYIMAGETOBUFFER2):
            handle_command(json);
            return;
    

        case (VKCMDRESOLVEIMAGE2):
            handle_command(json);
            return;
    

        case (VKCMDRESOLVEIMAGE2):
            handle_command(json);
            return;
    

        case (VKCMDSETFRAGMENTSHADINGRATEKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR):
            handle_command(json);
            return;
    

        case (VKCMDSETFRAGMENTSHADINGRATEENUMNV):
            handle_command(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR):
            handle_command(json);
            return;
    

        case (VKCMDSETVERTEXINPUTEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETCOLORWRITEENABLEEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETEVENT2):
            handle_command(json);
            return;
    

        case (VKCMDSETEVENT2):
            handle_command(json);
            return;
    

        case (VKCMDRESETEVENT2):
            handle_command(json);
            return;
    

        case (VKCMDRESETEVENT2):
            handle_command(json);
            return;
    

        case (VKCMDWAITEVENTS2):
            handle_command(json);
            return;
    

        case (VKCMDWAITEVENTS2):
            handle_command(json);
            return;
    

        case (VKCMDPIPELINEBARRIER2):
            handle_command(json);
            return;
    

        case (VKCMDPIPELINEBARRIER2):
            handle_command(json);
            return;
    

        case (VKQUEUESUBMIT2):
            handle_command(json);
            return;
    

        case (VKQUEUESUBMIT2):
            handle_command(json);
            return;
    

        case (VKCMDWRITETIMESTAMP2):
            handle_command(json);
            return;
    

        case (VKCMDWRITETIMESTAMP2):
            handle_command(json);
            return;
    

        case (VKCMDWRITEBUFFERMARKER2AMD):
            handle_command(json);
            return;
    

        case (VKGETQUEUECHECKPOINTDATA2NV):
            handle_command(json);
            return;
    

        case (VKCOPYMEMORYTOIMAGEEXT):
            handle_command(json);
            return;
    

        case (VKCOPYIMAGETOMEMORYEXT):
            handle_command(json);
            return;
    

        case (VKCOPYIMAGETOIMAGEEXT):
            handle_command(json);
            return;
    

        case (VKTRANSITIONIMAGELAYOUTEXT):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR):
            handle_command(json);
            return;
    

        case (VKCREATEVIDEOSESSIONKHR):
            handle_command(json);
            return;
    

        case (VKDESTROYVIDEOSESSIONKHR):
            handle_command(json);
            return;
    

        case (VKCREATEVIDEOSESSIONPARAMETERSKHR):
            handle_command(json);
            return;
    

        case (VKUPDATEVIDEOSESSIONPARAMETERSKHR):
            handle_command(json);
            return;
    

        case (VKDESTROYVIDEOSESSIONPARAMETERSKHR):
            handle_command(json);
            return;
    

        case (VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR):
            handle_command(json);
            return;
    

        case (VKBINDVIDEOSESSIONMEMORYKHR):
            handle_command(json);
            return;
    

        case (VKCMDDECODEVIDEOKHR):
            handle_command(json);
            return;
    

        case (VKCMDBEGINVIDEOCODINGKHR):
            handle_command(json);
            return;
    

        case (VKCMDCONTROLVIDEOCODINGKHR):
            handle_command(json);
            return;
    

        case (VKCMDENDVIDEOCODINGKHR):
            handle_command(json);
            return;
    

        case (VKCMDDECOMPRESSMEMORYNV):
            handle_command(json);
            return;
    

        case (VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV):
            handle_command(json);
            return;
    

        case (VKCREATECUMODULENVX):
            handle_command(json);
            return;
    

        case (VKCREATECUFUNCTIONNVX):
            handle_command(json);
            return;
    

        case (VKDESTROYCUMODULENVX):
            handle_command(json);
            return;
    

        case (VKDESTROYCUFUNCTIONNVX):
            handle_command(json);
            return;
    

        case (VKCMDCULAUNCHKERNELNVX):
            handle_command(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTSIZEEXT):
            handle_command(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT):
            handle_command(json);
            return;
    

        case (VKGETDESCRIPTOREXT):
            handle_command(json);
            return;
    

        case (VKCMDBINDDESCRIPTORBUFFERSEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETDESCRIPTORBUFFEROFFSETSEXT):
            handle_command(json);
            return;
    

        case (VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT):
            handle_command(json);
            return;
    

        case (VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_command(json);
            return;
    

        case (VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_command(json);
            return;
    

        case (VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_command(json);
            return;
    

        case (VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_command(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_command(json);
            return;
    

        case (VKSETDEVICEMEMORYPRIORITYEXT):
            handle_command(json);
            return;
    

        case (VKACQUIREDRMDISPLAYEXT):
            handle_command(json);
            return;
    

        case (VKGETDRMDISPLAYEXT):
            handle_command(json);
            return;
    

        case (VKWAITFORPRESENTKHR):
            handle_command(json);
            return;
    

        case (VKCMDBEGINRENDERING):
            handle_command(json);
            return;
    

        case (VKCMDBEGINRENDERING):
            handle_command(json);
            return;
    

        case (VKCMDENDRENDERING):
            handle_command(json);
            return;
    

        case (VKCMDENDRENDERING):
            handle_command(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE):
            handle_command(json);
            return;
    

        case (VKGETDESCRIPTORSETHOSTMAPPINGVALVE):
            handle_command(json);
            return;
    

        case (VKCREATEMICROMAPEXT):
            handle_command(json);
            return;
    

        case (VKCMDBUILDMICROMAPSEXT):
            handle_command(json);
            return;
    

        case (VKBUILDMICROMAPSEXT):
            handle_command(json);
            return;
    

        case (VKDESTROYMICROMAPEXT):
            handle_command(json);
            return;
    

        case (VKCMDCOPYMICROMAPEXT):
            handle_command(json);
            return;
    

        case (VKCOPYMICROMAPEXT):
            handle_command(json);
            return;
    

        case (VKCMDCOPYMICROMAPTOMEMORYEXT):
            handle_command(json);
            return;
    

        case (VKCOPYMICROMAPTOMEMORYEXT):
            handle_command(json);
            return;
    

        case (VKCMDCOPYMEMORYTOMICROMAPEXT):
            handle_command(json);
            return;
    

        case (VKCOPYMEMORYTOMICROMAPEXT):
            handle_command(json);
            return;
    

        case (VKCMDWRITEMICROMAPSPROPERTIESEXT):
            handle_command(json);
            return;
    

        case (VKWRITEMICROMAPSPROPERTIESEXT):
            handle_command(json);
            return;
    

        case (VKGETDEVICEMICROMAPCOMPATIBILITYEXT):
            handle_command(json);
            return;
    

        case (VKGETMICROMAPBUILDSIZESEXT):
            handle_command(json);
            return;
    

        case (VKGETSHADERMODULEIDENTIFIEREXT):
            handle_command(json);
            return;
    

        case (VKGETSHADERMODULECREATEINFOIDENTIFIEREXT):
            handle_command(json);
            return;
    

        case (VKGETIMAGESUBRESOURCELAYOUT2KHR):
            handle_command(json);
            return;
    

        case (VKGETIMAGESUBRESOURCELAYOUT2KHR):
            handle_command(json);
            return;
    

        case (VKGETPIPELINEPROPERTIESEXT):
            handle_command(json);
            return;
    

        case (VKGETFRAMEBUFFERTILEPROPERTIESQCOM):
            handle_command(json);
            return;
    

        case (VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV):
            handle_command(json);
            return;
    

        case (VKCREATEOPTICALFLOWSESSIONNV):
            handle_command(json);
            return;
    

        case (VKDESTROYOPTICALFLOWSESSIONNV):
            handle_command(json);
            return;
    

        case (VKBINDOPTICALFLOWSESSIONIMAGENV):
            handle_command(json);
            return;
    

        case (VKCMDOPTICALFLOWEXECUTENV):
            handle_command(json);
            return;
    

        case (VKGETDEVICEFAULTINFOEXT):
            handle_command(json);
            return;
    

        case (VKCMDSETDEPTHBIAS2EXT):
            handle_command(json);
            return;
    

        case (VKRELEASESWAPCHAINIMAGESEXT):
            handle_command(json);
            return;
    

        case (VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR):
            handle_command(json);
            return;
    

        case (VKMAPMEMORY2KHR):
            handle_command(json);
            return;
    

        case (VKUNMAPMEMORY2KHR):
            handle_command(json);
            return;
    

        case (VKCREATESHADERSEXT):
            handle_command(json);
            return;
    

        case (VKDESTROYSHADEREXT):
            handle_command(json);
            return;
    

        case (VKGETSHADERBINARYDATAEXT):
            handle_command(json);
            return;
    

        case (VKCMDBINDSHADERSEXT):
            handle_command(json);
            return;
    

        case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR):
            handle_command(json);
            return;
    
}
#else

typedef struct {
VkInstance instance;
VkDevice device;
} parent_handle_struct;

std::map<uintptr_t,parent_handle_struct> handle_to_parent_handle_struct;


extern "C" {

VKAPI_ATTR VkResult VKAPI_CALL vk_icdNegotiateLoaderICDInterfaceVersion (uint32_t* pSupportedVersion){
    *pSupportedVersion=3;
    return VK_SUCCESS;
}

VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vk_icdGetInstanceProcAddr(VkInstance instance, const char* pName){
        return vkGetInstanceProcAddr(instance,pName);
    }

__attribute__((visibility ("hidden"))) VkResult vkCreateInstance( const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance ){
//Will only be called by the client
debug_printf("Executing vkCreateInstance\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEINSTANCE;
    
parent_json["instance"]=(uintptr_t)NULL;
{
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_yCteunD=json["pCreateInfo"].emplace_array();
        for(int pSiEPar=0; pSiEPar < 1; pSiEPar++){
            [&](){
            auto& temp=arr_yCteunD[pSiEPar].emplace_object();
            return serialize_struct(temp, pCreateInfo[pSiEPar]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pInstance==NULL){
                json["pInstance"]=boost::json::array();
            return; }
        auto& arr_GanofFb=json["pInstance"].emplace_array();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){serialize_VkInstance(arr_GanofFb[ErvKwSS],pInstance[ErvKwSS]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEINSTANCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}


[&](){
            if (json["pInstance"].as_array().size()==0){
                pInstance=NULL;
            return; }
        auto& arr_GanofFb=json["pInstance"].as_array();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){deserialize_VkInstance(arr_GanofFb[ErvKwSS], pInstance[ErvKwSS]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_lsbnNsC;[&](){temp_lsbnNsC=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_lsbnNsC;}();}();
handle_to_parent_handle_struct[(uintptr_t)(*pInstance)]={.instance=(*pInstance),.device=NULL};

debug_printf("Ending vkCreateInstance...\n");
debug_printf("Return value of vkCreateInstance is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyInstance( VkInstance instance, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyInstance\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYINSTANCE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYINSTANCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();


debug_printf("Ending vkDestroyInstance...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDevices( VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices ){
//Will only be called by the client
debug_printf("Executing vkEnumeratePhysicalDevices\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKENUMERATEPHYSICALDEVICES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceCount==NULL){
                json["pPhysicalDeviceCount"]=boost::json::array();
            return; }
        auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].emplace_array();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){arr_ngpFKeB[TRqNryD]=pPhysicalDeviceCount[TRqNryD];}();
        }
        }();
[&](){
            if (pPhysicalDevices==NULL){
                json["pPhysicalDevices"]=boost::json::array();
            return; }
        auto& arr_ZSQNUNc=json["pPhysicalDevices"].emplace_array();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){serialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY],pPhysicalDevices[ChMMltY]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEPHYSICALDEVICES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){
            if (json["pPhysicalDeviceCount"].as_array().size()==0){
                pPhysicalDeviceCount=NULL;
            return; }
        auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].as_array();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(value_to<int>(arr_ngpFKeB[TRqNryD]));}();
        }
        }();
[&](){
            if (json["pPhysicalDevices"].as_array().size()==0){
                pPhysicalDevices=NULL;
            return; }
        auto& arr_ZSQNUNc=json["pPhysicalDevices"].as_array();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){deserialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY], pPhysicalDevices[ChMMltY]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_vEAfuKP;[&](){temp_vEAfuKP=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_vEAfuKP;}();}();

                if (pPhysicalDevices!=NULL){
                    for (int i=0; i<*pPhysicalDeviceCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPhysicalDevices[i])]=parent;
                    }
                }
                

debug_printf("Ending vkEnumeratePhysicalDevices...\n");
debug_printf("Return value of vkEnumeratePhysicalDevices is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) PFN_vkVoidFunction vkGetDeviceProcAddr( VkDevice device, const char* pName ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceProcAddr\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEPROCADDR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pName==NULL){
                json["pName"]=boost::json::array();
            return; }
        auto& arr_XCtfitt=json["pName"].emplace_array();
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=pName[EZmXTUp];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEPROCADDR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

PFN_vkVoidFunction result;

        if (strcmp(pName,"vk_icdNegotiateLoaderICDInterfaceVersion")==0){
            result=(PFN_vkVoidFunction)vk_icdNegotiateLoaderICDInterfaceVersion;
        }
        #ifdef VK_USE_PLATFORM_XCB_KHR
            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXcbSurfaceKHR;
            }
        #endif
        
        #ifdef VK_USE_PLATFORM_XLIB_KHR
            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXlibSurfaceKHR;
            }
        #endif
        

            else if (strcmp(pName,"vkCreateInstance")==0){
                debug_printf("Retrieving vkCreateInstance...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyInstance")==0){
                debug_printf("Retrieving vkDestroyInstance...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDevices")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDevices...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDevices : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceProcAddr")==0){
                debug_printf("Retrieving vkGetDeviceProcAddr...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetInstanceProcAddr")==0){
                debug_printf("Retrieving vkGetInstanceProcAddr...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetInstanceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDevice")==0){
                debug_printf("Retrieving vkCreateDevice...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDevice")==0){
                debug_printf("Retrieving vkDestroyDevice...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceVersion")==0){
                debug_printf("Retrieving vkEnumerateInstanceVersion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceVersion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceLayerProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceExtensionProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceLayerProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceExtensionProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue")==0){
                debug_printf("Retrieving vkGetDeviceQueue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit")==0){
                debug_printf("Retrieving vkQueueSubmit...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueWaitIdle")==0){
                debug_printf("Retrieving vkQueueWaitIdle...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeviceWaitIdle")==0){
                debug_printf("Retrieving vkDeviceWaitIdle...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeviceWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateMemory")==0){
                debug_printf("Retrieving vkAllocateMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeMemory")==0){
                debug_printf("Retrieving vkFreeMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory")==0){
                debug_printf("Retrieving vkMapMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory")==0){
                debug_printf("Retrieving vkUnmapMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFlushMappedMemoryRanges")==0){
                debug_printf("Retrieving vkFlushMappedMemoryRanges...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFlushMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInvalidateMappedMemoryRanges")==0){
                debug_printf("Retrieving vkInvalidateMappedMemoryRanges...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInvalidateMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryCommitment")==0){
                debug_printf("Retrieving vkGetDeviceMemoryCommitment...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryCommitment : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory")==0){
                debug_printf("Retrieving vkBindBufferMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory")==0){
                debug_printf("Retrieving vkBindImageMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBindSparse")==0){
                debug_printf("Retrieving vkQueueBindSparse...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBindSparse : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFence")==0){
                debug_printf("Retrieving vkCreateFence...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFence")==0){
                debug_printf("Retrieving vkDestroyFence...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetFences")==0){
                debug_printf("Retrieving vkResetFences...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceStatus")==0){
                debug_printf("Retrieving vkGetFenceStatus...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForFences")==0){
                debug_printf("Retrieving vkWaitForFences...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSemaphore")==0){
                debug_printf("Retrieving vkCreateSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySemaphore")==0){
                debug_printf("Retrieving vkDestroySemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateEvent")==0){
                debug_printf("Retrieving vkCreateEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyEvent")==0){
                debug_printf("Retrieving vkDestroyEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetEventStatus")==0){
                debug_printf("Retrieving vkGetEventStatus...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetEventStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetEvent")==0){
                debug_printf("Retrieving vkSetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetEvent")==0){
                debug_printf("Retrieving vkResetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateQueryPool")==0){
                debug_printf("Retrieving vkCreateQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyQueryPool")==0){
                debug_printf("Retrieving vkDestroyQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueryPoolResults")==0){
                debug_printf("Retrieving vkGetQueryPoolResults...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBuffer")==0){
                debug_printf("Retrieving vkCreateBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBuffer")==0){
                debug_printf("Retrieving vkDestroyBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBufferView")==0){
                debug_printf("Retrieving vkCreateBufferView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBufferView")==0){
                debug_printf("Retrieving vkDestroyBufferView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImage")==0){
                debug_printf("Retrieving vkCreateImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImage")==0){
                debug_printf("Retrieving vkDestroyImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImageView")==0){
                debug_printf("Retrieving vkCreateImageView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImageView")==0){
                debug_printf("Retrieving vkDestroyImageView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShaderModule")==0){
                debug_printf("Retrieving vkCreateShaderModule...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderModule")==0){
                debug_printf("Retrieving vkDestroyShaderModule...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineCache")==0){
                debug_printf("Retrieving vkCreatePipelineCache...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineCache")==0){
                debug_printf("Retrieving vkDestroyPipelineCache...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineCacheData")==0){
                debug_printf("Retrieving vkGetPipelineCacheData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineCacheData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergePipelineCaches")==0){
                debug_printf("Retrieving vkMergePipelineCaches...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergePipelineCaches : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateGraphicsPipelines")==0){
                debug_printf("Retrieving vkCreateGraphicsPipelines...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateGraphicsPipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateComputePipelines")==0){
                debug_printf("Retrieving vkCreateComputePipelines...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateComputePipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")==0){
                debug_printf("Retrieving vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipeline")==0){
                debug_printf("Retrieving vkDestroyPipeline...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineLayout")==0){
                debug_printf("Retrieving vkCreatePipelineLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineLayout")==0){
                debug_printf("Retrieving vkDestroyPipelineLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSampler")==0){
                debug_printf("Retrieving vkCreateSampler...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySampler")==0){
                debug_printf("Retrieving vkDestroySampler...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorSetLayout")==0){
                debug_printf("Retrieving vkCreateDescriptorSetLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorSetLayout")==0){
                debug_printf("Retrieving vkDestroyDescriptorSetLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorPool")==0){
                debug_printf("Retrieving vkCreateDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorPool")==0){
                debug_printf("Retrieving vkDestroyDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetDescriptorPool")==0){
                debug_printf("Retrieving vkResetDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateDescriptorSets")==0){
                debug_printf("Retrieving vkAllocateDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeDescriptorSets")==0){
                debug_printf("Retrieving vkFreeDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSets")==0){
                debug_printf("Retrieving vkUpdateDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFramebuffer")==0){
                debug_printf("Retrieving vkCreateFramebuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFramebuffer")==0){
                debug_printf("Retrieving vkDestroyFramebuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass")==0){
                debug_printf("Retrieving vkCreateRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyRenderPass")==0){
                debug_printf("Retrieving vkDestroyRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderAreaGranularity")==0){
                debug_printf("Retrieving vkGetRenderAreaGranularity...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderAreaGranularity : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderingAreaGranularityKHR")==0){
                debug_printf("Retrieving vkGetRenderingAreaGranularityKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderingAreaGranularityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCommandPool")==0){
                debug_printf("Retrieving vkCreateCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCommandPool")==0){
                debug_printf("Retrieving vkDestroyCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandPool")==0){
                debug_printf("Retrieving vkResetCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateCommandBuffers")==0){
                debug_printf("Retrieving vkAllocateCommandBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeCommandBuffers")==0){
                debug_printf("Retrieving vkFreeCommandBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBeginCommandBuffer")==0){
                debug_printf("Retrieving vkBeginCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBeginCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEndCommandBuffer")==0){
                debug_printf("Retrieving vkEndCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEndCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandBuffer")==0){
                debug_printf("Retrieving vkResetCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipeline")==0){
                debug_printf("Retrieving vkCmdBindPipeline...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAttachmentFeedbackLoopEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAttachmentFeedbackLoopEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAttachmentFeedbackLoopEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewport")==0){
                debug_printf("Retrieving vkCmdSetViewport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissor")==0){
                debug_printf("Retrieving vkCmdSetScissor...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissor : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineWidth")==0){
                debug_printf("Retrieving vkCmdSetLineWidth...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineWidth : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias")==0){
                debug_printf("Retrieving vkCmdSetDepthBias...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetBlendConstants")==0){
                debug_printf("Retrieving vkCmdSetBlendConstants...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetBlendConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBounds")==0){
                debug_printf("Retrieving vkCmdSetDepthBounds...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBounds : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilCompareMask")==0){
                debug_printf("Retrieving vkCmdSetStencilCompareMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilCompareMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilWriteMask")==0){
                debug_printf("Retrieving vkCmdSetStencilWriteMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilWriteMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilReference")==0){
                debug_printf("Retrieving vkCmdSetStencilReference...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilReference : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorSets")==0){
                debug_printf("Retrieving vkCmdBindDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDraw")==0){
                debug_printf("Retrieving vkCmdDraw...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDraw : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexed")==0){
                debug_printf("Retrieving vkCmdDrawIndexed...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexed : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiIndexedEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatch")==0){
                debug_printf("Retrieving vkCmdDispatch...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatch : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchIndirect")==0){
                debug_printf("Retrieving vkCmdDispatchIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSubpassShadingHUAWEI")==0){
                debug_printf("Retrieving vkCmdSubpassShadingHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSubpassShadingHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterIndirectHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterIndirectHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterIndirectHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdatePipelineIndirectBufferNV")==0){
                debug_printf("Retrieving vkCmdUpdatePipelineIndirectBufferNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdatePipelineIndirectBufferNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer")==0){
                debug_printf("Retrieving vkCmdCopyBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage")==0){
                debug_printf("Retrieving vkCmdCopyImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage")==0){
                debug_printf("Retrieving vkCmdBlitImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToImageIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToImageIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToImageIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdateBuffer")==0){
                debug_printf("Retrieving vkCmdUpdateBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdFillBuffer")==0){
                debug_printf("Retrieving vkCmdFillBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdFillBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearColorImage")==0){
                debug_printf("Retrieving vkCmdClearColorImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearColorImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearDepthStencilImage")==0){
                debug_printf("Retrieving vkCmdClearDepthStencilImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearDepthStencilImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearAttachments")==0){
                debug_printf("Retrieving vkCmdClearAttachments...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearAttachments : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage")==0){
                debug_printf("Retrieving vkCmdResolveImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent")==0){
                debug_printf("Retrieving vkCmdSetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent")==0){
                debug_printf("Retrieving vkCmdResetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents")==0){
                debug_printf("Retrieving vkCmdWaitEvents...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQuery")==0){
                debug_printf("Retrieving vkCmdBeginQuery...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQuery")==0){
                debug_printf("Retrieving vkCmdEndQuery...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdBeginConditionalRenderingEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdEndConditionalRenderingEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetQueryPool")==0){
                debug_printf("Retrieving vkCmdResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyQueryPoolResults")==0){
                debug_printf("Retrieving vkCmdCopyQueryPoolResults...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushConstants")==0){
                debug_printf("Retrieving vkCmdPushConstants...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass")==0){
                debug_printf("Retrieving vkCmdNextSubpass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass")==0){
                debug_printf("Retrieving vkCmdEndRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteCommands")==0){
                debug_printf("Retrieving vkCmdExecuteCommands...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteCommands : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlanePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlanePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneSupportedDisplaysKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneSupportedDisplaysKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneSupportedDisplaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModePropertiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayModePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayModeKHR")==0){
                debug_printf("Retrieving vkCreateDisplayModeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayModeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayPlaneSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateDisplayPlaneSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayPlaneSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSharedSwapchainsKHR")==0){
                debug_printf("Retrieving vkCreateSharedSwapchainsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSharedSwapchainsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySurfaceKHR")==0){
                debug_printf("Retrieving vkDestroySurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormatsKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormatsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormatsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfacePresentModesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSwapchainKHR")==0){
                debug_printf("Retrieving vkCreateSwapchainKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySwapchainKHR")==0){
                debug_printf("Retrieving vkDestroySwapchainKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainImagesKHR")==0){
                debug_printf("Retrieving vkGetSwapchainImagesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainImagesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImageKHR")==0){
                debug_printf("Retrieving vkAcquireNextImageKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImageKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueuePresentKHR")==0){
                debug_printf("Retrieving vkQueuePresentKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueuePresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXlibSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXlibSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXlibPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXlibPresentationSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXlibPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXcbSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXcbSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXcbPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXcbPresentationSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXcbPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkCreateDebugReportCallbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkDestroyDebugReportCallbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugReportMessageEXT")==0){
                debug_printf("Retrieving vkDebugReportMessageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugReportMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectNameEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectNameEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectTagEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectTagEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerBeginEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerBeginEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerBeginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerEndEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerEndEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerEndEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerInsertEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerInsertEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerInsertEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalImageFormatPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalImageFormatPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdExecuteGeneratedCommandsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPreprocessGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdPreprocessGeneratedCommandsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPreprocessGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipelineShaderGroupNV")==0){
                debug_printf("Retrieving vkCmdBindPipelineShaderGroupNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipelineShaderGroupNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetGeneratedCommandsMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetGeneratedCommandsMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetGeneratedCommandsMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkCreateIndirectCommandsLayoutNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkDestroyIndirectCommandsLayoutNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdPropertiesKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryRemoteAddressNV")==0){
                debug_printf("Retrieving vkGetMemoryRemoteAddressNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryRemoteAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkGetSemaphoreFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkImportSemaphoreFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceFdKHR")==0){
                debug_printf("Retrieving vkGetFenceFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportFenceFdKHR")==0){
                debug_printf("Retrieving vkImportFenceFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseDisplayEXT")==0){
                debug_printf("Retrieving vkReleaseDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDisplayPowerControlEXT")==0){
                debug_printf("Retrieving vkDisplayPowerControlEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDisplayPowerControlEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDeviceEventEXT")==0){
                debug_printf("Retrieving vkRegisterDeviceEventEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDeviceEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDisplayEventEXT")==0){
                debug_printf("Retrieving vkRegisterDisplayEventEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDisplayEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainCounterEXT")==0){
                debug_printf("Retrieving vkGetSwapchainCounterEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainCounterEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2EXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2EXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPresentCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupPresentCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPresentCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupSurfacePresentModesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImage2KHR")==0){
                debug_printf("Retrieving vkAcquireNextImage2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImage2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDevicePresentRectanglesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDevicePresentRectanglesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDevicePresentRectanglesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetWithTemplateKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetWithTemplateKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetWithTemplateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetHdrMetadataEXT")==0){
                debug_printf("Retrieving vkSetHdrMetadataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetHdrMetadataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainStatusKHR")==0){
                debug_printf("Retrieving vkGetSwapchainStatusKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainStatusKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRefreshCycleDurationGOOGLE")==0){
                debug_printf("Retrieving vkGetRefreshCycleDurationGOOGLE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRefreshCycleDurationGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPastPresentationTimingGOOGLE")==0){
                debug_printf("Retrieving vkGetPastPresentationTimingGOOGLE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPastPresentationTimingGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleModeEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMultisamplePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMultisamplePropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMultisamplePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormats2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormats2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormats2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlaneProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlaneProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModeProperties2KHR")==0){
                debug_printf("Retrieving vkGetDisplayModeProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModeProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilities2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue2")==0){
                debug_printf("Retrieving vkGetDeviceQueue2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateValidationCacheEXT")==0){
                debug_printf("Retrieving vkCreateValidationCacheEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyValidationCacheEXT")==0){
                debug_printf("Retrieving vkDestroyValidationCacheEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetValidationCacheDataEXT")==0){
                debug_printf("Retrieving vkGetValidationCacheDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetValidationCacheDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergeValidationCachesEXT")==0){
                debug_printf("Retrieving vkMergeValidationCachesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergeValidationCachesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderInfoAMD")==0){
                debug_printf("Retrieving vkGetShaderInfoAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderInfoAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetLocalDimmingAMD")==0){
                debug_printf("Retrieving vkSetLocalDimmingAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetLocalDimmingAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCalibrateableTimeDomainsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCalibrateableTimeDomainsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetCalibratedTimestampsEXT")==0){
                debug_printf("Retrieving vkGetCalibratedTimestampsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetCalibratedTimestampsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectNameEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectNameEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectTagEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectTagEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueBeginDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueEndDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueInsertDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdBeginDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdEndDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdInsertDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkCreateDebugUtilsMessengerEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkDestroyDebugUtilsMessengerEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSubmitDebugUtilsMessageEXT")==0){
                debug_printf("Retrieving vkSubmitDebugUtilsMessageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSubmitDebugUtilsMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryHostPointerPropertiesEXT")==0){
                debug_printf("Retrieving vkGetMemoryHostPointerPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryHostPointerPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarkerAMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarkerAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarkerAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCheckpointNV")==0){
                debug_printf("Retrieving vkCmdSetCheckpointNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCheckpointNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointDataNV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointDataNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointDataNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindTransformFeedbackBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindTransformFeedbackBuffersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindTransformFeedbackBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdBeginTransformFeedbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdEndTransformFeedbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdBeginQueryIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdEndQueryIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectByteCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawIndirectByteCountEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectByteCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadingRateImageNV")==0){
                debug_printf("Retrieving vkCmdBindShadingRateImageNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadingRateImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportShadingRatePaletteNV")==0){
                debug_printf("Retrieving vkCmdSetViewportShadingRatePaletteNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportShadingRatePaletteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoarseSampleOrderNV")==0){
                debug_printf("Retrieving vkCmdSetCoarseSampleOrderNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoarseSampleOrderNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCompileDeferredNV")==0){
                debug_printf("Retrieving vkCompileDeferredNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCompileDeferredNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindInvocationMaskHUAWEI")==0){
                debug_printf("Retrieving vkCmdBindInvocationMaskHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindInvocationMaskHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindAccelerationStructureMemoryNV")==0){
                debug_printf("Retrieving vkBindAccelerationStructureMemoryNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindAccelerationStructureMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureToMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureToMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyMemoryToAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesNV")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkWriteAccelerationStructuresPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysNV")==0){
                debug_printf("Retrieving vkCmdTraceRaysNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingCaptureReplayShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingCaptureReplayShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureHandleNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureHandleNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureHandleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesNV")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesKHR")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirectKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirectKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirect2KHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirect2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirect2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceAccelerationStructureCompatibilityKHR")==0){
                debug_printf("Retrieving vkGetDeviceAccelerationStructureCompatibilityKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceAccelerationStructureCompatibilityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupStackSizeKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupStackSizeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRayTracingPipelineStackSizeKHR")==0){
                debug_printf("Retrieving vkCmdSetRayTracingPipelineStackSizeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRayTracingPipelineStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewHandleNVX")==0){
                debug_printf("Retrieving vkGetImageViewHandleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewHandleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewAddressNVX")==0){
                debug_printf("Retrieving vkGetImageViewAddressNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewAddressNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireProfilingLockKHR")==0){
                debug_printf("Retrieving vkAcquireProfilingLockKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseProfilingLockKHR")==0){
                debug_printf("Retrieving vkReleaseProfilingLockKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageDrmFormatModifierPropertiesEXT")==0){
                debug_printf("Retrieving vkGetImageDrmFormatModifierPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageDrmFormatModifierPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateHeadlessSurfaceEXT")==0){
                debug_printf("Retrieving vkCreateHeadlessSurfaceEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateHeadlessSurfaceEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkInitializePerformanceApiINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUninitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkUninitializePerformanceApiINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUninitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceMarkerINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceStreamMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceStreamMarkerINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceStreamMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceOverrideINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceOverrideINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceOverrideINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquirePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkAcquirePerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquirePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleasePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkReleasePerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleasePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSetPerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkQueueSetPerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSetPerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPerformanceParameterINTEL")==0){
                debug_printf("Retrieving vkGetPerformanceParameterINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPerformanceParameterINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutablePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutablePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutablePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableStatisticsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableStatisticsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableStatisticsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableInternalRepresentationsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableInternalRepresentationsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableInternalRepresentationsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresIndirectKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresIndirectKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkBuildAccelerationStructuresKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureDeviceAddressKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureDeviceAddressKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureDeviceAddressKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDeferredOperationKHR")==0){
                debug_printf("Retrieving vkCreateDeferredOperationKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDeferredOperationKHR")==0){
                debug_printf("Retrieving vkDestroyDeferredOperationKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationMaxConcurrencyKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationMaxConcurrencyKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationMaxConcurrencyKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationResultKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationResultKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationResultKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeferredOperationJoinKHR")==0){
                debug_printf("Retrieving vkDeferredOperationJoinKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeferredOperationJoinKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectDeviceAddressNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectDeviceAddressNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectDeviceAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer2KHR")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPatchControlPointsEXT")==0){
                debug_printf("Retrieving vkCmdSetPatchControlPointsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPatchControlPointsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetTessellationDomainOriginEXT")==0){
                debug_printf("Retrieving vkCmdSetTessellationDomainOriginEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetTessellationDomainOriginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClampEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClampEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClampEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPolygonModeEXT")==0){
                debug_printf("Retrieving vkCmdSetPolygonModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPolygonModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationSamplesEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationSamplesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationSamplesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleMaskEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToCoverageEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToCoverageEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToCoverageEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToOneEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToOneEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToOneEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEquationEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEquationEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEquationEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteMaskEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationStreamEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationStreamEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationStreamEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetConservativeRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetConservativeRasterizationModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetConservativeRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExtraPrimitiveOverestimationSizeEXT")==0){
                debug_printf("Retrieving vkCmdSetExtraPrimitiveOverestimationSizeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExtraPrimitiveOverestimationSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendAdvancedEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendAdvancedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendAdvancedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetProvokingVertexModeEXT")==0){
                debug_printf("Retrieving vkCmdSetProvokingVertexModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetProvokingVertexModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetLineRasterizationModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipNegativeOneToOneEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipNegativeOneToOneEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipNegativeOneToOneEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingEnableNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportSwizzleNV")==0){
                debug_printf("Retrieving vkCmdSetViewportSwizzleNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportSwizzleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorLocationNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorLocationNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorLocationNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationModeNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetShadingRateImageEnableNV")==0){
                debug_printf("Retrieving vkCmdSetShadingRateImageEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetShadingRateImageEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageReductionModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageReductionModeNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageReductionModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRepresentativeFragmentTestEnableNV")==0){
                debug_printf("Retrieving vkCmdSetRepresentativeFragmentTestEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRepresentativeFragmentTestEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateKHR")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFragmentShadingRatesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFragmentShadingRatesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFragmentShadingRatesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateEnumNV")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateEnumNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateEnumNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureBuildSizesKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureBuildSizesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureBuildSizesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetVertexInputEXT")==0){
                debug_printf("Retrieving vkCmdSetVertexInputEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetVertexInputEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarker2AMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarker2AMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarker2AMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointData2NV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointData2NV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointData2NV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToImageEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToImageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyImageToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToImageEXT")==0){
                debug_printf("Retrieving vkCopyImageToImageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTransitionImageLayoutEXT")==0){
                debug_printf("Retrieving vkTransitionImageLayoutEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTransitionImageLayoutEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoFormatPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoFormatPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoFormatPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkUpdateVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetVideoSessionMemoryRequirementsKHR")==0){
                debug_printf("Retrieving vkGetVideoSessionMemoryRequirementsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetVideoSessionMemoryRequirementsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindVideoSessionMemoryKHR")==0){
                debug_printf("Retrieving vkBindVideoSessionMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindVideoSessionMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecodeVideoKHR")==0){
                debug_printf("Retrieving vkCmdDecodeVideoKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecodeVideoKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdBeginVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdControlVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdControlVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdControlVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdEndVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryIndirectCountNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuModuleNVX")==0){
                debug_printf("Retrieving vkCreateCuModuleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuFunctionNVX")==0){
                debug_printf("Retrieving vkCreateCuFunctionNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuModuleNVX")==0){
                debug_printf("Retrieving vkDestroyCuModuleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuFunctionNVX")==0){
                debug_printf("Retrieving vkDestroyCuFunctionNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCuLaunchKernelNVX")==0){
                debug_printf("Retrieving vkCmdCuLaunchKernelNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCuLaunchKernelNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSizeEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSizeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutBindingOffsetEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutBindingOffsetEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutBindingOffsetEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorEXT")==0){
                debug_printf("Retrieving vkGetDescriptorEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBuffersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDescriptorBufferOffsetsEXT")==0){
                debug_printf("Retrieving vkCmdSetDescriptorBufferOffsetsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDescriptorBufferOffsetsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBufferEmbeddedSamplersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBufferEmbeddedSamplersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageViewOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSamplerOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetSamplerOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSamplerOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDeviceMemoryPriorityEXT")==0){
                debug_printf("Retrieving vkSetDeviceMemoryPriorityEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDeviceMemoryPriorityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireDrmDisplayEXT")==0){
                debug_printf("Retrieving vkAcquireDrmDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDrmDisplayEXT")==0){
                debug_printf("Retrieving vkGetDrmDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForPresentKHR")==0){
                debug_printf("Retrieving vkWaitForPresentKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForPresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutHostMappingInfoVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutHostMappingInfoVALVE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutHostMappingInfoVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetHostMappingVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetHostMappingVALVE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetHostMappingVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateMicromapEXT")==0){
                debug_printf("Retrieving vkCreateMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkCmdBuildMicromapsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkBuildMicromapsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyMicromapEXT")==0){
                debug_printf("Retrieving vkDestroyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyMicromapToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkCmdWriteMicromapsPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkWriteMicromapsPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMicromapCompatibilityEXT")==0){
                debug_printf("Retrieving vkGetDeviceMicromapCompatibilityEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMicromapCompatibilityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMicromapBuildSizesEXT")==0){
                debug_printf("Retrieving vkGetMicromapBuildSizesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMicromapBuildSizesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleIdentifierEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleCreateInfoIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleCreateInfoIdentifierEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleCreateInfoIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelinePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPipelinePropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelinePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFramebufferTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetFramebufferTilePropertiesQCOM...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFramebufferTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDynamicRenderingTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetDynamicRenderingTilePropertiesQCOM...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDynamicRenderingTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceOpticalFlowImageFormatsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceOpticalFlowImageFormatsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkCreateOpticalFlowSessionNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkDestroyOpticalFlowSessionNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindOpticalFlowSessionImageNV")==0){
                debug_printf("Retrieving vkBindOpticalFlowSessionImageNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindOpticalFlowSessionImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdOpticalFlowExecuteNV")==0){
                debug_printf("Retrieving vkCmdOpticalFlowExecuteNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdOpticalFlowExecuteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceFaultInfoEXT")==0){
                debug_printf("Retrieving vkGetDeviceFaultInfoEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceFaultInfoEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias2EXT")==0){
                debug_printf("Retrieving vkCmdSetDepthBias2EXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseSwapchainImagesEXT")==0){
                debug_printf("Retrieving vkReleaseSwapchainImagesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseSwapchainImagesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSubresourceLayoutKHR")==0){
                debug_printf("Retrieving vkGetDeviceImageSubresourceLayoutKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSubresourceLayoutKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory2KHR")==0){
                debug_printf("Retrieving vkMapMemory2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory2KHR")==0){
                debug_printf("Retrieving vkUnmapMemory2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShadersEXT")==0){
                debug_printf("Retrieving vkCreateShadersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderEXT")==0){
                debug_printf("Retrieving vkDestroyShaderEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderBinaryDataEXT")==0){
                debug_printf("Retrieving vkGetShaderBinaryDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderBinaryDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadersEXT")==0){
                debug_printf("Retrieving vkCmdBindShadersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else {
                debug_printf("Unknown function: %s\n", pName);
                result=NULL;
            }
            
            debug_printf("Address of ProcAddr: %p\n",result);
        

debug_printf("Ending vkGetDeviceProcAddr...\n");
return result;
}
__attribute__((visibility ("hidden"))) PFN_vkVoidFunction vkGetInstanceProcAddr( VkInstance instance, const char* pName ){
//Will only be called by the client
debug_printf("Executing vkGetInstanceProcAddr\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETINSTANCEPROCADDR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pName==NULL){
                json["pName"]=boost::json::array();
            return; }
        auto& arr_XCtfitt=json["pName"].emplace_array();
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=pName[EZmXTUp];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETINSTANCEPROCADDR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();

PFN_vkVoidFunction result;

        if (strcmp(pName,"vk_icdNegotiateLoaderICDInterfaceVersion")==0){
            result=(PFN_vkVoidFunction)vk_icdNegotiateLoaderICDInterfaceVersion;
        }
        #ifdef VK_USE_PLATFORM_XCB_KHR
            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXcbSurfaceKHR;
            }
        #endif
        
        #ifdef VK_USE_PLATFORM_XLIB_KHR
            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXlibSurfaceKHR;
            }
        #endif
        

            else if (strcmp(pName,"vkCreateInstance")==0){
                debug_printf("Retrieving vkCreateInstance...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyInstance")==0){
                debug_printf("Retrieving vkDestroyInstance...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDevices")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDevices...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDevices : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceProcAddr")==0){
                debug_printf("Retrieving vkGetDeviceProcAddr...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetInstanceProcAddr")==0){
                debug_printf("Retrieving vkGetInstanceProcAddr...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetInstanceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDevice")==0){
                debug_printf("Retrieving vkCreateDevice...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDevice")==0){
                debug_printf("Retrieving vkDestroyDevice...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceVersion")==0){
                debug_printf("Retrieving vkEnumerateInstanceVersion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceVersion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceLayerProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceExtensionProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceLayerProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceExtensionProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue")==0){
                debug_printf("Retrieving vkGetDeviceQueue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit")==0){
                debug_printf("Retrieving vkQueueSubmit...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueWaitIdle")==0){
                debug_printf("Retrieving vkQueueWaitIdle...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeviceWaitIdle")==0){
                debug_printf("Retrieving vkDeviceWaitIdle...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeviceWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateMemory")==0){
                debug_printf("Retrieving vkAllocateMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeMemory")==0){
                debug_printf("Retrieving vkFreeMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory")==0){
                debug_printf("Retrieving vkMapMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory")==0){
                debug_printf("Retrieving vkUnmapMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFlushMappedMemoryRanges")==0){
                debug_printf("Retrieving vkFlushMappedMemoryRanges...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFlushMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInvalidateMappedMemoryRanges")==0){
                debug_printf("Retrieving vkInvalidateMappedMemoryRanges...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInvalidateMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryCommitment")==0){
                debug_printf("Retrieving vkGetDeviceMemoryCommitment...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryCommitment : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory")==0){
                debug_printf("Retrieving vkBindBufferMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory")==0){
                debug_printf("Retrieving vkBindImageMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBindSparse")==0){
                debug_printf("Retrieving vkQueueBindSparse...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBindSparse : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFence")==0){
                debug_printf("Retrieving vkCreateFence...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFence")==0){
                debug_printf("Retrieving vkDestroyFence...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetFences")==0){
                debug_printf("Retrieving vkResetFences...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceStatus")==0){
                debug_printf("Retrieving vkGetFenceStatus...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForFences")==0){
                debug_printf("Retrieving vkWaitForFences...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSemaphore")==0){
                debug_printf("Retrieving vkCreateSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySemaphore")==0){
                debug_printf("Retrieving vkDestroySemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateEvent")==0){
                debug_printf("Retrieving vkCreateEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyEvent")==0){
                debug_printf("Retrieving vkDestroyEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetEventStatus")==0){
                debug_printf("Retrieving vkGetEventStatus...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetEventStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetEvent")==0){
                debug_printf("Retrieving vkSetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetEvent")==0){
                debug_printf("Retrieving vkResetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateQueryPool")==0){
                debug_printf("Retrieving vkCreateQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyQueryPool")==0){
                debug_printf("Retrieving vkDestroyQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueryPoolResults")==0){
                debug_printf("Retrieving vkGetQueryPoolResults...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBuffer")==0){
                debug_printf("Retrieving vkCreateBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBuffer")==0){
                debug_printf("Retrieving vkDestroyBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBufferView")==0){
                debug_printf("Retrieving vkCreateBufferView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBufferView")==0){
                debug_printf("Retrieving vkDestroyBufferView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImage")==0){
                debug_printf("Retrieving vkCreateImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImage")==0){
                debug_printf("Retrieving vkDestroyImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImageView")==0){
                debug_printf("Retrieving vkCreateImageView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImageView")==0){
                debug_printf("Retrieving vkDestroyImageView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShaderModule")==0){
                debug_printf("Retrieving vkCreateShaderModule...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderModule")==0){
                debug_printf("Retrieving vkDestroyShaderModule...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineCache")==0){
                debug_printf("Retrieving vkCreatePipelineCache...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineCache")==0){
                debug_printf("Retrieving vkDestroyPipelineCache...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineCacheData")==0){
                debug_printf("Retrieving vkGetPipelineCacheData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineCacheData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergePipelineCaches")==0){
                debug_printf("Retrieving vkMergePipelineCaches...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergePipelineCaches : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateGraphicsPipelines")==0){
                debug_printf("Retrieving vkCreateGraphicsPipelines...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateGraphicsPipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateComputePipelines")==0){
                debug_printf("Retrieving vkCreateComputePipelines...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateComputePipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")==0){
                debug_printf("Retrieving vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipeline")==0){
                debug_printf("Retrieving vkDestroyPipeline...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineLayout")==0){
                debug_printf("Retrieving vkCreatePipelineLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineLayout")==0){
                debug_printf("Retrieving vkDestroyPipelineLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSampler")==0){
                debug_printf("Retrieving vkCreateSampler...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySampler")==0){
                debug_printf("Retrieving vkDestroySampler...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorSetLayout")==0){
                debug_printf("Retrieving vkCreateDescriptorSetLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorSetLayout")==0){
                debug_printf("Retrieving vkDestroyDescriptorSetLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorPool")==0){
                debug_printf("Retrieving vkCreateDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorPool")==0){
                debug_printf("Retrieving vkDestroyDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetDescriptorPool")==0){
                debug_printf("Retrieving vkResetDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateDescriptorSets")==0){
                debug_printf("Retrieving vkAllocateDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeDescriptorSets")==0){
                debug_printf("Retrieving vkFreeDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSets")==0){
                debug_printf("Retrieving vkUpdateDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFramebuffer")==0){
                debug_printf("Retrieving vkCreateFramebuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFramebuffer")==0){
                debug_printf("Retrieving vkDestroyFramebuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass")==0){
                debug_printf("Retrieving vkCreateRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyRenderPass")==0){
                debug_printf("Retrieving vkDestroyRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderAreaGranularity")==0){
                debug_printf("Retrieving vkGetRenderAreaGranularity...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderAreaGranularity : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderingAreaGranularityKHR")==0){
                debug_printf("Retrieving vkGetRenderingAreaGranularityKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderingAreaGranularityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCommandPool")==0){
                debug_printf("Retrieving vkCreateCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCommandPool")==0){
                debug_printf("Retrieving vkDestroyCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandPool")==0){
                debug_printf("Retrieving vkResetCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateCommandBuffers")==0){
                debug_printf("Retrieving vkAllocateCommandBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeCommandBuffers")==0){
                debug_printf("Retrieving vkFreeCommandBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBeginCommandBuffer")==0){
                debug_printf("Retrieving vkBeginCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBeginCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEndCommandBuffer")==0){
                debug_printf("Retrieving vkEndCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEndCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandBuffer")==0){
                debug_printf("Retrieving vkResetCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipeline")==0){
                debug_printf("Retrieving vkCmdBindPipeline...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAttachmentFeedbackLoopEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAttachmentFeedbackLoopEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAttachmentFeedbackLoopEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewport")==0){
                debug_printf("Retrieving vkCmdSetViewport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissor")==0){
                debug_printf("Retrieving vkCmdSetScissor...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissor : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineWidth")==0){
                debug_printf("Retrieving vkCmdSetLineWidth...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineWidth : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias")==0){
                debug_printf("Retrieving vkCmdSetDepthBias...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetBlendConstants")==0){
                debug_printf("Retrieving vkCmdSetBlendConstants...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetBlendConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBounds")==0){
                debug_printf("Retrieving vkCmdSetDepthBounds...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBounds : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilCompareMask")==0){
                debug_printf("Retrieving vkCmdSetStencilCompareMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilCompareMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilWriteMask")==0){
                debug_printf("Retrieving vkCmdSetStencilWriteMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilWriteMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilReference")==0){
                debug_printf("Retrieving vkCmdSetStencilReference...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilReference : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorSets")==0){
                debug_printf("Retrieving vkCmdBindDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDraw")==0){
                debug_printf("Retrieving vkCmdDraw...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDraw : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexed")==0){
                debug_printf("Retrieving vkCmdDrawIndexed...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexed : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiIndexedEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatch")==0){
                debug_printf("Retrieving vkCmdDispatch...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatch : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchIndirect")==0){
                debug_printf("Retrieving vkCmdDispatchIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSubpassShadingHUAWEI")==0){
                debug_printf("Retrieving vkCmdSubpassShadingHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSubpassShadingHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterIndirectHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterIndirectHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterIndirectHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdatePipelineIndirectBufferNV")==0){
                debug_printf("Retrieving vkCmdUpdatePipelineIndirectBufferNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdatePipelineIndirectBufferNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer")==0){
                debug_printf("Retrieving vkCmdCopyBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage")==0){
                debug_printf("Retrieving vkCmdCopyImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage")==0){
                debug_printf("Retrieving vkCmdBlitImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToImageIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToImageIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToImageIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdateBuffer")==0){
                debug_printf("Retrieving vkCmdUpdateBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdFillBuffer")==0){
                debug_printf("Retrieving vkCmdFillBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdFillBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearColorImage")==0){
                debug_printf("Retrieving vkCmdClearColorImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearColorImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearDepthStencilImage")==0){
                debug_printf("Retrieving vkCmdClearDepthStencilImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearDepthStencilImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearAttachments")==0){
                debug_printf("Retrieving vkCmdClearAttachments...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearAttachments : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage")==0){
                debug_printf("Retrieving vkCmdResolveImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent")==0){
                debug_printf("Retrieving vkCmdSetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent")==0){
                debug_printf("Retrieving vkCmdResetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents")==0){
                debug_printf("Retrieving vkCmdWaitEvents...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQuery")==0){
                debug_printf("Retrieving vkCmdBeginQuery...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQuery")==0){
                debug_printf("Retrieving vkCmdEndQuery...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdBeginConditionalRenderingEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdEndConditionalRenderingEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetQueryPool")==0){
                debug_printf("Retrieving vkCmdResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyQueryPoolResults")==0){
                debug_printf("Retrieving vkCmdCopyQueryPoolResults...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushConstants")==0){
                debug_printf("Retrieving vkCmdPushConstants...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass")==0){
                debug_printf("Retrieving vkCmdNextSubpass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass")==0){
                debug_printf("Retrieving vkCmdEndRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteCommands")==0){
                debug_printf("Retrieving vkCmdExecuteCommands...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteCommands : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlanePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlanePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneSupportedDisplaysKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneSupportedDisplaysKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneSupportedDisplaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModePropertiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayModePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayModeKHR")==0){
                debug_printf("Retrieving vkCreateDisplayModeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayModeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayPlaneSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateDisplayPlaneSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayPlaneSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSharedSwapchainsKHR")==0){
                debug_printf("Retrieving vkCreateSharedSwapchainsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSharedSwapchainsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySurfaceKHR")==0){
                debug_printf("Retrieving vkDestroySurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormatsKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormatsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormatsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfacePresentModesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSwapchainKHR")==0){
                debug_printf("Retrieving vkCreateSwapchainKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySwapchainKHR")==0){
                debug_printf("Retrieving vkDestroySwapchainKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainImagesKHR")==0){
                debug_printf("Retrieving vkGetSwapchainImagesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainImagesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImageKHR")==0){
                debug_printf("Retrieving vkAcquireNextImageKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImageKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueuePresentKHR")==0){
                debug_printf("Retrieving vkQueuePresentKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueuePresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXlibSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXlibSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXlibPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXlibPresentationSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXlibPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXcbSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXcbSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXcbPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXcbPresentationSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXcbPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkCreateDebugReportCallbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkDestroyDebugReportCallbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugReportMessageEXT")==0){
                debug_printf("Retrieving vkDebugReportMessageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugReportMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectNameEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectNameEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectTagEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectTagEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerBeginEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerBeginEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerBeginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerEndEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerEndEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerEndEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerInsertEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerInsertEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerInsertEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalImageFormatPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalImageFormatPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdExecuteGeneratedCommandsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPreprocessGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdPreprocessGeneratedCommandsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPreprocessGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipelineShaderGroupNV")==0){
                debug_printf("Retrieving vkCmdBindPipelineShaderGroupNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipelineShaderGroupNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetGeneratedCommandsMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetGeneratedCommandsMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetGeneratedCommandsMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkCreateIndirectCommandsLayoutNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkDestroyIndirectCommandsLayoutNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdPropertiesKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryRemoteAddressNV")==0){
                debug_printf("Retrieving vkGetMemoryRemoteAddressNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryRemoteAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkGetSemaphoreFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkImportSemaphoreFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceFdKHR")==0){
                debug_printf("Retrieving vkGetFenceFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportFenceFdKHR")==0){
                debug_printf("Retrieving vkImportFenceFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseDisplayEXT")==0){
                debug_printf("Retrieving vkReleaseDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDisplayPowerControlEXT")==0){
                debug_printf("Retrieving vkDisplayPowerControlEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDisplayPowerControlEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDeviceEventEXT")==0){
                debug_printf("Retrieving vkRegisterDeviceEventEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDeviceEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDisplayEventEXT")==0){
                debug_printf("Retrieving vkRegisterDisplayEventEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDisplayEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainCounterEXT")==0){
                debug_printf("Retrieving vkGetSwapchainCounterEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainCounterEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2EXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2EXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPresentCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupPresentCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPresentCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupSurfacePresentModesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImage2KHR")==0){
                debug_printf("Retrieving vkAcquireNextImage2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImage2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDevicePresentRectanglesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDevicePresentRectanglesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDevicePresentRectanglesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetWithTemplateKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetWithTemplateKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetWithTemplateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetHdrMetadataEXT")==0){
                debug_printf("Retrieving vkSetHdrMetadataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetHdrMetadataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainStatusKHR")==0){
                debug_printf("Retrieving vkGetSwapchainStatusKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainStatusKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRefreshCycleDurationGOOGLE")==0){
                debug_printf("Retrieving vkGetRefreshCycleDurationGOOGLE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRefreshCycleDurationGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPastPresentationTimingGOOGLE")==0){
                debug_printf("Retrieving vkGetPastPresentationTimingGOOGLE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPastPresentationTimingGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleModeEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMultisamplePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMultisamplePropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMultisamplePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormats2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormats2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormats2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlaneProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlaneProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModeProperties2KHR")==0){
                debug_printf("Retrieving vkGetDisplayModeProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModeProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilities2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue2")==0){
                debug_printf("Retrieving vkGetDeviceQueue2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateValidationCacheEXT")==0){
                debug_printf("Retrieving vkCreateValidationCacheEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyValidationCacheEXT")==0){
                debug_printf("Retrieving vkDestroyValidationCacheEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetValidationCacheDataEXT")==0){
                debug_printf("Retrieving vkGetValidationCacheDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetValidationCacheDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergeValidationCachesEXT")==0){
                debug_printf("Retrieving vkMergeValidationCachesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergeValidationCachesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderInfoAMD")==0){
                debug_printf("Retrieving vkGetShaderInfoAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderInfoAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetLocalDimmingAMD")==0){
                debug_printf("Retrieving vkSetLocalDimmingAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetLocalDimmingAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCalibrateableTimeDomainsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCalibrateableTimeDomainsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetCalibratedTimestampsEXT")==0){
                debug_printf("Retrieving vkGetCalibratedTimestampsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetCalibratedTimestampsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectNameEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectNameEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectTagEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectTagEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueBeginDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueEndDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueInsertDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdBeginDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdEndDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdInsertDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkCreateDebugUtilsMessengerEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkDestroyDebugUtilsMessengerEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSubmitDebugUtilsMessageEXT")==0){
                debug_printf("Retrieving vkSubmitDebugUtilsMessageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSubmitDebugUtilsMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryHostPointerPropertiesEXT")==0){
                debug_printf("Retrieving vkGetMemoryHostPointerPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryHostPointerPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarkerAMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarkerAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarkerAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCheckpointNV")==0){
                debug_printf("Retrieving vkCmdSetCheckpointNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCheckpointNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointDataNV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointDataNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointDataNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindTransformFeedbackBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindTransformFeedbackBuffersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindTransformFeedbackBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdBeginTransformFeedbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdEndTransformFeedbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdBeginQueryIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdEndQueryIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectByteCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawIndirectByteCountEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectByteCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadingRateImageNV")==0){
                debug_printf("Retrieving vkCmdBindShadingRateImageNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadingRateImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportShadingRatePaletteNV")==0){
                debug_printf("Retrieving vkCmdSetViewportShadingRatePaletteNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportShadingRatePaletteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoarseSampleOrderNV")==0){
                debug_printf("Retrieving vkCmdSetCoarseSampleOrderNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoarseSampleOrderNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCompileDeferredNV")==0){
                debug_printf("Retrieving vkCompileDeferredNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCompileDeferredNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindInvocationMaskHUAWEI")==0){
                debug_printf("Retrieving vkCmdBindInvocationMaskHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindInvocationMaskHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindAccelerationStructureMemoryNV")==0){
                debug_printf("Retrieving vkBindAccelerationStructureMemoryNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindAccelerationStructureMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureToMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureToMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyMemoryToAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesNV")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkWriteAccelerationStructuresPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysNV")==0){
                debug_printf("Retrieving vkCmdTraceRaysNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingCaptureReplayShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingCaptureReplayShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureHandleNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureHandleNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureHandleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesNV")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesKHR")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirectKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirectKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirect2KHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirect2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirect2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceAccelerationStructureCompatibilityKHR")==0){
                debug_printf("Retrieving vkGetDeviceAccelerationStructureCompatibilityKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceAccelerationStructureCompatibilityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupStackSizeKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupStackSizeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRayTracingPipelineStackSizeKHR")==0){
                debug_printf("Retrieving vkCmdSetRayTracingPipelineStackSizeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRayTracingPipelineStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewHandleNVX")==0){
                debug_printf("Retrieving vkGetImageViewHandleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewHandleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewAddressNVX")==0){
                debug_printf("Retrieving vkGetImageViewAddressNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewAddressNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireProfilingLockKHR")==0){
                debug_printf("Retrieving vkAcquireProfilingLockKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseProfilingLockKHR")==0){
                debug_printf("Retrieving vkReleaseProfilingLockKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageDrmFormatModifierPropertiesEXT")==0){
                debug_printf("Retrieving vkGetImageDrmFormatModifierPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageDrmFormatModifierPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateHeadlessSurfaceEXT")==0){
                debug_printf("Retrieving vkCreateHeadlessSurfaceEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateHeadlessSurfaceEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkInitializePerformanceApiINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUninitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkUninitializePerformanceApiINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUninitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceMarkerINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceStreamMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceStreamMarkerINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceStreamMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceOverrideINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceOverrideINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceOverrideINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquirePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkAcquirePerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquirePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleasePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkReleasePerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleasePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSetPerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkQueueSetPerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSetPerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPerformanceParameterINTEL")==0){
                debug_printf("Retrieving vkGetPerformanceParameterINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPerformanceParameterINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutablePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutablePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutablePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableStatisticsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableStatisticsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableStatisticsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableInternalRepresentationsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableInternalRepresentationsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableInternalRepresentationsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresIndirectKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresIndirectKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkBuildAccelerationStructuresKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureDeviceAddressKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureDeviceAddressKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureDeviceAddressKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDeferredOperationKHR")==0){
                debug_printf("Retrieving vkCreateDeferredOperationKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDeferredOperationKHR")==0){
                debug_printf("Retrieving vkDestroyDeferredOperationKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationMaxConcurrencyKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationMaxConcurrencyKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationMaxConcurrencyKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationResultKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationResultKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationResultKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeferredOperationJoinKHR")==0){
                debug_printf("Retrieving vkDeferredOperationJoinKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeferredOperationJoinKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectDeviceAddressNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectDeviceAddressNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectDeviceAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer2KHR")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPatchControlPointsEXT")==0){
                debug_printf("Retrieving vkCmdSetPatchControlPointsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPatchControlPointsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetTessellationDomainOriginEXT")==0){
                debug_printf("Retrieving vkCmdSetTessellationDomainOriginEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetTessellationDomainOriginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClampEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClampEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClampEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPolygonModeEXT")==0){
                debug_printf("Retrieving vkCmdSetPolygonModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPolygonModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationSamplesEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationSamplesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationSamplesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleMaskEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToCoverageEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToCoverageEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToCoverageEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToOneEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToOneEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToOneEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEquationEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEquationEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEquationEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteMaskEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationStreamEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationStreamEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationStreamEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetConservativeRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetConservativeRasterizationModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetConservativeRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExtraPrimitiveOverestimationSizeEXT")==0){
                debug_printf("Retrieving vkCmdSetExtraPrimitiveOverestimationSizeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExtraPrimitiveOverestimationSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendAdvancedEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendAdvancedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendAdvancedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetProvokingVertexModeEXT")==0){
                debug_printf("Retrieving vkCmdSetProvokingVertexModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetProvokingVertexModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetLineRasterizationModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipNegativeOneToOneEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipNegativeOneToOneEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipNegativeOneToOneEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingEnableNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportSwizzleNV")==0){
                debug_printf("Retrieving vkCmdSetViewportSwizzleNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportSwizzleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorLocationNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorLocationNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorLocationNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationModeNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetShadingRateImageEnableNV")==0){
                debug_printf("Retrieving vkCmdSetShadingRateImageEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetShadingRateImageEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageReductionModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageReductionModeNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageReductionModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRepresentativeFragmentTestEnableNV")==0){
                debug_printf("Retrieving vkCmdSetRepresentativeFragmentTestEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRepresentativeFragmentTestEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateKHR")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFragmentShadingRatesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFragmentShadingRatesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFragmentShadingRatesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateEnumNV")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateEnumNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateEnumNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureBuildSizesKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureBuildSizesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureBuildSizesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetVertexInputEXT")==0){
                debug_printf("Retrieving vkCmdSetVertexInputEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetVertexInputEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarker2AMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarker2AMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarker2AMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointData2NV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointData2NV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointData2NV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToImageEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToImageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyImageToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToImageEXT")==0){
                debug_printf("Retrieving vkCopyImageToImageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTransitionImageLayoutEXT")==0){
                debug_printf("Retrieving vkTransitionImageLayoutEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTransitionImageLayoutEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoFormatPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoFormatPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoFormatPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkUpdateVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetVideoSessionMemoryRequirementsKHR")==0){
                debug_printf("Retrieving vkGetVideoSessionMemoryRequirementsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetVideoSessionMemoryRequirementsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindVideoSessionMemoryKHR")==0){
                debug_printf("Retrieving vkBindVideoSessionMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindVideoSessionMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecodeVideoKHR")==0){
                debug_printf("Retrieving vkCmdDecodeVideoKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecodeVideoKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdBeginVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdControlVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdControlVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdControlVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdEndVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryIndirectCountNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuModuleNVX")==0){
                debug_printf("Retrieving vkCreateCuModuleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuFunctionNVX")==0){
                debug_printf("Retrieving vkCreateCuFunctionNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuModuleNVX")==0){
                debug_printf("Retrieving vkDestroyCuModuleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuFunctionNVX")==0){
                debug_printf("Retrieving vkDestroyCuFunctionNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCuLaunchKernelNVX")==0){
                debug_printf("Retrieving vkCmdCuLaunchKernelNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCuLaunchKernelNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSizeEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSizeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutBindingOffsetEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutBindingOffsetEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutBindingOffsetEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorEXT")==0){
                debug_printf("Retrieving vkGetDescriptorEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBuffersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDescriptorBufferOffsetsEXT")==0){
                debug_printf("Retrieving vkCmdSetDescriptorBufferOffsetsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDescriptorBufferOffsetsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBufferEmbeddedSamplersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBufferEmbeddedSamplersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageViewOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSamplerOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetSamplerOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSamplerOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDeviceMemoryPriorityEXT")==0){
                debug_printf("Retrieving vkSetDeviceMemoryPriorityEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDeviceMemoryPriorityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireDrmDisplayEXT")==0){
                debug_printf("Retrieving vkAcquireDrmDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDrmDisplayEXT")==0){
                debug_printf("Retrieving vkGetDrmDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForPresentKHR")==0){
                debug_printf("Retrieving vkWaitForPresentKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForPresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutHostMappingInfoVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutHostMappingInfoVALVE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutHostMappingInfoVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetHostMappingVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetHostMappingVALVE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetHostMappingVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateMicromapEXT")==0){
                debug_printf("Retrieving vkCreateMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkCmdBuildMicromapsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkBuildMicromapsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyMicromapEXT")==0){
                debug_printf("Retrieving vkDestroyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyMicromapToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkCmdWriteMicromapsPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkWriteMicromapsPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMicromapCompatibilityEXT")==0){
                debug_printf("Retrieving vkGetDeviceMicromapCompatibilityEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMicromapCompatibilityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMicromapBuildSizesEXT")==0){
                debug_printf("Retrieving vkGetMicromapBuildSizesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMicromapBuildSizesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleIdentifierEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleCreateInfoIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleCreateInfoIdentifierEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleCreateInfoIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelinePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPipelinePropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelinePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFramebufferTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetFramebufferTilePropertiesQCOM...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFramebufferTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDynamicRenderingTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetDynamicRenderingTilePropertiesQCOM...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDynamicRenderingTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceOpticalFlowImageFormatsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceOpticalFlowImageFormatsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkCreateOpticalFlowSessionNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkDestroyOpticalFlowSessionNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindOpticalFlowSessionImageNV")==0){
                debug_printf("Retrieving vkBindOpticalFlowSessionImageNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindOpticalFlowSessionImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdOpticalFlowExecuteNV")==0){
                debug_printf("Retrieving vkCmdOpticalFlowExecuteNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdOpticalFlowExecuteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceFaultInfoEXT")==0){
                debug_printf("Retrieving vkGetDeviceFaultInfoEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceFaultInfoEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias2EXT")==0){
                debug_printf("Retrieving vkCmdSetDepthBias2EXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseSwapchainImagesEXT")==0){
                debug_printf("Retrieving vkReleaseSwapchainImagesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseSwapchainImagesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSubresourceLayoutKHR")==0){
                debug_printf("Retrieving vkGetDeviceImageSubresourceLayoutKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSubresourceLayoutKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory2KHR")==0){
                debug_printf("Retrieving vkMapMemory2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory2KHR")==0){
                debug_printf("Retrieving vkUnmapMemory2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShadersEXT")==0){
                debug_printf("Retrieving vkCreateShadersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderEXT")==0){
                debug_printf("Retrieving vkDestroyShaderEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderBinaryDataEXT")==0){
                debug_printf("Retrieving vkGetShaderBinaryDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderBinaryDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadersEXT")==0){
                debug_printf("Retrieving vkCmdBindShadersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else {
                debug_printf("Unknown function: %s\n", pName);
                result=NULL;
            }
            
            debug_printf("Address of ProcAddr: %p\n",result);
        

debug_printf("Ending vkGetInstanceProcAddr...\n");
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceProperties( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_rSttUuQ=json["pProperties"].emplace_array();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto& temp=arr_rSttUuQ[RBAofpr].emplace_object();
            return serialize_struct(temp, pProperties[RBAofpr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_rSttUuQ=json["pProperties"].as_array();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto& temp=arr_rSttUuQ[RBAofpr].as_object();
            deserialize_struct(temp,pProperties[RBAofpr]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyProperties( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceQueueFamilyProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=boost::json::array();
            return; }
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].emplace_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=pQueueFamilyPropertyCount[cPKCUxv];}();
        }
        }();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=boost::json::array();
            return; }
        auto& arr_ixxluvk=json["pQueueFamilyProperties"].emplace_array();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto& temp=arr_ixxluvk[WYdxXmB].emplace_object();
            return serialize_struct(temp, pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pQueueFamilyPropertyCount"].as_array().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].as_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(value_to<int>(arr_tzRlmPf[cPKCUxv]));}();
        }
        }();
[&](){
            if (json["pQueueFamilyProperties"].as_array().size()==0){
                pQueueFamilyProperties=NULL;
            return; }
        auto& arr_ixxluvk=json["pQueueFamilyProperties"].as_array();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto& temp=arr_ixxluvk[WYdxXmB].as_object();
            deserialize_struct(temp,pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceQueueFamilyProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMemoryProperties( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceMemoryProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEMEMORYPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=boost::json::array();
            return; }
        auto& arr_cVJWqPt=json["pMemoryProperties"].emplace_array();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto& temp=arr_cVJWqPt[iqfYjRc].emplace_object();
            return serialize_struct(temp, pMemoryProperties[iqfYjRc]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEMEMORYPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pMemoryProperties"].as_array().size()==0){
                pMemoryProperties=NULL;
            return; }
        auto& arr_cVJWqPt=json["pMemoryProperties"].as_array();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto& temp=arr_cVJWqPt[iqfYjRc].as_object();
            deserialize_struct(temp,pMemoryProperties[iqfYjRc]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceMemoryProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFeatures( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFeatures\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEFEATURES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=boost::json::array();
            return; }
        auto& arr_MNJcbZO=json["pFeatures"].emplace_array();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto& temp=arr_MNJcbZO[IqPoadP].emplace_object();
            return serialize_struct(temp, pFeatures[IqPoadP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFEATURES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pFeatures"].as_array().size()==0){
                pFeatures=NULL;
            return; }
        auto& arr_MNJcbZO=json["pFeatures"].as_array();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto& temp=arr_MNJcbZO[IqPoadP].as_object();
            deserialize_struct(temp,pFeatures[IqPoadP]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFeatures...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFormatProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEFORMATPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=boost::json::array();
            return; }
        auto& arr_ktGodop=json["pFormatProperties"].emplace_array();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto& temp=arr_ktGodop[CLkwuSw].emplace_object();
            return serialize_struct(temp, pFormatProperties[CLkwuSw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFORMATPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){
            if (json["pFormatProperties"].as_array().size()==0){
                pFormatProperties=NULL;
            return; }
        auto& arr_ktGodop=json["pFormatProperties"].as_array();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto& temp=arr_ktGodop[CLkwuSw].as_object();
            deserialize_struct(temp,pFormatProperties[CLkwuSw]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFormatProperties...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceImageFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceImageFormatProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }
        auto& arr_sBgMBXU=json["pImageFormatProperties"].emplace_array();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto& temp=arr_sBgMBXU[hhYjZOs].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){[&](){int temp_bMZuPlo;[&](){temp_bMZuPlo=static_cast<int>(value_to<int>(json["type"]));}();type=(VkImageType)temp_bMZuPlo;}();}();
[&](){[&](){int temp_PtqdPDE;[&](){temp_PtqdPDE=static_cast<int>(value_to<int>(json["tiling"]));}();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
[&](){[&](){int temp_sXuQFYv;[&](){temp_sXuQFYv=static_cast<int>(value_to<int>(json["usage"]));}();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
[&](){[&](){int temp_LpOHWxp;[&](){temp_LpOHWxp=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
[&](){
            if (json["pImageFormatProperties"].as_array().size()==0){
                pImageFormatProperties=NULL;
            return; }
        auto& arr_sBgMBXU=json["pImageFormatProperties"].as_array();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto& temp=arr_sBgMBXU[hhYjZOs].as_object();
            deserialize_struct(temp,pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_VDkKjCy;[&](){temp_VDkKjCy=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_VDkKjCy;}();}();

debug_printf("Ending vkGetPhysicalDeviceImageFormatProperties...\n");
debug_printf("Return value of vkGetPhysicalDeviceImageFormatProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDevice( VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice ){
//Will only be called by the client
debug_printf("Executing vkCreateDevice\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEDEVICE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_TuuJAwt=json["pCreateInfo"].emplace_array();
        for(int Ktbkccz=0; Ktbkccz < 1; Ktbkccz++){
            [&](){
            auto& temp=arr_TuuJAwt[Ktbkccz].emplace_object();
            return serialize_struct(temp, pCreateInfo[Ktbkccz]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDevice==NULL){
                json["pDevice"]=boost::json::array();
            return; }
        auto& arr_WTIobJE=json["pDevice"].emplace_array();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){serialize_VkDevice(arr_WTIobJE[okBORdn],pDevice[okBORdn]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEVICE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();


[&](){
            if (json["pDevice"].as_array().size()==0){
                pDevice=NULL;
            return; }
        auto& arr_WTIobJE=json["pDevice"].as_array();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){deserialize_VkDevice(arr_WTIobJE[okBORdn], pDevice[okBORdn]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_vNoBwLT;[&](){temp_vNoBwLT=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_vNoBwLT;}();}();
handle_to_parent_handle_struct[(uintptr_t)(*pDevice)]={.instance=NULL,.device=(*pDevice) };
registerDevice(*pDevice,physicalDevice);

debug_printf("Ending vkCreateDevice...\n");
debug_printf("Return value of vkCreateDevice is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDevice( VkDevice device, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDevice\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYDEVICE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEVICE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


debug_printf("Ending vkDestroyDevice...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateInstanceVersion( uint32_t* pApiVersion ){
//Will only be called by the client
debug_printf("Executing vkEnumerateInstanceVersion\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKENUMERATEINSTANCEVERSION;
    
parent_json["instance"]=(uintptr_t)NULL;
{
[&](){
            if (pApiVersion==NULL){
                json["pApiVersion"]=boost::json::array();
            return; }
        auto& arr_qBCKjKo=json["pApiVersion"].emplace_array();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){arr_qBCKjKo[KJjQFCs]=pApiVersion[KJjQFCs];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEINSTANCEVERSION):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){
            if (json["pApiVersion"].as_array().size()==0){
                pApiVersion=NULL;
            return; }
        auto& arr_qBCKjKo=json["pApiVersion"].as_array();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){pApiVersion[KJjQFCs]=static_cast<uint32_t>(value_to<int>(arr_qBCKjKo[KJjQFCs]));}();
        }
        }();
VkResult result;
[&](){[&](){int temp_WToUkej;[&](){temp_WToUkej=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_WToUkej;}();}();

debug_printf("Ending vkEnumerateInstanceVersion...\n");
debug_printf("Return value of vkEnumerateInstanceVersion is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateInstanceLayerProperties( uint32_t* pPropertyCount, VkLayerProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateInstanceLayerProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKENUMERATEINSTANCELAYERPROPERTIES;
    
parent_json["instance"]=(uintptr_t)NULL;
{
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_AKGITwD=json["pProperties"].emplace_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].emplace_object();
            return serialize_struct(temp, pProperties[AVcpYdO]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEINSTANCELAYERPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_AKGITwD=json["pProperties"].as_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].as_object();
            deserialize_struct(temp,pProperties[AVcpYdO]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_lTPioWe;[&](){temp_lTPioWe=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_lTPioWe;}();}();

debug_printf("Ending vkEnumerateInstanceLayerProperties...\n");
debug_printf("Return value of vkEnumerateInstanceLayerProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateInstanceExtensionProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKENUMERATEINSTANCEEXTENSIONPROPERTIES;
    
parent_json["instance"]=(uintptr_t)NULL;

        if(pProperties==NULL){
            const uint32_t DEFAULT_PROPERTIES_LENGTH=100;
            pProperties=(VkExtensionProperties*)malloc(DEFAULT_PROPERTIES_LENGTH*sizeof(VkExtensionProperties));
            *pPropertyCount=DEFAULT_PROPERTIES_LENGTH;
            
            for (uint32_t i=0; i<*pPropertyCount; i++){
                pProperties[i]=VkExtensionProperties();
            }
        }
        
        uint32_t len_of_properties_array=*pPropertyCount;
        
{
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=boost::json::array();
            return; }
        auto& arr_xWfwWBl=json["pLayerName"].emplace_array();
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=pLayerName[EYxuOlw];}();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_yJzeHZb=json["pProperties"].emplace_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].emplace_object();
            return serialize_struct(temp, pProperties[oiKhvHw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEINSTANCEEXTENSIONPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}

[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_yJzeHZb=json["pProperties"].as_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].as_object();
            deserialize_struct(temp,pProperties[oiKhvHw]);
            }();
        }
        }();

        std::set<std::string> propertiesSet;
        for(uint32_t i=0; i<*pPropertyCount; i++){
            propertiesSet.insert(std::string(pProperties[i].extensionName));
        }
        

            #ifdef VK_USE_PLATFORM_XLIB_KHR
                if(!propertiesSet.contains(std::string(VK_KHR_XLIB_SURFACE_EXTENSION_NAME))){
                    if (*pPropertyCount<len_of_properties_array){
                        auto property=VkExtensionProperties();
                        strcpy(property.extensionName,VK_KHR_XLIB_SURFACE_EXTENSION_NAME);
                        property.specVersion=VK_KHR_XLIB_SURFACE_SPEC_VERSION;
                        pProperties[*pPropertyCount]=property;
                        *pPropertyCount=*pPropertyCount+1;
                    }
                }
            #endif
            

            #ifdef VK_USE_PLATFORM_XCB_KHR
                if(!propertiesSet.contains(std::string(VK_KHR_XCB_SURFACE_EXTENSION_NAME))){
                    if (*pPropertyCount<len_of_properties_array){
                        auto property=VkExtensionProperties();
                        strcpy(property.extensionName,VK_KHR_XCB_SURFACE_EXTENSION_NAME);
                        property.specVersion=VK_KHR_XCB_SURFACE_SPEC_VERSION;
                        pProperties[*pPropertyCount]=property;
                        *pPropertyCount=*pPropertyCount+1;
                    }
                }
            #endif
            
VkResult result;
[&](){[&](){int temp_TPUBHmQ;[&](){temp_TPUBHmQ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_TPUBHmQ;}();}();

debug_printf("Ending vkEnumerateInstanceExtensionProperties...\n");
debug_printf("Return value of vkEnumerateInstanceExtensionProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateDeviceLayerProperties( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateDeviceLayerProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKENUMERATEDEVICELAYERPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_AKGITwD=json["pProperties"].emplace_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].emplace_object();
            return serialize_struct(temp, pProperties[AVcpYdO]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEDEVICELAYERPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_AKGITwD=json["pProperties"].as_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].as_object();
            deserialize_struct(temp,pProperties[AVcpYdO]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_wGlyXuH;[&](){temp_wGlyXuH=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_wGlyXuH;}();}();

debug_printf("Ending vkEnumerateDeviceLayerProperties...\n");
debug_printf("Return value of vkEnumerateDeviceLayerProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateDeviceExtensionProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKENUMERATEDEVICEEXTENSIONPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=boost::json::array();
            return; }
        auto& arr_xWfwWBl=json["pLayerName"].emplace_array();
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=pLayerName[EYxuOlw];}();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_yJzeHZb=json["pProperties"].emplace_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].emplace_object();
            return serialize_struct(temp, pProperties[oiKhvHw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEDEVICEEXTENSIONPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_yJzeHZb=json["pProperties"].as_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].as_object();
            deserialize_struct(temp,pProperties[oiKhvHw]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_PXcskQJ;[&](){temp_PXcskQJ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_PXcskQJ;}();}();

debug_printf("Ending vkEnumerateDeviceExtensionProperties...\n");
debug_printf("Return value of vkEnumerateDeviceExtensionProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceQueue( VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceQueue\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEQUEUE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){json["queueIndex"]=queueIndex;}();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=boost::json::array();
            return; }
        auto& arr_rYZbcEA=json["pQueue"].emplace_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEQUEUE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
[&](){queueIndex=static_cast<uint32_t>(value_to<int>(json["queueIndex"]));}();
[&](){
            if (json["pQueue"].as_array().size()==0){
                pQueue=NULL;
            return; }
        auto& arr_rYZbcEA=json["pQueue"].as_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

                if (pQueue!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pQueue[i])]=parent;
                    }
                }
                

debug_printf("Ending vkGetDeviceQueue...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSubmit( VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkQueueSubmit\n");
MemoryMapLock.lock_shared();

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKQUEUESUBMIT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=submitCount;}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=boost::json::array();
            return; }
        auto& arr_kYcwgKD=json["pSubmits"].emplace_array();
        for(int FrUhwZA=0; FrUhwZA < submitCount; FrUhwZA++){
            [&](){
            auto& temp=arr_kYcwgKD[FrUhwZA].emplace_object();
            return serialize_struct(temp, pSubmits[FrUhwZA]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();
}
SyncAll();


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUESUBMIT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){submitCount=static_cast<uint32_t>(value_to<int>(json["submitCount"]));}();

[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_tvMipOm;[&](){temp_tvMipOm=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_tvMipOm;}();}();

MemoryMapLock.unlock_shared();
debug_printf("Ending vkQueueSubmit...\n");
debug_printf("Return value of vkQueueSubmit is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueueWaitIdle( VkQueue queue ){
//Will only be called by the client
debug_printf("Executing vkQueueWaitIdle\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKQUEUEWAITIDLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEWAITIDLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();
VkResult result;
[&](){[&](){int temp_DbglyCZ;[&](){temp_DbglyCZ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_DbglyCZ;}();}();

debug_printf("Ending vkQueueWaitIdle...\n");
debug_printf("Return value of vkQueueWaitIdle is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDeviceWaitIdle( VkDevice device ){
//Will only be called by the client
debug_printf("Executing vkDeviceWaitIdle\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDEVICEWAITIDLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEVICEWAITIDLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
VkResult result;
[&](){[&](){int temp_iRPdwrC;[&](){temp_iRPdwrC=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_iRPdwrC;}();}();

waitForCounterIdle(device);
debug_printf("Ending vkDeviceWaitIdle...\n");
debug_printf("Return value of vkDeviceWaitIdle is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAllocateMemory( VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory ){
//Will only be called by the client
debug_printf("Executing vkAllocateMemory\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKALLOCATEMEMORY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }
        auto& arr_NGCHnPz=json["pAllocateInfo"].emplace_array();
        for(int MAXIAGO=0; MAXIAGO < 1; MAXIAGO++){
            [&](){
            auto& temp=arr_NGCHnPz[MAXIAGO].emplace_object();
            return serialize_struct(temp, pAllocateInfo[MAXIAGO]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMemory==NULL){
                json["pMemory"]=boost::json::array();
            return; }
        auto& arr_JqUSUSb=json["pMemory"].emplace_array();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){serialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV],pMemory[iFmVAsV]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKALLOCATEMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pMemory"].as_array().size()==0){
                pMemory=NULL;
            return; }
        auto& arr_JqUSUSb=json["pMemory"].as_array();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){deserialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV], pMemory[iFmVAsV]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_NOgQUZs;[&](){temp_NOgQUZs=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_NOgQUZs;}();}();
registerDeviceMemory(*pMemory, pAllocateInfo->allocationSize);

debug_printf("Ending vkAllocateMemory...\n");
debug_printf("Return value of vkAllocateMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkFreeMemory( VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkFreeMemory\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKFREEMEMORY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}
vkUnmapMemory(device,memory);


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFREEMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();


debug_printf("Ending vkFreeMemory...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkMapMemory( VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData ){
//Will only be called by the client
debug_printf("Executing vkMapMemory\n");
MemoryMapLock.lock();

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKMAPMEMORY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        

        if (size==VK_WHOLE_SIZE){
            size=devicememory_to_size[(uintptr_t)memory]-offset;
        }
        
{
*ppData=NULL;
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }
        auto& arr_syvZTtN=json["ppData"].emplace_array();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (ppData[weOJAdg]==NULL){
                arr_syvZTtN[weOJAdg]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[weOJAdg]))==NULL){
                arr_syvZTtN[weOJAdg]=boost::json::array();
            return; }
        auto& arr_yHvgdEb=arr_syvZTtN[weOJAdg].emplace_array();
        for(int vgxltbA=0; vgxltbA < size; vgxltbA++){
            [&](){arr_yHvgdEb[vgxltbA]=((char*)(ppData[weOJAdg]))[vgxltbA];}();
        }
        }();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMAPMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){uint64_t temp_PlNcOBd;[&](){temp_PlNcOBd=static_cast<uint64_t>(value_to<int>(json["size"]));}();size=(VkDeviceSize)temp_PlNcOBd;}();
[&](){[&](){int temp_UEEqVUK;[&](){temp_UEEqVUK=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkMemoryMapFlags)temp_UEEqVUK;}();}();
[&](){
            if (json["ppData"].as_array().size()==0){
                ppData=NULL;
            return; }
        auto& arr_syvZTtN=json["ppData"].as_array();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (arr_syvZTtN[weOJAdg].as_array().size()==0){
                ppData[weOJAdg]=NULL;
            return; }char* temp_syvZTtN;[&](){
            if (arr_syvZTtN[weOJAdg].as_array().size()==0){
                temp_syvZTtN=NULL;
            return; }
        auto& arr_yHvgdEb=arr_syvZTtN[weOJAdg].as_array();
        for(int vgxltbA=0; vgxltbA < size; vgxltbA++){
            [&](){temp_syvZTtN[vgxltbA]=static_cast<char>(value_to<int>(arr_yHvgdEb[vgxltbA]));}();
        }
        }();ppData[weOJAdg]=temp_syvZTtN;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_VmUJgEr;[&](){temp_VmUJgEr=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_VmUJgEr;}();}();

        boost::json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, memory);
        
        auto server_memory=value_to<uintptr_t>(server_memory_json); 
        
        *ppData=registerDeviceMemoryMap(server_memory, memory,size,*ppData,value_to<uintptr_t>(json["mem"]));
        
        #ifndef CLIENT
            json["mem"]=value_to<uintptr_t>(json["mem"]);
        #endif
        
MemoryMapLock.unlock();
debug_printf("Ending vkMapMemory...\n");
debug_printf("Return value of vkMapMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkUnmapMemory( VkDevice device, VkDeviceMemory memory ){
//Will only be called by the client
debug_printf("Executing vkUnmapMemory\n");
MemoryMapLock.lock();

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKUNMAPMEMORY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
}
deregisterDeviceMemoryMap(memory);

        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUNMAPMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();

MemoryMapLock.unlock();
debug_printf("Ending vkUnmapMemory...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkFlushMappedMemoryRanges( VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges ){
//Will only be called by the client
debug_printf("Executing vkFlushMappedMemoryRanges\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKFLUSHMAPPEDMEMORYRANGES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=memoryRangeCount;}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=boost::json::array();
            return; }
        auto& arr_sKDZFVw=json["pMemoryRanges"].emplace_array();
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto& temp=arr_sKDZFVw[GdhGpVL].emplace_object();
            return serialize_struct(temp, pMemoryRanges[GdhGpVL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFLUSHMAPPEDMEMORYRANGES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){memoryRangeCount=static_cast<uint32_t>(value_to<int>(json["memoryRangeCount"]));}();

VkResult result;
[&](){[&](){int temp_wEJNmiO;[&](){temp_wEJNmiO=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_wEJNmiO;}();}();

debug_printf("Ending vkFlushMappedMemoryRanges...\n");
debug_printf("Return value of vkFlushMappedMemoryRanges is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkInvalidateMappedMemoryRanges( VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges ){
//Will only be called by the client
debug_printf("Executing vkInvalidateMappedMemoryRanges\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKINVALIDATEMAPPEDMEMORYRANGES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=memoryRangeCount;}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=boost::json::array();
            return; }
        auto& arr_sKDZFVw=json["pMemoryRanges"].emplace_array();
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto& temp=arr_sKDZFVw[GdhGpVL].emplace_object();
            return serialize_struct(temp, pMemoryRanges[GdhGpVL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKINVALIDATEMAPPEDMEMORYRANGES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){memoryRangeCount=static_cast<uint32_t>(value_to<int>(json["memoryRangeCount"]));}();

VkResult result;
[&](){[&](){int temp_XdYFFJw;[&](){temp_XdYFFJw=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_XdYFFJw;}();}();

debug_printf("Ending vkInvalidateMappedMemoryRanges...\n");
debug_printf("Return value of vkInvalidateMappedMemoryRanges is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceMemoryCommitment( VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceMemoryCommitment\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEMEMORYCOMMITMENT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pCommittedMemoryInBytes==NULL){
                json["pCommittedMemoryInBytes"]=boost::json::array();
            return; }
        auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].emplace_array();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){[&](){arr_BkHcKeY[iEYXrVv]=pCommittedMemoryInBytes[iEYXrVv];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEMEMORYCOMMITMENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){
            if (json["pCommittedMemoryInBytes"].as_array().size()==0){
                pCommittedMemoryInBytes=NULL;
            return; }
        auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].as_array();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){uint64_t temp_BkHcKeY;[&](){temp_BkHcKeY=static_cast<uint64_t>(value_to<int>(arr_BkHcKeY[iEYXrVv]));}();pCommittedMemoryInBytes[iEYXrVv]=(VkDeviceSize)temp_BkHcKeY;}();
        }
        }();

debug_printf("Ending vkGetDeviceMemoryCommitment...\n");
}
__attribute__((visibility ("hidden"))) void vkGetBufferMemoryRequirements( VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetBufferMemoryRequirements\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETBUFFERMEMORYREQUIREMENTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_qQjUyYD=json["pMemoryRequirements"].emplace_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[VeirrNu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFERMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_qQjUyYD=json["pMemoryRequirements"].as_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].as_object();
            deserialize_struct(temp,pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

debug_printf("Ending vkGetBufferMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindBufferMemory( VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset ){
//Will only be called by the client
debug_printf("Executing vkBindBufferMemory\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBINDBUFFERMEMORY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=memoryOffset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDBUFFERMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){uint64_t temp_yVqWYJm;[&](){temp_yVqWYJm=static_cast<uint64_t>(value_to<int>(json["memoryOffset"]));}();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();
VkResult result;
[&](){[&](){int temp_ckUKYFd;[&](){temp_ckUKYFd=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_ckUKYFd;}();}();

debug_printf("Ending vkBindBufferMemory...\n");
debug_printf("Return value of vkBindBufferMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetImageMemoryRequirements( VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageMemoryRequirements\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGEMEMORYREQUIREMENTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_qQjUyYD=json["pMemoryRequirements"].emplace_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[VeirrNu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_qQjUyYD=json["pMemoryRequirements"].as_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].as_object();
            deserialize_struct(temp,pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

debug_printf("Ending vkGetImageMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindImageMemory( VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset ){
//Will only be called by the client
debug_printf("Executing vkBindImageMemory\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBINDIMAGEMEMORY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=memoryOffset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDIMAGEMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){uint64_t temp_yVqWYJm;[&](){temp_yVqWYJm=static_cast<uint64_t>(value_to<int>(json["memoryOffset"]));}();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();
VkResult result;
[&](){[&](){int temp_JdfkAvP;[&](){temp_JdfkAvP=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_JdfkAvP;}();}();

debug_printf("Ending vkBindImageMemory...\n");
debug_printf("Return value of vkBindImageMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetImageSparseMemoryRequirements( VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageSparseMemoryRequirements\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGESPARSEMEMORYREQUIREMENTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].emplace_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].emplace_array();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto& temp=arr_gCgbiZM[HKRWUBR].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESPARSEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){
            if (json["pSparseMemoryRequirementCount"].as_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(value_to<int>(arr_QpqRnvg[pFgmjla]));}();
        }
        }();
[&](){
            if (json["pSparseMemoryRequirements"].as_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }
        auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].as_array();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto& temp=arr_gCgbiZM[HKRWUBR].as_object();
            deserialize_struct(temp,pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSparseMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceSparseImageFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSparseImageFormatProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_jINYdYP=json["pProperties"].emplace_array();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto& temp=arr_jINYdYP[BOLcXca].emplace_object();
            return serialize_struct(temp, pProperties[BOLcXca]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){[&](){int temp_bMZuPlo;[&](){temp_bMZuPlo=static_cast<int>(value_to<int>(json["type"]));}();type=(VkImageType)temp_bMZuPlo;}();}();
[&](){[&](){int temp_lbKgbKj;[&](){temp_lbKgbKj=static_cast<int>(value_to<int>(json["samples"]));}();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
[&](){[&](){int temp_sXuQFYv;[&](){temp_sXuQFYv=static_cast<int>(value_to<int>(json["usage"]));}();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
[&](){[&](){int temp_PtqdPDE;[&](){temp_PtqdPDE=static_cast<int>(value_to<int>(json["tiling"]));}();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_jINYdYP=json["pProperties"].as_array();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto& temp=arr_jINYdYP[BOLcXca].as_object();
            deserialize_struct(temp,pProperties[BOLcXca]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceSparseImageFormatProperties...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkQueueBindSparse( VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkQueueBindSparse\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKQUEUEBINDSPARSE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfo==NULL){
                json["pBindInfo"]=boost::json::array();
            return; }
        auto& arr_eUGJCxJ=json["pBindInfo"].emplace_array();
        for(int ujBkVap=0; ujBkVap < bindInfoCount; ujBkVap++){
            [&](){
            auto& temp=arr_eUGJCxJ[ujBkVap].emplace_object();
            return serialize_struct(temp, pBindInfo[ujBkVap]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEBINDSPARSE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){bindInfoCount=static_cast<uint32_t>(value_to<int>(json["bindInfoCount"]));}();

[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_buDedpb;[&](){temp_buDedpb=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_buDedpb;}();}();

debug_printf("Ending vkQueueBindSparse...\n");
debug_printf("Return value of vkQueueBindSparse is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateFence( VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence ){
//Will only be called by the client
debug_printf("Executing vkCreateFence\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEFENCE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_qbBwXza=json["pCreateInfo"].emplace_array();
        for(int kPSKeJY=0; kPSKeJY < 1; kPSKeJY++){
            [&](){
            auto& temp=arr_qbBwXza[kPSKeJY].emplace_object();
            return serialize_struct(temp, pCreateInfo[kPSKeJY]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }
        auto& arr_SJohVKr=json["pFence"].emplace_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEFENCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFence"].as_array().size()==0){
                pFence=NULL;
            return; }
        auto& arr_SJohVKr=json["pFence"].as_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_gEfSkUD;[&](){temp_gEfSkUD=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_gEfSkUD;}();}();

                if (pFence!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pFence[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateFence...\n");
debug_printf("Return value of vkCreateFence is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyFence( VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyFence\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYFENCE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYFENCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFence(json["fence"], fence);}();


debug_printf("Ending vkDestroyFence...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkResetFences( VkDevice device, uint32_t fenceCount, const VkFence* pFences ){
//Will only be called by the client
debug_printf("Executing vkResetFences\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRESETFENCES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=fenceCount;}();
[&](){
            if (pFences==NULL){
                json["pFences"]=boost::json::array();
            return; }
        auto& arr_UUllwqV=json["pFences"].emplace_array();
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETFENCES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){fenceCount=static_cast<uint32_t>(value_to<int>(json["fenceCount"]));}();

VkResult result;
[&](){[&](){int temp_bTybKmM;[&](){temp_bTybKmM=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_bTybKmM;}();}();

debug_printf("Ending vkResetFences...\n");
debug_printf("Return value of vkResetFences is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetFenceStatus( VkDevice device, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkGetFenceStatus\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETFENCESTATUS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETFENCESTATUS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_KfSFzfG;[&](){temp_KfSFzfG=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_KfSFzfG;}();}();

debug_printf("Ending vkGetFenceStatus...\n");
debug_printf("Return value of vkGetFenceStatus is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkWaitForFences( VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout ){
//Will only be called by the client
debug_printf("Executing vkWaitForFences\n");
MemoryMapLock.lock_shared();

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKWAITFORFENCES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=fenceCount;}();
[&](){
            if (pFences==NULL){
                json["pFences"]=boost::json::array();
            return; }
        auto& arr_UUllwqV=json["pFences"].emplace_array();
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        }();
[&](){[&](){json["waitAll"]=waitAll;}();}();
[&](){json["timeout"]=timeout;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWAITFORFENCES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){fenceCount=static_cast<uint32_t>(value_to<int>(json["fenceCount"]));}();

[&](){uint32_t temp_pqKsrTL;[&](){temp_pqKsrTL=static_cast<uint32_t>(value_to<int>(json["waitAll"]));}();waitAll=(VkBool32)temp_pqKsrTL;}();
[&](){timeout=static_cast<uint64_t>(value_to<int>(json["timeout"]));}();
VkResult result;
[&](){[&](){int temp_UfhEDZO;[&](){temp_UfhEDZO=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_UfhEDZO;}();}();

MemoryMapLock.unlock_shared();
debug_printf("Ending vkWaitForFences...\n");
debug_printf("Return value of vkWaitForFences is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSemaphore( VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore ){
//Will only be called by the client
debug_printf("Executing vkCreateSemaphore\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATESEMAPHORE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_hQVwpIP=json["pCreateInfo"].emplace_array();
        for(int TzTYDbe=0; TzTYDbe < 1; TzTYDbe++){
            [&](){
            auto& temp=arr_hQVwpIP[TzTYDbe].emplace_object();
            return serialize_struct(temp, pCreateInfo[TzTYDbe]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSemaphore==NULL){
                json["pSemaphore"]=boost::json::array();
            return; }
        auto& arr_rvNHvxY=json["pSemaphore"].emplace_array();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){serialize_VkSemaphore(arr_rvNHvxY[lrrAvof],pSemaphore[lrrAvof]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESEMAPHORE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSemaphore"].as_array().size()==0){
                pSemaphore=NULL;
            return; }
        auto& arr_rvNHvxY=json["pSemaphore"].as_array();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){deserialize_VkSemaphore(arr_rvNHvxY[lrrAvof], pSemaphore[lrrAvof]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_whDfYlO;[&](){temp_whDfYlO=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_whDfYlO;}();}();

                if (pSemaphore!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSemaphore[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSemaphore...\n");
debug_printf("Return value of vkCreateSemaphore is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySemaphore( VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySemaphore\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYSEMAPHORE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSEMAPHORE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();


debug_printf("Ending vkDestroySemaphore...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateEvent( VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent ){
//Will only be called by the client
debug_printf("Executing vkCreateEvent\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEEVENT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_wqWioqo=json["pCreateInfo"].emplace_array();
        for(int ThfQKZW=0; ThfQKZW < 1; ThfQKZW++){
            [&](){
            auto& temp=arr_wqWioqo[ThfQKZW].emplace_object();
            return serialize_struct(temp, pCreateInfo[ThfQKZW]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pEvent==NULL){
                json["pEvent"]=boost::json::array();
            return; }
        auto& arr_edObbrc=json["pEvent"].emplace_array();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){serialize_VkEvent(arr_edObbrc[vdhtBcH],pEvent[vdhtBcH]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pEvent"].as_array().size()==0){
                pEvent=NULL;
            return; }
        auto& arr_edObbrc=json["pEvent"].as_array();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){deserialize_VkEvent(arr_edObbrc[vdhtBcH], pEvent[vdhtBcH]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_OjsPcKb;[&](){temp_OjsPcKb=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_OjsPcKb;}();}();

                if (pEvent!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pEvent[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateEvent...\n");
debug_printf("Return value of vkCreateEvent is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyEvent( VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyEvent\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYEVENT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();


debug_printf("Ending vkDestroyEvent...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetEventStatus( VkDevice device, VkEvent event ){
//Will only be called by the client
debug_printf("Executing vkGetEventStatus\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETEVENTSTATUS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETEVENTSTATUS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();
VkResult result;
[&](){[&](){int temp_XMFeSCI;[&](){temp_XMFeSCI=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_XMFeSCI;}();}();

debug_printf("Ending vkGetEventStatus...\n");
debug_printf("Return value of vkGetEventStatus is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetEvent( VkDevice device, VkEvent event ){
//Will only be called by the client
debug_printf("Executing vkSetEvent\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKSETEVENT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();
VkResult result;
[&](){[&](){int temp_fPoYzYF;[&](){temp_fPoYzYF=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_fPoYzYF;}();}();

debug_printf("Ending vkSetEvent...\n");
debug_printf("Return value of vkSetEvent is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkResetEvent( VkDevice device, VkEvent event ){
//Will only be called by the client
debug_printf("Executing vkResetEvent\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRESETEVENT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();
VkResult result;
[&](){[&](){int temp_OJNFZGf;[&](){temp_OJNFZGf=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_OJNFZGf;}();}();

debug_printf("Ending vkResetEvent...\n");
debug_printf("Return value of vkResetEvent is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateQueryPool( VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool ){
//Will only be called by the client
debug_printf("Executing vkCreateQueryPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEQUERYPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_AOuTZQo=json["pCreateInfo"].emplace_array();
        for(int SvYxRUl=0; SvYxRUl < 1; SvYxRUl++){
            [&](){
            auto& temp=arr_AOuTZQo[SvYxRUl].emplace_object();
            return serialize_struct(temp, pCreateInfo[SvYxRUl]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pQueryPool==NULL){
                json["pQueryPool"]=boost::json::array();
            return; }
        auto& arr_uEjfPmz=json["pQueryPool"].emplace_array();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){serialize_VkQueryPool(arr_uEjfPmz[HoCFbNC],pQueryPool[HoCFbNC]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pQueryPool"].as_array().size()==0){
                pQueryPool=NULL;
            return; }
        auto& arr_uEjfPmz=json["pQueryPool"].as_array();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){deserialize_VkQueryPool(arr_uEjfPmz[HoCFbNC], pQueryPool[HoCFbNC]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_UuzdUbG;[&](){temp_UuzdUbG=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_UuzdUbG;}();}();

                if (pQueryPool!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pQueryPool[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateQueryPool...\n");
debug_printf("Return value of vkCreateQueryPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyQueryPool( VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyQueryPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYQUERYPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();


debug_printf("Ending vkDestroyQueryPool...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetQueryPoolResults( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags ){
//Will only be called by the client
debug_printf("Executing vkGetQueryPoolResults\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETQUERYPOOLRESULTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
[&](){[&](){json["stride"]=stride;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETQUERYPOOLRESULTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();
[&](){queryCount=static_cast<uint32_t>(value_to<int>(json["queryCount"]));}();
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();
[&](){uint64_t temp_fLSTSIg;[&](){temp_fLSTSIg=static_cast<uint64_t>(value_to<int>(json["stride"]));}();stride=(VkDeviceSize)temp_fLSTSIg;}();
[&](){[&](){int temp_jzLjdpj;[&](){temp_jzLjdpj=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();
VkResult result;
[&](){[&](){int temp_pIFNtPZ;[&](){temp_pIFNtPZ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_pIFNtPZ;}();}();

debug_printf("Ending vkGetQueryPoolResults...\n");
debug_printf("Return value of vkGetQueryPoolResults is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkResetQueryPool( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount ){
//Will only be called by the client
debug_printf("Executing vkResetQueryPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRESETQUERYPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();
[&](){queryCount=static_cast<uint32_t>(value_to<int>(json["queryCount"]));}();

debug_printf("Ending vkResetQueryPool...\n");
}
__attribute__((visibility ("hidden"))) void vkResetQueryPoolEXT( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount ){
return vkResetQueryPool(device, queryPool, firstQuery, queryCount);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateBuffer( VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer ){
//Will only be called by the client
debug_printf("Executing vkCreateBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_YapwvbL=json["pCreateInfo"].emplace_array();
        for(int XkzMxbI=0; XkzMxbI < 1; XkzMxbI++){
            [&](){
            auto& temp=arr_YapwvbL[XkzMxbI].emplace_object();
            return serialize_struct(temp, pCreateInfo[XkzMxbI]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pBuffer==NULL){
                json["pBuffer"]=boost::json::array();
            return; }
        auto& arr_cIWQmjJ=json["pBuffer"].emplace_array();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){serialize_VkBuffer(arr_cIWQmjJ[XGujqfM],pBuffer[XGujqfM]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pBuffer"].as_array().size()==0){
                pBuffer=NULL;
            return; }
        auto& arr_cIWQmjJ=json["pBuffer"].as_array();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){deserialize_VkBuffer(arr_cIWQmjJ[XGujqfM], pBuffer[XGujqfM]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ycNtJRl;[&](){temp_ycNtJRl=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_ycNtJRl;}();}();

                if (pBuffer!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pBuffer[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateBuffer...\n");
debug_printf("Return value of vkCreateBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyBuffer( VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();


debug_printf("Ending vkDestroyBuffer...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateBufferView( VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView ){
//Will only be called by the client
debug_printf("Executing vkCreateBufferView\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEBUFFERVIEW;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_SvrkcZl=json["pCreateInfo"].emplace_array();
        for(int cSdiRJj=0; cSdiRJj < 1; cSdiRJj++){
            [&](){
            auto& temp=arr_SvrkcZl[cSdiRJj].emplace_object();
            return serialize_struct(temp, pCreateInfo[cSdiRJj]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pView==NULL){
                json["pView"]=boost::json::array();
            return; }
        auto& arr_FoBLnTF=json["pView"].emplace_array();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){serialize_VkBufferView(arr_FoBLnTF[jjvyrOh],pView[jjvyrOh]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEBUFFERVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pView"].as_array().size()==0){
                pView=NULL;
            return; }
        auto& arr_FoBLnTF=json["pView"].as_array();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){deserialize_VkBufferView(arr_FoBLnTF[jjvyrOh], pView[jjvyrOh]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_HuOiorC;[&](){temp_HuOiorC=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_HuOiorC;}();}();

                if (pView!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pView[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateBufferView...\n");
debug_printf("Return value of vkCreateBufferView is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyBufferView( VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyBufferView\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYBUFFERVIEW;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBufferView(json["bufferView"],bufferView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYBUFFERVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBufferView(json["bufferView"], bufferView);}();


debug_printf("Ending vkDestroyBufferView...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateImage( VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage ){
//Will only be called by the client
debug_printf("Executing vkCreateImage\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEIMAGE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_TpPCnAy=json["pCreateInfo"].emplace_array();
        for(int pRwmwcF=0; pRwmwcF < 1; pRwmwcF++){
            [&](){
            auto& temp=arr_TpPCnAy[pRwmwcF].emplace_object();
            return serialize_struct(temp, pCreateInfo[pRwmwcF]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pImage==NULL){
                json["pImage"]=boost::json::array();
            return; }
        auto& arr_YGmHGGw=json["pImage"].emplace_array();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){serialize_VkImage(arr_YGmHGGw[Lmwohhp],pImage[Lmwohhp]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pImage"].as_array().size()==0){
                pImage=NULL;
            return; }
        auto& arr_YGmHGGw=json["pImage"].as_array();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){deserialize_VkImage(arr_YGmHGGw[Lmwohhp], pImage[Lmwohhp]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_YsNHIFZ;[&](){temp_YsNHIFZ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_YsNHIFZ;}();}();

                if (pImage!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pImage[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateImage...\n");
debug_printf("Return value of vkCreateImage is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyImage( VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyImage\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYIMAGE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();


debug_printf("Ending vkDestroyImage...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSubresourceLayout( VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout ){
//Will only be called by the client
debug_printf("Executing vkGetImageSubresourceLayout\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGESUBRESOURCELAYOUT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=boost::json::array();
            return; }
        auto& arr_bNRLlpX=json["pSubresource"].emplace_array();
        for(int trrMzRH=0; trrMzRH < 1; trrMzRH++){
            [&](){
            auto& temp=arr_bNRLlpX[trrMzRH].emplace_object();
            return serialize_struct(temp, pSubresource[trrMzRH]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }
        auto& arr_JAFsVvP=json["pLayout"].emplace_array();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto& temp=arr_JAFsVvP[jGHmbXh].emplace_object();
            return serialize_struct(temp, pLayout[jGHmbXh]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESUBRESOURCELAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();

[&](){
            if (json["pLayout"].as_array().size()==0){
                pLayout=NULL;
            return; }
        auto& arr_JAFsVvP=json["pLayout"].as_array();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto& temp=arr_JAFsVvP[jGHmbXh].as_object();
            deserialize_struct(temp,pLayout[jGHmbXh]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSubresourceLayout...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateImageView( VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView ){
//Will only be called by the client
debug_printf("Executing vkCreateImageView\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEIMAGEVIEW;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_TYfFrkP=json["pCreateInfo"].emplace_array();
        for(int HNOogbj=0; HNOogbj < 1; HNOogbj++){
            [&](){
            auto& temp=arr_TYfFrkP[HNOogbj].emplace_object();
            return serialize_struct(temp, pCreateInfo[HNOogbj]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pView==NULL){
                json["pView"]=boost::json::array();
            return; }
        auto& arr_GCwrdnq=json["pView"].emplace_array();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){serialize_VkImageView(arr_GCwrdnq[frngisT],pView[frngisT]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEIMAGEVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pView"].as_array().size()==0){
                pView=NULL;
            return; }
        auto& arr_GCwrdnq=json["pView"].as_array();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){deserialize_VkImageView(arr_GCwrdnq[frngisT], pView[frngisT]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_FVanQVO;[&](){temp_FVanQVO=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_FVanQVO;}();}();

                if (pView!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pView[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateImageView...\n");
debug_printf("Return value of vkCreateImageView is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyImageView( VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyImageView\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYIMAGEVIEW;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYIMAGEVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();


debug_printf("Ending vkDestroyImageView...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateShaderModule( VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule ){
//Will only be called by the client
debug_printf("Executing vkCreateShaderModule\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATESHADERMODULE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_iSZUILM=json["pCreateInfo"].emplace_array();
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto& temp=arr_iSZUILM[dKxemXH].emplace_object();
            return serialize_struct(temp, pCreateInfo[dKxemXH]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pShaderModule==NULL){
                json["pShaderModule"]=boost::json::array();
            return; }
        auto& arr_FaKUyxw=json["pShaderModule"].emplace_array();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){serialize_VkShaderModule(arr_FaKUyxw[EDcqjpD],pShaderModule[EDcqjpD]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESHADERMODULE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pShaderModule"].as_array().size()==0){
                pShaderModule=NULL;
            return; }
        auto& arr_FaKUyxw=json["pShaderModule"].as_array();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){deserialize_VkShaderModule(arr_FaKUyxw[EDcqjpD], pShaderModule[EDcqjpD]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_EVVmLiR;[&](){temp_EVVmLiR=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_EVVmLiR;}();}();

                if (pShaderModule!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pShaderModule[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateShaderModule...\n");
debug_printf("Return value of vkCreateShaderModule is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyShaderModule( VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyShaderModule\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYSHADERMODULE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSHADERMODULE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();


debug_printf("Ending vkDestroyShaderModule...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePipelineCache( VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache ){
//Will only be called by the client
debug_printf("Executing vkCreatePipelineCache\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEPIPELINECACHE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_wTXOYfz=json["pCreateInfo"].emplace_array();
        for(int iWdFkeP=0; iWdFkeP < 1; iWdFkeP++){
            [&](){
            auto& temp=arr_wTXOYfz[iWdFkeP].emplace_object();
            return serialize_struct(temp, pCreateInfo[iWdFkeP]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelineCache==NULL){
                json["pPipelineCache"]=boost::json::array();
            return; }
        auto& arr_mogHiwV=json["pPipelineCache"].emplace_array();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){serialize_VkPipelineCache(arr_mogHiwV[ndOADAA],pPipelineCache[ndOADAA]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEPIPELINECACHE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pPipelineCache"].as_array().size()==0){
                pPipelineCache=NULL;
            return; }
        auto& arr_mogHiwV=json["pPipelineCache"].as_array();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){deserialize_VkPipelineCache(arr_mogHiwV[ndOADAA], pPipelineCache[ndOADAA]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_aIGOsTa;[&](){temp_aIGOsTa=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_aIGOsTa;}();}();

                if (pPipelineCache!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelineCache[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreatePipelineCache...\n");
debug_printf("Return value of vkCreatePipelineCache is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyPipelineCache( VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPipelineCache\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYPIPELINECACHE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPIPELINECACHE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();


debug_printf("Ending vkDestroyPipelineCache...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineCacheData( VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineCacheData\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPIPELINECACHEDATA;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].emplace_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINECACHEDATA):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["pDataSize"].as_array().size()==0){
                pDataSize=NULL;
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].as_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){pDataSize[HCzJfGC]=static_cast<size_t>(value_to<int>(arr_Zcusyfw[HCzJfGC]));}();
        }
        }();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){temp_ZtBEjVJ[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_ZtBEjVJ;}();
VkResult result;
[&](){[&](){int temp_WFDLsZk;[&](){temp_WFDLsZk=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_WFDLsZk;}();}();

debug_printf("Ending vkGetPipelineCacheData...\n");
debug_printf("Return value of vkGetPipelineCacheData is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkMergePipelineCaches( VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches ){
//Will only be called by the client
debug_printf("Executing vkMergePipelineCaches\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKMERGEPIPELINECACHES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=srcCacheCount;}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=boost::json::array();
            return; }
        auto& arr_DmqfOOL=json["pSrcCaches"].emplace_array();
        for(int MmYiSON=0; MmYiSON < srcCacheCount; MmYiSON++){
            [&](){serialize_VkPipelineCache(arr_DmqfOOL[MmYiSON],pSrcCaches[MmYiSON]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMERGEPIPELINECACHES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["dstCache"], dstCache);}();
[&](){srcCacheCount=static_cast<uint32_t>(value_to<int>(json["srcCacheCount"]));}();

VkResult result;
[&](){[&](){int temp_ySMmqvV;[&](){temp_ySMmqvV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_ySMmqvV;}();}();

debug_printf("Ending vkMergePipelineCaches...\n");
debug_printf("Return value of vkMergePipelineCaches is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateGraphicsPipelines( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateGraphicsPipelines\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEGRAPHICSPIPELINES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_juQDvLY=json["pCreateInfos"].emplace_array();
        for(int wqGiARr=0; wqGiARr < createInfoCount; wqGiARr++){
            [&](){
            auto& temp=arr_juQDvLY[wqGiARr].emplace_object();
            return serialize_struct(temp, pCreateInfos[wqGiARr]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].emplace_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEGRAPHICSPIPELINES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();


[&](){
            if (json["pPipelines"].as_array().size()==0){
                pPipelines=NULL;
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].as_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_SJhAzEB;[&](){temp_SJhAzEB=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_SJhAzEB;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateGraphicsPipelines...\n");
debug_printf("Return value of vkCreateGraphicsPipelines is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateComputePipelines( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateComputePipelines\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATECOMPUTEPIPELINES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_eqiaDas=json["pCreateInfos"].emplace_array();
        for(int NsFJrJk=0; NsFJrJk < createInfoCount; NsFJrJk++){
            [&](){
            auto& temp=arr_eqiaDas[NsFJrJk].emplace_object();
            return serialize_struct(temp, pCreateInfos[NsFJrJk]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].emplace_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECOMPUTEPIPELINES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();


[&](){
            if (json["pPipelines"].as_array().size()==0){
                pPipelines=NULL;
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].as_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_tByZPwo;[&](){temp_tByZPwo=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_tByZPwo;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateComputePipelines...\n");
debug_printf("Return value of vkCreateComputePipelines is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI( VkDevice device, VkRenderPass renderpass, VkExtent2D* pMaxWorkgroupSize ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderpass"],renderpass);}();
[&](){
            if (pMaxWorkgroupSize==NULL){
                json["pMaxWorkgroupSize"]=boost::json::array();
            return; }
        auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].emplace_array();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto& temp=arr_QJRQgTX[WdbibPk].emplace_object();
            return serialize_struct(temp, pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkRenderPass(json["renderpass"], renderpass);}();
[&](){
            if (json["pMaxWorkgroupSize"].as_array().size()==0){
                pMaxWorkgroupSize=NULL;
            return; }
        auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].as_array();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto& temp=arr_QJRQgTX[WdbibPk].as_object();
            deserialize_struct(temp,pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_optavPF;[&](){temp_optavPF=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_optavPF;}();}();

debug_printf("Ending vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI...\n");
debug_printf("Return value of vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyPipeline( VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPipeline\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYPIPELINE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPIPELINE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();


debug_printf("Ending vkDestroyPipeline...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePipelineLayout( VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout ){
//Will only be called by the client
debug_printf("Executing vkCreatePipelineLayout\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEPIPELINELAYOUT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_iyZpkhm=json["pCreateInfo"].emplace_array();
        for(int AdWYCmn=0; AdWYCmn < 1; AdWYCmn++){
            [&](){
            auto& temp=arr_iyZpkhm[AdWYCmn].emplace_object();
            return serialize_struct(temp, pCreateInfo[AdWYCmn]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelineLayout==NULL){
                json["pPipelineLayout"]=boost::json::array();
            return; }
        auto& arr_NheDZho=json["pPipelineLayout"].emplace_array();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){serialize_VkPipelineLayout(arr_NheDZho[QNJuRwu],pPipelineLayout[QNJuRwu]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEPIPELINELAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pPipelineLayout"].as_array().size()==0){
                pPipelineLayout=NULL;
            return; }
        auto& arr_NheDZho=json["pPipelineLayout"].as_array();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){deserialize_VkPipelineLayout(arr_NheDZho[QNJuRwu], pPipelineLayout[QNJuRwu]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_YRBHkCw;[&](){temp_YRBHkCw=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_YRBHkCw;}();}();

                if (pPipelineLayout!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelineLayout[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreatePipelineLayout...\n");
debug_printf("Return value of vkCreatePipelineLayout is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyPipelineLayout( VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPipelineLayout\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYPIPELINELAYOUT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineLayout(json["pipelineLayout"],pipelineLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPIPELINELAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineLayout(json["pipelineLayout"], pipelineLayout);}();


debug_printf("Ending vkDestroyPipelineLayout...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSampler( VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler ){
//Will only be called by the client
debug_printf("Executing vkCreateSampler\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATESAMPLER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_xWlqrLm=json["pCreateInfo"].emplace_array();
        for(int yMsdBPh=0; yMsdBPh < 1; yMsdBPh++){
            [&](){
            auto& temp=arr_xWlqrLm[yMsdBPh].emplace_object();
            return serialize_struct(temp, pCreateInfo[yMsdBPh]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSampler==NULL){
                json["pSampler"]=boost::json::array();
            return; }
        auto& arr_nEROYrx=json["pSampler"].emplace_array();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){serialize_VkSampler(arr_nEROYrx[iCIaKrl],pSampler[iCIaKrl]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESAMPLER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSampler"].as_array().size()==0){
                pSampler=NULL;
            return; }
        auto& arr_nEROYrx=json["pSampler"].as_array();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){deserialize_VkSampler(arr_nEROYrx[iCIaKrl], pSampler[iCIaKrl]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_KIVoqao;[&](){temp_KIVoqao=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_KIVoqao;}();}();

                if (pSampler!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSampler[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSampler...\n");
debug_printf("Return value of vkCreateSampler is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySampler( VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySampler\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYSAMPLER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSampler(json["sampler"],sampler);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSAMPLER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSampler(json["sampler"], sampler);}();


debug_printf("Ending vkDestroySampler...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorSetLayout( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout ){
//Will only be called by the client
debug_printf("Executing vkCreateDescriptorSetLayout\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEDESCRIPTORSETLAYOUT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_dFRsqIW=json["pCreateInfo"].emplace_array();
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto& temp=arr_dFRsqIW[tUGauKK].emplace_object();
            return serialize_struct(temp, pCreateInfo[tUGauKK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSetLayout==NULL){
                json["pSetLayout"]=boost::json::array();
            return; }
        auto& arr_iCAhOCt=json["pSetLayout"].emplace_array();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){serialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl],pSetLayout[RWEcihl]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDESCRIPTORSETLAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSetLayout"].as_array().size()==0){
                pSetLayout=NULL;
            return; }
        auto& arr_iCAhOCt=json["pSetLayout"].as_array();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){deserialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl], pSetLayout[RWEcihl]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_zYbjCOm;[&](){temp_zYbjCOm=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_zYbjCOm;}();}();

                if (pSetLayout!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSetLayout[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDescriptorSetLayout...\n");
debug_printf("Return value of vkCreateDescriptorSetLayout is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorSetLayout( VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDescriptorSetLayout\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYDESCRIPTORSETLAYOUT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["descriptorSetLayout"],descriptorSetLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDESCRIPTORSETLAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSetLayout(json["descriptorSetLayout"], descriptorSetLayout);}();


debug_printf("Ending vkDestroyDescriptorSetLayout...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorPool( VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool ){
//Will only be called by the client
debug_printf("Executing vkCreateDescriptorPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEDESCRIPTORPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_fChMCRL=json["pCreateInfo"].emplace_array();
        for(int XgrRVVh=0; XgrRVVh < 1; XgrRVVh++){
            [&](){
            auto& temp=arr_fChMCRL[XgrRVVh].emplace_object();
            return serialize_struct(temp, pCreateInfo[XgrRVVh]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDescriptorPool==NULL){
                json["pDescriptorPool"]=boost::json::array();
            return; }
        auto& arr_zvYCksx=json["pDescriptorPool"].emplace_array();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){serialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo],pDescriptorPool[UuMLZWo]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDESCRIPTORPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pDescriptorPool"].as_array().size()==0){
                pDescriptorPool=NULL;
            return; }
        auto& arr_zvYCksx=json["pDescriptorPool"].as_array();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){deserialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo], pDescriptorPool[UuMLZWo]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_uixcqXC;[&](){temp_uixcqXC=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_uixcqXC;}();}();

                if (pDescriptorPool!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDescriptorPool[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDescriptorPool...\n");
debug_printf("Return value of vkCreateDescriptorPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorPool( VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDescriptorPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYDESCRIPTORPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDESCRIPTORPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();


debug_printf("Ending vkDestroyDescriptorPool...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkResetDescriptorPool( VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags ){
//Will only be called by the client
debug_printf("Executing vkResetDescriptorPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRESETDESCRIPTORPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETDESCRIPTORPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
[&](){[&](){int temp_zAsidUJ;[&](){temp_zAsidUJ=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkDescriptorPoolResetFlags)temp_zAsidUJ;}();}();
VkResult result;
[&](){[&](){int temp_eMIVKJe;[&](){temp_eMIVKJe=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_eMIVKJe;}();}();

debug_printf("Ending vkResetDescriptorPool...\n");
debug_printf("Return value of vkResetDescriptorPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAllocateDescriptorSets( VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets ){
//Will only be called by the client
debug_printf("Executing vkAllocateDescriptorSets\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKALLOCATEDESCRIPTORSETS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }
        auto& arr_yVqYJHW=json["pAllocateInfo"].emplace_array();
        for(int jTINpTr=0; jTINpTr < 1; jTINpTr++){
            [&](){
            auto& temp=arr_yVqYJHW[jTINpTr].emplace_object();
            return serialize_struct(temp, pAllocateInfo[jTINpTr]);
            }();
        }
        }();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }
        auto& arr_hwQSDBT=json["pDescriptorSets"].emplace_array();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){serialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY],pDescriptorSets[spXEqJY]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKALLOCATEDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pDescriptorSets"].as_array().size()==0){
                pDescriptorSets=NULL;
            return; }
        auto& arr_hwQSDBT=json["pDescriptorSets"].as_array();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){deserialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY], pDescriptorSets[spXEqJY]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_iCDmAqH;[&](){temp_iCDmAqH=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_iCDmAqH;}();}();

                if (pDescriptorSets!=NULL){
                    for (int i=0; i<pAllocateInfo->descriptorSetCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDescriptorSets[i])]=parent;
                    }
                }
                

debug_printf("Ending vkAllocateDescriptorSets...\n");
debug_printf("Return value of vkAllocateDescriptorSets is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkFreeDescriptorSets( VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets ){
//Will only be called by the client
debug_printf("Executing vkFreeDescriptorSets\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKFREEDESCRIPTORSETS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){json["descriptorSetCount"]=descriptorSetCount;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }
        auto& arr_JZNsxgK=json["pDescriptorSets"].emplace_array();
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFREEDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
[&](){descriptorSetCount=static_cast<uint32_t>(value_to<int>(json["descriptorSetCount"]));}();

VkResult result;
[&](){[&](){int temp_kwglIzF;[&](){temp_kwglIzF=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_kwglIzF;}();}();

debug_printf("Ending vkFreeDescriptorSets...\n");
debug_printf("Return value of vkFreeDescriptorSets is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkUpdateDescriptorSets( VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies ){
//Will only be called by the client
debug_printf("Executing vkUpdateDescriptorSets\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKUPDATEDESCRIPTORSETS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["descriptorWriteCount"]=descriptorWriteCount;}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=boost::json::array();
            return; }
        auto& arr_AuOrFWk=json["pDescriptorWrites"].emplace_array();
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto& temp=arr_AuOrFWk[qJACxKx].emplace_object();
            return serialize_struct(temp, pDescriptorWrites[qJACxKx]);
            }();
        }
        }();
[&](){json["descriptorCopyCount"]=descriptorCopyCount;}();
[&](){
            if (pDescriptorCopies==NULL){
                json["pDescriptorCopies"]=boost::json::array();
            return; }
        auto& arr_WWZDhqd=json["pDescriptorCopies"].emplace_array();
        for(int ryeXdkw=0; ryeXdkw < descriptorCopyCount; ryeXdkw++){
            [&](){
            auto& temp=arr_WWZDhqd[ryeXdkw].emplace_object();
            return serialize_struct(temp, pDescriptorCopies[ryeXdkw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUPDATEDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){descriptorWriteCount=static_cast<uint32_t>(value_to<int>(json["descriptorWriteCount"]));}();

[&](){descriptorCopyCount=static_cast<uint32_t>(value_to<int>(json["descriptorCopyCount"]));}();


debug_printf("Ending vkUpdateDescriptorSets...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateFramebuffer( VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer ){
//Will only be called by the client
debug_printf("Executing vkCreateFramebuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEFRAMEBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_LBIrWmz=json["pCreateInfo"].emplace_array();
        for(int jMLqpUb=0; jMLqpUb < 1; jMLqpUb++){
            [&](){
            auto& temp=arr_LBIrWmz[jMLqpUb].emplace_object();
            return serialize_struct(temp, pCreateInfo[jMLqpUb]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFramebuffer==NULL){
                json["pFramebuffer"]=boost::json::array();
            return; }
        auto& arr_xECXRAK=json["pFramebuffer"].emplace_array();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){serialize_VkFramebuffer(arr_xECXRAK[zDUSKRl],pFramebuffer[zDUSKRl]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEFRAMEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFramebuffer"].as_array().size()==0){
                pFramebuffer=NULL;
            return; }
        auto& arr_xECXRAK=json["pFramebuffer"].as_array();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){deserialize_VkFramebuffer(arr_xECXRAK[zDUSKRl], pFramebuffer[zDUSKRl]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_cmYyImH;[&](){temp_cmYyImH=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_cmYyImH;}();}();

                if (pFramebuffer!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pFramebuffer[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateFramebuffer...\n");
debug_printf("Return value of vkCreateFramebuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyFramebuffer( VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyFramebuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYFRAMEBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYFRAMEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();


debug_printf("Ending vkDestroyFramebuffer...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRenderPass( VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass ){
//Will only be called by the client
debug_printf("Executing vkCreateRenderPass\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATERENDERPASS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_upxhtZe=json["pCreateInfo"].emplace_array();
        for(int oHJSJzU=0; oHJSJzU < 1; oHJSJzU++){
            [&](){
            auto& temp=arr_upxhtZe[oHJSJzU].emplace_object();
            return serialize_struct(temp, pCreateInfo[oHJSJzU]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=boost::json::array();
            return; }
        auto& arr_ZwdXTfx=json["pRenderPass"].emplace_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pRenderPass"].as_array().size()==0){
                pRenderPass=NULL;
            return; }
        auto& arr_ZwdXTfx=json["pRenderPass"].as_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_zWeBCln;[&](){temp_zWeBCln=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_zWeBCln;}();}();

                if (pRenderPass!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pRenderPass[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRenderPass...\n");
debug_printf("Return value of vkCreateRenderPass is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyRenderPass( VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyRenderPass\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYRENDERPASS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYRENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();


debug_printf("Ending vkDestroyRenderPass...\n");
}
__attribute__((visibility ("hidden"))) void vkGetRenderAreaGranularity( VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity ){
//Will only be called by the client
debug_printf("Executing vkGetRenderAreaGranularity\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETRENDERAREAGRANULARITY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=boost::json::array();
            return; }
        auto& arr_VvmWHYL=json["pGranularity"].emplace_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].emplace_object();
            return serialize_struct(temp, pGranularity[tgiNLQL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRENDERAREAGRANULARITY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();
[&](){
            if (json["pGranularity"].as_array().size()==0){
                pGranularity=NULL;
            return; }
        auto& arr_VvmWHYL=json["pGranularity"].as_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].as_object();
            deserialize_struct(temp,pGranularity[tgiNLQL]);
            }();
        }
        }();

debug_printf("Ending vkGetRenderAreaGranularity...\n");
}
__attribute__((visibility ("hidden"))) void vkGetRenderingAreaGranularityKHR( VkDevice device, const VkRenderingAreaInfoKHR* pRenderingAreaInfo, VkExtent2D* pGranularity ){
//Will only be called by the client
debug_printf("Executing vkGetRenderingAreaGranularityKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETRENDERINGAREAGRANULARITYKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingAreaInfo==NULL){
                json["pRenderingAreaInfo"]=boost::json::array();
            return; }
        auto& arr_QFvDqfG=json["pRenderingAreaInfo"].emplace_array();
        for(int WRYBJDa=0; WRYBJDa < 1; WRYBJDa++){
            [&](){
            auto& temp=arr_QFvDqfG[WRYBJDa].emplace_object();
            return serialize_struct(temp, pRenderingAreaInfo[WRYBJDa]);
            }();
        }
        }();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=boost::json::array();
            return; }
        auto& arr_VvmWHYL=json["pGranularity"].emplace_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].emplace_object();
            return serialize_struct(temp, pGranularity[tgiNLQL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRENDERINGAREAGRANULARITYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pGranularity"].as_array().size()==0){
                pGranularity=NULL;
            return; }
        auto& arr_VvmWHYL=json["pGranularity"].as_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].as_object();
            deserialize_struct(temp,pGranularity[tgiNLQL]);
            }();
        }
        }();

debug_printf("Ending vkGetRenderingAreaGranularityKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateCommandPool( VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool ){
//Will only be called by the client
debug_printf("Executing vkCreateCommandPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATECOMMANDPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_ISnaSOj=json["pCreateInfo"].emplace_array();
        for(int ubLLexW=0; ubLLexW < 1; ubLLexW++){
            [&](){
            auto& temp=arr_ISnaSOj[ubLLexW].emplace_object();
            return serialize_struct(temp, pCreateInfo[ubLLexW]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pCommandPool==NULL){
                json["pCommandPool"]=boost::json::array();
            return; }
        auto& arr_ohCGecZ=json["pCommandPool"].emplace_array();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){serialize_VkCommandPool(arr_ohCGecZ[oHETrgL],pCommandPool[oHETrgL]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pCommandPool"].as_array().size()==0){
                pCommandPool=NULL;
            return; }
        auto& arr_ohCGecZ=json["pCommandPool"].as_array();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){deserialize_VkCommandPool(arr_ohCGecZ[oHETrgL], pCommandPool[oHETrgL]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_HYIvEtZ;[&](){temp_HYIvEtZ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_HYIvEtZ;}();}();

                if (pCommandPool!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pCommandPool[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateCommandPool...\n");
debug_printf("Return value of vkCreateCommandPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyCommandPool( VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyCommandPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYCOMMANDPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYCOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();


debug_printf("Ending vkDestroyCommandPool...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkResetCommandPool( VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags ){
//Will only be called by the client
debug_printf("Executing vkResetCommandPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRESETCOMMANDPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETCOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
[&](){[&](){int temp_ZfbLqrp;[&](){temp_ZfbLqrp=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkCommandPoolResetFlags)temp_ZfbLqrp;}();}();
VkResult result;
[&](){[&](){int temp_CuEhFlV;[&](){temp_CuEhFlV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_CuEhFlV;}();}();

debug_printf("Ending vkResetCommandPool...\n");
debug_printf("Return value of vkResetCommandPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAllocateCommandBuffers( VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers ){
//Will only be called by the client
debug_printf("Executing vkAllocateCommandBuffers\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKALLOCATECOMMANDBUFFERS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }
        auto& arr_ZURucFE=json["pAllocateInfo"].emplace_array();
        for(int VMrKYrr=0; VMrKYrr < 1; VMrKYrr++){
            [&](){
            auto& temp=arr_ZURucFE[VMrKYrr].emplace_object();
            return serialize_struct(temp, pAllocateInfo[VMrKYrr]);
            }();
        }
        }();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }
        auto& arr_WZYlBGU=json["pCommandBuffers"].emplace_array();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){serialize_VkCommandBuffer(arr_WZYlBGU[RztseIK],pCommandBuffers[RztseIK]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKALLOCATECOMMANDBUFFERS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pCommandBuffers"].as_array().size()==0){
                pCommandBuffers=NULL;
            return; }
        auto& arr_WZYlBGU=json["pCommandBuffers"].as_array();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){deserialize_VkCommandBuffer(arr_WZYlBGU[RztseIK], pCommandBuffers[RztseIK]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ovQhmYf;[&](){temp_ovQhmYf=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_ovQhmYf;}();}();

                if (pCommandBuffers!=NULL){
                    for (int i=0; i<pAllocateInfo->commandBufferCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pCommandBuffers[i])]=parent;
                    }
                }
                

debug_printf("Ending vkAllocateCommandBuffers...\n");
debug_printf("Return value of vkAllocateCommandBuffers is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkFreeCommandBuffers( VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers ){
//Will only be called by the client
debug_printf("Executing vkFreeCommandBuffers\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKFREECOMMANDBUFFERS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){json["commandBufferCount"]=commandBufferCount;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }
        auto& arr_PdRlpEO=json["pCommandBuffers"].emplace_array();
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFREECOMMANDBUFFERS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
[&](){commandBufferCount=static_cast<uint32_t>(value_to<int>(json["commandBufferCount"]));}();


debug_printf("Ending vkFreeCommandBuffers...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBeginCommandBuffer( VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo ){
//Will only be called by the client
debug_printf("Executing vkBeginCommandBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBEGINCOMMANDBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=boost::json::array();
            return; }
        auto& arr_cULABHU=json["pBeginInfo"].emplace_array();
        for(int MlslWJM=0; MlslWJM < 1; MlslWJM++){
            [&](){
            auto& temp=arr_cULABHU[MlslWJM].emplace_object();
            return serialize_struct(temp, pBeginInfo[MlslWJM]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBEGINCOMMANDBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_OadhEnt;[&](){temp_OadhEnt=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_OadhEnt;}();}();

debug_printf("Ending vkBeginCommandBuffer...\n");
debug_printf("Return value of vkBeginCommandBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEndCommandBuffer( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkEndCommandBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKENDCOMMANDBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENDCOMMANDBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkResult result;
[&](){[&](){int temp_UprYAUm;[&](){temp_UprYAUm=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_UprYAUm;}();}();

debug_printf("Ending vkEndCommandBuffer...\n");
debug_printf("Return value of vkEndCommandBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkResetCommandBuffer( VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags ){
//Will only be called by the client
debug_printf("Executing vkResetCommandBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRESETCOMMANDBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETCOMMANDBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_lxCkbVG;[&](){temp_lxCkbVG=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkCommandBufferResetFlags)temp_lxCkbVG;}();}();
VkResult result;
[&](){[&](){int temp_XiIQapg;[&](){temp_XiIQapg=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_XiIQapg;}();}();

debug_printf("Ending vkResetCommandBuffer...\n");
debug_printf("Return value of vkResetCommandBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBindPipeline( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline ){
//Will only be called by the client
debug_printf("Executing vkCmdBindPipeline\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDPIPELINE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDPIPELINE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

debug_printf("Ending vkCmdBindPipeline...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetAttachmentFeedbackLoopEnableEXT( VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetAttachmentFeedbackLoopEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["aspectMask"]=aspectMask;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_LWxAVsj;[&](){temp_LWxAVsj=static_cast<int>(value_to<int>(json["aspectMask"]));}();aspectMask=(VkImageAspectFlags)temp_LWxAVsj;}();}();

debug_printf("Ending vkCmdSetAttachmentFeedbackLoopEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewport( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewport\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETVIEWPORT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=boost::json::array();
            return; }
        auto& arr_SyYryUE=json["pViewports"].emplace_array();
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto& temp=arr_SyYryUE[HAuJlzw].emplace_object();
            return serialize_struct(temp, pViewports[HAuJlzw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstViewport=static_cast<uint32_t>(value_to<int>(json["firstViewport"]));}();
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();


debug_printf("Ending vkCmdSetViewport...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetScissor( VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors ){
//Will only be called by the client
debug_printf("Executing vkCmdSetScissor\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSCISSOR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstScissor"]=firstScissor;}();
[&](){json["scissorCount"]=scissorCount;}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=boost::json::array();
            return; }
        auto& arr_RpUaBcS=json["pScissors"].emplace_array();
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto& temp=arr_RpUaBcS[XBYGvVT].emplace_object();
            return serialize_struct(temp, pScissors[XBYGvVT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSCISSOR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstScissor=static_cast<uint32_t>(value_to<int>(json["firstScissor"]));}();
[&](){scissorCount=static_cast<uint32_t>(value_to<int>(json["scissorCount"]));}();


debug_printf("Ending vkCmdSetScissor...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineWidth( VkCommandBuffer commandBuffer, float lineWidth ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineWidth\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETLINEWIDTH;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineWidth"]=lineWidth;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINEWIDTH):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){lineWidth=static_cast<float>(value_to<int>(json["lineWidth"]));}();

debug_printf("Ending vkCmdSetLineWidth...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBias( VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBias\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHBIAS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["depthBiasConstantFactor"]=depthBiasConstantFactor;}();
[&](){json["depthBiasClamp"]=depthBiasClamp;}();
[&](){json["depthBiasSlopeFactor"]=depthBiasSlopeFactor;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBIAS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){depthBiasConstantFactor=static_cast<float>(value_to<int>(json["depthBiasConstantFactor"]));}();
[&](){depthBiasClamp=static_cast<float>(value_to<int>(json["depthBiasClamp"]));}();
[&](){depthBiasSlopeFactor=static_cast<float>(value_to<int>(json["depthBiasSlopeFactor"]));}();

debug_printf("Ending vkCmdSetDepthBias...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetBlendConstants( VkCommandBuffer commandBuffer, const float blendConstants[4] ){
//Will only be called by the client
debug_printf("Executing vkCmdSetBlendConstants\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETBLENDCONSTANTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
        auto& arr_SsKZRbG=json["blendConstants"].emplace_array();
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            [&](){arr_SsKZRbG[lLRJClr]=blendConstants[lLRJClr];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETBLENDCONSTANTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
        auto& arr_SsKZRbG=json["blendConstants"].as_array();
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            
        }
        }();

debug_printf("Ending vkCmdSetBlendConstants...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBounds( VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBounds\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHBOUNDS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["minDepthBounds"]=minDepthBounds;}();
[&](){json["maxDepthBounds"]=maxDepthBounds;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBOUNDS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){minDepthBounds=static_cast<float>(value_to<int>(json["minDepthBounds"]));}();
[&](){maxDepthBounds=static_cast<float>(value_to<int>(json["maxDepthBounds"]));}();

debug_printf("Ending vkCmdSetDepthBounds...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilCompareMask( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilCompareMask\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSTENCILCOMPAREMASK;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["compareMask"]=compareMask;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILCOMPAREMASK):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){temp_VFXTqgy=static_cast<int>(value_to<int>(json["faceMask"]));}();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){compareMask=static_cast<uint32_t>(value_to<int>(json["compareMask"]));}();

debug_printf("Ending vkCmdSetStencilCompareMask...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilWriteMask( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilWriteMask\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSTENCILWRITEMASK;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["writeMask"]=writeMask;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILWRITEMASK):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){temp_VFXTqgy=static_cast<int>(value_to<int>(json["faceMask"]));}();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){writeMask=static_cast<uint32_t>(value_to<int>(json["writeMask"]));}();

debug_printf("Ending vkCmdSetStencilWriteMask...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilReference( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilReference\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSTENCILREFERENCE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["reference"]=reference;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILREFERENCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){temp_VFXTqgy=static_cast<int>(value_to<int>(json["faceMask"]));}();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){reference=static_cast<uint32_t>(value_to<int>(json["reference"]));}();

debug_printf("Ending vkCmdSetStencilReference...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindDescriptorSets( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdBindDescriptorSets\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDDESCRIPTORSETS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=firstSet;}();
[&](){json["descriptorSetCount"]=descriptorSetCount;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }
        auto& arr_JZNsxgK=json["pDescriptorSets"].emplace_array();
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        }();
[&](){json["dynamicOffsetCount"]=dynamicOffsetCount;}();
[&](){
            if (pDynamicOffsets==NULL){
                json["pDynamicOffsets"]=boost::json::array();
            return; }
        auto& arr_Zetuxcc=json["pDynamicOffsets"].emplace_array();
        for(int nxuqgVF=0; nxuqgVF < dynamicOffsetCount; nxuqgVF++){
            [&](){arr_Zetuxcc[nxuqgVF]=pDynamicOffsets[nxuqgVF];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){firstSet=static_cast<uint32_t>(value_to<int>(json["firstSet"]));}();
[&](){descriptorSetCount=static_cast<uint32_t>(value_to<int>(json["descriptorSetCount"]));}();

[&](){dynamicOffsetCount=static_cast<uint32_t>(value_to<int>(json["dynamicOffsetCount"]));}();


debug_printf("Ending vkCmdBindDescriptorSets...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindIndexBuffer( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType ){
//Will only be called by the client
debug_printf("Executing vkCmdBindIndexBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDINDEXBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){[&](){json["indexType"]=indexType;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDINDEXBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){[&](){int temp_GdrXdVh;[&](){temp_GdrXdVh=static_cast<int>(value_to<int>(json["indexType"]));}();indexType=(VkIndexType)temp_GdrXdVh;}();}();

debug_printf("Ending vkCmdBindIndexBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindVertexBuffers( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdBindVertexBuffers\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDVERTEXBUFFERS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }
        auto& arr_ENtnMTo=json["pBuffers"].emplace_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }
        auto& arr_YvpyTDd=json["pOffsets"].emplace_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDVERTEXBUFFERS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstBinding=static_cast<uint32_t>(value_to<int>(json["firstBinding"]));}();
[&](){bindingCount=static_cast<uint32_t>(value_to<int>(json["bindingCount"]));}();



debug_printf("Ending vkCmdBindVertexBuffers...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDraw( VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance ){
//Will only be called by the client
debug_printf("Executing vkCmdDraw\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAW;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexCount"]=vertexCount;}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstVertex"]=firstVertex;}();
[&](){json["firstInstance"]=firstInstance;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){vertexCount=static_cast<uint32_t>(value_to<int>(json["vertexCount"]));}();
[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
[&](){firstVertex=static_cast<uint32_t>(value_to<int>(json["firstVertex"]));}();
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();

debug_printf("Ending vkCmdDraw...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexed( VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndexed\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWINDEXED;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["indexCount"]=indexCount;}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstIndex"]=firstIndex;}();
[&](){json["vertexOffset"]=vertexOffset;}();
[&](){json["firstInstance"]=firstInstance;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDEXED):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){indexCount=static_cast<uint32_t>(value_to<int>(json["indexCount"]));}();
[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
[&](){firstIndex=static_cast<uint32_t>(value_to<int>(json["firstIndex"]));}();
[&](){vertexOffset=static_cast<int32_t>(value_to<int>(json["vertexOffset"]));}();
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();

debug_printf("Ending vkCmdDrawIndexed...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMultiEXT( VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMultiEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWMULTIEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=drawCount;}();
[&](){
            if (pVertexInfo==NULL){
                json["pVertexInfo"]=boost::json::array();
            return; }
        auto& arr_NmVssTF=json["pVertexInfo"].emplace_array();
        for(int xJCsgzh=0; xJCsgzh < drawCount; xJCsgzh++){
            [&](){
            auto& temp=arr_NmVssTF[xJCsgzh].emplace_object();
            return serialize_struct(temp, pVertexInfo[xJCsgzh]);
            }();
        }
        }();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMULTIEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();

[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDrawMultiEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMultiIndexedEXT( VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMultiIndexedEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWMULTIINDEXEDEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=drawCount;}();
[&](){
            if (pIndexInfo==NULL){
                json["pIndexInfo"]=boost::json::array();
            return; }
        auto& arr_OvAOCiL=json["pIndexInfo"].emplace_array();
        for(int FmfkOAV=0; FmfkOAV < drawCount; FmfkOAV++){
            [&](){
            auto& temp=arr_OvAOCiL[FmfkOAV].emplace_object();
            return serialize_struct(temp, pIndexInfo[FmfkOAV]);
            }();
        }
        }();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){json["stride"]=stride;}();
[&](){
            if (pVertexOffset==NULL){
                json["pVertexOffset"]=boost::json::array();
            return; }
        auto& arr_PavgIEG=json["pVertexOffset"].emplace_array();
        for(int PNvrUEs=0; PNvrUEs < 1; PNvrUEs++){
            [&](){arr_PavgIEG[PNvrUEs]=pVertexOffset[PNvrUEs];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMULTIINDEXEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();

[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();


debug_printf("Ending vkCmdDrawMultiIndexedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndirect\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWINDIRECT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDIRECT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDrawIndirect...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndexedIndirect\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWINDEXEDINDIRECT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDEXEDINDIRECT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDrawIndexedIndirect...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDispatch( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDispatch\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDISPATCH;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDISPATCH):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){groupCountX=static_cast<uint32_t>(value_to<int>(json["groupCountX"]));}();
[&](){groupCountY=static_cast<uint32_t>(value_to<int>(json["groupCountY"]));}();
[&](){groupCountZ=static_cast<uint32_t>(value_to<int>(json["groupCountZ"]));}();

debug_printf("Ending vkCmdDispatch...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDispatchIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset ){
//Will only be called by the client
debug_printf("Executing vkCmdDispatchIndirect\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDISPATCHINDIRECT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDISPATCHINDIRECT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();

debug_printf("Ending vkCmdDispatchIndirect...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSubpassShadingHUAWEI( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdSubpassShadingHUAWEI\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSUBPASSSHADINGHUAWEI;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSUBPASSSHADINGHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdSubpassShadingHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawClusterHUAWEI( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawClusterHUAWEI\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWCLUSTERHUAWEI;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWCLUSTERHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){groupCountX=static_cast<uint32_t>(value_to<int>(json["groupCountX"]));}();
[&](){groupCountY=static_cast<uint32_t>(value_to<int>(json["groupCountY"]));}();
[&](){groupCountZ=static_cast<uint32_t>(value_to<int>(json["groupCountZ"]));}();

debug_printf("Ending vkCmdDrawClusterHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawClusterIndirectHUAWEI( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawClusterIndirectHUAWEI\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWCLUSTERINDIRECTHUAWEI;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWCLUSTERINDIRECTHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();

debug_printf("Ending vkCmdDrawClusterIndirectHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdUpdatePipelineIndirectBufferNV( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline ){
//Will only be called by the client
debug_printf("Executing vkCmdUpdatePipelineIndirectBufferNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDUPDATEPIPELINEINDIRECTBUFFERNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDUPDATEPIPELINEINDIRECTBUFFERNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

debug_printf("Ending vkCmdUpdatePipelineIndirectBufferNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBuffer( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_McSYWcQ=json["pRegions"].emplace_array();
        for(int IaMuFrO=0; IaMuFrO < regionCount; IaMuFrO++){
            [&](){
            auto& temp=arr_McSYWcQ[IaMuFrO].emplace_object();
            return serialize_struct(temp, pRegions[IaMuFrO]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();


debug_printf("Ending vkCmdCopyBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImage\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYIMAGE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_HMPixWj=json["pRegions"].emplace_array();
        for(int TvxHvSV=0; TvxHvSV < regionCount; TvxHvSV++){
            [&](){
            auto& temp=arr_HMPixWj[TvxHvSV].emplace_object();
            return serialize_struct(temp, pRegions[TvxHvSV]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){temp_zMKCozb=static_cast<int>(value_to<int>(json["srcImageLayout"]));}();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();


debug_printf("Ending vkCmdCopyImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBlitImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter ){
//Will only be called by the client
debug_printf("Executing vkCmdBlitImage\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBLITIMAGE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_dQsoHhP=json["pRegions"].emplace_array();
        for(int YEXYPDJ=0; YEXYPDJ < regionCount; YEXYPDJ++){
            [&](){
            auto& temp=arr_dQsoHhP[YEXYPDJ].emplace_object();
            return serialize_struct(temp, pRegions[YEXYPDJ]);
            }();
        }
        }();
[&](){[&](){[&](){json["filter"]=filter;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBLITIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){temp_zMKCozb=static_cast<int>(value_to<int>(json["srcImageLayout"]));}();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();

[&](){[&](){int temp_DaCTyEq;[&](){temp_DaCTyEq=static_cast<int>(value_to<int>(json["filter"]));}();filter=(VkFilter)temp_DaCTyEq;}();}();

debug_printf("Ending vkCmdBlitImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBufferToImage( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBufferToImage\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYBUFFERTOIMAGE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_igZnVsu=json["pRegions"].emplace_array();
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto& temp=arr_igZnVsu[yuuZKOo].emplace_object();
            return serialize_struct(temp, pRegions[yuuZKOo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFERTOIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();


debug_printf("Ending vkCmdCopyBufferToImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImageToBuffer( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImageToBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYIMAGETOBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_igZnVsu=json["pRegions"].emplace_array();
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto& temp=arr_igZnVsu[yuuZKOo].emplace_object();
            return serialize_struct(temp, pRegions[yuuZKOo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGETOBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){temp_zMKCozb=static_cast<int>(value_to<int>(json["srcImageLayout"]));}();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();


debug_printf("Ending vkCmdCopyImageToBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryIndirectNV( VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryIndirectNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYMEMORYINDIRECTNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=copyBufferAddress;}();}();
[&](){json["copyCount"]=copyCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYINDIRECTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_qveUnrh;[&](){temp_qveUnrh=static_cast<uint64_t>(value_to<int>(json["copyBufferAddress"]));}();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
[&](){copyCount=static_cast<uint32_t>(value_to<int>(json["copyCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdCopyMemoryIndirectNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryToImageIndirectNV( VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers* pImageSubresources ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryToImageIndirectNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYMEMORYTOIMAGEINDIRECTNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=copyBufferAddress;}();}();
[&](){json["copyCount"]=copyCount;}();
[&](){json["stride"]=stride;}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){
            if (pImageSubresources==NULL){
                json["pImageSubresources"]=boost::json::array();
            return; }
        auto& arr_hVMAkcO=json["pImageSubresources"].emplace_array();
        for(int OfGHasS=0; OfGHasS < copyCount; OfGHasS++){
            [&](){
            auto& temp=arr_hVMAkcO[OfGHasS].emplace_object();
            return serialize_struct(temp, pImageSubresources[OfGHasS]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYTOIMAGEINDIRECTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_qveUnrh;[&](){temp_qveUnrh=static_cast<uint64_t>(value_to<int>(json["copyBufferAddress"]));}();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
[&](){copyCount=static_cast<uint32_t>(value_to<int>(json["copyCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();


debug_printf("Ending vkCmdCopyMemoryToImageIndirectNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdUpdateBuffer( VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData ){
//Will only be called by the client
debug_printf("Executing vkCmdUpdateBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDUPDATEBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["dataSize"]=dataSize;}();}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_wjMrkki=json["pData"].emplace_array();
        for(int qQUyxsG=0; qQUyxsG < dataSize; qQUyxsG++){
            [&](){arr_wjMrkki[qQUyxsG]=((char*)(pData))[qQUyxsG];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDUPDATEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){uint64_t temp_SwYyzuh;[&](){temp_SwYyzuh=static_cast<uint64_t>(value_to<int>(json["dataSize"]));}();dataSize=(VkDeviceSize)temp_SwYyzuh;}();


debug_printf("Ending vkCmdUpdateBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdFillBuffer( VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data ){
//Will only be called by the client
debug_printf("Executing vkCmdFillBuffer\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDFILLBUFFER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){json["data"]=data;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDFILLBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){uint64_t temp_PlNcOBd;[&](){temp_PlNcOBd=static_cast<uint64_t>(value_to<int>(json["size"]));}();size=(VkDeviceSize)temp_PlNcOBd;}();
[&](){data=static_cast<uint32_t>(value_to<int>(json["data"]));}();

debug_printf("Ending vkCmdFillBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdClearColorImage( VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges ){
//Will only be called by the client
debug_printf("Executing vkCmdClearColorImage\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCLEARCOLORIMAGE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
[&](){
            if (pColor==NULL){
                json["pColor"]=boost::json::array();
            return; }
        auto& arr_SGRyjqE=json["pColor"].emplace_array();
        for(int ldPlUDi=0; ldPlUDi < 1; ldPlUDi++){
            [&](){
            auto& temp=arr_SGRyjqE[ldPlUDi].emplace_object();
            return serialize_struct(temp, pColor[ldPlUDi]);
            }();
        }
        }();
[&](){json["rangeCount"]=rangeCount;}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=boost::json::array();
            return; }
        auto& arr_BisbUqU=json["pRanges"].emplace_array();
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto& temp=arr_BisbUqU[IZgopUD].emplace_object();
            return serialize_struct(temp, pRanges[IZgopUD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCLEARCOLORIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){[&](){int temp_VgsvIeW;[&](){temp_VgsvIeW=static_cast<int>(value_to<int>(json["imageLayout"]));}();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

[&](){rangeCount=static_cast<uint32_t>(value_to<int>(json["rangeCount"]));}();


debug_printf("Ending vkCmdClearColorImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdClearDepthStencilImage( VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges ){
//Will only be called by the client
debug_printf("Executing vkCmdClearDepthStencilImage\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCLEARDEPTHSTENCILIMAGE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
[&](){
            if (pDepthStencil==NULL){
                json["pDepthStencil"]=boost::json::array();
            return; }
        auto& arr_gYzlVps=json["pDepthStencil"].emplace_array();
        for(int jJUemfv=0; jJUemfv < 1; jJUemfv++){
            [&](){
            auto& temp=arr_gYzlVps[jJUemfv].emplace_object();
            return serialize_struct(temp, pDepthStencil[jJUemfv]);
            }();
        }
        }();
[&](){json["rangeCount"]=rangeCount;}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=boost::json::array();
            return; }
        auto& arr_BisbUqU=json["pRanges"].emplace_array();
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto& temp=arr_BisbUqU[IZgopUD].emplace_object();
            return serialize_struct(temp, pRanges[IZgopUD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCLEARDEPTHSTENCILIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){[&](){int temp_VgsvIeW;[&](){temp_VgsvIeW=static_cast<int>(value_to<int>(json["imageLayout"]));}();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

[&](){rangeCount=static_cast<uint32_t>(value_to<int>(json["rangeCount"]));}();


debug_printf("Ending vkCmdClearDepthStencilImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdClearAttachments( VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects ){
//Will only be called by the client
debug_printf("Executing vkCmdClearAttachments\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCLEARATTACHMENTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pAttachments==NULL){
                json["pAttachments"]=boost::json::array();
            return; }
        auto& arr_fOlilkR=json["pAttachments"].emplace_array();
        for(int BsFiayf=0; BsFiayf < attachmentCount; BsFiayf++){
            [&](){
            auto& temp=arr_fOlilkR[BsFiayf].emplace_object();
            return serialize_struct(temp, pAttachments[BsFiayf]);
            }();
        }
        }();
[&](){json["rectCount"]=rectCount;}();
[&](){
            if (pRects==NULL){
                json["pRects"]=boost::json::array();
            return; }
        auto& arr_cgJwUFb=json["pRects"].emplace_array();
        for(int HncrKEH=0; HncrKEH < rectCount; HncrKEH++){
            [&](){
            auto& temp=arr_cgJwUFb[HncrKEH].emplace_object();
            return serialize_struct(temp, pRects[HncrKEH]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCLEARATTACHMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();

[&](){rectCount=static_cast<uint32_t>(value_to<int>(json["rectCount"]));}();


debug_printf("Ending vkCmdClearAttachments...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResolveImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdResolveImage\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDRESOLVEIMAGE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }
        auto& arr_OGNZeww=json["pRegions"].emplace_array();
        for(int UbqELUx=0; UbqELUx < regionCount; UbqELUx++){
            [&](){
            auto& temp=arr_OGNZeww[UbqELUx].emplace_object();
            return serialize_struct(temp, pRegions[UbqELUx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESOLVEIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){temp_zMKCozb=static_cast<int>(value_to<int>(json["srcImageLayout"]));}();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){temp_jOGlaAP=static_cast<int>(value_to<int>(json["dstImageLayout"]));}();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){regionCount=static_cast<uint32_t>(value_to<int>(json["regionCount"]));}();


debug_printf("Ending vkCmdResolveImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetEvent( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetEvent\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETEVENT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();
[&](){[&](){int temp_aUxfTbC;[&](){temp_aUxfTbC=static_cast<int>(value_to<int>(json["stageMask"]));}();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

debug_printf("Ending vkCmdSetEvent...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResetEvent( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask ){
//Will only be called by the client
debug_printf("Executing vkCmdResetEvent\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDRESETEVENT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();
[&](){[&](){int temp_aUxfTbC;[&](){temp_aUxfTbC=static_cast<int>(value_to<int>(json["stageMask"]));}();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

debug_printf("Ending vkCmdResetEvent...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWaitEvents( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers ){
//Will only be called by the client
debug_printf("Executing vkCmdWaitEvents\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDWAITEVENTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=eventCount;}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=boost::json::array();
            return; }
        auto& arr_tUuyOPJ=json["pEvents"].emplace_array();
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        }();
[&](){[&](){[&](){json["srcStageMask"]=srcStageMask;}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=dstStageMask;}();}();}();
[&](){json["memoryBarrierCount"]=memoryBarrierCount;}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_fXDYoDs=json["pMemoryBarriers"].emplace_array();
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto& temp=arr_fXDYoDs[JhnlCAW].emplace_object();
            return serialize_struct(temp, pMemoryBarriers[JhnlCAW]);
            }();
        }
        }();
[&](){json["bufferMemoryBarrierCount"]=bufferMemoryBarrierCount;}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_FmJTDmX=json["pBufferMemoryBarriers"].emplace_array();
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto& temp=arr_FmJTDmX[aFMQios].emplace_object();
            return serialize_struct(temp, pBufferMemoryBarriers[aFMQios]);
            }();
        }
        }();
[&](){json["imageMemoryBarrierCount"]=imageMemoryBarrierCount;}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_nkkvvYR=json["pImageMemoryBarriers"].emplace_array();
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto& temp=arr_nkkvvYR[trWYSmx].emplace_object();
            return serialize_struct(temp, pImageMemoryBarriers[trWYSmx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWAITEVENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){eventCount=static_cast<uint32_t>(value_to<int>(json["eventCount"]));}();

[&](){[&](){int temp_puDZLNO;[&](){temp_puDZLNO=static_cast<int>(value_to<int>(json["srcStageMask"]));}();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
[&](){[&](){int temp_OgAwXVW;[&](){temp_OgAwXVW=static_cast<int>(value_to<int>(json["dstStageMask"]));}();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
[&](){memoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["memoryBarrierCount"]));}();

[&](){bufferMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["bufferMemoryBarrierCount"]));}();

[&](){imageMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["imageMemoryBarrierCount"]));}();


debug_printf("Ending vkCmdWaitEvents...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPipelineBarrier( VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers ){
//Will only be called by the client
debug_printf("Executing vkCmdPipelineBarrier\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDPIPELINEBARRIER;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["srcStageMask"]=srcStageMask;}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=dstStageMask;}();}();}();
[&](){[&](){[&](){json["dependencyFlags"]=dependencyFlags;}();}();}();
[&](){json["memoryBarrierCount"]=memoryBarrierCount;}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_fXDYoDs=json["pMemoryBarriers"].emplace_array();
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto& temp=arr_fXDYoDs[JhnlCAW].emplace_object();
            return serialize_struct(temp, pMemoryBarriers[JhnlCAW]);
            }();
        }
        }();
[&](){json["bufferMemoryBarrierCount"]=bufferMemoryBarrierCount;}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_FmJTDmX=json["pBufferMemoryBarriers"].emplace_array();
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto& temp=arr_FmJTDmX[aFMQios].emplace_object();
            return serialize_struct(temp, pBufferMemoryBarriers[aFMQios]);
            }();
        }
        }();
[&](){json["imageMemoryBarrierCount"]=imageMemoryBarrierCount;}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=boost::json::array();
            return; }
        auto& arr_nkkvvYR=json["pImageMemoryBarriers"].emplace_array();
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto& temp=arr_nkkvvYR[trWYSmx].emplace_object();
            return serialize_struct(temp, pImageMemoryBarriers[trWYSmx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPIPELINEBARRIER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_puDZLNO;[&](){temp_puDZLNO=static_cast<int>(value_to<int>(json["srcStageMask"]));}();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
[&](){[&](){int temp_OgAwXVW;[&](){temp_OgAwXVW=static_cast<int>(value_to<int>(json["dstStageMask"]));}();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
[&](){[&](){int temp_MJCELwI;[&](){temp_MJCELwI=static_cast<int>(value_to<int>(json["dependencyFlags"]));}();dependencyFlags=(VkDependencyFlags)temp_MJCELwI;}();}();
[&](){memoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["memoryBarrierCount"]));}();

[&](){bufferMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["bufferMemoryBarrierCount"]));}();

[&](){imageMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(json["imageMemoryBarrierCount"]));}();


debug_printf("Ending vkCmdPipelineBarrier...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginQuery( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginQuery\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBEGINQUERY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINQUERY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();
[&](){[&](){int temp_iyzDJOK;[&](){temp_iyzDJOK=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();

debug_printf("Ending vkCmdBeginQuery...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndQuery( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query ){
//Will only be called by the client
debug_printf("Executing vkCmdEndQuery\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDENDQUERY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDQUERY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();

debug_printf("Ending vkCmdEndQuery...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginConditionalRenderingEXT( VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginConditionalRenderingEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBEGINCONDITIONALRENDERINGEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pConditionalRenderingBegin==NULL){
                json["pConditionalRenderingBegin"]=boost::json::array();
            return; }
        auto& arr_guEoeuh=json["pConditionalRenderingBegin"].emplace_array();
        for(int KETgcvj=0; KETgcvj < 1; KETgcvj++){
            [&](){
            auto& temp=arr_guEoeuh[KETgcvj].emplace_object();
            return serialize_struct(temp, pConditionalRenderingBegin[KETgcvj]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINCONDITIONALRENDERINGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginConditionalRenderingEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndConditionalRenderingEXT( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndConditionalRenderingEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDENDCONDITIONALRENDERINGEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDCONDITIONALRENDERINGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndConditionalRenderingEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResetQueryPool( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount ){
//Will only be called by the client
debug_printf("Executing vkCmdResetQueryPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDRESETQUERYPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESETQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();
[&](){queryCount=static_cast<uint32_t>(value_to<int>(json["queryCount"]));}();

debug_printf("Ending vkCmdResetQueryPool...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWriteTimestamp( VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteTimestamp\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDWRITETIMESTAMP;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=pipelineStage;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITETIMESTAMP):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_WILNXWI;[&](){temp_WILNXWI=static_cast<int>(value_to<int>(json["pipelineStage"]));}();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();

debug_printf("Ending vkCmdWriteTimestamp...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyQueryPoolResults( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyQueryPoolResults\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYQUERYPOOLRESULTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["stride"]=stride;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYQUERYPOOLRESULTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();
[&](){queryCount=static_cast<uint32_t>(value_to<int>(json["queryCount"]));}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){uint64_t temp_fLSTSIg;[&](){temp_fLSTSIg=static_cast<uint64_t>(value_to<int>(json["stride"]));}();stride=(VkDeviceSize)temp_fLSTSIg;}();
[&](){[&](){int temp_jzLjdpj;[&](){temp_jzLjdpj=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();

debug_printf("Ending vkCmdCopyQueryPoolResults...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPushConstants( VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues ){
//Will only be called by the client
debug_printf("Executing vkCmdPushConstants\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDPUSHCONSTANTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){[&](){[&](){json["stageFlags"]=stageFlags;}();}();}();
[&](){json["offset"]=offset;}();
[&](){json["size"]=size;}();
[&](){
            if (pValues==NULL){
                json["pValues"]=boost::json::array();
            return; }[&](){
            if (((char*)(pValues))==NULL){
                json["pValues"]=boost::json::array();
            return; }
        auto& arr_NQXrjwW=json["pValues"].emplace_array();
        for(int GopYbEO=0; GopYbEO < size; GopYbEO++){
            [&](){arr_NQXrjwW[GopYbEO]=((char*)(pValues))[GopYbEO];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPUSHCONSTANTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){[&](){int temp_oWGKgUV;[&](){temp_oWGKgUV=static_cast<int>(value_to<int>(json["stageFlags"]));}();stageFlags=(VkShaderStageFlags)temp_oWGKgUV;}();}();
[&](){offset=static_cast<uint32_t>(value_to<int>(json["offset"]));}();
[&](){size=static_cast<uint32_t>(value_to<int>(json["size"]));}();


debug_printf("Ending vkCmdPushConstants...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderPass( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginRenderPass\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBEGINRENDERPASS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=boost::json::array();
            return; }
        auto& arr_XtnTubd=json["pRenderPassBegin"].emplace_array();
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto& temp=arr_XtnTubd[lCAvoJt].emplace_object();
            return serialize_struct(temp, pRenderPassBegin[lCAvoJt]);
            }();
        }
        }();
[&](){[&](){[&](){json["contents"]=contents;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINRENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

[&](){[&](){int temp_pXPXcBB;[&](){temp_pXPXcBB=static_cast<int>(value_to<int>(json["contents"]));}();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

debug_printf("Ending vkCmdBeginRenderPass...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdNextSubpass( VkCommandBuffer commandBuffer, VkSubpassContents contents ){
//Will only be called by the client
debug_printf("Executing vkCmdNextSubpass\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDNEXTSUBPASS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["contents"]=contents;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDNEXTSUBPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_pXPXcBB;[&](){temp_pXPXcBB=static_cast<int>(value_to<int>(json["contents"]));}();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

debug_printf("Ending vkCmdNextSubpass...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderPass( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndRenderPass\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDENDRENDERPASS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDRENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndRenderPass...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdExecuteCommands( VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers ){
//Will only be called by the client
debug_printf("Executing vkCmdExecuteCommands\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDEXECUTECOMMANDS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["commandBufferCount"]=commandBufferCount;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }
        auto& arr_PdRlpEO=json["pCommandBuffers"].emplace_array();
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDEXECUTECOMMANDS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){commandBufferCount=static_cast<uint32_t>(value_to<int>(json["commandBufferCount"]));}();


debug_printf("Ending vkCmdExecuteCommands...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayPropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayPropertiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_jKVTjSh=json["pProperties"].emplace_array();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto& temp=arr_jKVTjSh[ULwTWiE].emplace_object();
            return serialize_struct(temp, pProperties[ULwTWiE]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_jKVTjSh=json["pProperties"].as_array();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto& temp=arr_jKVTjSh[ULwTWiE].as_object();
            deserialize_struct(temp,pProperties[ULwTWiE]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_ukLWRDF;[&](){temp_ukLWRDF=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_ukLWRDF;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayPropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayPlanePropertiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_TBQSgXa=json["pProperties"].emplace_array();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto& temp=arr_TBQSgXa[yGKhOKS].emplace_object();
            return serialize_struct(temp, pProperties[yGKhOKS]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_TBQSgXa=json["pProperties"].as_array();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto& temp=arr_TBQSgXa[yGKhOKS].as_object();
            deserialize_struct(temp,pProperties[yGKhOKS]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_FyRLWbQ;[&](){temp_FyRLWbQ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_FyRLWbQ;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayPlanePropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayPlanePropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayPlaneSupportedDisplaysKHR( VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayPlaneSupportedDisplaysKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["planeIndex"]=planeIndex;}();
[&](){
            if (pDisplayCount==NULL){
                json["pDisplayCount"]=boost::json::array();
            return; }
        auto& arr_HfQXIoE=json["pDisplayCount"].emplace_array();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){arr_HfQXIoE[tJtenSc]=pDisplayCount[tJtenSc];}();
        }
        }();
[&](){
            if (pDisplays==NULL){
                json["pDisplays"]=boost::json::array();
            return; }
        auto& arr_zfKAWAH=json["pDisplays"].emplace_array();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){serialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV],pDisplays[OSaHdZV]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){planeIndex=static_cast<uint32_t>(value_to<int>(json["planeIndex"]));}();
[&](){
            if (json["pDisplayCount"].as_array().size()==0){
                pDisplayCount=NULL;
            return; }
        auto& arr_HfQXIoE=json["pDisplayCount"].as_array();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){pDisplayCount[tJtenSc]=static_cast<uint32_t>(value_to<int>(arr_HfQXIoE[tJtenSc]));}();
        }
        }();
[&](){
            if (json["pDisplays"].as_array().size()==0){
                pDisplays=NULL;
            return; }
        auto& arr_zfKAWAH=json["pDisplays"].as_array();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){deserialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV], pDisplays[OSaHdZV]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_vlwItRH;[&](){temp_vlwItRH=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_vlwItRH;}();}();

debug_printf("Ending vkGetDisplayPlaneSupportedDisplaysKHR...\n");
debug_printf("Return value of vkGetDisplayPlaneSupportedDisplaysKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayModePropertiesKHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayModePropertiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDISPLAYMODEPROPERTIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_kllbUBl=json["pProperties"].emplace_array();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto& temp=arr_kllbUBl[MCBnXbq].emplace_object();
            return serialize_struct(temp, pProperties[MCBnXbq]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYMODEPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_kllbUBl=json["pProperties"].as_array();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto& temp=arr_kllbUBl[MCBnXbq].as_object();
            deserialize_struct(temp,pProperties[MCBnXbq]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_rFVDHFY;[&](){temp_rFVDHFY=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_rFVDHFY;}();}();

debug_printf("Ending vkGetDisplayModePropertiesKHR...\n");
debug_printf("Return value of vkGetDisplayModePropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDisplayModeKHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode ){
//Will only be called by the client
debug_printf("Executing vkCreateDisplayModeKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEDISPLAYMODEKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_mQflhNS=json["pCreateInfo"].emplace_array();
        for(int UOiSdEd=0; UOiSdEd < 1; UOiSdEd++){
            [&](){
            auto& temp=arr_mQflhNS[UOiSdEd].emplace_object();
            return serialize_struct(temp, pCreateInfo[UOiSdEd]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMode==NULL){
                json["pMode"]=boost::json::array();
            return; }
        auto& arr_CHqKWyT=json["pMode"].emplace_array();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){serialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo],pMode[PRMVnqo]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDISPLAYMODEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();


[&](){
            if (json["pMode"].as_array().size()==0){
                pMode=NULL;
            return; }
        auto& arr_CHqKWyT=json["pMode"].as_array();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){deserialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo], pMode[PRMVnqo]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_QxruGnP;[&](){temp_QxruGnP=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_QxruGnP;}();}();

                if (pMode!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pMode[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDisplayModeKHR...\n");
debug_printf("Return value of vkCreateDisplayModeKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayPlaneCapabilitiesKHR( VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayPlaneCapabilitiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDISPLAYPLANECAPABILITIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayModeKHR(json["mode"],mode);}();
[&](){json["planeIndex"]=planeIndex;}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }
        auto& arr_HrzVMCr=json["pCapabilities"].emplace_array();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto& temp=arr_HrzVMCr[aOxwnlc].emplace_object();
            return serialize_struct(temp, pCapabilities[aOxwnlc]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYPLANECAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayModeKHR(json["mode"], mode);}();
[&](){planeIndex=static_cast<uint32_t>(value_to<int>(json["planeIndex"]));}();
[&](){
            if (json["pCapabilities"].as_array().size()==0){
                pCapabilities=NULL;
            return; }
        auto& arr_HrzVMCr=json["pCapabilities"].as_array();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto& temp=arr_HrzVMCr[aOxwnlc].as_object();
            deserialize_struct(temp,pCapabilities[aOxwnlc]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_BZyFTXN;[&](){temp_BZyFTXN=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_BZyFTXN;}();}();

debug_printf("Ending vkGetDisplayPlaneCapabilitiesKHR...\n");
debug_printf("Return value of vkGetDisplayPlaneCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDisplayPlaneSurfaceKHR( VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateDisplayPlaneSurfaceKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEDISPLAYPLANESURFACEKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_pnrRUFC=json["pCreateInfo"].emplace_array();
        for(int KAVLDOd=0; KAVLDOd < 1; KAVLDOd++){
            [&](){
            auto& temp=arr_pnrRUFC[KAVLDOd].emplace_object();
            return serialize_struct(temp, pCreateInfo[KAVLDOd]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }
        auto& arr_zGtWguc=json["pSurface"].emplace_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDISPLAYPLANESURFACEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pSurface"].as_array().size()==0){
                pSurface=NULL;
            return; }
        auto& arr_zGtWguc=json["pSurface"].as_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_UuVTpcb;[&](){temp_UuVTpcb=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_UuVTpcb;}();}();

                if (pSurface!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSurface[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDisplayPlaneSurfaceKHR...\n");
debug_printf("Return value of vkCreateDisplayPlaneSurfaceKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSharedSwapchainsKHR( VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains ){
//Will only be called by the client
debug_printf("Executing vkCreateSharedSwapchainsKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATESHAREDSWAPCHAINSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=swapchainCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_GXhEUBn=json["pCreateInfos"].emplace_array();
        for(int KSXdUUO=0; KSXdUUO < swapchainCount; KSXdUUO++){
            [&](){
            auto& temp=arr_GXhEUBn[KSXdUUO].emplace_object();
            return serialize_struct(temp, pCreateInfos[KSXdUUO]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=boost::json::array();
            return; }
        auto& arr_UlEaWkU=json["pSwapchains"].emplace_array();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){serialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd],pSwapchains[SREXLhd]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESHAREDSWAPCHAINSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){swapchainCount=static_cast<uint32_t>(value_to<int>(json["swapchainCount"]));}();


[&](){
            if (json["pSwapchains"].as_array().size()==0){
                pSwapchains=NULL;
            return; }
        auto& arr_UlEaWkU=json["pSwapchains"].as_array();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){deserialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd], pSwapchains[SREXLhd]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_pdvkrdy;[&](){temp_pdvkrdy=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_pdvkrdy;}();}();

                if (pSwapchains!=NULL){
                    for (int i=0; i<swapchainCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSwapchains[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSharedSwapchainsKHR...\n");
debug_printf("Return value of vkCreateSharedSwapchainsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySurfaceKHR( VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySurfaceKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYSURFACEKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSURFACEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();


debug_printf("Ending vkDestroySurfaceKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceSupportKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESURFACESUPPORTKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSupported==NULL){
                json["pSupported"]=boost::json::array();
            return; }
        auto& arr_SEnYPHg=json["pSupported"].emplace_array();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){[&](){arr_SEnYPHg[rAhuVoM]=pSupported[rAhuVoM];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACESUPPORTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSupported"].as_array().size()==0){
                pSupported=NULL;
            return; }
        auto& arr_SEnYPHg=json["pSupported"].as_array();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){uint32_t temp_SEnYPHg;[&](){temp_SEnYPHg=static_cast<uint32_t>(value_to<int>(arr_SEnYPHg[rAhuVoM]));}();pSupported[rAhuVoM]=(VkBool32)temp_SEnYPHg;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_gHmWlfE;[&](){temp_gHmWlfE=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_gHmWlfE;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceSupportKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceSupportKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceCapabilitiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESURFACECAPABILITIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }
        auto& arr_mjTYhnS=json["pSurfaceCapabilities"].emplace_array();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto& temp=arr_mjTYhnS[MvYVwuP].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACECAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSurfaceCapabilities"].as_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }
        auto& arr_mjTYhnS=json["pSurfaceCapabilities"].as_array();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto& temp=arr_mjTYhnS[MvYVwuP].as_object();
            deserialize_struct(temp,pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_NxZQRYZ;[&](){temp_NxZQRYZ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_NxZQRYZ;}();}();

        debug_printf("[INFO]: Current extent: %d, %d\n", pSurfaceCapabilities->currentExtent.width, pSurfaceCapabilities->currentExtent.height);
        debug_printf("[INFO]: Min extent: %d, %d\n", pSurfaceCapabilities->minImageExtent.width, pSurfaceCapabilities->minImageExtent.height);
        debug_printf("[INFO]: Max extent: %d, %d\n", pSurfaceCapabilities->maxImageExtent.width, pSurfaceCapabilities->maxImageExtent.height);
        

debug_printf("Ending vkGetPhysicalDeviceSurfaceCapabilitiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceFormatsKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceFormatsKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESURFACEFORMATSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=boost::json::array();
            return; }
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].emplace_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=pSurfaceFormatCount[bFtFQKD];}();
        }
        }();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=boost::json::array();
            return; }
        auto& arr_FttXsVA=json["pSurfaceFormats"].emplace_array();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto& temp=arr_FttXsVA[sioXabq].emplace_object();
            return serialize_struct(temp, pSurfaceFormats[sioXabq]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACEFORMATSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSurfaceFormatCount"].as_array().size()==0){
                pSurfaceFormatCount=NULL;
            return; }
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].as_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(value_to<int>(arr_mbQwRYl[bFtFQKD]));}();
        }
        }();
[&](){
            if (json["pSurfaceFormats"].as_array().size()==0){
                pSurfaceFormats=NULL;
            return; }
        auto& arr_FttXsVA=json["pSurfaceFormats"].as_array();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto& temp=arr_FttXsVA[sioXabq].as_object();
            deserialize_struct(temp,pSurfaceFormats[sioXabq]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_CDkGFTU;[&](){temp_CDkGFTU=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_CDkGFTU;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceFormatsKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceFormatsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfacePresentModesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfacePresentModesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pPresentModeCount==NULL){
                json["pPresentModeCount"]=boost::json::array();
            return; }
        auto& arr_jrQQyxv=json["pPresentModeCount"].emplace_array();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){arr_jrQQyxv[yThsxfd]=pPresentModeCount[yThsxfd];}();
        }
        }();
[&](){
            if (pPresentModes==NULL){
                json["pPresentModes"]=boost::json::array();
            return; }
        auto& arr_hrNyEFX=json["pPresentModes"].emplace_array();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){[&](){arr_hrNyEFX[ULOmMaK]=pPresentModes[ULOmMaK];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pPresentModeCount"].as_array().size()==0){
                pPresentModeCount=NULL;
            return; }
        auto& arr_jrQQyxv=json["pPresentModeCount"].as_array();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){pPresentModeCount[yThsxfd]=static_cast<uint32_t>(value_to<int>(arr_jrQQyxv[yThsxfd]));}();
        }
        }();
[&](){
            if (json["pPresentModes"].as_array().size()==0){
                pPresentModes=NULL;
            return; }
        auto& arr_hrNyEFX=json["pPresentModes"].as_array();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){int temp_ZltIdVU;[&](){temp_ZltIdVU=static_cast<int>(value_to<int>(arr_hrNyEFX[ULOmMaK]));}();pPresentModes[ULOmMaK]=(VkPresentModeKHR)temp_ZltIdVU;}();}();
        }
        }();
VkResult result;
[&](){[&](){int temp_NLAKUDB;[&](){temp_NLAKUDB=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_NLAKUDB;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfacePresentModesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfacePresentModesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSwapchainKHR( VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain ){
//Will only be called by the client
debug_printf("Executing vkCreateSwapchainKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATESWAPCHAINKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{

        VkSwapchainCreateInfoKHR temp_info=*pCreateInfo;
        
        temp_info.imageUsage|=VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
        
        pCreateInfo=&temp_info;
        
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_egkAfIq=json["pCreateInfo"].emplace_array();
        for(int RzLCOHt=0; RzLCOHt < 1; RzLCOHt++){
            [&](){
            auto& temp=arr_egkAfIq[RzLCOHt].emplace_object();
            return serialize_struct(temp, pCreateInfo[RzLCOHt]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSwapchain==NULL){
                json["pSwapchain"]=boost::json::array();
            return; }
        auto& arr_vaTnpgr=json["pSwapchain"].emplace_array();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){serialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc],pSwapchain[KnKufZc]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESWAPCHAINKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSwapchain"].as_array().size()==0){
                pSwapchain=NULL;
            return; }
        auto& arr_vaTnpgr=json["pSwapchain"].as_array();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){deserialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc], pSwapchain[KnKufZc]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_RmneQzw;[&](){temp_RmneQzw=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_RmneQzw;}();}();

                if (pSwapchain!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSwapchain[i])]=parent;
                    }
                }
                
registerSwapchain(*pSwapchain,device, pCreateInfo);

debug_printf("Ending vkCreateSwapchainKHR...\n");
debug_printf("Return value of vkCreateSwapchainKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySwapchainKHR( VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySwapchainKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYSWAPCHAINKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSWAPCHAINKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();


debug_printf("Ending vkDestroySwapchainKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetSwapchainImagesKHR( VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages ){
//Will only be called by the client
debug_printf("Executing vkGetSwapchainImagesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSWAPCHAINIMAGESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pSwapchainImageCount==NULL){
                json["pSwapchainImageCount"]=boost::json::array();
            return; }
        auto& arr_fUdbkNA=json["pSwapchainImageCount"].emplace_array();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){arr_fUdbkNA[YVmxCel]=pSwapchainImageCount[YVmxCel];}();
        }
        }();
[&](){
            if (pSwapchainImages==NULL){
                json["pSwapchainImages"]=boost::json::array();
            return; }
        auto& arr_KNYDiQo=json["pSwapchainImages"].emplace_array();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){serialize_VkImage(arr_KNYDiQo[ICMlCyp],pSwapchainImages[ICMlCyp]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSWAPCHAINIMAGESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["pSwapchainImageCount"].as_array().size()==0){
                pSwapchainImageCount=NULL;
            return; }
        auto& arr_fUdbkNA=json["pSwapchainImageCount"].as_array();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(value_to<int>(arr_fUdbkNA[YVmxCel]));}();
        }
        }();
[&](){
            if (json["pSwapchainImages"].as_array().size()==0){
                pSwapchainImages=NULL;
            return; }
        auto& arr_KNYDiQo=json["pSwapchainImages"].as_array();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){deserialize_VkImage(arr_KNYDiQo[ICMlCyp], pSwapchainImages[ICMlCyp]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_xbmjWOL;[&](){temp_xbmjWOL=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_xbmjWOL;}();}();

debug_printf("Ending vkGetSwapchainImagesKHR...\n");
debug_printf("Return value of vkGetSwapchainImagesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireNextImageKHR( VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex ){
//Will only be called by the client
debug_printf("Executing vkAcquireNextImageKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKACQUIRENEXTIMAGEKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["timeout"]=timeout;}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=boost::json::array();
            return; }
        auto& arr_oSqpNfH=json["pImageIndex"].emplace_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=pImageIndex[BEjuBtR];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIRENEXTIMAGEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){timeout=static_cast<uint64_t>(value_to<int>(json["timeout"]));}();
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
[&](){deserialize_VkFence(json["fence"], fence);}();
[&](){
            if (json["pImageIndex"].as_array().size()==0){
                pImageIndex=NULL;
            return; }
        auto& arr_oSqpNfH=json["pImageIndex"].as_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){pImageIndex[BEjuBtR]=static_cast<uint32_t>(value_to<int>(arr_oSqpNfH[BEjuBtR]));}();
        }
        }();
VkResult result;
[&](){[&](){int temp_iInAhNU;[&](){temp_iInAhNU=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_iInAhNU;}();}();

debug_printf("Ending vkAcquireNextImageKHR...\n");
debug_printf("Return value of vkAcquireNextImageKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueuePresentKHR( VkQueue queue, const VkPresentInfoKHR* pPresentInfo ){
//Will only be called by the client
debug_printf("Executing vkQueuePresentKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKQUEUEPRESENTKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{

        auto new_info=(VkPresentInfoKHR*)copyVkStruct(pPresentInfo);
        
        auto parent_struct=(StreamStructure*)new_info;
        void* curr_struct=copyVkStruct(parent_struct->pNext);
        VkSwapchainPresentFenceInfoEXT* swapchain_fence_info=NULL;
        
        while(curr_struct!=NULL){
            parent_struct->pNext=curr_struct;
            if (((StreamStructure*)curr_struct)->sType==VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT){
                swapchain_fence_info=(VkSwapchainPresentFenceInfoEXT*)curr_struct;
            }
            parent_struct=(StreamStructure*)curr_struct;
            curr_struct=copyVkStruct(parent_struct->pNext);
        }
            
         if (swapchain_fence_info==NULL){
            swapchain_fence_info=new VkSwapchainPresentFenceInfoEXT;
            swapchain_fence_info->sType=VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT;
            swapchain_fence_info->pNext=NULL;
            swapchain_fence_info->swapchainCount=0;
            swapchain_fence_info->pFences=NULL;
            parent_struct->pNext=swapchain_fence_info;
         }
         
         auto old_count=swapchain_fence_info->swapchainCount;
         auto fences_list=(VkFence*)memdup(swapchain_fence_info->pFences,old_count*sizeof(VkFence));
         
         swapchain_fence_info->swapchainCount=new_info->swapchainCount;
         auto new_count=swapchain_fence_info->swapchainCount;
         fences_list=(VkFence*)realloc(fences_list,new_count*sizeof(VkFence));
         swapchain_fence_info->pFences=fences_list;
         
         auto fence_create_info=VkFenceCreateInfo{
         .sType=VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
         .pNext=NULL,
         .flags=0
         };
         
         for (int i=0; i< new_count; i++){
            if ((i>= old_count) || (fences_list[i]==VK_NULL_HANDLE)){
                vkCreateFence(swapchain_to_device[(uintptr_t)(new_info->pSwapchains[i])],&fence_create_info, NULL, &(fences_list[i]));
            }
         }
         
         VkPresentInfoKHR* pPresentInfo=new_info;
         
          std::thread display_thread(QueueDisplay, fences_list, (VkSwapchainKHR*)memdup(pPresentInfo->pSwapchains, new_count*sizeof(VkSwapchainKHR)), (uint32_t*)memdup(pPresentInfo->pImageIndices, new_count*sizeof(uint32_t)), new_count);
          display_thread.detach();
        
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pPresentInfo==NULL){
                json["pPresentInfo"]=boost::json::array();
            return; }
        auto& arr_EyhZHrS=json["pPresentInfo"].emplace_array();
        for(int EKHdNlu=0; EKHdNlu < 1; EKHdNlu++){
            [&](){
            auto& temp=arr_EyhZHrS[EKHdNlu].emplace_object();
            return serialize_struct(temp, pPresentInfo[EKHdNlu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEPRESENTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();

VkResult result;
[&](){[&](){int temp_zgjxZFz;[&](){temp_zgjxZFz=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_zgjxZFz;}();}();

debug_printf("Ending vkQueuePresentKHR...\n");
debug_printf("Return value of vkQueuePresentKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateXlibSurfaceKHR( VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateXlibSurfaceKHR\n");

        auto create_info=VkHeadlessSurfaceCreateInfoEXT{.sType=VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, .pNext=NULL, .flags=0};
        auto result=vkCreateHeadlessSurfaceEXT(instance,&create_info,pAllocator,pSurface);
        if (result!=VK_SUCCESS){
            return result;
        }
        

        registerSurface(*pSurface,pCreateInfo,Xlib);
        
        return result;
        }
        
__attribute__((visibility ("hidden"))) VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceXlibPresentationSupportKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (dpy==NULL){
                json["dpy"]=boost::json::array();
            return; }json["dpy"]=(uintptr_t)dpy;}();
[&](){json["visualID"]=(uintptr_t)visualID;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
[&](){
            if (json["dpy"].as_array().size()==0){
                dpy=NULL;
            return; }dpy=(Display* )(value_to<uintptr_t>(json["dpy"]));}();
[&](){visualID=(VisualID )(value_to<uintptr_t>(json["visualID"]));}();
VkBool32 result;
[&](){uint32_t temp_uHHjUPJ;[&](){temp_uHHjUPJ=static_cast<uint32_t>(value_to<int>(json["result"]));}();result=(VkBool32)temp_uHHjUPJ;}();

debug_printf("Ending vkGetPhysicalDeviceXlibPresentationSupportKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateXcbSurfaceKHR( VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateXcbSurfaceKHR\n");

        auto create_info=VkHeadlessSurfaceCreateInfoEXT{.sType=VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, .pNext=NULL, .flags=0};
        auto result=vkCreateHeadlessSurfaceEXT(instance,&create_info,pAllocator,pSurface);
        if (result!=VK_SUCCESS){
            return result;
        }
        

        registerSurface(*pSurface,pCreateInfo,Xcb);
        
        return result;
        }
        
__attribute__((visibility ("hidden"))) VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceXcbPresentationSupportKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (connection==NULL){
                json["connection"]=boost::json::array();
            return; }json["connection"]=(uintptr_t)connection;}();
[&](){json["visual_id"]=(uintptr_t)visual_id;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
[&](){
            if (json["connection"].as_array().size()==0){
                connection=NULL;
            return; }connection=(xcb_connection_t* )(value_to<uintptr_t>(json["connection"]));}();
[&](){visual_id=(xcb_visualid_t )(value_to<uintptr_t>(json["visual_id"]));}();
VkBool32 result;
[&](){uint32_t temp_mYSXjFA;[&](){temp_mYSXjFA=static_cast<uint32_t>(value_to<int>(json["result"]));}();result=(VkBool32)temp_mYSXjFA;}();

debug_printf("Ending vkGetPhysicalDeviceXcbPresentationSupportKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDebugReportCallbackEXT( VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback ){
//Will only be called by the client
debug_printf("Executing vkCreateDebugReportCallbackEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEDEBUGREPORTCALLBACKEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_YvgjHhM=json["pCreateInfo"].emplace_array();
        for(int BsRBklZ=0; BsRBklZ < 1; BsRBklZ++){
            [&](){
            auto& temp=arr_YvgjHhM[BsRBklZ].emplace_object();
            return serialize_struct(temp, pCreateInfo[BsRBklZ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pCallback==NULL){
                json["pCallback"]=boost::json::array();
            return; }
        auto& arr_qwLilWz=json["pCallback"].emplace_array();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){serialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy],pCallback[GoaYtYy]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEBUGREPORTCALLBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pCallback"].as_array().size()==0){
                pCallback=NULL;
            return; }
        auto& arr_qwLilWz=json["pCallback"].as_array();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){deserialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy], pCallback[GoaYtYy]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_dcGePqW;[&](){temp_dcGePqW=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_dcGePqW;}();}();

                if (pCallback!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pCallback[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDebugReportCallbackEXT...\n");
debug_printf("Return value of vkCreateDebugReportCallbackEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDebugReportCallbackEXT( VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDebugReportCallbackEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYDEBUGREPORTCALLBACKEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugReportCallbackEXT(json["callback"],callback);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEBUGREPORTCALLBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){deserialize_VkDebugReportCallbackEXT(json["callback"], callback);}();


debug_printf("Ending vkDestroyDebugReportCallbackEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkDebugReportMessageEXT( VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage ){
//Will only be called by the client
debug_printf("Executing vkDebugReportMessageEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDEBUGREPORTMESSAGEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["object"]=object;}();
[&](){json["location"]=location;}();
[&](){json["messageCode"]=messageCode;}();
[&](){
            if (pLayerPrefix==NULL){
                json["pLayerPrefix"]=boost::json::array();
            return; }
        auto& arr_SZVAgkt=json["pLayerPrefix"].emplace_array();
        for(int ESuRCqF=0; ESuRCqF < strlen(pLayerPrefix)+1; ESuRCqF++){
            [&](){arr_SZVAgkt[ESuRCqF]=pLayerPrefix[ESuRCqF];}();
        }
        }();
[&](){
            if (pMessage==NULL){
                json["pMessage"]=boost::json::array();
            return; }
        auto& arr_rGBBIki=json["pMessage"].emplace_array();
        for(int ZYKcZZQ=0; ZYKcZZQ < strlen(pMessage)+1; ZYKcZZQ++){
            [&](){arr_rGBBIki[ZYKcZZQ]=pMessage[ZYKcZZQ];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEBUGREPORTMESSAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){[&](){int temp_tiROuYA;[&](){temp_tiROuYA=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkDebugReportFlagsEXT)temp_tiROuYA;}();}();
[&](){[&](){int temp_rGtGMFh;[&](){temp_rGtGMFh=static_cast<int>(value_to<int>(json["objectType"]));}();objectType=(VkDebugReportObjectTypeEXT)temp_rGtGMFh;}();}();
[&](){object=static_cast<uint64_t>(value_to<int>(json["object"]));}();
[&](){location=static_cast<size_t>(value_to<int>(json["location"]));}();
[&](){messageCode=static_cast<int32_t>(value_to<int>(json["messageCode"]));}();



debug_printf("Ending vkDebugReportMessageEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkDebugMarkerSetObjectNameEXT( VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo ){
//Will only be called by the client
debug_printf("Executing vkDebugMarkerSetObjectNameEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDEBUGMARKERSETOBJECTNAMEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=boost::json::array();
            return; }
        auto& arr_WQmILKl=json["pNameInfo"].emplace_array();
        for(int VlhHang=0; VlhHang < 1; VlhHang++){
            [&](){
            auto& temp=arr_WQmILKl[VlhHang].emplace_object();
            return serialize_struct(temp, pNameInfo[VlhHang]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEBUGMARKERSETOBJECTNAMEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_zTVFTax;[&](){temp_zTVFTax=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_zTVFTax;}();}();

debug_printf("Ending vkDebugMarkerSetObjectNameEXT...\n");
debug_printf("Return value of vkDebugMarkerSetObjectNameEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDebugMarkerSetObjectTagEXT( VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo ){
//Will only be called by the client
debug_printf("Executing vkDebugMarkerSetObjectTagEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDEBUGMARKERSETOBJECTTAGEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=boost::json::array();
            return; }
        auto& arr_uESKIxS=json["pTagInfo"].emplace_array();
        for(int fibGciH=0; fibGciH < 1; fibGciH++){
            [&](){
            auto& temp=arr_uESKIxS[fibGciH].emplace_object();
            return serialize_struct(temp, pTagInfo[fibGciH]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEBUGMARKERSETOBJECTTAGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_RXmxilc;[&](){temp_RXmxilc=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_RXmxilc;}();}();

debug_printf("Ending vkDebugMarkerSetObjectTagEXT...\n");
debug_printf("Return value of vkDebugMarkerSetObjectTagEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdDebugMarkerBeginEXT( VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdDebugMarkerBeginEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDEBUGMARKERBEGINEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }
        auto& arr_sUKpmoY=json["pMarkerInfo"].emplace_array();
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto& temp=arr_sUKpmoY[MSMqdqs].emplace_object();
            return serialize_struct(temp, pMarkerInfo[MSMqdqs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDEBUGMARKERBEGINEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdDebugMarkerBeginEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDebugMarkerEndEXT( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdDebugMarkerEndEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDEBUGMARKERENDEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDEBUGMARKERENDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdDebugMarkerEndEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDebugMarkerInsertEXT( VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdDebugMarkerInsertEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDEBUGMARKERINSERTEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }
        auto& arr_sUKpmoY=json["pMarkerInfo"].emplace_array();
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto& temp=arr_sUKpmoY[MSMqdqs].emplace_object();
            return serialize_struct(temp, pMarkerInfo[MSMqdqs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDEBUGMARKERINSERTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdDebugMarkerInsertEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalImageFormatPropertiesNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["externalHandleType"]=externalHandleType;}();}();}();
[&](){
            if (pExternalImageFormatProperties==NULL){
                json["pExternalImageFormatProperties"]=boost::json::array();
            return; }
        auto& arr_gXHGwln=json["pExternalImageFormatProperties"].emplace_array();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto& temp=arr_gXHGwln[CfNLqMF].emplace_object();
            return serialize_struct(temp, pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){[&](){int temp_bMZuPlo;[&](){temp_bMZuPlo=static_cast<int>(value_to<int>(json["type"]));}();type=(VkImageType)temp_bMZuPlo;}();}();
[&](){[&](){int temp_PtqdPDE;[&](){temp_PtqdPDE=static_cast<int>(value_to<int>(json["tiling"]));}();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
[&](){[&](){int temp_sXuQFYv;[&](){temp_sXuQFYv=static_cast<int>(value_to<int>(json["usage"]));}();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
[&](){[&](){int temp_LpOHWxp;[&](){temp_LpOHWxp=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
[&](){[&](){int temp_DSfbDyM;[&](){temp_DSfbDyM=static_cast<int>(value_to<int>(json["externalHandleType"]));}();externalHandleType=(VkExternalMemoryHandleTypeFlagsNV)temp_DSfbDyM;}();}();
[&](){
            if (json["pExternalImageFormatProperties"].as_array().size()==0){
                pExternalImageFormatProperties=NULL;
            return; }
        auto& arr_gXHGwln=json["pExternalImageFormatProperties"].as_array();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto& temp=arr_gXHGwln[CfNLqMF].as_object();
            deserialize_struct(temp,pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_MzDarrQ;[&](){temp_MzDarrQ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_MzDarrQ;}();}();

debug_printf("Ending vkGetPhysicalDeviceExternalImageFormatPropertiesNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceExternalImageFormatPropertiesNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdExecuteGeneratedCommandsNV( VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdExecuteGeneratedCommandsNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDEXECUTEGENERATEDCOMMANDSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["isPreprocessed"]=isPreprocessed;}();}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=boost::json::array();
            return; }
        auto& arr_mvZtJqS=json["pGeneratedCommandsInfo"].emplace_array();
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto& temp=arr_mvZtJqS[breVZQP].emplace_object();
            return serialize_struct(temp, pGeneratedCommandsInfo[breVZQP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDEXECUTEGENERATEDCOMMANDSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_tPMaOPc;[&](){temp_tPMaOPc=static_cast<uint32_t>(value_to<int>(json["isPreprocessed"]));}();isPreprocessed=(VkBool32)temp_tPMaOPc;}();


debug_printf("Ending vkCmdExecuteGeneratedCommandsNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPreprocessGeneratedCommandsNV( VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdPreprocessGeneratedCommandsNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDPREPROCESSGENERATEDCOMMANDSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=boost::json::array();
            return; }
        auto& arr_mvZtJqS=json["pGeneratedCommandsInfo"].emplace_array();
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto& temp=arr_mvZtJqS[breVZQP].emplace_object();
            return serialize_struct(temp, pGeneratedCommandsInfo[breVZQP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPREPROCESSGENERATEDCOMMANDSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdPreprocessGeneratedCommandsNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindPipelineShaderGroupNV( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex ){
//Will only be called by the client
debug_printf("Executing vkCmdBindPipelineShaderGroupNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDPIPELINESHADERGROUPNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["groupIndex"]=groupIndex;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDPIPELINESHADERGROUPNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){groupIndex=static_cast<uint32_t>(value_to<int>(json["groupIndex"]));}();

debug_printf("Ending vkCmdBindPipelineShaderGroupNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetGeneratedCommandsMemoryRequirementsNV( VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetGeneratedCommandsMemoryRequirementsNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_bVjZkmU=json["pInfo"].emplace_array();
        for(int suoLDtj=0; suoLDtj < 1; suoLDtj++){
            [&](){
            auto& temp=arr_bVjZkmU[suoLDtj].emplace_object();
            return serialize_struct(temp, pInfo[suoLDtj]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetGeneratedCommandsMemoryRequirementsNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateIndirectCommandsLayoutNV( VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNV* pIndirectCommandsLayout ){
//Will only be called by the client
debug_printf("Executing vkCreateIndirectCommandsLayoutNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEINDIRECTCOMMANDSLAYOUTNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_EQPGiEt=json["pCreateInfo"].emplace_array();
        for(int TPVCKbG=0; TPVCKbG < 1; TPVCKbG++){
            [&](){
            auto& temp=arr_EQPGiEt[TPVCKbG].emplace_object();
            return serialize_struct(temp, pCreateInfo[TPVCKbG]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pIndirectCommandsLayout==NULL){
                json["pIndirectCommandsLayout"]=boost::json::array();
            return; }
        auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].emplace_array();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){serialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy],pIndirectCommandsLayout[becsFhy]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEINDIRECTCOMMANDSLAYOUTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pIndirectCommandsLayout"].as_array().size()==0){
                pIndirectCommandsLayout=NULL;
            return; }
        auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].as_array();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){deserialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy], pIndirectCommandsLayout[becsFhy]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_pgQBDFz;[&](){temp_pgQBDFz=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_pgQBDFz;}();}();

                if (pIndirectCommandsLayout!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pIndirectCommandsLayout[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateIndirectCommandsLayoutNV...\n");
debug_printf("Return value of vkCreateIndirectCommandsLayoutNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyIndirectCommandsLayoutNV( VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyIndirectCommandsLayoutNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYINDIRECTCOMMANDSLAYOUTNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"],indirectCommandsLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYINDIRECTCOMMANDSLAYOUTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"], indirectCommandsLayout);}();


debug_printf("Ending vkDestroyIndirectCommandsLayoutNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFeatures2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFeatures2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEFEATURES2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=boost::json::array();
            return; }
        auto& arr_QUwriqy=json["pFeatures"].emplace_array();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto& temp=arr_QUwriqy[AlewVZE].emplace_object();
            return serialize_struct(temp, pFeatures[AlewVZE]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFEATURES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pFeatures"].as_array().size()==0){
                pFeatures=NULL;
            return; }
        auto& arr_QUwriqy=json["pFeatures"].as_array();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto& temp=arr_QUwriqy[AlewVZE].as_object();
            deserialize_struct(temp,pFeatures[AlewVZE]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFeatures2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFeatures2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures ){
return vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceProperties2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceProperties2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEPROPERTIES2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_oZVBLox=json["pProperties"].emplace_array();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto& temp=arr_oZVBLox[pxUpVYV].emplace_object();
            return serialize_struct(temp, pProperties[pxUpVYV]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_oZVBLox=json["pProperties"].as_array();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto& temp=arr_oZVBLox[pxUpVYV].as_object();
            deserialize_struct(temp,pProperties[pxUpVYV]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceProperties2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties ){
return vkGetPhysicalDeviceProperties2(physicalDevice, pProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFormatProperties2( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFormatProperties2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEFORMATPROPERTIES2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=boost::json::array();
            return; }
        auto& arr_RNYTnLU=json["pFormatProperties"].emplace_array();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto& temp=arr_RNYTnLU[VZFdkqX].emplace_object();
            return serialize_struct(temp, pFormatProperties[VZFdkqX]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFORMATPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){temp_MKJOJVI=static_cast<int>(value_to<int>(json["format"]));}();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){
            if (json["pFormatProperties"].as_array().size()==0){
                pFormatProperties=NULL;
            return; }
        auto& arr_RNYTnLU=json["pFormatProperties"].as_array();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto& temp=arr_RNYTnLU[VZFdkqX].as_object();
            deserialize_struct(temp,pFormatProperties[VZFdkqX]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFormatProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFormatProperties2KHR( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties ){
return vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceImageFormatProperties2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pImageFormatInfo==NULL){
                json["pImageFormatInfo"]=boost::json::array();
            return; }
        auto& arr_MpVGyYe=json["pImageFormatInfo"].emplace_array();
        for(int YAeYFEt=0; YAeYFEt < 1; YAeYFEt++){
            [&](){
            auto& temp=arr_MpVGyYe[YAeYFEt].emplace_object();
            return serialize_struct(temp, pImageFormatInfo[YAeYFEt]);
            }();
        }
        }();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }
        auto& arr_wmAZzRc=json["pImageFormatProperties"].emplace_array();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto& temp=arr_wmAZzRc[NQfBHSv].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pImageFormatProperties"].as_array().size()==0){
                pImageFormatProperties=NULL;
            return; }
        auto& arr_wmAZzRc=json["pImageFormatProperties"].as_array();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto& temp=arr_wmAZzRc[NQfBHSv].as_object();
            deserialize_struct(temp,pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_vKmyCsh;[&](){temp_vKmyCsh=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_vKmyCsh;}();}();

debug_printf("Ending vkGetPhysicalDeviceImageFormatProperties2...\n");
debug_printf("Return value of vkGetPhysicalDeviceImageFormatProperties2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceImageFormatProperties2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties ){
return vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyProperties2( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceQueueFamilyProperties2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=boost::json::array();
            return; }
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].emplace_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=pQueueFamilyPropertyCount[cPKCUxv];}();
        }
        }();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=boost::json::array();
            return; }
        auto& arr_NqmNsHw=json["pQueueFamilyProperties"].emplace_array();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto& temp=arr_NqmNsHw[UxEWlik].emplace_object();
            return serialize_struct(temp, pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pQueueFamilyPropertyCount"].as_array().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].as_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(value_to<int>(arr_tzRlmPf[cPKCUxv]));}();
        }
        }();
[&](){
            if (json["pQueueFamilyProperties"].as_array().size()==0){
                pQueueFamilyProperties=NULL;
            return; }
        auto& arr_NqmNsHw=json["pQueueFamilyProperties"].as_array();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto& temp=arr_NqmNsHw[UxEWlik].as_object();
            deserialize_struct(temp,pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceQueueFamilyProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties ){
return vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMemoryProperties2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceMemoryProperties2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEMEMORYPROPERTIES2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=boost::json::array();
            return; }
        auto& arr_nJXNYGt=json["pMemoryProperties"].emplace_array();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto& temp=arr_nJXNYGt[tFDFCkf].emplace_object();
            return serialize_struct(temp, pMemoryProperties[tFDFCkf]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEMEMORYPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pMemoryProperties"].as_array().size()==0){
                pMemoryProperties=NULL;
            return; }
        auto& arr_nJXNYGt=json["pMemoryProperties"].as_array();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto& temp=arr_nJXNYGt[tFDFCkf].as_object();
            deserialize_struct(temp,pMemoryProperties[tFDFCkf]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceMemoryProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMemoryProperties2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties ){
return vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceSparseImageFormatProperties2( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSparseImageFormatProperties2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFormatInfo==NULL){
                json["pFormatInfo"]=boost::json::array();
            return; }
        auto& arr_nZOUWlt=json["pFormatInfo"].emplace_array();
        for(int cvknnOe=0; cvknnOe < 1; cvknnOe++){
            [&](){
            auto& temp=arr_nZOUWlt[cvknnOe].emplace_object();
            return serialize_struct(temp, pFormatInfo[cvknnOe]);
            }();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_YaLkATe=json["pProperties"].emplace_array();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto& temp=arr_YaLkATe[lIrIGCv].emplace_object();
            return serialize_struct(temp, pProperties[lIrIGCv]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_YaLkATe=json["pProperties"].as_array();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto& temp=arr_YaLkATe[lIrIGCv].as_object();
            deserialize_struct(temp,pProperties[lIrIGCv]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceSparseImageFormatProperties2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties ){
return vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
__attribute__((visibility ("hidden"))) void vkCmdPushDescriptorSetKHR( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites ){
//Will only be called by the client
debug_printf("Executing vkCmdPushDescriptorSetKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDPUSHDESCRIPTORSETKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
[&](){json["descriptorWriteCount"]=descriptorWriteCount;}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=boost::json::array();
            return; }
        auto& arr_AuOrFWk=json["pDescriptorWrites"].emplace_array();
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto& temp=arr_AuOrFWk[qJACxKx].emplace_object();
            return serialize_struct(temp, pDescriptorWrites[qJACxKx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPUSHDESCRIPTORSETKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){set=static_cast<uint32_t>(value_to<int>(json["set"]));}();
[&](){descriptorWriteCount=static_cast<uint32_t>(value_to<int>(json["descriptorWriteCount"]));}();


debug_printf("Ending vkCmdPushDescriptorSetKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkTrimCommandPool( VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags ){
//Will only be called by the client
debug_printf("Executing vkTrimCommandPool\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKTRIMCOMMANDPOOL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKTRIMCOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
[&](){[&](){int temp_FGvozFl;[&](){temp_FGvozFl=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkCommandPoolTrimFlags)temp_FGvozFl;}();}();

debug_printf("Ending vkTrimCommandPool...\n");
}
__attribute__((visibility ("hidden"))) void vkTrimCommandPoolKHR( VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags ){
return vkTrimCommandPool(device, commandPool, flags);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalBufferProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalBufferProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalBufferInfo==NULL){
                json["pExternalBufferInfo"]=boost::json::array();
            return; }
        auto& arr_VbIxQJg=json["pExternalBufferInfo"].emplace_array();
        for(int XeSwNaV=0; XeSwNaV < 1; XeSwNaV++){
            [&](){
            auto& temp=arr_VbIxQJg[XeSwNaV].emplace_object();
            return serialize_struct(temp, pExternalBufferInfo[XeSwNaV]);
            }();
        }
        }();
[&](){
            if (pExternalBufferProperties==NULL){
                json["pExternalBufferProperties"]=boost::json::array();
            return; }
        auto& arr_oXzExYk=json["pExternalBufferProperties"].emplace_array();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto& temp=arr_oXzExYk[ufvutei].emplace_object();
            return serialize_struct(temp, pExternalBufferProperties[ufvutei]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pExternalBufferProperties"].as_array().size()==0){
                pExternalBufferProperties=NULL;
            return; }
        auto& arr_oXzExYk=json["pExternalBufferProperties"].as_array();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto& temp=arr_oXzExYk[ufvutei].as_object();
            deserialize_struct(temp,pExternalBufferProperties[ufvutei]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceExternalBufferProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalBufferPropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties ){
return vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryFdKHR( VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryFdKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETMEMORYFDKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }
        auto& arr_imCbcqk=json["pGetFdInfo"].emplace_array();
        for(int oZoTEJx=0; oZoTEJx < 1; oZoTEJx++){
            [&](){
            auto& temp=arr_imCbcqk[oZoTEJx].emplace_object();
            return serialize_struct(temp, pGetFdInfo[oZoTEJx]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }
        auto& arr_iYlwGBh=json["pFd"].emplace_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pFd"].as_array().size()==0){
                pFd=NULL;
            return; }
        auto& arr_iYlwGBh=json["pFd"].as_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){pFd[ENGggcC]=static_cast<int>(value_to<int>(arr_iYlwGBh[ENGggcC]));}();
        }
        }();
VkResult result;
[&](){[&](){int temp_OGgLqwm;[&](){temp_OGgLqwm=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_OGgLqwm;}();}();

debug_printf("Ending vkGetMemoryFdKHR...\n");
debug_printf("Return value of vkGetMemoryFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryFdPropertiesKHR( VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryFdPropertiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETMEMORYFDPROPERTIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=handleType;}();}();}();
[&](){json["fd"]=fd;}();
[&](){
            if (pMemoryFdProperties==NULL){
                json["pMemoryFdProperties"]=boost::json::array();
            return; }
        auto& arr_tzzZhYk=json["pMemoryFdProperties"].emplace_array();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto& temp=arr_tzzZhYk[UpKTZRJ].emplace_object();
            return serialize_struct(temp, pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYFDPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_vuWMBJk;[&](){temp_vuWMBJk=static_cast<int>(value_to<int>(json["handleType"]));}();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();
[&](){fd=static_cast<int>(value_to<int>(json["fd"]));}();
[&](){
            if (json["pMemoryFdProperties"].as_array().size()==0){
                pMemoryFdProperties=NULL;
            return; }
        auto& arr_tzzZhYk=json["pMemoryFdProperties"].as_array();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto& temp=arr_tzzZhYk[UpKTZRJ].as_object();
            deserialize_struct(temp,pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_pUkZVXw;[&](){temp_pUkZVXw=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_pUkZVXw;}();}();

debug_printf("Ending vkGetMemoryFdPropertiesKHR...\n");
debug_printf("Return value of vkGetMemoryFdPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryRemoteAddressNV( VkDevice device, const VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo, VkRemoteAddressNV* pAddress ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryRemoteAddressNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETMEMORYREMOTEADDRESSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryGetRemoteAddressInfo==NULL){
                json["pMemoryGetRemoteAddressInfo"]=boost::json::array();
            return; }
        auto& arr_JYmQngD=json["pMemoryGetRemoteAddressInfo"].emplace_array();
        for(int tlzypUU=0; tlzypUU < 1; tlzypUU++){
            [&](){
            auto& temp=arr_JYmQngD[tlzypUU].emplace_object();
            return serialize_struct(temp, pMemoryGetRemoteAddressInfo[tlzypUU]);
            }();
        }
        }();
[&](){
            if (pAddress==NULL){
                json["pAddress"]=boost::json::array();
            return; }
        auto& arr_LTIxmQF=json["pAddress"].emplace_array();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){[&](){
            if (pAddress[LIvckbR]==NULL){
                arr_LTIxmQF[LIvckbR]=boost::json::array();
            return; }[&](){
            if (((char*)(pAddress[LIvckbR]))==NULL){
                arr_LTIxmQF[LIvckbR]=boost::json::array();
            return; }
        auto& arr_ydTJNuu=arr_LTIxmQF[LIvckbR].emplace_array();
        for(int DAUTQtp=0; DAUTQtp < strlen(((char*)(pAddress[LIvckbR])))+1; DAUTQtp++){
            [&](){arr_ydTJNuu[DAUTQtp]=((char*)(pAddress[LIvckbR]))[DAUTQtp];}();
        }
        }();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYREMOTEADDRESSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pAddress"].as_array().size()==0){
                pAddress=NULL;
            return; }
        auto& arr_LTIxmQF=json["pAddress"].as_array();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){void* temp_LTIxmQF;[&](){
            if (arr_LTIxmQF[LIvckbR].as_array().size()==0){
                temp_LTIxmQF=NULL;
            return; }char* temp_KKuuYCW;[&](){
            if (arr_LTIxmQF[LIvckbR].as_array().size()==0){
                temp_KKuuYCW=NULL;
            return; }temp_KKuuYCW=(char*)malloc(arr_LTIxmQF[LIvckbR].as_array().size()*sizeof(char));
        auto& arr_ydTJNuu=arr_LTIxmQF[LIvckbR].as_array();
        for(int DAUTQtp=0; DAUTQtp < arr_LTIxmQF[LIvckbR].as_array().size(); DAUTQtp++){
            [&](){temp_KKuuYCW[DAUTQtp]=static_cast<char>(value_to<int>(arr_ydTJNuu[DAUTQtp]));}();
        }
        }();temp_LTIxmQF=temp_KKuuYCW;}();pAddress[LIvckbR]=(VkRemoteAddressNV)temp_LTIxmQF;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_AAlFXoN;[&](){temp_AAlFXoN=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_AAlFXoN;}();}();

debug_printf("Ending vkGetMemoryRemoteAddressNV...\n");
debug_printf("Return value of vkGetMemoryRemoteAddressNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalSemaphoreProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalSemaphoreProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalSemaphoreInfo==NULL){
                json["pExternalSemaphoreInfo"]=boost::json::array();
            return; }
        auto& arr_qgIgkyH=json["pExternalSemaphoreInfo"].emplace_array();
        for(int VMbMUUS=0; VMbMUUS < 1; VMbMUUS++){
            [&](){
            auto& temp=arr_qgIgkyH[VMbMUUS].emplace_object();
            return serialize_struct(temp, pExternalSemaphoreInfo[VMbMUUS]);
            }();
        }
        }();
[&](){
            if (pExternalSemaphoreProperties==NULL){
                json["pExternalSemaphoreProperties"]=boost::json::array();
            return; }
        auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].emplace_array();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto& temp=arr_yLCjbDt[rKjPzGR].emplace_object();
            return serialize_struct(temp, pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pExternalSemaphoreProperties"].as_array().size()==0){
                pExternalSemaphoreProperties=NULL;
            return; }
        auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].as_array();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto& temp=arr_yLCjbDt[rKjPzGR].as_object();
            deserialize_struct(temp,pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties ){
return vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetSemaphoreFdKHR( VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd ){
//Will only be called by the client
debug_printf("Executing vkGetSemaphoreFdKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSEMAPHOREFDKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }
        auto& arr_fyTHWII=json["pGetFdInfo"].emplace_array();
        for(int dBynwwO=0; dBynwwO < 1; dBynwwO++){
            [&](){
            auto& temp=arr_fyTHWII[dBynwwO].emplace_object();
            return serialize_struct(temp, pGetFdInfo[dBynwwO]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }
        auto& arr_iYlwGBh=json["pFd"].emplace_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSEMAPHOREFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pFd"].as_array().size()==0){
                pFd=NULL;
            return; }
        auto& arr_iYlwGBh=json["pFd"].as_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){pFd[ENGggcC]=static_cast<int>(value_to<int>(arr_iYlwGBh[ENGggcC]));}();
        }
        }();
VkResult result;
[&](){[&](){int temp_lFHgwPB;[&](){temp_lFHgwPB=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_lFHgwPB;}();}();

debug_printf("Ending vkGetSemaphoreFdKHR...\n");
debug_printf("Return value of vkGetSemaphoreFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkImportSemaphoreFdKHR( VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo ){
//Will only be called by the client
debug_printf("Executing vkImportSemaphoreFdKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKIMPORTSEMAPHOREFDKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportSemaphoreFdInfo==NULL){
                json["pImportSemaphoreFdInfo"]=boost::json::array();
            return; }
        auto& arr_vWNEWeX=json["pImportSemaphoreFdInfo"].emplace_array();
        for(int kfpLCyT=0; kfpLCyT < 1; kfpLCyT++){
            [&](){
            auto& temp=arr_vWNEWeX[kfpLCyT].emplace_object();
            return serialize_struct(temp, pImportSemaphoreFdInfo[kfpLCyT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKIMPORTSEMAPHOREFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_WuiagkE;[&](){temp_WuiagkE=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_WuiagkE;}();}();

debug_printf("Ending vkImportSemaphoreFdKHR...\n");
debug_printf("Return value of vkImportSemaphoreFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalFenceProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalFenceProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalFenceInfo==NULL){
                json["pExternalFenceInfo"]=boost::json::array();
            return; }
        auto& arr_DSVeGvM=json["pExternalFenceInfo"].emplace_array();
        for(int ApMvCYQ=0; ApMvCYQ < 1; ApMvCYQ++){
            [&](){
            auto& temp=arr_DSVeGvM[ApMvCYQ].emplace_object();
            return serialize_struct(temp, pExternalFenceInfo[ApMvCYQ]);
            }();
        }
        }();
[&](){
            if (pExternalFenceProperties==NULL){
                json["pExternalFenceProperties"]=boost::json::array();
            return; }
        auto& arr_nPbItsj=json["pExternalFenceProperties"].emplace_array();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto& temp=arr_nPbItsj[VoSEUdo].emplace_object();
            return serialize_struct(temp, pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pExternalFenceProperties"].as_array().size()==0){
                pExternalFenceProperties=NULL;
            return; }
        auto& arr_nPbItsj=json["pExternalFenceProperties"].as_array();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto& temp=arr_nPbItsj[VoSEUdo].as_object();
            deserialize_struct(temp,pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceExternalFenceProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalFencePropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties ){
return vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetFenceFdKHR( VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd ){
//Will only be called by the client
debug_printf("Executing vkGetFenceFdKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETFENCEFDKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }
        auto& arr_mgmOmEV=json["pGetFdInfo"].emplace_array();
        for(int DYSusBe=0; DYSusBe < 1; DYSusBe++){
            [&](){
            auto& temp=arr_mgmOmEV[DYSusBe].emplace_object();
            return serialize_struct(temp, pGetFdInfo[DYSusBe]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }
        auto& arr_iYlwGBh=json["pFd"].emplace_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETFENCEFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pFd"].as_array().size()==0){
                pFd=NULL;
            return; }
        auto& arr_iYlwGBh=json["pFd"].as_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){pFd[ENGggcC]=static_cast<int>(value_to<int>(arr_iYlwGBh[ENGggcC]));}();
        }
        }();
VkResult result;
[&](){[&](){int temp_PZJhnPi;[&](){temp_PZJhnPi=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_PZJhnPi;}();}();

debug_printf("Ending vkGetFenceFdKHR...\n");
debug_printf("Return value of vkGetFenceFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkImportFenceFdKHR( VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo ){
//Will only be called by the client
debug_printf("Executing vkImportFenceFdKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKIMPORTFENCEFDKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportFenceFdInfo==NULL){
                json["pImportFenceFdInfo"]=boost::json::array();
            return; }
        auto& arr_PmxwQMO=json["pImportFenceFdInfo"].emplace_array();
        for(int QSUnAUF=0; QSUnAUF < 1; QSUnAUF++){
            [&](){
            auto& temp=arr_PmxwQMO[QSUnAUF].emplace_object();
            return serialize_struct(temp, pImportFenceFdInfo[QSUnAUF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKIMPORTFENCEFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_amDOBHn;[&](){temp_amDOBHn=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_amDOBHn;}();}();

debug_printf("Ending vkImportFenceFdKHR...\n");
debug_printf("Return value of vkImportFenceFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkReleaseDisplayEXT( VkPhysicalDevice physicalDevice, VkDisplayKHR display ){
//Will only be called by the client
debug_printf("Executing vkReleaseDisplayEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRELEASEDISPLAYEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASEDISPLAYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
VkResult result;
[&](){[&](){int temp_EKgqLcV;[&](){temp_EKgqLcV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_EKgqLcV;}();}();

debug_printf("Ending vkReleaseDisplayEXT...\n");
debug_printf("Return value of vkReleaseDisplayEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDisplayPowerControlEXT( VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo ){
//Will only be called by the client
debug_printf("Executing vkDisplayPowerControlEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDISPLAYPOWERCONTROLEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayPowerInfo==NULL){
                json["pDisplayPowerInfo"]=boost::json::array();
            return; }
        auto& arr_MrfcjyV=json["pDisplayPowerInfo"].emplace_array();
        for(int xtIgTXd=0; xtIgTXd < 1; xtIgTXd++){
            [&](){
            auto& temp=arr_MrfcjyV[xtIgTXd].emplace_object();
            return serialize_struct(temp, pDisplayPowerInfo[xtIgTXd]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDISPLAYPOWERCONTROLEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();

VkResult result;
[&](){[&](){int temp_pjNFHxg;[&](){temp_pjNFHxg=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_pjNFHxg;}();}();

debug_printf("Ending vkDisplayPowerControlEXT...\n");
debug_printf("Return value of vkDisplayPowerControlEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkRegisterDeviceEventEXT( VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence ){
//Will only be called by the client
debug_printf("Executing vkRegisterDeviceEventEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKREGISTERDEVICEEVENTEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceEventInfo==NULL){
                json["pDeviceEventInfo"]=boost::json::array();
            return; }
        auto& arr_PBonFka=json["pDeviceEventInfo"].emplace_array();
        for(int JNqwWzK=0; JNqwWzK < 1; JNqwWzK++){
            [&](){
            auto& temp=arr_PBonFka[JNqwWzK].emplace_object();
            return serialize_struct(temp, pDeviceEventInfo[JNqwWzK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }
        auto& arr_SJohVKr=json["pFence"].emplace_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKREGISTERDEVICEEVENTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFence"].as_array().size()==0){
                pFence=NULL;
            return; }
        auto& arr_SJohVKr=json["pFence"].as_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_GFBzKkr;[&](){temp_GFBzKkr=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_GFBzKkr;}();}();

debug_printf("Ending vkRegisterDeviceEventEXT...\n");
debug_printf("Return value of vkRegisterDeviceEventEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkRegisterDisplayEventEXT( VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence ){
//Will only be called by the client
debug_printf("Executing vkRegisterDisplayEventEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKREGISTERDISPLAYEVENTEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayEventInfo==NULL){
                json["pDisplayEventInfo"]=boost::json::array();
            return; }
        auto& arr_EEWRWgk=json["pDisplayEventInfo"].emplace_array();
        for(int ZywgBIl=0; ZywgBIl < 1; ZywgBIl++){
            [&](){
            auto& temp=arr_EEWRWgk[ZywgBIl].emplace_object();
            return serialize_struct(temp, pDisplayEventInfo[ZywgBIl]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }
        auto& arr_SJohVKr=json["pFence"].emplace_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKREGISTERDISPLAYEVENTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();


[&](){
            if (json["pFence"].as_array().size()==0){
                pFence=NULL;
            return; }
        auto& arr_SJohVKr=json["pFence"].as_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_xeseLpW;[&](){temp_xeseLpW=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_xeseLpW;}();}();

debug_printf("Ending vkRegisterDisplayEventEXT...\n");
debug_printf("Return value of vkRegisterDisplayEventEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetSwapchainCounterEXT( VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue ){
//Will only be called by the client
debug_printf("Executing vkGetSwapchainCounterEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSWAPCHAINCOUNTEREXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){[&](){[&](){json["counter"]=counter;}();}();}();
[&](){
            if (pCounterValue==NULL){
                json["pCounterValue"]=boost::json::array();
            return; }
        auto& arr_VmPfCNz=json["pCounterValue"].emplace_array();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){arr_VmPfCNz[BVcpEyO]=pCounterValue[BVcpEyO];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSWAPCHAINCOUNTEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){[&](){int temp_RusGBTK;[&](){temp_RusGBTK=static_cast<int>(value_to<int>(json["counter"]));}();counter=(VkSurfaceCounterFlagBitsEXT)temp_RusGBTK;}();}();
[&](){
            if (json["pCounterValue"].as_array().size()==0){
                pCounterValue=NULL;
            return; }
        auto& arr_VmPfCNz=json["pCounterValue"].as_array();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){pCounterValue[BVcpEyO]=static_cast<uint64_t>(value_to<int>(arr_VmPfCNz[BVcpEyO]));}();
        }
        }();
VkResult result;
[&](){[&](){int temp_rIkTiqV;[&](){temp_rIkTiqV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_rIkTiqV;}();}();

debug_printf("Ending vkGetSwapchainCounterEXT...\n");
debug_printf("Return value of vkGetSwapchainCounterEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceCapabilities2EXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }
        auto& arr_KYzynfJ=json["pSurfaceCapabilities"].emplace_array();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto& temp=arr_KYzynfJ[QJCcfVY].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSurfaceCapabilities"].as_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }
        auto& arr_KYzynfJ=json["pSurfaceCapabilities"].as_array();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto& temp=arr_KYzynfJ[QJCcfVY].as_object();
            deserialize_struct(temp,pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_uUQHuJg;[&](){temp_uUQHuJg=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_uUQHuJg;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceCapabilities2EXT...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceCapabilities2EXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDeviceGroups( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumeratePhysicalDeviceGroups\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKENUMERATEPHYSICALDEVICEGROUPS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceGroupCount==NULL){
                json["pPhysicalDeviceGroupCount"]=boost::json::array();
            return; }
        auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].emplace_array();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){arr_Cmahtvc[SYfwvYv]=pPhysicalDeviceGroupCount[SYfwvYv];}();
        }
        }();
[&](){
            if (pPhysicalDeviceGroupProperties==NULL){
                json["pPhysicalDeviceGroupProperties"]=boost::json::array();
            return; }
        auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].emplace_array();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto& temp=arr_kSmADNy[LorZWUi].emplace_object();
            return serialize_struct(temp, pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEPHYSICALDEVICEGROUPS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){
            if (json["pPhysicalDeviceGroupCount"].as_array().size()==0){
                pPhysicalDeviceGroupCount=NULL;
            return; }
        auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].as_array();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(value_to<int>(arr_Cmahtvc[SYfwvYv]));}();
        }
        }();
[&](){
            if (json["pPhysicalDeviceGroupProperties"].as_array().size()==0){
                pPhysicalDeviceGroupProperties=NULL;
            return; }
        auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].as_array();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto& temp=arr_kSmADNy[LorZWUi].as_object();
            deserialize_struct(temp,pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_tAUWVlr;[&](){temp_tAUWVlr=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_tAUWVlr;}();}();

debug_printf("Ending vkEnumeratePhysicalDeviceGroups...\n");
debug_printf("Return value of vkEnumeratePhysicalDeviceGroups is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDeviceGroupsKHR( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties ){
return vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceGroupPeerMemoryFeatures( VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceGroupPeerMemoryFeatures\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEGROUPPEERMEMORYFEATURES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["heapIndex"]=heapIndex;}();
[&](){json["localDeviceIndex"]=localDeviceIndex;}();
[&](){json["remoteDeviceIndex"]=remoteDeviceIndex;}();
[&](){
            if (pPeerMemoryFeatures==NULL){
                json["pPeerMemoryFeatures"]=boost::json::array();
            return; }
        auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].emplace_array();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){[&](){arr_IMNDPVx[dvtpqQO]=pPeerMemoryFeatures[dvtpqQO];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEGROUPPEERMEMORYFEATURES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){heapIndex=static_cast<uint32_t>(value_to<int>(json["heapIndex"]));}();
[&](){localDeviceIndex=static_cast<uint32_t>(value_to<int>(json["localDeviceIndex"]));}();
[&](){remoteDeviceIndex=static_cast<uint32_t>(value_to<int>(json["remoteDeviceIndex"]));}();
[&](){
            if (json["pPeerMemoryFeatures"].as_array().size()==0){
                pPeerMemoryFeatures=NULL;
            return; }
        auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].as_array();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){int temp_ohtAtfL;[&](){temp_ohtAtfL=static_cast<int>(value_to<int>(arr_IMNDPVx[dvtpqQO]));}();pPeerMemoryFeatures[dvtpqQO]=(VkPeerMemoryFeatureFlags)temp_ohtAtfL;}();}();
        }
        }();

debug_printf("Ending vkGetDeviceGroupPeerMemoryFeatures...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceGroupPeerMemoryFeaturesKHR( VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures ){
return vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
__attribute__((visibility ("hidden"))) VkResult vkBindBufferMemory2( VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos ){
//Will only be called by the client
debug_printf("Executing vkBindBufferMemory2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBINDBUFFERMEMORY2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }
        auto& arr_NWunNSr=json["pBindInfos"].emplace_array();
        for(int DbCSPHR=0; DbCSPHR < bindInfoCount; DbCSPHR++){
            [&](){
            auto& temp=arr_NWunNSr[DbCSPHR].emplace_object();
            return serialize_struct(temp, pBindInfos[DbCSPHR]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDBUFFERMEMORY2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){bindInfoCount=static_cast<uint32_t>(value_to<int>(json["bindInfoCount"]));}();

VkResult result;
[&](){[&](){int temp_VZgSPJD;[&](){temp_VZgSPJD=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_VZgSPJD;}();}();

debug_printf("Ending vkBindBufferMemory2...\n");
debug_printf("Return value of vkBindBufferMemory2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkBindBufferMemory2KHR( VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos ){
return vkBindBufferMemory2(device, bindInfoCount, pBindInfos);
}
__attribute__((visibility ("hidden"))) VkResult vkBindImageMemory2( VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos ){
//Will only be called by the client
debug_printf("Executing vkBindImageMemory2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBINDIMAGEMEMORY2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }
        auto& arr_FifZmRy=json["pBindInfos"].emplace_array();
        for(int TInZfLo=0; TInZfLo < bindInfoCount; TInZfLo++){
            [&](){
            auto& temp=arr_FifZmRy[TInZfLo].emplace_object();
            return serialize_struct(temp, pBindInfos[TInZfLo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDIMAGEMEMORY2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){bindInfoCount=static_cast<uint32_t>(value_to<int>(json["bindInfoCount"]));}();

VkResult result;
[&](){[&](){int temp_PDbaogl;[&](){temp_PDbaogl=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_PDbaogl;}();}();

debug_printf("Ending vkBindImageMemory2...\n");
debug_printf("Return value of vkBindImageMemory2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkBindImageMemory2KHR( VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos ){
return vkBindImageMemory2(device, bindInfoCount, pBindInfos);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDeviceMask( VkCommandBuffer commandBuffer, uint32_t deviceMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDeviceMask\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEVICEMASK;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["deviceMask"]=deviceMask;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEVICEMASK):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deviceMask=static_cast<uint32_t>(value_to<int>(json["deviceMask"]));}();

debug_printf("Ending vkCmdSetDeviceMask...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDeviceMaskKHR( VkCommandBuffer commandBuffer, uint32_t deviceMask ){
return vkCmdSetDeviceMask(commandBuffer, deviceMask);
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceGroupPresentCapabilitiesKHR( VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceGroupPresentCapabilitiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEGROUPPRESENTCAPABILITIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceGroupPresentCapabilities==NULL){
                json["pDeviceGroupPresentCapabilities"]=boost::json::array();
            return; }
        auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].emplace_array();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto& temp=arr_gEodIfI[HHoUQIw].emplace_object();
            return serialize_struct(temp, pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEGROUPPRESENTCAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["pDeviceGroupPresentCapabilities"].as_array().size()==0){
                pDeviceGroupPresentCapabilities=NULL;
            return; }
        auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].as_array();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto& temp=arr_gEodIfI[HHoUQIw].as_object();
            deserialize_struct(temp,pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_aWJvGQa;[&](){temp_aWJvGQa=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_aWJvGQa;}();}();

debug_printf("Ending vkGetDeviceGroupPresentCapabilitiesKHR...\n");
debug_printf("Return value of vkGetDeviceGroupPresentCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceGroupSurfacePresentModesKHR( VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceGroupSurfacePresentModesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEGROUPSURFACEPRESENTMODESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pModes==NULL){
                json["pModes"]=boost::json::array();
            return; }
        auto& arr_RUtBuZy=json["pModes"].emplace_array();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){[&](){arr_RUtBuZy[OxSHrMn]=pModes[OxSHrMn];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEGROUPSURFACEPRESENTMODESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pModes"].as_array().size()==0){
                pModes=NULL;
            return; }
        auto& arr_RUtBuZy=json["pModes"].as_array();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){int temp_TkvTwGZ;[&](){temp_TkvTwGZ=static_cast<int>(value_to<int>(arr_RUtBuZy[OxSHrMn]));}();pModes[OxSHrMn]=(VkDeviceGroupPresentModeFlagsKHR)temp_TkvTwGZ;}();}();
        }
        }();
VkResult result;
[&](){[&](){int temp_UthFZPH;[&](){temp_UthFZPH=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_UthFZPH;}();}();

debug_printf("Ending vkGetDeviceGroupSurfacePresentModesKHR...\n");
debug_printf("Return value of vkGetDeviceGroupSurfacePresentModesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireNextImage2KHR( VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex ){
//Will only be called by the client
debug_printf("Executing vkAcquireNextImage2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKACQUIRENEXTIMAGE2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=boost::json::array();
            return; }
        auto& arr_plPbild=json["pAcquireInfo"].emplace_array();
        for(int QzLRJum=0; QzLRJum < 1; QzLRJum++){
            [&](){
            auto& temp=arr_plPbild[QzLRJum].emplace_object();
            return serialize_struct(temp, pAcquireInfo[QzLRJum]);
            }();
        }
        }();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=boost::json::array();
            return; }
        auto& arr_oSqpNfH=json["pImageIndex"].emplace_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=pImageIndex[BEjuBtR];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIRENEXTIMAGE2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pImageIndex"].as_array().size()==0){
                pImageIndex=NULL;
            return; }
        auto& arr_oSqpNfH=json["pImageIndex"].as_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){pImageIndex[BEjuBtR]=static_cast<uint32_t>(value_to<int>(arr_oSqpNfH[BEjuBtR]));}();
        }
        }();
VkResult result;
[&](){[&](){int temp_TLCaIVV;[&](){temp_TLCaIVV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_TLCaIVV;}();}();

debug_printf("Ending vkAcquireNextImage2KHR...\n");
debug_printf("Return value of vkAcquireNextImage2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdDispatchBase( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDispatchBase\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDISPATCHBASE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["baseGroupX"]=baseGroupX;}();
[&](){json["baseGroupY"]=baseGroupY;}();
[&](){json["baseGroupZ"]=baseGroupZ;}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDISPATCHBASE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){baseGroupX=static_cast<uint32_t>(value_to<int>(json["baseGroupX"]));}();
[&](){baseGroupY=static_cast<uint32_t>(value_to<int>(json["baseGroupY"]));}();
[&](){baseGroupZ=static_cast<uint32_t>(value_to<int>(json["baseGroupZ"]));}();
[&](){groupCountX=static_cast<uint32_t>(value_to<int>(json["groupCountX"]));}();
[&](){groupCountY=static_cast<uint32_t>(value_to<int>(json["groupCountY"]));}();
[&](){groupCountZ=static_cast<uint32_t>(value_to<int>(json["groupCountZ"]));}();

debug_printf("Ending vkCmdDispatchBase...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDispatchBaseKHR( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
return vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDevicePresentRectanglesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDevicePresentRectanglesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pRectCount==NULL){
                json["pRectCount"]=boost::json::array();
            return; }
        auto& arr_vsEoMvr=json["pRectCount"].emplace_array();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){arr_vsEoMvr[TgFYlRi]=pRectCount[TgFYlRi];}();
        }
        }();
[&](){
            if (pRects==NULL){
                json["pRects"]=boost::json::array();
            return; }
        auto& arr_BxIGDMm=json["pRects"].emplace_array();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto& temp=arr_BxIGDMm[LNnHsjT].emplace_object();
            return serialize_struct(temp, pRects[LNnHsjT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pRectCount"].as_array().size()==0){
                pRectCount=NULL;
            return; }
        auto& arr_vsEoMvr=json["pRectCount"].as_array();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){pRectCount[TgFYlRi]=static_cast<uint32_t>(value_to<int>(arr_vsEoMvr[TgFYlRi]));}();
        }
        }();
[&](){
            if (json["pRects"].as_array().size()==0){
                pRects=NULL;
            return; }
        auto& arr_BxIGDMm=json["pRects"].as_array();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto& temp=arr_BxIGDMm[LNnHsjT].as_object();
            deserialize_struct(temp,pRects[LNnHsjT]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_gIuEnea;[&](){temp_gIuEnea=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_gIuEnea;}();}();

debug_printf("Ending vkGetPhysicalDevicePresentRectanglesKHR...\n");
debug_printf("Return value of vkGetPhysicalDevicePresentRectanglesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorUpdateTemplate( VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate ){
//Will only be called by the client
debug_printf("Executing vkCreateDescriptorUpdateTemplate\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEDESCRIPTORUPDATETEMPLATE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_GOaQfzV=json["pCreateInfo"].emplace_array();
        for(int bDXkRSI=0; bDXkRSI < 1; bDXkRSI++){
            [&](){
            auto& temp=arr_GOaQfzV[bDXkRSI].emplace_object();
            return serialize_struct(temp, pCreateInfo[bDXkRSI]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDescriptorUpdateTemplate==NULL){
                json["pDescriptorUpdateTemplate"]=boost::json::array();
            return; }
        auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].emplace_array();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){serialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS],pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDESCRIPTORUPDATETEMPLATE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pDescriptorUpdateTemplate"].as_array().size()==0){
                pDescriptorUpdateTemplate=NULL;
            return; }
        auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].as_array();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){deserialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS], pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_JrESYAz;[&](){temp_JrESYAz=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_JrESYAz;}();}();

                if (pDescriptorUpdateTemplate!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDescriptorUpdateTemplate[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDescriptorUpdateTemplate...\n");
debug_printf("Return value of vkCreateDescriptorUpdateTemplate is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorUpdateTemplateKHR( VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate ){
return vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorUpdateTemplate( VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDescriptorUpdateTemplate\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYDESCRIPTORUPDATETEMPLATE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDESCRIPTORUPDATETEMPLATE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();


debug_printf("Ending vkDestroyDescriptorUpdateTemplate...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorUpdateTemplateKHR( VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator ){
return vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
}
__attribute__((visibility ("hidden"))) void vkUpdateDescriptorSetWithTemplate( VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData ){
//Will only be called by the client
debug_printf("Executing vkUpdateDescriptorSetWithTemplate\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKUPDATEDESCRIPTORSETWITHTEMPLATE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_wjMrkki=json["pData"].emplace_array();
        for(int qQUyxsG=0; qQUyxsG < strlen(((char*)(pData)))+1; qQUyxsG++){
            [&](){arr_wjMrkki[qQUyxsG]=((char*)(pData))[qQUyxsG];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUPDATEDESCRIPTORSETWITHTEMPLATE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();


debug_printf("Ending vkUpdateDescriptorSetWithTemplate...\n");
}
__attribute__((visibility ("hidden"))) void vkUpdateDescriptorSetWithTemplateKHR( VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData ){
return vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
}
__attribute__((visibility ("hidden"))) void vkCmdPushDescriptorSetWithTemplateKHR( VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData ){
//Will only be called by the client
debug_printf("Executing vkCmdPushDescriptorSetWithTemplateKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_wjMrkki=json["pData"].emplace_array();
        for(int qQUyxsG=0; qQUyxsG < strlen(((char*)(pData)))+1; qQUyxsG++){
            [&](){arr_wjMrkki[qQUyxsG]=((char*)(pData))[qQUyxsG];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){set=static_cast<uint32_t>(value_to<int>(json["set"]));}();


debug_printf("Ending vkCmdPushDescriptorSetWithTemplateKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkSetHdrMetadataEXT( VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata ){
//Will only be called by the client
debug_printf("Executing vkSetHdrMetadataEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKSETHDRMETADATAEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=swapchainCount;}();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=boost::json::array();
            return; }
        auto& arr_ItrwriJ=json["pSwapchains"].emplace_array();
        for(int ButVMnQ=0; ButVMnQ < swapchainCount; ButVMnQ++){
            [&](){serialize_VkSwapchainKHR(arr_ItrwriJ[ButVMnQ],pSwapchains[ButVMnQ]);}();
        }
        }();
[&](){
            if (pMetadata==NULL){
                json["pMetadata"]=boost::json::array();
            return; }
        auto& arr_gUCeGgy=json["pMetadata"].emplace_array();
        for(int qGnEfca=0; qGnEfca < swapchainCount; qGnEfca++){
            [&](){
            auto& temp=arr_gUCeGgy[qGnEfca].emplace_object();
            return serialize_struct(temp, pMetadata[qGnEfca]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETHDRMETADATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){swapchainCount=static_cast<uint32_t>(value_to<int>(json["swapchainCount"]));}();



debug_printf("Ending vkSetHdrMetadataEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetSwapchainStatusKHR( VkDevice device, VkSwapchainKHR swapchain ){
//Will only be called by the client
debug_printf("Executing vkGetSwapchainStatusKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSWAPCHAINSTATUSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSWAPCHAINSTATUSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkResult result;
[&](){[&](){int temp_xfASmzO;[&](){temp_xfASmzO=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_xfASmzO;}();}();

debug_printf("Ending vkGetSwapchainStatusKHR...\n");
debug_printf("Return value of vkGetSwapchainStatusKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetRefreshCycleDurationGOOGLE( VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties ){
//Will only be called by the client
debug_printf("Executing vkGetRefreshCycleDurationGOOGLE\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETREFRESHCYCLEDURATIONGOOGLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pDisplayTimingProperties==NULL){
                json["pDisplayTimingProperties"]=boost::json::array();
            return; }
        auto& arr_nDUaeZL=json["pDisplayTimingProperties"].emplace_array();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto& temp=arr_nDUaeZL[NSFWKiB].emplace_object();
            return serialize_struct(temp, pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETREFRESHCYCLEDURATIONGOOGLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["pDisplayTimingProperties"].as_array().size()==0){
                pDisplayTimingProperties=NULL;
            return; }
        auto& arr_nDUaeZL=json["pDisplayTimingProperties"].as_array();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto& temp=arr_nDUaeZL[NSFWKiB].as_object();
            deserialize_struct(temp,pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_DSOgfaq;[&](){temp_DSOgfaq=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_DSOgfaq;}();}();

debug_printf("Ending vkGetRefreshCycleDurationGOOGLE...\n");
debug_printf("Return value of vkGetRefreshCycleDurationGOOGLE is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPastPresentationTimingGOOGLE( VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings ){
//Will only be called by the client
debug_printf("Executing vkGetPastPresentationTimingGOOGLE\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPASTPRESENTATIONTIMINGGOOGLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pPresentationTimingCount==NULL){
                json["pPresentationTimingCount"]=boost::json::array();
            return; }
        auto& arr_LiCpViZ=json["pPresentationTimingCount"].emplace_array();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){arr_LiCpViZ[ihpxywU]=pPresentationTimingCount[ihpxywU];}();
        }
        }();
[&](){
            if (pPresentationTimings==NULL){
                json["pPresentationTimings"]=boost::json::array();
            return; }
        auto& arr_CGvQjMK=json["pPresentationTimings"].emplace_array();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto& temp=arr_CGvQjMK[CzbyDFb].emplace_object();
            return serialize_struct(temp, pPresentationTimings[CzbyDFb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPASTPRESENTATIONTIMINGGOOGLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["pPresentationTimingCount"].as_array().size()==0){
                pPresentationTimingCount=NULL;
            return; }
        auto& arr_LiCpViZ=json["pPresentationTimingCount"].as_array();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(value_to<int>(arr_LiCpViZ[ihpxywU]));}();
        }
        }();
[&](){
            if (json["pPresentationTimings"].as_array().size()==0){
                pPresentationTimings=NULL;
            return; }
        auto& arr_CGvQjMK=json["pPresentationTimings"].as_array();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto& temp=arr_CGvQjMK[CzbyDFb].as_object();
            deserialize_struct(temp,pPresentationTimings[CzbyDFb]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_lJRRFWO;[&](){temp_lJRRFWO=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_lJRRFWO;}();}();

debug_printf("Ending vkGetPastPresentationTimingGOOGLE...\n");
debug_printf("Return value of vkGetPastPresentationTimingGOOGLE is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWScalingNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportWScalingNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETVIEWPORTWSCALINGNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewportWScalings==NULL){
                json["pViewportWScalings"]=boost::json::array();
            return; }
        auto& arr_gZVGKnq=json["pViewportWScalings"].emplace_array();
        for(int GRZXlou=0; GRZXlou < viewportCount; GRZXlou++){
            [&](){
            auto& temp=arr_gZVGKnq[GRZXlou].emplace_object();
            return serialize_struct(temp, pViewportWScalings[GRZXlou]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTWSCALINGNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstViewport=static_cast<uint32_t>(value_to<int>(json["firstViewport"]));}();
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();


debug_printf("Ending vkCmdSetViewportWScalingNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDiscardRectangleEXT( VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDiscardRectangleEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDISCARDRECTANGLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstDiscardRectangle"]=firstDiscardRectangle;}();
[&](){json["discardRectangleCount"]=discardRectangleCount;}();
[&](){
            if (pDiscardRectangles==NULL){
                json["pDiscardRectangles"]=boost::json::array();
            return; }
        auto& arr_uUeweOj=json["pDiscardRectangles"].emplace_array();
        for(int WtUHHLW=0; WtUHHLW < discardRectangleCount; WtUHHLW++){
            [&](){
            auto& temp=arr_uUeweOj[WtUHHLW].emplace_object();
            return serialize_struct(temp, pDiscardRectangles[WtUHHLW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDISCARDRECTANGLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstDiscardRectangle=static_cast<uint32_t>(value_to<int>(json["firstDiscardRectangle"]));}();
[&](){discardRectangleCount=static_cast<uint32_t>(value_to<int>(json["discardRectangleCount"]));}();


debug_printf("Ending vkCmdSetDiscardRectangleEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDiscardRectangleEnableEXT( VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDiscardRectangleEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDISCARDRECTANGLEENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["discardRectangleEnable"]=discardRectangleEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDISCARDRECTANGLEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_GnHxsqE;[&](){temp_GnHxsqE=static_cast<uint32_t>(value_to<int>(json["discardRectangleEnable"]));}();discardRectangleEnable=(VkBool32)temp_GnHxsqE;}();

debug_printf("Ending vkCmdSetDiscardRectangleEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDiscardRectangleModeEXT( VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDiscardRectangleModeEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDISCARDRECTANGLEMODEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["discardRectangleMode"]=discardRectangleMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDISCARDRECTANGLEMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_iBxDvRc;[&](){temp_iBxDvRc=static_cast<int>(value_to<int>(json["discardRectangleMode"]));}();discardRectangleMode=(VkDiscardRectangleModeEXT)temp_iBxDvRc;}();}();

debug_printf("Ending vkCmdSetDiscardRectangleModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetSampleLocationsEXT( VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetSampleLocationsEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSAMPLELOCATIONSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSampleLocationsInfo==NULL){
                json["pSampleLocationsInfo"]=boost::json::array();
            return; }
        auto& arr_KfRxBlJ=json["pSampleLocationsInfo"].emplace_array();
        for(int XjGOezZ=0; XjGOezZ < 1; XjGOezZ++){
            [&](){
            auto& temp=arr_KfRxBlJ[XjGOezZ].emplace_object();
            return serialize_struct(temp, pSampleLocationsInfo[XjGOezZ]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSAMPLELOCATIONSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdSetSampleLocationsEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMultisamplePropertiesEXT( VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceMultisamplePropertiesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){
            if (pMultisampleProperties==NULL){
                json["pMultisampleProperties"]=boost::json::array();
            return; }
        auto& arr_IduiRHb=json["pMultisampleProperties"].emplace_array();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto& temp=arr_IduiRHb[xJhEIjr].emplace_object();
            return serialize_struct(temp, pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_lbKgbKj;[&](){temp_lbKgbKj=static_cast<int>(value_to<int>(json["samples"]));}();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
[&](){
            if (json["pMultisampleProperties"].as_array().size()==0){
                pMultisampleProperties=NULL;
            return; }
        auto& arr_IduiRHb=json["pMultisampleProperties"].as_array();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto& temp=arr_IduiRHb[xJhEIjr].as_object();
            deserialize_struct(temp,pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceMultisamplePropertiesEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceCapabilities2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=boost::json::array();
            return; }
        auto& arr_kqlTDpj=json["pSurfaceInfo"].emplace_array();
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto& temp=arr_kqlTDpj[yiVsRWe].emplace_object();
            return serialize_struct(temp, pSurfaceInfo[yiVsRWe]);
            }();
        }
        }();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }
        auto& arr_JfroxEi=json["pSurfaceCapabilities"].emplace_array();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto& temp=arr_JfroxEi[Baebpht].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pSurfaceCapabilities"].as_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }
        auto& arr_JfroxEi=json["pSurfaceCapabilities"].as_array();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto& temp=arr_JfroxEi[Baebpht].as_object();
            deserialize_struct(temp,pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_XymsZwX;[&](){temp_XymsZwX=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_XymsZwX;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceCapabilities2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceCapabilities2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceFormats2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceFormats2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESURFACEFORMATS2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=boost::json::array();
            return; }
        auto& arr_kqlTDpj=json["pSurfaceInfo"].emplace_array();
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto& temp=arr_kqlTDpj[yiVsRWe].emplace_object();
            return serialize_struct(temp, pSurfaceInfo[yiVsRWe]);
            }();
        }
        }();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=boost::json::array();
            return; }
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].emplace_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=pSurfaceFormatCount[bFtFQKD];}();
        }
        }();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=boost::json::array();
            return; }
        auto& arr_AuCicsY=json["pSurfaceFormats"].emplace_array();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto& temp=arr_AuCicsY[lVrVWxA].emplace_object();
            return serialize_struct(temp, pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACEFORMATS2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pSurfaceFormatCount"].as_array().size()==0){
                pSurfaceFormatCount=NULL;
            return; }
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].as_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(value_to<int>(arr_mbQwRYl[bFtFQKD]));}();
        }
        }();
[&](){
            if (json["pSurfaceFormats"].as_array().size()==0){
                pSurfaceFormats=NULL;
            return; }
        auto& arr_AuCicsY=json["pSurfaceFormats"].as_array();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto& temp=arr_AuCicsY[lVrVWxA].as_object();
            deserialize_struct(temp,pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_XHVeCWh;[&](){temp_XHVeCWh=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_XHVeCWh;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceFormats2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceFormats2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayProperties2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_WgClQQW=json["pProperties"].emplace_array();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto& temp=arr_WgClQQW[IPCMyur].emplace_object();
            return serialize_struct(temp, pProperties[IPCMyur]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_WgClQQW=json["pProperties"].as_array();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto& temp=arr_WgClQQW[IPCMyur].as_object();
            deserialize_struct(temp,pProperties[IPCMyur]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_tEIQQOJ;[&](){temp_tEIQQOJ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_tEIQQOJ;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayProperties2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayProperties2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayPlaneProperties2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_oqLTQEe=json["pProperties"].emplace_array();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto& temp=arr_oqLTQEe[KJvijjP].emplace_object();
            return serialize_struct(temp, pProperties[KJvijjP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_oqLTQEe=json["pProperties"].as_array();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto& temp=arr_oqLTQEe[KJvijjP].as_object();
            deserialize_struct(temp,pProperties[KJvijjP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_SmiGvTk;[&](){temp_SmiGvTk=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_SmiGvTk;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayPlaneProperties2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayPlaneProperties2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayModeProperties2KHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayModeProperties2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDISPLAYMODEPROPERTIES2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_LvUqkhm=json["pProperties"].emplace_array();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto& temp=arr_LvUqkhm[gThvzcU].emplace_object();
            return serialize_struct(temp, pProperties[gThvzcU]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYMODEPROPERTIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_LvUqkhm=json["pProperties"].as_array();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto& temp=arr_LvUqkhm[gThvzcU].as_object();
            deserialize_struct(temp,pProperties[gThvzcU]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_tuLJGSV;[&](){temp_tuLJGSV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_tuLJGSV;}();}();

debug_printf("Ending vkGetDisplayModeProperties2KHR...\n");
debug_printf("Return value of vkGetDisplayModeProperties2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayPlaneCapabilities2KHR( VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayPlaneCapabilities2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDISPLAYPLANECAPABILITIES2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pDisplayPlaneInfo==NULL){
                json["pDisplayPlaneInfo"]=boost::json::array();
            return; }
        auto& arr_rwBYAlG=json["pDisplayPlaneInfo"].emplace_array();
        for(int iEdZMtQ=0; iEdZMtQ < 1; iEdZMtQ++){
            [&](){
            auto& temp=arr_rwBYAlG[iEdZMtQ].emplace_object();
            return serialize_struct(temp, pDisplayPlaneInfo[iEdZMtQ]);
            }();
        }
        }();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }
        auto& arr_perBkIp=json["pCapabilities"].emplace_array();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto& temp=arr_perBkIp[wDZGRHI].emplace_object();
            return serialize_struct(temp, pCapabilities[wDZGRHI]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYPLANECAPABILITIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pCapabilities"].as_array().size()==0){
                pCapabilities=NULL;
            return; }
        auto& arr_perBkIp=json["pCapabilities"].as_array();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto& temp=arr_perBkIp[wDZGRHI].as_object();
            deserialize_struct(temp,pCapabilities[wDZGRHI]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_xCSQphb;[&](){temp_xCSQphb=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_xCSQphb;}();}();

debug_printf("Ending vkGetDisplayPlaneCapabilities2KHR...\n");
debug_printf("Return value of vkGetDisplayPlaneCapabilities2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetBufferMemoryRequirements2( VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetBufferMemoryRequirements2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETBUFFERMEMORYREQUIREMENTS2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_xrBSgMU=json["pInfo"].emplace_array();
        for(int XaVdoIX=0; XaVdoIX < 1; XaVdoIX++){
            [&](){
            auto& temp=arr_xrBSgMU[XaVdoIX].emplace_object();
            return serialize_struct(temp, pInfo[XaVdoIX]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFERMEMORYREQUIREMENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetBufferMemoryRequirements2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetBufferMemoryRequirements2KHR( VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetImageMemoryRequirements2( VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageMemoryRequirements2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGEMEMORYREQUIREMENTS2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_OVesMNt=json["pInfo"].emplace_array();
        for(int xSwhhlO=0; xSwhhlO < 1; xSwhhlO++){
            [&](){
            auto& temp=arr_OVesMNt[xSwhhlO].emplace_object();
            return serialize_struct(temp, pInfo[xSwhhlO]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEMEMORYREQUIREMENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetImageMemoryRequirements2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageMemoryRequirements2KHR( VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetImageSparseMemoryRequirements2( VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageSparseMemoryRequirements2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGESPARSEMEMORYREQUIREMENTS2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_frlqZZl=json["pInfo"].emplace_array();
        for(int DnuwqwS=0; DnuwqwS < 1; DnuwqwS++){
            [&](){
            auto& temp=arr_frlqZZl[DnuwqwS].emplace_object();
            return serialize_struct(temp, pInfo[DnuwqwS]);
            }();
        }
        }();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].emplace_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].emplace_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESPARSEMEMORYREQUIREMENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pSparseMemoryRequirementCount"].as_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(value_to<int>(arr_QpqRnvg[pFgmjla]));}();
        }
        }();
[&](){
            if (json["pSparseMemoryRequirements"].as_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].as_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].as_object();
            deserialize_struct(temp,pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSparseMemoryRequirements2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSparseMemoryRequirements2KHR( VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
return vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceBufferMemoryRequirements( VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceBufferMemoryRequirements\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEBUFFERMEMORYREQUIREMENTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_LbYKRdp=json["pInfo"].emplace_array();
        for(int sabbuKR=0; sabbuKR < 1; sabbuKR++){
            [&](){
            auto& temp=arr_LbYKRdp[sabbuKR].emplace_object();
            return serialize_struct(temp, pInfo[sabbuKR]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEBUFFERMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceBufferMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceBufferMemoryRequirementsKHR( VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageMemoryRequirements( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceImageMemoryRequirements\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEIMAGEMEMORYREQUIREMENTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_dGiJKQX=json["pInfo"].emplace_array();
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto& temp=arr_dGiJKQX[Hfcgcwr].emplace_object();
            return serialize_struct(temp, pInfo[Hfcgcwr]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEIMAGEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceImageMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageMemoryRequirementsKHR( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageSparseMemoryRequirements( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceImageSparseMemoryRequirements\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_dGiJKQX=json["pInfo"].emplace_array();
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto& temp=arr_dGiJKQX[Hfcgcwr].emplace_object();
            return serialize_struct(temp, pInfo[Hfcgcwr]);
            }();
        }
        }();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].emplace_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].emplace_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pSparseMemoryRequirementCount"].as_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(value_to<int>(arr_QpqRnvg[pFgmjla]));}();
        }
        }();
[&](){
            if (json["pSparseMemoryRequirements"].as_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].as_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].as_object();
            deserialize_struct(temp,pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceImageSparseMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageSparseMemoryRequirementsKHR( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
return vkGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSamplerYcbcrConversion( VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion ){
//Will only be called by the client
debug_printf("Executing vkCreateSamplerYcbcrConversion\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATESAMPLERYCBCRCONVERSION;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_kLHhxUL=json["pCreateInfo"].emplace_array();
        for(int zgqBgkX=0; zgqBgkX < 1; zgqBgkX++){
            [&](){
            auto& temp=arr_kLHhxUL[zgqBgkX].emplace_object();
            return serialize_struct(temp, pCreateInfo[zgqBgkX]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pYcbcrConversion==NULL){
                json["pYcbcrConversion"]=boost::json::array();
            return; }
        auto& arr_joRRIst=json["pYcbcrConversion"].emplace_array();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){serialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr],pYcbcrConversion[VRaBMYr]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESAMPLERYCBCRCONVERSION):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pYcbcrConversion"].as_array().size()==0){
                pYcbcrConversion=NULL;
            return; }
        auto& arr_joRRIst=json["pYcbcrConversion"].as_array();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){deserialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr], pYcbcrConversion[VRaBMYr]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_zweNkqM;[&](){temp_zweNkqM=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_zweNkqM;}();}();

                if (pYcbcrConversion!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pYcbcrConversion[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSamplerYcbcrConversion...\n");
debug_printf("Return value of vkCreateSamplerYcbcrConversion is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSamplerYcbcrConversionKHR( VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion ){
return vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
__attribute__((visibility ("hidden"))) void vkDestroySamplerYcbcrConversion( VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySamplerYcbcrConversion\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYSAMPLERYCBCRCONVERSION;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSamplerYcbcrConversion(json["ycbcrConversion"],ycbcrConversion);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSAMPLERYCBCRCONVERSION):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSamplerYcbcrConversion(json["ycbcrConversion"], ycbcrConversion);}();


debug_printf("Ending vkDestroySamplerYcbcrConversion...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroySamplerYcbcrConversionKHR( VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator ){
return vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceQueue2( VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceQueue2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEQUEUE2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pQueueInfo==NULL){
                json["pQueueInfo"]=boost::json::array();
            return; }
        auto& arr_bNCRimR=json["pQueueInfo"].emplace_array();
        for(int ubuvbaB=0; ubuvbaB < 1; ubuvbaB++){
            [&](){
            auto& temp=arr_bNCRimR[ubuvbaB].emplace_object();
            return serialize_struct(temp, pQueueInfo[ubuvbaB]);
            }();
        }
        }();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=boost::json::array();
            return; }
        auto& arr_rYZbcEA=json["pQueue"].emplace_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEQUEUE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pQueue"].as_array().size()==0){
                pQueue=NULL;
            return; }
        auto& arr_rYZbcEA=json["pQueue"].as_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

debug_printf("Ending vkGetDeviceQueue2...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateValidationCacheEXT( VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache ){
//Will only be called by the client
debug_printf("Executing vkCreateValidationCacheEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEVALIDATIONCACHEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_ZCXiwLp=json["pCreateInfo"].emplace_array();
        for(int XeWuaSR=0; XeWuaSR < 1; XeWuaSR++){
            [&](){
            auto& temp=arr_ZCXiwLp[XeWuaSR].emplace_object();
            return serialize_struct(temp, pCreateInfo[XeWuaSR]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pValidationCache==NULL){
                json["pValidationCache"]=boost::json::array();
            return; }
        auto& arr_oYoDWhC=json["pValidationCache"].emplace_array();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){serialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs],pValidationCache[ejlwFKs]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEVALIDATIONCACHEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pValidationCache"].as_array().size()==0){
                pValidationCache=NULL;
            return; }
        auto& arr_oYoDWhC=json["pValidationCache"].as_array();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){deserialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs], pValidationCache[ejlwFKs]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_aLEbwvl;[&](){temp_aLEbwvl=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_aLEbwvl;}();}();

                if (pValidationCache!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pValidationCache[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateValidationCacheEXT...\n");
debug_printf("Return value of vkCreateValidationCacheEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyValidationCacheEXT( VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyValidationCacheEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYVALIDATIONCACHEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYVALIDATIONCACHEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();


debug_printf("Ending vkDestroyValidationCacheEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetValidationCacheDataEXT( VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetValidationCacheDataEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETVALIDATIONCACHEDATAEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].emplace_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETVALIDATIONCACHEDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();
[&](){
            if (json["pDataSize"].as_array().size()==0){
                pDataSize=NULL;
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].as_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){pDataSize[HCzJfGC]=static_cast<size_t>(value_to<int>(arr_Zcusyfw[HCzJfGC]));}();
        }
        }();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){temp_ZtBEjVJ[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_ZtBEjVJ;}();
VkResult result;
[&](){[&](){int temp_NgivFne;[&](){temp_NgivFne=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_NgivFne;}();}();

debug_printf("Ending vkGetValidationCacheDataEXT...\n");
debug_printf("Return value of vkGetValidationCacheDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkMergeValidationCachesEXT( VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches ){
//Will only be called by the client
debug_printf("Executing vkMergeValidationCachesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKMERGEVALIDATIONCACHESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=srcCacheCount;}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=boost::json::array();
            return; }
        auto& arr_xXUlTaQ=json["pSrcCaches"].emplace_array();
        for(int AJDSLsE=0; AJDSLsE < srcCacheCount; AJDSLsE++){
            [&](){serialize_VkValidationCacheEXT(arr_xXUlTaQ[AJDSLsE],pSrcCaches[AJDSLsE]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMERGEVALIDATIONCACHESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkValidationCacheEXT(json["dstCache"], dstCache);}();
[&](){srcCacheCount=static_cast<uint32_t>(value_to<int>(json["srcCacheCount"]));}();

VkResult result;
[&](){[&](){int temp_FcfMOyA;[&](){temp_FcfMOyA=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_FcfMOyA;}();}();

debug_printf("Ending vkMergeValidationCachesEXT...\n");
debug_printf("Return value of vkMergeValidationCachesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutSupport( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutSupport\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDESCRIPTORSETLAYOUTSUPPORT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_dFRsqIW=json["pCreateInfo"].emplace_array();
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto& temp=arr_dFRsqIW[tUGauKK].emplace_object();
            return serialize_struct(temp, pCreateInfo[tUGauKK]);
            }();
        }
        }();
[&](){
            if (pSupport==NULL){
                json["pSupport"]=boost::json::array();
            return; }
        auto& arr_xgzGluH=json["pSupport"].emplace_array();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto& temp=arr_xgzGluH[UvZyHDI].emplace_object();
            return serialize_struct(temp, pSupport[UvZyHDI]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTSUPPORT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pSupport"].as_array().size()==0){
                pSupport=NULL;
            return; }
        auto& arr_xgzGluH=json["pSupport"].as_array();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto& temp=arr_xgzGluH[UvZyHDI].as_object();
            deserialize_struct(temp,pSupport[UvZyHDI]);
            }();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutSupport...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutSupportKHR( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport ){
return vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
}
__attribute__((visibility ("hidden"))) VkResult vkGetShaderInfoAMD( VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetShaderInfoAMD\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSHADERINFOAMD;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){[&](){[&](){json["shaderStage"]=shaderStage;}();}();}();
[&](){[&](){[&](){json["infoType"]=infoType;}();}();}();
[&](){
            if (pInfoSize==NULL){
                json["pInfoSize"]=boost::json::array();
            return; }
        auto& arr_ouDPuUh=json["pInfoSize"].emplace_array();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){arr_ouDPuUh[wpUCmEy]=pInfoSize[wpUCmEy];}();
        }
        }();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }[&](){
            if (((char*)(pInfo))==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_aWNzgGe=json["pInfo"].emplace_array();
        for(int sqfWcCN=0; sqfWcCN < *pInfoSize; sqfWcCN++){
            [&](){arr_aWNzgGe[sqfWcCN]=((char*)(pInfo))[sqfWcCN];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERINFOAMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){[&](){int temp_nGZQHxq;[&](){temp_nGZQHxq=static_cast<int>(value_to<int>(json["shaderStage"]));}();shaderStage=(VkShaderStageFlagBits)temp_nGZQHxq;}();}();
[&](){[&](){int temp_nNfHNkf;[&](){temp_nNfHNkf=static_cast<int>(value_to<int>(json["infoType"]));}();infoType=(VkShaderInfoTypeAMD)temp_nNfHNkf;}();}();
[&](){
            if (json["pInfoSize"].as_array().size()==0){
                pInfoSize=NULL;
            return; }
        auto& arr_ouDPuUh=json["pInfoSize"].as_array();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){pInfoSize[wpUCmEy]=static_cast<size_t>(value_to<int>(arr_ouDPuUh[wpUCmEy]));}();
        }
        }();
[&](){
            if (json["pInfo"].as_array().size()==0){
                pInfo=NULL;
            return; }char* temp_ziBtDwK;[&](){
            if (json["pInfo"].as_array().size()==0){
                temp_ziBtDwK=NULL;
            return; }
        auto& arr_aWNzgGe=json["pInfo"].as_array();
        for(int sqfWcCN=0; sqfWcCN < *pInfoSize; sqfWcCN++){
            [&](){temp_ziBtDwK[sqfWcCN]=static_cast<char>(value_to<int>(arr_aWNzgGe[sqfWcCN]));}();
        }
        }();pInfo=temp_ziBtDwK;}();
VkResult result;
[&](){[&](){int temp_eQSVrgv;[&](){temp_eQSVrgv=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_eQSVrgv;}();}();

debug_printf("Ending vkGetShaderInfoAMD...\n");
debug_printf("Return value of vkGetShaderInfoAMD is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkSetLocalDimmingAMD( VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable ){
//Will only be called by the client
debug_printf("Executing vkSetLocalDimmingAMD\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKSETLOCALDIMMINGAMD;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapChain"],swapChain);}();
[&](){[&](){json["localDimmingEnable"]=localDimmingEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETLOCALDIMMINGAMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapChain"], swapChain);}();
[&](){uint32_t temp_jfGMipq;[&](){temp_jfGMipq=static_cast<uint32_t>(value_to<int>(json["localDimmingEnable"]));}();localDimmingEnable=(VkBool32)temp_jfGMipq;}();

debug_printf("Ending vkSetLocalDimmingAMD...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT( VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainEXT* pTimeDomains ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceCalibrateableTimeDomainsEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pTimeDomainCount==NULL){
                json["pTimeDomainCount"]=boost::json::array();
            return; }
        auto& arr_siSbERs=json["pTimeDomainCount"].emplace_array();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){arr_siSbERs[xFQhUzA]=pTimeDomainCount[xFQhUzA];}();
        }
        }();
[&](){
            if (pTimeDomains==NULL){
                json["pTimeDomains"]=boost::json::array();
            return; }
        auto& arr_fMkUaJq=json["pTimeDomains"].emplace_array();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){[&](){arr_fMkUaJq[ZiXuFCL]=pTimeDomains[ZiXuFCL];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pTimeDomainCount"].as_array().size()==0){
                pTimeDomainCount=NULL;
            return; }
        auto& arr_siSbERs=json["pTimeDomainCount"].as_array();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(value_to<int>(arr_siSbERs[xFQhUzA]));}();
        }
        }();
[&](){
            if (json["pTimeDomains"].as_array().size()==0){
                pTimeDomains=NULL;
            return; }
        auto& arr_fMkUaJq=json["pTimeDomains"].as_array();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){int temp_EryZVUE;[&](){temp_EryZVUE=static_cast<int>(value_to<int>(arr_fMkUaJq[ZiXuFCL]));}();pTimeDomains[ZiXuFCL]=(VkTimeDomainEXT)temp_EryZVUE;}();}();
        }
        }();
VkResult result;
[&](){[&](){int temp_WDIxlsG;[&](){temp_WDIxlsG=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_WDIxlsG;}();}();

debug_printf("Ending vkGetPhysicalDeviceCalibrateableTimeDomainsEXT...\n");
debug_printf("Return value of vkGetPhysicalDeviceCalibrateableTimeDomainsEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetCalibratedTimestampsEXT( VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation ){
//Will only be called by the client
debug_printf("Executing vkGetCalibratedTimestampsEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETCALIBRATEDTIMESTAMPSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["timestampCount"]=timestampCount;}();
[&](){
            if (pTimestampInfos==NULL){
                json["pTimestampInfos"]=boost::json::array();
            return; }
        auto& arr_XQeyMsT=json["pTimestampInfos"].emplace_array();
        for(int aXwwgcz=0; aXwwgcz < timestampCount; aXwwgcz++){
            [&](){
            auto& temp=arr_XQeyMsT[aXwwgcz].emplace_object();
            return serialize_struct(temp, pTimestampInfos[aXwwgcz]);
            }();
        }
        }();
[&](){
            if (pTimestamps==NULL){
                json["pTimestamps"]=boost::json::array();
            return; }
        auto& arr_CHzcvgg=json["pTimestamps"].emplace_array();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){arr_CHzcvgg[ptqlrVt]=pTimestamps[ptqlrVt];}();
        }
        }();
[&](){
            if (pMaxDeviation==NULL){
                json["pMaxDeviation"]=boost::json::array();
            return; }
        auto& arr_zQmthvJ=json["pMaxDeviation"].emplace_array();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){arr_zQmthvJ[FUkBved]=pMaxDeviation[FUkBved];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETCALIBRATEDTIMESTAMPSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){timestampCount=static_cast<uint32_t>(value_to<int>(json["timestampCount"]));}();

[&](){
            if (json["pTimestamps"].as_array().size()==0){
                pTimestamps=NULL;
            return; }
        auto& arr_CHzcvgg=json["pTimestamps"].as_array();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){pTimestamps[ptqlrVt]=static_cast<uint64_t>(value_to<int>(arr_CHzcvgg[ptqlrVt]));}();
        }
        }();
[&](){
            if (json["pMaxDeviation"].as_array().size()==0){
                pMaxDeviation=NULL;
            return; }
        auto& arr_zQmthvJ=json["pMaxDeviation"].as_array();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){pMaxDeviation[FUkBved]=static_cast<uint64_t>(value_to<int>(arr_zQmthvJ[FUkBved]));}();
        }
        }();
VkResult result;
[&](){[&](){int temp_aXgXwZu;[&](){temp_aXgXwZu=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_aXgXwZu;}();}();

debug_printf("Ending vkGetCalibratedTimestampsEXT...\n");
debug_printf("Return value of vkGetCalibratedTimestampsEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetDebugUtilsObjectNameEXT( VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo ){
//Will only be called by the client
debug_printf("Executing vkSetDebugUtilsObjectNameEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKSETDEBUGUTILSOBJECTNAMEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=boost::json::array();
            return; }
        auto& arr_gpHzyjV=json["pNameInfo"].emplace_array();
        for(int sXDrIfX=0; sXDrIfX < 1; sXDrIfX++){
            [&](){
            auto& temp=arr_gpHzyjV[sXDrIfX].emplace_object();
            return serialize_struct(temp, pNameInfo[sXDrIfX]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETDEBUGUTILSOBJECTNAMEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_yKLOovT;[&](){temp_yKLOovT=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_yKLOovT;}();}();

debug_printf("Ending vkSetDebugUtilsObjectNameEXT...\n");
debug_printf("Return value of vkSetDebugUtilsObjectNameEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetDebugUtilsObjectTagEXT( VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo ){
//Will only be called by the client
debug_printf("Executing vkSetDebugUtilsObjectTagEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKSETDEBUGUTILSOBJECTTAGEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=boost::json::array();
            return; }
        auto& arr_jMraQzd=json["pTagInfo"].emplace_array();
        for(int lQZzjnQ=0; lQZzjnQ < 1; lQZzjnQ++){
            [&](){
            auto& temp=arr_jMraQzd[lQZzjnQ].emplace_object();
            return serialize_struct(temp, pTagInfo[lQZzjnQ]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETDEBUGUTILSOBJECTTAGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_FWYvzMZ;[&](){temp_FWYvzMZ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_FWYvzMZ;}();}();

debug_printf("Ending vkSetDebugUtilsObjectTagEXT...\n");
debug_printf("Return value of vkSetDebugUtilsObjectTagEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkQueueBeginDebugUtilsLabelEXT( VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkQueueBeginDebugUtilsLabelEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKQUEUEBEGINDEBUGUTILSLABELEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }
        auto& arr_GvONoAl=json["pLabelInfo"].emplace_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEBEGINDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();


debug_printf("Ending vkQueueBeginDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkQueueEndDebugUtilsLabelEXT( VkQueue queue ){
//Will only be called by the client
debug_printf("Executing vkQueueEndDebugUtilsLabelEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKQUEUEENDDEBUGUTILSLABELEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEENDDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();

debug_printf("Ending vkQueueEndDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkQueueInsertDebugUtilsLabelEXT( VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkQueueInsertDebugUtilsLabelEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKQUEUEINSERTDEBUGUTILSLABELEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }
        auto& arr_GvONoAl=json["pLabelInfo"].emplace_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEINSERTDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();


debug_printf("Ending vkQueueInsertDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginDebugUtilsLabelEXT( VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginDebugUtilsLabelEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBEGINDEBUGUTILSLABELEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }
        auto& arr_GvONoAl=json["pLabelInfo"].emplace_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndDebugUtilsLabelEXT( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndDebugUtilsLabelEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDENDDEBUGUTILSLABELEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdInsertDebugUtilsLabelEXT( VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdInsertDebugUtilsLabelEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDINSERTDEBUGUTILSLABELEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }
        auto& arr_GvONoAl=json["pLabelInfo"].emplace_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDINSERTDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdInsertDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDebugUtilsMessengerEXT( VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger ){
//Will only be called by the client
debug_printf("Executing vkCreateDebugUtilsMessengerEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEDEBUGUTILSMESSENGEREXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_alrnjyY=json["pCreateInfo"].emplace_array();
        for(int uDOYkhP=0; uDOYkhP < 1; uDOYkhP++){
            [&](){
            auto& temp=arr_alrnjyY[uDOYkhP].emplace_object();
            return serialize_struct(temp, pCreateInfo[uDOYkhP]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMessenger==NULL){
                json["pMessenger"]=boost::json::array();
            return; }
        auto& arr_INDwqtI=json["pMessenger"].emplace_array();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){serialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe],pMessenger[XlveIOe]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEBUGUTILSMESSENGEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pMessenger"].as_array().size()==0){
                pMessenger=NULL;
            return; }
        auto& arr_INDwqtI=json["pMessenger"].as_array();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){deserialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe], pMessenger[XlveIOe]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_txQQPPe;[&](){temp_txQQPPe=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_txQQPPe;}();}();

                if (pMessenger!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pMessenger[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDebugUtilsMessengerEXT...\n");
debug_printf("Return value of vkCreateDebugUtilsMessengerEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDebugUtilsMessengerEXT( VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDebugUtilsMessengerEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYDEBUGUTILSMESSENGEREXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugUtilsMessengerEXT(json["messenger"],messenger);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEBUGUTILSMESSENGEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){deserialize_VkDebugUtilsMessengerEXT(json["messenger"], messenger);}();


debug_printf("Ending vkDestroyDebugUtilsMessengerEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkSubmitDebugUtilsMessageEXT( VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData ){
//Will only be called by the client
debug_printf("Executing vkSubmitDebugUtilsMessageEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKSUBMITDEBUGUTILSMESSAGEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["messageSeverity"]=messageSeverity;}();}();}();
[&](){[&](){[&](){json["messageTypes"]=messageTypes;}();}();}();
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=boost::json::array();
            return; }
        auto& arr_kahfHKb=json["pCallbackData"].emplace_array();
        for(int YuXULtv=0; YuXULtv < 1; YuXULtv++){
            [&](){
            auto& temp=arr_kahfHKb[YuXULtv].emplace_object();
            return serialize_struct(temp, pCallbackData[YuXULtv]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSUBMITDEBUGUTILSMESSAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){[&](){int temp_UpocUQR;[&](){temp_UpocUQR=static_cast<int>(value_to<int>(json["messageSeverity"]));}();messageSeverity=(VkDebugUtilsMessageSeverityFlagBitsEXT)temp_UpocUQR;}();}();
[&](){[&](){int temp_vbjSEUE;[&](){temp_vbjSEUE=static_cast<int>(value_to<int>(json["messageTypes"]));}();messageTypes=(VkDebugUtilsMessageTypeFlagsEXT)temp_vbjSEUE;}();}();


debug_printf("Ending vkSubmitDebugUtilsMessageEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryHostPointerPropertiesEXT( VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryHostPointerPropertiesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETMEMORYHOSTPOINTERPROPERTIESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=handleType;}();}();}();
[&](){
            if (pHostPointer==NULL){
                json["pHostPointer"]=boost::json::array();
            return; }[&](){
            if (((char*)(pHostPointer))==NULL){
                json["pHostPointer"]=boost::json::array();
            return; }
        auto& arr_jCVfueD=json["pHostPointer"].emplace_array();
        for(int ePeFnfT=0; ePeFnfT < strlen(((char*)(pHostPointer)))+1; ePeFnfT++){
            [&](){arr_jCVfueD[ePeFnfT]=((char*)(pHostPointer))[ePeFnfT];}();
        }
        }();}();
[&](){
            if (pMemoryHostPointerProperties==NULL){
                json["pMemoryHostPointerProperties"]=boost::json::array();
            return; }
        auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].emplace_array();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto& temp=arr_CBNxdHG[hqDeAHT].emplace_object();
            return serialize_struct(temp, pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYHOSTPOINTERPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_vuWMBJk;[&](){temp_vuWMBJk=static_cast<int>(value_to<int>(json["handleType"]));}();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();

[&](){
            if (json["pMemoryHostPointerProperties"].as_array().size()==0){
                pMemoryHostPointerProperties=NULL;
            return; }
        auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].as_array();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto& temp=arr_CBNxdHG[hqDeAHT].as_object();
            deserialize_struct(temp,pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_jzFrnFo;[&](){temp_jzFrnFo=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_jzFrnFo;}();}();

debug_printf("Ending vkGetMemoryHostPointerPropertiesEXT...\n");
debug_printf("Return value of vkGetMemoryHostPointerPropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdWriteBufferMarkerAMD( VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteBufferMarkerAMD\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDWRITEBUFFERMARKERAMD;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=pipelineStage;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){json["marker"]=marker;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEBUFFERMARKERAMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_WILNXWI;[&](){temp_WILNXWI=static_cast<int>(value_to<int>(json["pipelineStage"]));}();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){marker=static_cast<uint32_t>(value_to<int>(json["marker"]));}();

debug_printf("Ending vkCmdWriteBufferMarkerAMD...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRenderPass2( VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass ){
//Will only be called by the client
debug_printf("Executing vkCreateRenderPass2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATERENDERPASS2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_cDssBor=json["pCreateInfo"].emplace_array();
        for(int SgbVidQ=0; SgbVidQ < 1; SgbVidQ++){
            [&](){
            auto& temp=arr_cDssBor[SgbVidQ].emplace_object();
            return serialize_struct(temp, pCreateInfo[SgbVidQ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=boost::json::array();
            return; }
        auto& arr_ZwdXTfx=json["pRenderPass"].emplace_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERENDERPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pRenderPass"].as_array().size()==0){
                pRenderPass=NULL;
            return; }
        auto& arr_ZwdXTfx=json["pRenderPass"].as_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_exWajoc;[&](){temp_exWajoc=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_exWajoc;}();}();

                if (pRenderPass!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pRenderPass[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRenderPass2...\n");
debug_printf("Return value of vkCreateRenderPass2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRenderPass2KHR( VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass ){
return vkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderPass2( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginRenderPass2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBEGINRENDERPASS2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=boost::json::array();
            return; }
        auto& arr_XtnTubd=json["pRenderPassBegin"].emplace_array();
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto& temp=arr_XtnTubd[lCAvoJt].emplace_object();
            return serialize_struct(temp, pRenderPassBegin[lCAvoJt]);
            }();
        }
        }();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=boost::json::array();
            return; }
        auto& arr_yxkVVDb=json["pSubpassBeginInfo"].emplace_array();
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto& temp=arr_yxkVVDb[nzkBQUL].emplace_object();
            return serialize_struct(temp, pSubpassBeginInfo[nzkBQUL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINRENDERPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();



debug_printf("Ending vkCmdBeginRenderPass2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderPass2KHR( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo ){
return vkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdNextSubpass2( VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdNextSubpass2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDNEXTSUBPASS2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=boost::json::array();
            return; }
        auto& arr_yxkVVDb=json["pSubpassBeginInfo"].emplace_array();
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto& temp=arr_yxkVVDb[nzkBQUL].emplace_object();
            return serialize_struct(temp, pSubpassBeginInfo[nzkBQUL]);
            }();
        }
        }();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=boost::json::array();
            return; }
        auto& arr_mmmwoMH=json["pSubpassEndInfo"].emplace_array();
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto& temp=arr_mmmwoMH[oMdHEHu].emplace_object();
            return serialize_struct(temp, pSubpassEndInfo[oMdHEHu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDNEXTSUBPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();



debug_printf("Ending vkCmdNextSubpass2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdNextSubpass2KHR( VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo ){
return vkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderPass2( VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdEndRenderPass2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDENDRENDERPASS2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=boost::json::array();
            return; }
        auto& arr_mmmwoMH=json["pSubpassEndInfo"].emplace_array();
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto& temp=arr_mmmwoMH[oMdHEHu].emplace_object();
            return serialize_struct(temp, pSubpassEndInfo[oMdHEHu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDRENDERPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdEndRenderPass2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderPass2KHR( VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo ){
return vkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkGetSemaphoreCounterValue( VkDevice device, VkSemaphore semaphore, uint64_t* pValue ){
//Will only be called by the client
debug_printf("Executing vkGetSemaphoreCounterValue\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSEMAPHORECOUNTERVALUE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pValue==NULL){
                json["pValue"]=boost::json::array();
            return; }
        auto& arr_xnMrErb=json["pValue"].emplace_array();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){arr_xnMrErb[fdUIVMD]=pValue[fdUIVMD];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSEMAPHORECOUNTERVALUE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
[&](){
            if (json["pValue"].as_array().size()==0){
                pValue=NULL;
            return; }
        auto& arr_xnMrErb=json["pValue"].as_array();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){pValue[fdUIVMD]=static_cast<uint64_t>(value_to<int>(arr_xnMrErb[fdUIVMD]));}();
        }
        }();
VkResult result;
[&](){[&](){int temp_VGLApiW;[&](){temp_VGLApiW=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_VGLApiW;}();}();

debug_printf("Ending vkGetSemaphoreCounterValue...\n");
debug_printf("Return value of vkGetSemaphoreCounterValue is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetSemaphoreCounterValueKHR( VkDevice device, VkSemaphore semaphore, uint64_t* pValue ){
return vkGetSemaphoreCounterValue(device, semaphore, pValue);
}
__attribute__((visibility ("hidden"))) VkResult vkWaitSemaphores( VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout ){
//Will only be called by the client
debug_printf("Executing vkWaitSemaphores\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKWAITSEMAPHORES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pWaitInfo==NULL){
                json["pWaitInfo"]=boost::json::array();
            return; }
        auto& arr_xzakrWz=json["pWaitInfo"].emplace_array();
        for(int hsOLCWG=0; hsOLCWG < 1; hsOLCWG++){
            [&](){
            auto& temp=arr_xzakrWz[hsOLCWG].emplace_object();
            return serialize_struct(temp, pWaitInfo[hsOLCWG]);
            }();
        }
        }();
[&](){json["timeout"]=timeout;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWAITSEMAPHORES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){timeout=static_cast<uint64_t>(value_to<int>(json["timeout"]));}();
VkResult result;
[&](){[&](){int temp_wPTLoVi;[&](){temp_wPTLoVi=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_wPTLoVi;}();}();

debug_printf("Ending vkWaitSemaphores...\n");
debug_printf("Return value of vkWaitSemaphores is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkWaitSemaphoresKHR( VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout ){
return vkWaitSemaphores(device, pWaitInfo, timeout);
}
__attribute__((visibility ("hidden"))) VkResult vkSignalSemaphore( VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo ){
//Will only be called by the client
debug_printf("Executing vkSignalSemaphore\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKSIGNALSEMAPHORE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pSignalInfo==NULL){
                json["pSignalInfo"]=boost::json::array();
            return; }
        auto& arr_WdRQTJS=json["pSignalInfo"].emplace_array();
        for(int MYLvJyX=0; MYLvJyX < 1; MYLvJyX++){
            [&](){
            auto& temp=arr_WdRQTJS[MYLvJyX].emplace_object();
            return serialize_struct(temp, pSignalInfo[MYLvJyX]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSIGNALSEMAPHORE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_QmFJpDR;[&](){temp_QmFJpDR=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_QmFJpDR;}();}();

debug_printf("Ending vkSignalSemaphore...\n");
debug_printf("Return value of vkSignalSemaphore is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSignalSemaphoreKHR( VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo ){
return vkSignalSemaphore(device, pSignalInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectCount( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndirectCount\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWINDIRECTCOUNT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDIRECTCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){temp_JpaFKmS=static_cast<uint64_t>(value_to<int>(json["countBufferOffset"]));}();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){maxDrawCount=static_cast<uint32_t>(value_to<int>(json["maxDrawCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDrawIndirectCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirectCount( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndexedIndirectCount\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWINDEXEDINDIRECTCOUNT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDEXEDINDIRECTCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){temp_JpaFKmS=static_cast<uint64_t>(value_to<int>(json["countBufferOffset"]));}();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){maxDrawCount=static_cast<uint32_t>(value_to<int>(json["maxDrawCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDrawIndexedIndirectCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdSetCheckpointNV( VkCommandBuffer commandBuffer, const void* pCheckpointMarker ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCheckpointNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCHECKPOINTNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCheckpointMarker==NULL){
                json["pCheckpointMarker"]=boost::json::array();
            return; }[&](){
            if (((char*)(pCheckpointMarker))==NULL){
                json["pCheckpointMarker"]=boost::json::array();
            return; }
        auto& arr_JthHPaJ=json["pCheckpointMarker"].emplace_array();
        for(int bwenvGE=0; bwenvGE < strlen(((char*)(pCheckpointMarker)))+1; bwenvGE++){
            [&](){arr_JthHPaJ[bwenvGE]=((char*)(pCheckpointMarker))[bwenvGE];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCHECKPOINTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdSetCheckpointNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetQueueCheckpointDataNV( VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData ){
//Will only be called by the client
debug_printf("Executing vkGetQueueCheckpointDataNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETQUEUECHECKPOINTDATANV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=boost::json::array();
            return; }
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].emplace_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=pCheckpointDataCount[lgasnOP];}();
        }
        }();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=boost::json::array();
            return; }
        auto& arr_gxwhODc=json["pCheckpointData"].emplace_array();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto& temp=arr_gxwhODc[TfFHlNo].emplace_object();
            return serialize_struct(temp, pCheckpointData[TfFHlNo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETQUEUECHECKPOINTDATANV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["pCheckpointDataCount"].as_array().size()==0){
                pCheckpointDataCount=NULL;
            return; }
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].as_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(value_to<int>(arr_LsYqVIK[lgasnOP]));}();
        }
        }();
[&](){
            if (json["pCheckpointData"].as_array().size()==0){
                pCheckpointData=NULL;
            return; }
        auto& arr_gxwhODc=json["pCheckpointData"].as_array();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto& temp=arr_gxwhODc[TfFHlNo].as_object();
            deserialize_struct(temp,pCheckpointData[TfFHlNo]);
            }();
        }
        }();

debug_printf("Ending vkGetQueueCheckpointDataNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindTransformFeedbackBuffersEXT( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes ){
//Will only be called by the client
debug_printf("Executing vkCmdBindTransformFeedbackBuffersEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }
        auto& arr_ENtnMTo=json["pBuffers"].emplace_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }
        auto& arr_YvpyTDd=json["pOffsets"].emplace_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=boost::json::array();
            return; }
        auto& arr_OwyEmcF=json["pSizes"].emplace_array();
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=pSizes[YFhxzVl];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstBinding=static_cast<uint32_t>(value_to<int>(json["firstBinding"]));}();
[&](){bindingCount=static_cast<uint32_t>(value_to<int>(json["bindingCount"]));}();




debug_printf("Ending vkCmdBindTransformFeedbackBuffersEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginTransformFeedbackEXT( VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginTransformFeedbackEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBEGINTRANSFORMFEEDBACKEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=firstCounterBuffer;}();
[&](){json["counterBufferCount"]=counterBufferCount;}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=boost::json::array();
            return; }
        auto& arr_eyGyJgR=json["pCounterBuffers"].emplace_array();
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        }();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=boost::json::array();
            return; }
        auto& arr_AiSbQbQ=json["pCounterBufferOffsets"].emplace_array();
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=pCounterBufferOffsets[ThYypfr];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINTRANSFORMFEEDBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstCounterBuffer=static_cast<uint32_t>(value_to<int>(json["firstCounterBuffer"]));}();
[&](){counterBufferCount=static_cast<uint32_t>(value_to<int>(json["counterBufferCount"]));}();



debug_printf("Ending vkCmdBeginTransformFeedbackEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndTransformFeedbackEXT( VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdEndTransformFeedbackEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDENDTRANSFORMFEEDBACKEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=firstCounterBuffer;}();
[&](){json["counterBufferCount"]=counterBufferCount;}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=boost::json::array();
            return; }
        auto& arr_eyGyJgR=json["pCounterBuffers"].emplace_array();
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        }();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=boost::json::array();
            return; }
        auto& arr_AiSbQbQ=json["pCounterBufferOffsets"].emplace_array();
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=pCounterBufferOffsets[ThYypfr];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDTRANSFORMFEEDBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstCounterBuffer=static_cast<uint32_t>(value_to<int>(json["firstCounterBuffer"]));}();
[&](){counterBufferCount=static_cast<uint32_t>(value_to<int>(json["counterBufferCount"]));}();



debug_printf("Ending vkCmdEndTransformFeedbackEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginQueryIndexedEXT( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginQueryIndexedEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBEGINQUERYINDEXEDEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){json["index"]=index;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINQUERYINDEXEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();
[&](){[&](){int temp_iyzDJOK;[&](){temp_iyzDJOK=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();
[&](){index=static_cast<uint32_t>(value_to<int>(json["index"]));}();

debug_printf("Ending vkCmdBeginQueryIndexedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndQueryIndexedEXT( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index ){
//Will only be called by the client
debug_printf("Executing vkCmdEndQueryIndexedEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDENDQUERYINDEXEDEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){json["index"]=index;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDQUERYINDEXEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();
[&](){index=static_cast<uint32_t>(value_to<int>(json["index"]));}();

debug_printf("Ending vkCmdEndQueryIndexedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectByteCountEXT( VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndirectByteCountEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWINDIRECTBYTECOUNTEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){serialize_VkBuffer(json["counterBuffer"],counterBuffer);}();
[&](){[&](){json["counterBufferOffset"]=counterBufferOffset;}();}();
[&](){json["counterOffset"]=counterOffset;}();
[&](){json["vertexStride"]=vertexStride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDIRECTBYTECOUNTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){instanceCount=static_cast<uint32_t>(value_to<int>(json["instanceCount"]));}();
[&](){firstInstance=static_cast<uint32_t>(value_to<int>(json["firstInstance"]));}();
[&](){deserialize_VkBuffer(json["counterBuffer"], counterBuffer);}();
[&](){uint64_t temp_AQwWAlK;[&](){temp_AQwWAlK=static_cast<uint64_t>(value_to<int>(json["counterBufferOffset"]));}();counterBufferOffset=(VkDeviceSize)temp_AQwWAlK;}();
[&](){counterOffset=static_cast<uint32_t>(value_to<int>(json["counterOffset"]));}();
[&](){vertexStride=static_cast<uint32_t>(value_to<int>(json["vertexStride"]));}();

debug_printf("Ending vkCmdDrawIndirectByteCountEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetExclusiveScissorNV( VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors ){
//Will only be called by the client
debug_printf("Executing vkCmdSetExclusiveScissorNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETEXCLUSIVESCISSORNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=firstExclusiveScissor;}();
[&](){json["exclusiveScissorCount"]=exclusiveScissorCount;}();
[&](){
            if (pExclusiveScissors==NULL){
                json["pExclusiveScissors"]=boost::json::array();
            return; }
        auto& arr_aPFLQnr=json["pExclusiveScissors"].emplace_array();
        for(int uoWCiOs=0; uoWCiOs < exclusiveScissorCount; uoWCiOs++){
            [&](){
            auto& temp=arr_aPFLQnr[uoWCiOs].emplace_object();
            return serialize_struct(temp, pExclusiveScissors[uoWCiOs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEXCLUSIVESCISSORNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstExclusiveScissor=static_cast<uint32_t>(value_to<int>(json["firstExclusiveScissor"]));}();
[&](){exclusiveScissorCount=static_cast<uint32_t>(value_to<int>(json["exclusiveScissorCount"]));}();


debug_printf("Ending vkCmdSetExclusiveScissorNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetExclusiveScissorEnableNV( VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32* pExclusiveScissorEnables ){
//Will only be called by the client
debug_printf("Executing vkCmdSetExclusiveScissorEnableNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETEXCLUSIVESCISSORENABLENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=firstExclusiveScissor;}();
[&](){json["exclusiveScissorCount"]=exclusiveScissorCount;}();
[&](){
            if (pExclusiveScissorEnables==NULL){
                json["pExclusiveScissorEnables"]=boost::json::array();
            return; }
        auto& arr_xqHCjsr=json["pExclusiveScissorEnables"].emplace_array();
        for(int ZwZaOgk=0; ZwZaOgk < exclusiveScissorCount; ZwZaOgk++){
            [&](){[&](){arr_xqHCjsr[ZwZaOgk]=pExclusiveScissorEnables[ZwZaOgk];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEXCLUSIVESCISSORENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstExclusiveScissor=static_cast<uint32_t>(value_to<int>(json["firstExclusiveScissor"]));}();
[&](){exclusiveScissorCount=static_cast<uint32_t>(value_to<int>(json["exclusiveScissorCount"]));}();


debug_printf("Ending vkCmdSetExclusiveScissorEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindShadingRateImageNV( VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout ){
//Will only be called by the client
debug_printf("Executing vkCmdBindShadingRateImageNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDSHADINGRATEIMAGENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDSHADINGRATEIMAGENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
[&](){[&](){int temp_VgsvIeW;[&](){temp_VgsvIeW=static_cast<int>(value_to<int>(json["imageLayout"]));}();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

debug_printf("Ending vkCmdBindShadingRateImageNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportShadingRatePaletteNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportShadingRatePaletteNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETVIEWPORTSHADINGRATEPALETTENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pShadingRatePalettes==NULL){
                json["pShadingRatePalettes"]=boost::json::array();
            return; }
        auto& arr_QGCIyPL=json["pShadingRatePalettes"].emplace_array();
        for(int iwmSeHU=0; iwmSeHU < viewportCount; iwmSeHU++){
            [&](){
            auto& temp=arr_QGCIyPL[iwmSeHU].emplace_object();
            return serialize_struct(temp, pShadingRatePalettes[iwmSeHU]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTSHADINGRATEPALETTENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstViewport=static_cast<uint32_t>(value_to<int>(json["firstViewport"]));}();
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();


debug_printf("Ending vkCmdSetViewportShadingRatePaletteNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoarseSampleOrderNV( VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoarseSampleOrderNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOARSESAMPLEORDERNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["sampleOrderType"]=sampleOrderType;}();}();}();
[&](){json["customSampleOrderCount"]=customSampleOrderCount;}();
[&](){
            if (pCustomSampleOrders==NULL){
                json["pCustomSampleOrders"]=boost::json::array();
            return; }
        auto& arr_UoJKhih=json["pCustomSampleOrders"].emplace_array();
        for(int nBPVlSV=0; nBPVlSV < customSampleOrderCount; nBPVlSV++){
            [&](){
            auto& temp=arr_UoJKhih[nBPVlSV].emplace_object();
            return serialize_struct(temp, pCustomSampleOrders[nBPVlSV]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOARSESAMPLEORDERNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_iGYbmmy;[&](){temp_iGYbmmy=static_cast<int>(value_to<int>(json["sampleOrderType"]));}();sampleOrderType=(VkCoarseSampleOrderTypeNV)temp_iGYbmmy;}();}();
[&](){customSampleOrderCount=static_cast<uint32_t>(value_to<int>(json["customSampleOrderCount"]));}();


debug_printf("Ending vkCmdSetCoarseSampleOrderNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksNV( VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWMESHTASKSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["taskCount"]=taskCount;}();
[&](){json["firstTask"]=firstTask;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){taskCount=static_cast<uint32_t>(value_to<int>(json["taskCount"]));}();
[&](){firstTask=static_cast<uint32_t>(value_to<int>(json["firstTask"]));}();

debug_printf("Ending vkCmdDrawMeshTasksNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectNV( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWMESHTASKSINDIRECTNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDrawMeshTasksIndirectNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectCountNV( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectCountNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWMESHTASKSINDIRECTCOUNTNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTCOUNTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){temp_JpaFKmS=static_cast<uint64_t>(value_to<int>(json["countBufferOffset"]));}();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){maxDrawCount=static_cast<uint32_t>(value_to<int>(json["maxDrawCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDrawMeshTasksIndirectCountNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksEXT( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWMESHTASKSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){groupCountX=static_cast<uint32_t>(value_to<int>(json["groupCountX"]));}();
[&](){groupCountY=static_cast<uint32_t>(value_to<int>(json["groupCountY"]));}();
[&](){groupCountZ=static_cast<uint32_t>(value_to<int>(json["groupCountZ"]));}();

debug_printf("Ending vkCmdDrawMeshTasksEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectEXT( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWMESHTASKSINDIRECTEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){drawCount=static_cast<uint32_t>(value_to<int>(json["drawCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDrawMeshTasksIndirectEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectCountEXT( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectCountEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){temp_JpaFKmS=static_cast<uint64_t>(value_to<int>(json["countBufferOffset"]));}();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){maxDrawCount=static_cast<uint32_t>(value_to<int>(json["maxDrawCount"]));}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDrawMeshTasksIndirectCountEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCompileDeferredNV( VkDevice device, VkPipeline pipeline, uint32_t shader ){
//Will only be called by the client
debug_printf("Executing vkCompileDeferredNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOMPILEDEFERREDNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["shader"]=shader;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOMPILEDEFERREDNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){shader=static_cast<uint32_t>(value_to<int>(json["shader"]));}();
VkResult result;
[&](){[&](){int temp_QQQvTJv;[&](){temp_QQQvTJv=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_QQQvTJv;}();}();

debug_printf("Ending vkCompileDeferredNV...\n");
debug_printf("Return value of vkCompileDeferredNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateAccelerationStructureNV( VkDevice device, const VkAccelerationStructureCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureNV* pAccelerationStructure ){
//Will only be called by the client
debug_printf("Executing vkCreateAccelerationStructureNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEACCELERATIONSTRUCTURENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_cRwwWhs=json["pCreateInfo"].emplace_array();
        for(int oEOLGTm=0; oEOLGTm < 1; oEOLGTm++){
            [&](){
            auto& temp=arr_cRwwWhs[oEOLGTm].emplace_object();
            return serialize_struct(temp, pCreateInfo[oEOLGTm]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=boost::json::array();
            return; }
        auto& arr_FUsucto=json["pAccelerationStructure"].emplace_array();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){serialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM],pAccelerationStructure[tRSoAUM]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pAccelerationStructure"].as_array().size()==0){
                pAccelerationStructure=NULL;
            return; }
        auto& arr_FUsucto=json["pAccelerationStructure"].as_array();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){deserialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM], pAccelerationStructure[tRSoAUM]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_GbqTTfb;[&](){temp_GbqTTfb=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_GbqTTfb;}();}();

                if (pAccelerationStructure!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pAccelerationStructure[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateAccelerationStructureNV...\n");
debug_printf("Return value of vkCreateAccelerationStructureNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBindInvocationMaskHUAWEI( VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout ){
//Will only be called by the client
debug_printf("Executing vkCmdBindInvocationMaskHUAWEI\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDINVOCATIONMASKHUAWEI;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDINVOCATIONMASKHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
[&](){[&](){int temp_VgsvIeW;[&](){temp_VgsvIeW=static_cast<int>(value_to<int>(json["imageLayout"]));}();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

debug_printf("Ending vkCmdBindInvocationMaskHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyAccelerationStructureKHR( VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyAccelerationStructureKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYACCELERATIONSTRUCTUREKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureKHR(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkAccelerationStructureKHR(json["accelerationStructure"], accelerationStructure);}();


debug_printf("Ending vkDestroyAccelerationStructureKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyAccelerationStructureNV( VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyAccelerationStructureNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYACCELERATIONSTRUCTURENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();


debug_printf("Ending vkDestroyAccelerationStructureNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetAccelerationStructureMemoryRequirementsNV( VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureMemoryRequirementsNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_QKzjkmC=json["pInfo"].emplace_array();
        for(int eEDmZTf=0; eEDmZTf < 1; eEDmZTf++){
            [&](){
            auto& temp=arr_QKzjkmC[eEDmZTf].emplace_object();
            return serialize_struct(temp, pInfo[eEDmZTf]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_lzklPBG=json["pMemoryRequirements"].emplace_array();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto& temp=arr_lzklPBG[HmtSVPA].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_lzklPBG=json["pMemoryRequirements"].as_array();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto& temp=arr_lzklPBG[HmtSVPA].as_object();
            deserialize_struct(temp,pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();

debug_printf("Ending vkGetAccelerationStructureMemoryRequirementsNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindAccelerationStructureMemoryNV( VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos ){
//Will only be called by the client
debug_printf("Executing vkBindAccelerationStructureMemoryNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBINDACCELERATIONSTRUCTUREMEMORYNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }
        auto& arr_rhzkvXd=json["pBindInfos"].emplace_array();
        for(int tRvmYFr=0; tRvmYFr < bindInfoCount; tRvmYFr++){
            [&](){
            auto& temp=arr_rhzkvXd[tRvmYFr].emplace_object();
            return serialize_struct(temp, pBindInfos[tRvmYFr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDACCELERATIONSTRUCTUREMEMORYNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){bindInfoCount=static_cast<uint32_t>(value_to<int>(json["bindInfoCount"]));}();

VkResult result;
[&](){[&](){int temp_TCzSJYj;[&](){temp_TCzSJYj=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_TCzSJYj;}();}();

debug_printf("Ending vkBindAccelerationStructureMemoryNV...\n");
debug_printf("Return value of vkBindAccelerationStructureMemoryNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyAccelerationStructureNV( VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyAccelerationStructureNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYACCELERATIONSTRUCTURENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){[&](){[&](){json["mode"]=mode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
[&](){[&](){int temp_KfOqWqs;[&](){temp_KfOqWqs=static_cast<int>(value_to<int>(json["mode"]));}();mode=(VkCopyAccelerationStructureModeKHR)temp_KfOqWqs;}();}();

debug_printf("Ending vkCmdCopyAccelerationStructureNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyAccelerationStructureKHR( VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyAccelerationStructureKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYACCELERATIONSTRUCTUREKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_mSSajtp=json["pInfo"].emplace_array();
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto& temp=arr_mSSajtp[ghvrBgW].emplace_object();
            return serialize_struct(temp, pInfo[ghvrBgW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyAccelerationStructureKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyAccelerationStructureKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyAccelerationStructureKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOPYACCELERATIONSTRUCTUREKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_mSSajtp=json["pInfo"].emplace_array();
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto& temp=arr_mSSajtp[ghvrBgW].emplace_object();
            return serialize_struct(temp, pInfo[ghvrBgW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_nUbvWlj;[&](){temp_nUbvWlj=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_nUbvWlj;}();}();

debug_printf("Ending vkCopyAccelerationStructureKHR...\n");
debug_printf("Return value of vkCopyAccelerationStructureKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyAccelerationStructureToMemoryKHR( VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyAccelerationStructureToMemoryKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_MpzusRq=json["pInfo"].emplace_array();
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto& temp=arr_MpzusRq[hToWSKz].emplace_object();
            return serialize_struct(temp, pInfo[hToWSKz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyAccelerationStructureToMemoryKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyAccelerationStructureToMemoryKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyAccelerationStructureToMemoryKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_MpzusRq=json["pInfo"].emplace_array();
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto& temp=arr_MpzusRq[hToWSKz].emplace_object();
            return serialize_struct(temp, pInfo[hToWSKz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_uCkIOop;[&](){temp_uCkIOop=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_uCkIOop;}();}();

debug_printf("Ending vkCopyAccelerationStructureToMemoryKHR...\n");
debug_printf("Return value of vkCopyAccelerationStructureToMemoryKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryToAccelerationStructureKHR( VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryToAccelerationStructureKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_yRNSaUF=json["pInfo"].emplace_array();
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto& temp=arr_yRNSaUF[ulOBYSb].emplace_object();
            return serialize_struct(temp, pInfo[ulOBYSb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMemoryToAccelerationStructureKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMemoryToAccelerationStructureKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMemoryToAccelerationStructureKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_yRNSaUF=json["pInfo"].emplace_array();
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto& temp=arr_yRNSaUF[ulOBYSb].emplace_object();
            return serialize_struct(temp, pInfo[ulOBYSb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_HusVZhG;[&](){temp_HusVZhG=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_HusVZhG;}();}();

debug_printf("Ending vkCopyMemoryToAccelerationStructureKHR...\n");
debug_printf("Return value of vkCopyMemoryToAccelerationStructureKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdWriteAccelerationStructuresPropertiesKHR( VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteAccelerationStructuresPropertiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }
        auto& arr_oCGlcEh=json["pAccelerationStructures"].emplace_array();
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){accelerationStructureCount=static_cast<uint32_t>(value_to<int>(json["accelerationStructureCount"]));}();

[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();

debug_printf("Ending vkCmdWriteAccelerationStructuresPropertiesKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWriteAccelerationStructuresPropertiesNV( VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteAccelerationStructuresPropertiesNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }
        auto& arr_NSQEnJt=json["pAccelerationStructures"].emplace_array();
        for(int zIyqkBG=0; zIyqkBG < accelerationStructureCount; zIyqkBG++){
            [&](){serialize_VkAccelerationStructureNV(arr_NSQEnJt[zIyqkBG],pAccelerationStructures[zIyqkBG]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){accelerationStructureCount=static_cast<uint32_t>(value_to<int>(json["accelerationStructureCount"]));}();

[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();

debug_printf("Ending vkCmdWriteAccelerationStructuresPropertiesNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBuildAccelerationStructureNV( VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildAccelerationStructureNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBUILDACCELERATIONSTRUCTURENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_GYyRhgo=json["pInfo"].emplace_array();
        for(int jJuvWAP=0; jJuvWAP < 1; jJuvWAP++){
            [&](){
            auto& temp=arr_GYyRhgo[jJuvWAP].emplace_object();
            return serialize_struct(temp, pInfo[jJuvWAP]);
            }();
        }
        }();
[&](){serialize_VkBuffer(json["instanceData"],instanceData);}();
[&](){[&](){json["instanceOffset"]=instanceOffset;}();}();
[&](){[&](){json["update"]=update;}();}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){serialize_VkBuffer(json["scratch"],scratch);}();
[&](){[&](){json["scratchOffset"]=scratchOffset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

[&](){deserialize_VkBuffer(json["instanceData"], instanceData);}();
[&](){uint64_t temp_sEYJico;[&](){temp_sEYJico=static_cast<uint64_t>(value_to<int>(json["instanceOffset"]));}();instanceOffset=(VkDeviceSize)temp_sEYJico;}();
[&](){uint32_t temp_LpVZhJf;[&](){temp_LpVZhJf=static_cast<uint32_t>(value_to<int>(json["update"]));}();update=(VkBool32)temp_LpVZhJf;}();
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
[&](){deserialize_VkBuffer(json["scratch"], scratch);}();
[&](){uint64_t temp_rbfZpmL;[&](){temp_rbfZpmL=static_cast<uint64_t>(value_to<int>(json["scratchOffset"]));}();scratchOffset=(VkDeviceSize)temp_rbfZpmL;}();

debug_printf("Ending vkCmdBuildAccelerationStructureNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkWriteAccelerationStructuresPropertiesKHR( VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, size_t dataSize, void* pData, size_t stride ){
//Will only be called by the client
debug_printf("Executing vkWriteAccelerationStructuresPropertiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }
        auto& arr_oCGlcEh=json["pAccelerationStructures"].emplace_array();
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){accelerationStructureCount=static_cast<uint32_t>(value_to<int>(json["accelerationStructureCount"]));}();

[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();
[&](){stride=static_cast<size_t>(value_to<int>(json["stride"]));}();
VkResult result;
[&](){[&](){int temp_CGwZkBw;[&](){temp_CGwZkBw=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_CGwZkBw;}();}();

debug_printf("Ending vkWriteAccelerationStructuresPropertiesKHR...\n");
debug_printf("Return value of vkWriteAccelerationStructuresPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysKHR( VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDTRACERAYSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_SlnAEUX=json["pRaygenShaderBindingTable"].emplace_array();
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto& temp=arr_SlnAEUX[VKRuDIv].emplace_object();
            return serialize_struct(temp, pRaygenShaderBindingTable[VKRuDIv]);
            }();
        }
        }();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_vBQknzc=json["pMissShaderBindingTable"].emplace_array();
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto& temp=arr_vBQknzc[ZhvHpIX].emplace_object();
            return serialize_struct(temp, pMissShaderBindingTable[ZhvHpIX]);
            }();
        }
        }();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_IhHhjXk=json["pHitShaderBindingTable"].emplace_array();
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto& temp=arr_IhHhjXk[yriMdrU].emplace_object();
            return serialize_struct(temp, pHitShaderBindingTable[yriMdrU]);
            }();
        }
        }();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_EmEYSBY=json["pCallableShaderBindingTable"].emplace_array();
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto& temp=arr_EmEYSBY[TiOHiqW].emplace_object();
            return serialize_struct(temp, pCallableShaderBindingTable[TiOHiqW]);
            }();
        }
        }();
[&](){json["width"]=width;}();
[&](){json["height"]=height;}();
[&](){json["depth"]=depth;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();




[&](){width=static_cast<uint32_t>(value_to<int>(json["width"]));}();
[&](){height=static_cast<uint32_t>(value_to<int>(json["height"]));}();
[&](){depth=static_cast<uint32_t>(value_to<int>(json["depth"]));}();

debug_printf("Ending vkCmdTraceRaysKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysNV( VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDTRACERAYSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["raygenShaderBindingTableBuffer"],raygenShaderBindingTableBuffer);}();
[&](){[&](){json["raygenShaderBindingOffset"]=raygenShaderBindingOffset;}();}();
[&](){serialize_VkBuffer(json["missShaderBindingTableBuffer"],missShaderBindingTableBuffer);}();
[&](){[&](){json["missShaderBindingOffset"]=missShaderBindingOffset;}();}();
[&](){[&](){json["missShaderBindingStride"]=missShaderBindingStride;}();}();
[&](){serialize_VkBuffer(json["hitShaderBindingTableBuffer"],hitShaderBindingTableBuffer);}();
[&](){[&](){json["hitShaderBindingOffset"]=hitShaderBindingOffset;}();}();
[&](){[&](){json["hitShaderBindingStride"]=hitShaderBindingStride;}();}();
[&](){serialize_VkBuffer(json["callableShaderBindingTableBuffer"],callableShaderBindingTableBuffer);}();
[&](){[&](){json["callableShaderBindingOffset"]=callableShaderBindingOffset;}();}();
[&](){[&](){json["callableShaderBindingStride"]=callableShaderBindingStride;}();}();
[&](){json["width"]=width;}();
[&](){json["height"]=height;}();
[&](){json["depth"]=depth;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["raygenShaderBindingTableBuffer"], raygenShaderBindingTableBuffer);}();
[&](){uint64_t temp_nbAYEyt;[&](){temp_nbAYEyt=static_cast<uint64_t>(value_to<int>(json["raygenShaderBindingOffset"]));}();raygenShaderBindingOffset=(VkDeviceSize)temp_nbAYEyt;}();
[&](){deserialize_VkBuffer(json["missShaderBindingTableBuffer"], missShaderBindingTableBuffer);}();
[&](){uint64_t temp_ORIaXGF;[&](){temp_ORIaXGF=static_cast<uint64_t>(value_to<int>(json["missShaderBindingOffset"]));}();missShaderBindingOffset=(VkDeviceSize)temp_ORIaXGF;}();
[&](){uint64_t temp_BOvfilr;[&](){temp_BOvfilr=static_cast<uint64_t>(value_to<int>(json["missShaderBindingStride"]));}();missShaderBindingStride=(VkDeviceSize)temp_BOvfilr;}();
[&](){deserialize_VkBuffer(json["hitShaderBindingTableBuffer"], hitShaderBindingTableBuffer);}();
[&](){uint64_t temp_oKlCsJj;[&](){temp_oKlCsJj=static_cast<uint64_t>(value_to<int>(json["hitShaderBindingOffset"]));}();hitShaderBindingOffset=(VkDeviceSize)temp_oKlCsJj;}();
[&](){uint64_t temp_qhwyGdu;[&](){temp_qhwyGdu=static_cast<uint64_t>(value_to<int>(json["hitShaderBindingStride"]));}();hitShaderBindingStride=(VkDeviceSize)temp_qhwyGdu;}();
[&](){deserialize_VkBuffer(json["callableShaderBindingTableBuffer"], callableShaderBindingTableBuffer);}();
[&](){uint64_t temp_WmjXZmz;[&](){temp_WmjXZmz=static_cast<uint64_t>(value_to<int>(json["callableShaderBindingOffset"]));}();callableShaderBindingOffset=(VkDeviceSize)temp_WmjXZmz;}();
[&](){uint64_t temp_giLAAVF;[&](){temp_giLAAVF=static_cast<uint64_t>(value_to<int>(json["callableShaderBindingStride"]));}();callableShaderBindingStride=(VkDeviceSize)temp_giLAAVF;}();
[&](){width=static_cast<uint32_t>(value_to<int>(json["width"]));}();
[&](){height=static_cast<uint32_t>(value_to<int>(json["height"]));}();
[&](){depth=static_cast<uint32_t>(value_to<int>(json["depth"]));}();

debug_printf("Ending vkCmdTraceRaysNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetRayTracingShaderGroupHandlesKHR( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetRayTracingShaderGroupHandlesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETRAYTRACINGSHADERGROUPHANDLESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=firstGroup;}();
[&](){json["groupCount"]=groupCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRAYTRACINGSHADERGROUPHANDLESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){firstGroup=static_cast<uint32_t>(value_to<int>(json["firstGroup"]));}();
[&](){groupCount=static_cast<uint32_t>(value_to<int>(json["groupCount"]));}();
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();
VkResult result;
[&](){[&](){int temp_hVOdxSV;[&](){temp_hVOdxSV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_hVOdxSV;}();}();

debug_printf("Ending vkGetRayTracingShaderGroupHandlesKHR...\n");
debug_printf("Return value of vkGetRayTracingShaderGroupHandlesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetRayTracingShaderGroupHandlesNV( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData ){
return vkGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
__attribute__((visibility ("hidden"))) VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetRayTracingCaptureReplayShaderGroupHandlesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=firstGroup;}();
[&](){json["groupCount"]=groupCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){firstGroup=static_cast<uint32_t>(value_to<int>(json["firstGroup"]));}();
[&](){groupCount=static_cast<uint32_t>(value_to<int>(json["groupCount"]));}();
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();
VkResult result;
[&](){[&](){int temp_iyLSRBR;[&](){temp_iyLSRBR=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_iyLSRBR;}();}();

debug_printf("Ending vkGetRayTracingCaptureReplayShaderGroupHandlesKHR...\n");
debug_printf("Return value of vkGetRayTracingCaptureReplayShaderGroupHandlesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetAccelerationStructureHandleNV( VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureHandleNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETACCELERATIONSTRUCTUREHANDLENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREHANDLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();
VkResult result;
[&](){[&](){int temp_lyDAiFa;[&](){temp_lyDAiFa=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_lyDAiFa;}();}();

debug_printf("Ending vkGetAccelerationStructureHandleNV...\n");
debug_printf("Return value of vkGetAccelerationStructureHandleNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRayTracingPipelinesNV( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateRayTracingPipelinesNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATERAYTRACINGPIPELINESNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_bzMTsat=json["pCreateInfos"].emplace_array();
        for(int oRbABSQ=0; oRbABSQ < createInfoCount; oRbABSQ++){
            [&](){
            auto& temp=arr_bzMTsat[oRbABSQ].emplace_object();
            return serialize_struct(temp, pCreateInfos[oRbABSQ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].emplace_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERAYTRACINGPIPELINESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();


[&](){
            if (json["pPipelines"].as_array().size()==0){
                pPipelines=NULL;
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].as_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ptpOsze;[&](){temp_ptpOsze=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_ptpOsze;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRayTracingPipelinesNV...\n");
debug_printf("Return value of vkCreateRayTracingPipelinesNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRayTracingPipelinesKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateRayTracingPipelinesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATERAYTRACINGPIPELINESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_zltFjJj=json["pCreateInfos"].emplace_array();
        for(int Szqaxlk=0; Szqaxlk < createInfoCount; Szqaxlk++){
            [&](){
            auto& temp=arr_zltFjJj[Szqaxlk].emplace_object();
            return serialize_struct(temp, pCreateInfos[Szqaxlk]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].emplace_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERAYTRACINGPIPELINESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();


[&](){
            if (json["pPipelines"].as_array().size()==0){
                pPipelines=NULL;
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].as_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_RaDYZgc;[&](){temp_RaDYZgc=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_RaDYZgc;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRayTracingPipelinesKHR...\n");
debug_printf("Return value of vkCreateRayTracingPipelinesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceCooperativeMatrixPropertiesNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_kVfVVDF=json["pProperties"].emplace_array();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto& temp=arr_kVfVVDF[WfgOgPA].emplace_object();
            return serialize_struct(temp, pProperties[WfgOgPA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_kVfVVDF=json["pProperties"].as_array();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto& temp=arr_kVfVVDF[WfgOgPA].as_object();
            deserialize_struct(temp,pProperties[WfgOgPA]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_lkNQQWK;[&](){temp_lkNQQWK=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_lkNQQWK;}();}();

debug_printf("Ending vkGetPhysicalDeviceCooperativeMatrixPropertiesNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceCooperativeMatrixPropertiesNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysIndirectKHR( VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysIndirectKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDTRACERAYSINDIRECTKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_SlnAEUX=json["pRaygenShaderBindingTable"].emplace_array();
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto& temp=arr_SlnAEUX[VKRuDIv].emplace_object();
            return serialize_struct(temp, pRaygenShaderBindingTable[VKRuDIv]);
            }();
        }
        }();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_vBQknzc=json["pMissShaderBindingTable"].emplace_array();
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto& temp=arr_vBQknzc[ZhvHpIX].emplace_object();
            return serialize_struct(temp, pMissShaderBindingTable[ZhvHpIX]);
            }();
        }
        }();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_IhHhjXk=json["pHitShaderBindingTable"].emplace_array();
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto& temp=arr_IhHhjXk[yriMdrU].emplace_object();
            return serialize_struct(temp, pHitShaderBindingTable[yriMdrU]);
            }();
        }
        }();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=boost::json::array();
            return; }
        auto& arr_EmEYSBY=json["pCallableShaderBindingTable"].emplace_array();
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto& temp=arr_EmEYSBY[TiOHiqW].emplace_object();
            return serialize_struct(temp, pCallableShaderBindingTable[TiOHiqW]);
            }();
        }
        }();
[&](){[&](){json["indirectDeviceAddress"]=indirectDeviceAddress;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSINDIRECTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();




[&](){uint64_t temp_QXnaHDk;[&](){temp_QXnaHDk=static_cast<uint64_t>(value_to<int>(json["indirectDeviceAddress"]));}();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

debug_printf("Ending vkCmdTraceRaysIndirectKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysIndirect2KHR( VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysIndirect2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDTRACERAYSINDIRECT2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectDeviceAddress"]=indirectDeviceAddress;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSINDIRECT2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_QXnaHDk;[&](){temp_QXnaHDk=static_cast<uint64_t>(value_to<int>(json["indirectDeviceAddress"]));}();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

debug_printf("Ending vkCmdTraceRaysIndirect2KHR...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceAccelerationStructureCompatibilityKHR( VkDevice device, const VkAccelerationStructureVersionInfoKHR* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceAccelerationStructureCompatibilityKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=boost::json::array();
            return; }
        auto& arr_wbhdpeb=json["pVersionInfo"].emplace_array();
        for(int vhWWlwM=0; vhWWlwM < 1; vhWWlwM++){
            [&](){
            auto& temp=arr_wbhdpeb[vhWWlwM].emplace_object();
            return serialize_struct(temp, pVersionInfo[vhWWlwM]);
            }();
        }
        }();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=boost::json::array();
            return; }
        auto& arr_dBMhFMX=json["pCompatibility"].emplace_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=pCompatibility[nzOFTGF];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pCompatibility"].as_array().size()==0){
                pCompatibility=NULL;
            return; }
        auto& arr_dBMhFMX=json["pCompatibility"].as_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){temp_guVSKHd=static_cast<int>(value_to<int>(arr_dBMhFMX[nzOFTGF]));}();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

debug_printf("Ending vkGetDeviceAccelerationStructureCompatibilityKHR...\n");
}
__attribute__((visibility ("hidden"))) VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR( VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader ){
//Will only be called by the client
debug_printf("Executing vkGetRayTracingShaderGroupStackSizeKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["group"]=group;}();
[&](){[&](){[&](){json["groupShader"]=groupShader;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){group=static_cast<uint32_t>(value_to<int>(json["group"]));}();
[&](){[&](){int temp_EOWKSMj;[&](){temp_EOWKSMj=static_cast<int>(value_to<int>(json["groupShader"]));}();groupShader=(VkShaderGroupShaderKHR)temp_EOWKSMj;}();}();
VkDeviceSize result;
[&](){uint64_t temp_BcaJgap;[&](){temp_BcaJgap=static_cast<uint64_t>(value_to<int>(json["result"]));}();result=(VkDeviceSize)temp_BcaJgap;}();

debug_printf("Ending vkGetRayTracingShaderGroupStackSizeKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetRayTracingPipelineStackSizeKHR( VkCommandBuffer commandBuffer, uint32_t pipelineStackSize ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRayTracingPipelineStackSizeKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["pipelineStackSize"]=pipelineStackSize;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){pipelineStackSize=static_cast<uint32_t>(value_to<int>(json["pipelineStackSize"]));}();

debug_printf("Ending vkCmdSetRayTracingPipelineStackSizeKHR...\n");
}
__attribute__((visibility ("hidden"))) uint32_t vkGetImageViewHandleNVX( VkDevice device, const VkImageViewHandleInfoNVX* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetImageViewHandleNVX\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGEVIEWHANDLENVX;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_mfMZJfb=json["pInfo"].emplace_array();
        for(int dQabsff=0; dQabsff < 1; dQabsff++){
            [&](){
            auto& temp=arr_mfMZJfb[dQabsff].emplace_object();
            return serialize_struct(temp, pInfo[dQabsff]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEVIEWHANDLENVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

uint32_t result;
[&](){result=static_cast<uint32_t>(value_to<int>(json["result"]));}();

debug_printf("Ending vkGetImageViewHandleNVX...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageViewAddressNVX( VkDevice device, VkImageView imageView, VkImageViewAddressPropertiesNVX* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetImageViewAddressNVX\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGEVIEWADDRESSNVX;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_hveoAIn=json["pProperties"].emplace_array();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto& temp=arr_hveoAIn[FiVrJfn].emplace_object();
            return serialize_struct(temp, pProperties[FiVrJfn]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEVIEWADDRESSNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_hveoAIn=json["pProperties"].as_array();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto& temp=arr_hveoAIn[FiVrJfn].as_object();
            deserialize_struct(temp,pProperties[FiVrJfn]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_AIEscwU;[&](){temp_AIEscwU=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_AIEscwU;}();}();

debug_printf("Ending vkGetImageViewAddressNVX...\n");
debug_printf("Return value of vkGetImageViewAddressNVX is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters, VkPerformanceCounterDescriptionKHR* pCounterDescriptions ){
//Will only be called by the client
debug_printf("Executing vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (pCounterCount==NULL){
                json["pCounterCount"]=boost::json::array();
            return; }
        auto& arr_QuwxWHd=json["pCounterCount"].emplace_array();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){arr_QuwxWHd[HDbVSFc]=pCounterCount[HDbVSFc];}();
        }
        }();
[&](){
            if (pCounters==NULL){
                json["pCounters"]=boost::json::array();
            return; }
        auto& arr_vEVlsJt=json["pCounters"].emplace_array();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto& temp=arr_vEVlsJt[WmftXku].emplace_object();
            return serialize_struct(temp, pCounters[WmftXku]);
            }();
        }
        }();
[&](){
            if (pCounterDescriptions==NULL){
                json["pCounterDescriptions"]=boost::json::array();
            return; }
        auto& arr_znRZkzO=json["pCounterDescriptions"].emplace_array();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto& temp=arr_znRZkzO[GjxogPx].emplace_object();
            return serialize_struct(temp, pCounterDescriptions[GjxogPx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){queueFamilyIndex=static_cast<uint32_t>(value_to<int>(json["queueFamilyIndex"]));}();
[&](){
            if (json["pCounterCount"].as_array().size()==0){
                pCounterCount=NULL;
            return; }
        auto& arr_QuwxWHd=json["pCounterCount"].as_array();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){pCounterCount[HDbVSFc]=static_cast<uint32_t>(value_to<int>(arr_QuwxWHd[HDbVSFc]));}();
        }
        }();
[&](){
            if (json["pCounters"].as_array().size()==0){
                pCounters=NULL;
            return; }
        auto& arr_vEVlsJt=json["pCounters"].as_array();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto& temp=arr_vEVlsJt[WmftXku].as_object();
            deserialize_struct(temp,pCounters[WmftXku]);
            }();
        }
        }();
[&](){
            if (json["pCounterDescriptions"].as_array().size()==0){
                pCounterDescriptions=NULL;
            return; }
        auto& arr_znRZkzO=json["pCounterDescriptions"].as_array();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto& temp=arr_znRZkzO[GjxogPx].as_object();
            deserialize_struct(temp,pCounterDescriptions[GjxogPx]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_xYrPsEn;[&](){temp_xYrPsEn=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_xYrPsEn;}();}();

debug_printf("Ending vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR...\n");
debug_printf("Return value of vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR( VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPerformanceQueryCreateInfo==NULL){
                json["pPerformanceQueryCreateInfo"]=boost::json::array();
            return; }
        auto& arr_HfbrSJi=json["pPerformanceQueryCreateInfo"].emplace_array();
        for(int aEYwfht=0; aEYwfht < 1; aEYwfht++){
            [&](){
            auto& temp=arr_HfbrSJi[aEYwfht].emplace_object();
            return serialize_struct(temp, pPerformanceQueryCreateInfo[aEYwfht]);
            }();
        }
        }();
[&](){
            if (pNumPasses==NULL){
                json["pNumPasses"]=boost::json::array();
            return; }
        auto& arr_QgclfwI=json["pNumPasses"].emplace_array();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){arr_QgclfwI[vyixxEg]=pNumPasses[vyixxEg];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pNumPasses"].as_array().size()==0){
                pNumPasses=NULL;
            return; }
        auto& arr_QgclfwI=json["pNumPasses"].as_array();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){pNumPasses[vyixxEg]=static_cast<uint32_t>(value_to<int>(arr_QgclfwI[vyixxEg]));}();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireProfilingLockKHR( VkDevice device, const VkAcquireProfilingLockInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkAcquireProfilingLockKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKACQUIREPROFILINGLOCKKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_BslWEPE=json["pInfo"].emplace_array();
        for(int ZgSmBLm=0; ZgSmBLm < 1; ZgSmBLm++){
            [&](){
            auto& temp=arr_BslWEPE[ZgSmBLm].emplace_object();
            return serialize_struct(temp, pInfo[ZgSmBLm]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIREPROFILINGLOCKKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_ezsaUrK;[&](){temp_ezsaUrK=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_ezsaUrK;}();}();

debug_printf("Ending vkAcquireProfilingLockKHR...\n");
debug_printf("Return value of vkAcquireProfilingLockKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkReleaseProfilingLockKHR( VkDevice device ){
//Will only be called by the client
debug_printf("Executing vkReleaseProfilingLockKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRELEASEPROFILINGLOCKKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASEPROFILINGLOCKKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

debug_printf("Ending vkReleaseProfilingLockKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageDrmFormatModifierPropertiesEXT( VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetImageDrmFormatModifierPropertiesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_oxSUmzu=json["pProperties"].emplace_array();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto& temp=arr_oxSUmzu[JPWNMan].emplace_object();
            return serialize_struct(temp, pProperties[JPWNMan]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_oxSUmzu=json["pProperties"].as_array();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto& temp=arr_oxSUmzu[JPWNMan].as_object();
            deserialize_struct(temp,pProperties[JPWNMan]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_TXdVvEr;[&](){temp_TXdVvEr=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_TXdVvEr;}();}();

debug_printf("Ending vkGetImageDrmFormatModifierPropertiesEXT...\n");
debug_printf("Return value of vkGetImageDrmFormatModifierPropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetBufferOpaqueCaptureAddress( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetBufferOpaqueCaptureAddress\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETBUFFEROPAQUECAPTUREADDRESS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_LRSftdl=json["pInfo"].emplace_array();
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto& temp=arr_LRSftdl[CPHfQOs].emplace_object();
            return serialize_struct(temp, pInfo[CPHfQOs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFEROPAQUECAPTUREADDRESS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

uint64_t result;
[&](){result=static_cast<uint64_t>(value_to<int>(json["result"]));}();

debug_printf("Ending vkGetBufferOpaqueCaptureAddress...\n");
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetBufferOpaqueCaptureAddressKHR( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
return vkGetBufferOpaqueCaptureAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetBufferDeviceAddress( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetBufferDeviceAddress\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETBUFFERDEVICEADDRESS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_LRSftdl=json["pInfo"].emplace_array();
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto& temp=arr_LRSftdl[CPHfQOs].emplace_object();
            return serialize_struct(temp, pInfo[CPHfQOs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFERDEVICEADDRESS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkDeviceAddress result;
[&](){uint64_t temp_MsmROiw;[&](){temp_MsmROiw=static_cast<uint64_t>(value_to<int>(json["result"]));}();result=(VkDeviceAddress)temp_MsmROiw;}();

debug_printf("Ending vkGetBufferDeviceAddress...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetBufferDeviceAddressKHR( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
return vkGetBufferDeviceAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetBufferDeviceAddressEXT( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
return vkGetBufferDeviceAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateHeadlessSurfaceEXT( VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateHeadlessSurfaceEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEHEADLESSSURFACEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_yHbnuDf=json["pCreateInfo"].emplace_array();
        for(int CyHXDmy=0; CyHXDmy < 1; CyHXDmy++){
            [&](){
            auto& temp=arr_yHbnuDf[CyHXDmy].emplace_object();
            return serialize_struct(temp, pCreateInfo[CyHXDmy]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }
        auto& arr_zGtWguc=json["pSurface"].emplace_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEHEADLESSSURFACEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pSurface"].as_array().size()==0){
                pSurface=NULL;
            return; }
        auto& arr_zGtWguc=json["pSurface"].as_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_sUGagdm;[&](){temp_sUGagdm=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_sUGagdm;}();}();

                if (pSurface!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSurface[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateHeadlessSurfaceEXT...\n");
debug_printf("Return value of vkCreateHeadlessSurfaceEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV( VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCombinationCount==NULL){
                json["pCombinationCount"]=boost::json::array();
            return; }
        auto& arr_VrJxAqY=json["pCombinationCount"].emplace_array();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){arr_VrJxAqY[jKkiHUO]=pCombinationCount[jKkiHUO];}();
        }
        }();
[&](){
            if (pCombinations==NULL){
                json["pCombinations"]=boost::json::array();
            return; }
        auto& arr_aOIaDFM=json["pCombinations"].emplace_array();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto& temp=arr_aOIaDFM[oxJqbjP].emplace_object();
            return serialize_struct(temp, pCombinations[oxJqbjP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pCombinationCount"].as_array().size()==0){
                pCombinationCount=NULL;
            return; }
        auto& arr_VrJxAqY=json["pCombinationCount"].as_array();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){pCombinationCount[jKkiHUO]=static_cast<uint32_t>(value_to<int>(arr_VrJxAqY[jKkiHUO]));}();
        }
        }();
[&](){
            if (json["pCombinations"].as_array().size()==0){
                pCombinations=NULL;
            return; }
        auto& arr_aOIaDFM=json["pCombinations"].as_array();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto& temp=arr_aOIaDFM[oxJqbjP].as_object();
            deserialize_struct(temp,pCombinations[oxJqbjP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_roUVeNn;[&](){temp_roUVeNn=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_roUVeNn;}();}();

debug_printf("Ending vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkInitializePerformanceApiINTEL( VkDevice device, const VkInitializePerformanceApiInfoINTEL* pInitializeInfo ){
//Will only be called by the client
debug_printf("Executing vkInitializePerformanceApiINTEL\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKINITIALIZEPERFORMANCEAPIINTEL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInitializeInfo==NULL){
                json["pInitializeInfo"]=boost::json::array();
            return; }
        auto& arr_BGIuPda=json["pInitializeInfo"].emplace_array();
        for(int pMSNyrD=0; pMSNyrD < 1; pMSNyrD++){
            [&](){
            auto& temp=arr_BGIuPda[pMSNyrD].emplace_object();
            return serialize_struct(temp, pInitializeInfo[pMSNyrD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKINITIALIZEPERFORMANCEAPIINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_FczrlCd;[&](){temp_FczrlCd=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_FczrlCd;}();}();

debug_printf("Ending vkInitializePerformanceApiINTEL...\n");
debug_printf("Return value of vkInitializePerformanceApiINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkUninitializePerformanceApiINTEL( VkDevice device ){
//Will only be called by the client
debug_printf("Executing vkUninitializePerformanceApiINTEL\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKUNINITIALIZEPERFORMANCEAPIINTEL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUNINITIALIZEPERFORMANCEAPIINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

debug_printf("Ending vkUninitializePerformanceApiINTEL...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCmdSetPerformanceMarkerINTEL( VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPerformanceMarkerINTEL\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETPERFORMANCEMARKERINTEL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }
        auto& arr_jnuNlGq=json["pMarkerInfo"].emplace_array();
        for(int zTzAESc=0; zTzAESc < 1; zTzAESc++){
            [&](){
            auto& temp=arr_jnuNlGq[zTzAESc].emplace_object();
            return serialize_struct(temp, pMarkerInfo[zTzAESc]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPERFORMANCEMARKERINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_JLIMAPs;[&](){temp_JLIMAPs=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_JLIMAPs;}();}();

debug_printf("Ending vkCmdSetPerformanceMarkerINTEL...\n");
debug_printf("Return value of vkCmdSetPerformanceMarkerINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCmdSetPerformanceStreamMarkerINTEL( VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPerformanceStreamMarkerINTEL\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETPERFORMANCESTREAMMARKERINTEL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }
        auto& arr_MVQnSpz=json["pMarkerInfo"].emplace_array();
        for(int xfSMHfo=0; xfSMHfo < 1; xfSMHfo++){
            [&](){
            auto& temp=arr_MVQnSpz[xfSMHfo].emplace_object();
            return serialize_struct(temp, pMarkerInfo[xfSMHfo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPERFORMANCESTREAMMARKERINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_ejAUPtu;[&](){temp_ejAUPtu=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_ejAUPtu;}();}();

debug_printf("Ending vkCmdSetPerformanceStreamMarkerINTEL...\n");
debug_printf("Return value of vkCmdSetPerformanceStreamMarkerINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCmdSetPerformanceOverrideINTEL( VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL* pOverrideInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPerformanceOverrideINTEL\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETPERFORMANCEOVERRIDEINTEL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pOverrideInfo==NULL){
                json["pOverrideInfo"]=boost::json::array();
            return; }
        auto& arr_LHSFuEM=json["pOverrideInfo"].emplace_array();
        for(int KZSCUHM=0; KZSCUHM < 1; KZSCUHM++){
            [&](){
            auto& temp=arr_LHSFuEM[KZSCUHM].emplace_object();
            return serialize_struct(temp, pOverrideInfo[KZSCUHM]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPERFORMANCEOVERRIDEINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_krlxAmE;[&](){temp_krlxAmE=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_krlxAmE;}();}();

debug_printf("Ending vkCmdSetPerformanceOverrideINTEL...\n");
debug_printf("Return value of vkCmdSetPerformanceOverrideINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAcquirePerformanceConfigurationINTEL( VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, VkPerformanceConfigurationINTEL* pConfiguration ){
//Will only be called by the client
debug_printf("Executing vkAcquirePerformanceConfigurationINTEL\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKACQUIREPERFORMANCECONFIGURATIONINTEL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=boost::json::array();
            return; }
        auto& arr_ZyqvvlF=json["pAcquireInfo"].emplace_array();
        for(int RYEcOAO=0; RYEcOAO < 1; RYEcOAO++){
            [&](){
            auto& temp=arr_ZyqvvlF[RYEcOAO].emplace_object();
            return serialize_struct(temp, pAcquireInfo[RYEcOAO]);
            }();
        }
        }();
[&](){
            if (pConfiguration==NULL){
                json["pConfiguration"]=boost::json::array();
            return; }
        auto& arr_zSRZrDS=json["pConfiguration"].emplace_array();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){serialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA],pConfiguration[MTgkTDA]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIREPERFORMANCECONFIGURATIONINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pConfiguration"].as_array().size()==0){
                pConfiguration=NULL;
            return; }
        auto& arr_zSRZrDS=json["pConfiguration"].as_array();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){deserialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA], pConfiguration[MTgkTDA]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_zOsUIZS;[&](){temp_zOsUIZS=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_zOsUIZS;}();}();

debug_printf("Ending vkAcquirePerformanceConfigurationINTEL...\n");
debug_printf("Return value of vkAcquirePerformanceConfigurationINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkReleasePerformanceConfigurationINTEL( VkDevice device, VkPerformanceConfigurationINTEL configuration ){
//Will only be called by the client
debug_printf("Executing vkReleasePerformanceConfigurationINTEL\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRELEASEPERFORMANCECONFIGURATIONINTEL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASEPERFORMANCECONFIGURATIONINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();
VkResult result;
[&](){[&](){int temp_hRPwiGo;[&](){temp_hRPwiGo=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_hRPwiGo;}();}();

debug_printf("Ending vkReleasePerformanceConfigurationINTEL...\n");
debug_printf("Return value of vkReleasePerformanceConfigurationINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSetPerformanceConfigurationINTEL( VkQueue queue, VkPerformanceConfigurationINTEL configuration ){
//Will only be called by the client
debug_printf("Executing vkQueueSetPerformanceConfigurationINTEL\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKQUEUESETPERFORMANCECONFIGURATIONINTEL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUESETPERFORMANCECONFIGURATIONINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();
VkResult result;
[&](){[&](){int temp_qIkardh;[&](){temp_qIkardh=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_qIkardh;}();}();

debug_printf("Ending vkQueueSetPerformanceConfigurationINTEL...\n");
debug_printf("Return value of vkQueueSetPerformanceConfigurationINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPerformanceParameterINTEL( VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL* pValue ){
//Will only be called by the client
debug_printf("Executing vkGetPerformanceParameterINTEL\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPERFORMANCEPARAMETERINTEL;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["parameter"]=parameter;}();}();}();
[&](){
            if (pValue==NULL){
                json["pValue"]=boost::json::array();
            return; }
        auto& arr_hOmaGpc=json["pValue"].emplace_array();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto& temp=arr_hOmaGpc[lyxuUNd].emplace_object();
            return serialize_struct(temp, pValue[lyxuUNd]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPERFORMANCEPARAMETERINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_TQususa;[&](){temp_TQususa=static_cast<int>(value_to<int>(json["parameter"]));}();parameter=(VkPerformanceParameterTypeINTEL)temp_TQususa;}();}();
[&](){
            if (json["pValue"].as_array().size()==0){
                pValue=NULL;
            return; }
        auto& arr_hOmaGpc=json["pValue"].as_array();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto& temp=arr_hOmaGpc[lyxuUNd].as_object();
            deserialize_struct(temp,pValue[lyxuUNd]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_NqWzncd;[&](){temp_NqWzncd=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_NqWzncd;}();}();

debug_printf("Ending vkGetPerformanceParameterINTEL...\n");
debug_printf("Return value of vkGetPerformanceParameterINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetDeviceMemoryOpaqueCaptureAddress( VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceMemoryOpaqueCaptureAddress\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_hjweGct=json["pInfo"].emplace_array();
        for(int vcZpbuB=0; vcZpbuB < 1; vcZpbuB++){
            [&](){
            auto& temp=arr_hjweGct[vcZpbuB].emplace_object();
            return serialize_struct(temp, pInfo[vcZpbuB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

uint64_t result;
[&](){result=static_cast<uint64_t>(value_to<int>(json["result"]));}();

debug_printf("Ending vkGetDeviceMemoryOpaqueCaptureAddress...\n");
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR( VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo ){
return vkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineExecutablePropertiesKHR( VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineExecutablePropertiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPIPELINEEXECUTABLEPROPERTIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=boost::json::array();
            return; }
        auto& arr_SxuxUqw=json["pPipelineInfo"].emplace_array();
        for(int mwoMxRp=0; mwoMxRp < 1; mwoMxRp++){
            [&](){
            auto& temp=arr_SxuxUqw[mwoMxRp].emplace_object();
            return serialize_struct(temp, pPipelineInfo[mwoMxRp]);
            }();
        }
        }();
[&](){
            if (pExecutableCount==NULL){
                json["pExecutableCount"]=boost::json::array();
            return; }
        auto& arr_tlXPSPh=json["pExecutableCount"].emplace_array();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){arr_tlXPSPh[ZFmbkCm]=pExecutableCount[ZFmbkCm];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_vtfdUfF=json["pProperties"].emplace_array();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto& temp=arr_vtfdUfF[uPFqrVz].emplace_object();
            return serialize_struct(temp, pProperties[uPFqrVz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEEXECUTABLEPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pExecutableCount"].as_array().size()==0){
                pExecutableCount=NULL;
            return; }
        auto& arr_tlXPSPh=json["pExecutableCount"].as_array();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(value_to<int>(arr_tlXPSPh[ZFmbkCm]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_vtfdUfF=json["pProperties"].as_array();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto& temp=arr_vtfdUfF[uPFqrVz].as_object();
            deserialize_struct(temp,pProperties[uPFqrVz]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_DBCOOfh;[&](){temp_DBCOOfh=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_DBCOOfh;}();}();

debug_printf("Ending vkGetPipelineExecutablePropertiesKHR...\n");
debug_printf("Return value of vkGetPipelineExecutablePropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineExecutableStatisticsKHR( VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineExecutableStatisticsKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPIPELINEEXECUTABLESTATISTICSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=boost::json::array();
            return; }
        auto& arr_xbHlsCc=json["pExecutableInfo"].emplace_array();
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto& temp=arr_xbHlsCc[JTDfcCv].emplace_object();
            return serialize_struct(temp, pExecutableInfo[JTDfcCv]);
            }();
        }
        }();
[&](){
            if (pStatisticCount==NULL){
                json["pStatisticCount"]=boost::json::array();
            return; }
        auto& arr_BIkbvee=json["pStatisticCount"].emplace_array();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){arr_BIkbvee[MiieuSo]=pStatisticCount[MiieuSo];}();
        }
        }();
[&](){
            if (pStatistics==NULL){
                json["pStatistics"]=boost::json::array();
            return; }
        auto& arr_cGybyJf=json["pStatistics"].emplace_array();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto& temp=arr_cGybyJf[ktSOZGx].emplace_object();
            return serialize_struct(temp, pStatistics[ktSOZGx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEEXECUTABLESTATISTICSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pStatisticCount"].as_array().size()==0){
                pStatisticCount=NULL;
            return; }
        auto& arr_BIkbvee=json["pStatisticCount"].as_array();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){pStatisticCount[MiieuSo]=static_cast<uint32_t>(value_to<int>(arr_BIkbvee[MiieuSo]));}();
        }
        }();
[&](){
            if (json["pStatistics"].as_array().size()==0){
                pStatistics=NULL;
            return; }
        auto& arr_cGybyJf=json["pStatistics"].as_array();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto& temp=arr_cGybyJf[ktSOZGx].as_object();
            deserialize_struct(temp,pStatistics[ktSOZGx]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_FuoCduI;[&](){temp_FuoCduI=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_FuoCduI;}();}();

debug_printf("Ending vkGetPipelineExecutableStatisticsKHR...\n");
debug_printf("Return value of vkGetPipelineExecutableStatisticsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineExecutableInternalRepresentationsKHR( VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineExecutableInternalRepresentationsKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=boost::json::array();
            return; }
        auto& arr_xbHlsCc=json["pExecutableInfo"].emplace_array();
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto& temp=arr_xbHlsCc[JTDfcCv].emplace_object();
            return serialize_struct(temp, pExecutableInfo[JTDfcCv]);
            }();
        }
        }();
[&](){
            if (pInternalRepresentationCount==NULL){
                json["pInternalRepresentationCount"]=boost::json::array();
            return; }
        auto& arr_bVgggzH=json["pInternalRepresentationCount"].emplace_array();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){arr_bVgggzH[urjNjhc]=pInternalRepresentationCount[urjNjhc];}();
        }
        }();
[&](){
            if (pInternalRepresentations==NULL){
                json["pInternalRepresentations"]=boost::json::array();
            return; }
        auto& arr_yqajgdo=json["pInternalRepresentations"].emplace_array();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto& temp=arr_yqajgdo[OdpgULc].emplace_object();
            return serialize_struct(temp, pInternalRepresentations[OdpgULc]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pInternalRepresentationCount"].as_array().size()==0){
                pInternalRepresentationCount=NULL;
            return; }
        auto& arr_bVgggzH=json["pInternalRepresentationCount"].as_array();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(value_to<int>(arr_bVgggzH[urjNjhc]));}();
        }
        }();
[&](){
            if (json["pInternalRepresentations"].as_array().size()==0){
                pInternalRepresentations=NULL;
            return; }
        auto& arr_yqajgdo=json["pInternalRepresentations"].as_array();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto& temp=arr_yqajgdo[OdpgULc].as_object();
            deserialize_struct(temp,pInternalRepresentations[OdpgULc]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_BcviJAt;[&](){temp_BcviJAt=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_BcviJAt;}();}();

debug_printf("Ending vkGetPipelineExecutableInternalRepresentationsKHR...\n");
debug_printf("Return value of vkGetPipelineExecutableInternalRepresentationsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineStippleEXT( VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineStippleEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETLINESTIPPLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineStippleFactor"]=lineStippleFactor;}();
[&](){json["lineStipplePattern"]=lineStipplePattern;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINESTIPPLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){lineStippleFactor=static_cast<uint32_t>(value_to<int>(json["lineStippleFactor"]));}();
[&](){lineStipplePattern=static_cast<uint16_t>(value_to<int>(json["lineStipplePattern"]));}();

debug_printf("Ending vkCmdSetLineStippleEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceToolProperties( VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceToolProperties\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICETOOLPROPERTIES;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pToolCount==NULL){
                json["pToolCount"]=boost::json::array();
            return; }
        auto& arr_PNAKwfC=json["pToolCount"].emplace_array();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){arr_PNAKwfC[iRGIIgT]=pToolCount[iRGIIgT];}();
        }
        }();
[&](){
            if (pToolProperties==NULL){
                json["pToolProperties"]=boost::json::array();
            return; }
        auto& arr_OYowiCQ=json["pToolProperties"].emplace_array();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto& temp=arr_OYowiCQ[dlPXJcQ].emplace_object();
            return serialize_struct(temp, pToolProperties[dlPXJcQ]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICETOOLPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pToolCount"].as_array().size()==0){
                pToolCount=NULL;
            return; }
        auto& arr_PNAKwfC=json["pToolCount"].as_array();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){pToolCount[iRGIIgT]=static_cast<uint32_t>(value_to<int>(arr_PNAKwfC[iRGIIgT]));}();
        }
        }();
[&](){
            if (json["pToolProperties"].as_array().size()==0){
                pToolProperties=NULL;
            return; }
        auto& arr_OYowiCQ=json["pToolProperties"].as_array();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto& temp=arr_OYowiCQ[dlPXJcQ].as_object();
            deserialize_struct(temp,pToolProperties[dlPXJcQ]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_GnmTjEv;[&](){temp_GnmTjEv=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_GnmTjEv;}();}();

debug_printf("Ending vkGetPhysicalDeviceToolProperties...\n");
debug_printf("Return value of vkGetPhysicalDeviceToolProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceToolPropertiesEXT( VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties ){
return vkGetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateAccelerationStructureKHR( VkDevice device, const VkAccelerationStructureCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureKHR* pAccelerationStructure ){
//Will only be called by the client
debug_printf("Executing vkCreateAccelerationStructureKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEACCELERATIONSTRUCTUREKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_XoURuCS=json["pCreateInfo"].emplace_array();
        for(int bGUDBRC=0; bGUDBRC < 1; bGUDBRC++){
            [&](){
            auto& temp=arr_XoURuCS[bGUDBRC].emplace_object();
            return serialize_struct(temp, pCreateInfo[bGUDBRC]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=boost::json::array();
            return; }
        auto& arr_vKbZGTA=json["pAccelerationStructure"].emplace_array();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){serialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb],pAccelerationStructure[YRzkUOb]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pAccelerationStructure"].as_array().size()==0){
                pAccelerationStructure=NULL;
            return; }
        auto& arr_vKbZGTA=json["pAccelerationStructure"].as_array();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb], pAccelerationStructure[YRzkUOb]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_UIXJrXH;[&](){temp_UIXJrXH=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_UIXJrXH;}();}();

                if (pAccelerationStructure!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pAccelerationStructure[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateAccelerationStructureKHR...\n");
debug_printf("Return value of vkCreateAccelerationStructureKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBuildAccelerationStructuresKHR( VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildAccelerationStructuresKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBUILDACCELERATIONSTRUCTURESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_lswJvjt=json["pInfos"].emplace_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=boost::json::array();
            return; }
        auto& arr_FMxYLmq=json["ppBuildRangeInfos"].emplace_array();
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=boost::json::array();
            return; }
        auto& arr_PKxEvVS=arr_FMxYLmq[CRaOjpb].emplace_array();
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto& temp=arr_PKxEvVS[IUJrDJF].emplace_object();
            return serialize_struct(temp, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            }();
        }
        }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDACCELERATIONSTRUCTURESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();



debug_printf("Ending vkCmdBuildAccelerationStructuresKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBuildAccelerationStructuresIndirectKHR( VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkDeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides, const uint32_t* const* ppMaxPrimitiveCounts ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildAccelerationStructuresIndirectKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_lswJvjt=json["pInfos"].emplace_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (pIndirectDeviceAddresses==NULL){
                json["pIndirectDeviceAddresses"]=boost::json::array();
            return; }
        auto& arr_YkBEqzj=json["pIndirectDeviceAddresses"].emplace_array();
        for(int tMAuxlx=0; tMAuxlx < infoCount; tMAuxlx++){
            [&](){[&](){arr_YkBEqzj[tMAuxlx]=pIndirectDeviceAddresses[tMAuxlx];}();}();
        }
        }();
[&](){
            if (pIndirectStrides==NULL){
                json["pIndirectStrides"]=boost::json::array();
            return; }
        auto& arr_Helprzq=json["pIndirectStrides"].emplace_array();
        for(int IXUUYlr=0; IXUUYlr < infoCount; IXUUYlr++){
            [&](){arr_Helprzq[IXUUYlr]=pIndirectStrides[IXUUYlr];}();
        }
        }();
[&](){
            if (ppMaxPrimitiveCounts==NULL){
                json["ppMaxPrimitiveCounts"]=boost::json::array();
            return; }
        auto& arr_DfsqJWs=json["ppMaxPrimitiveCounts"].emplace_array();
        for(int TyNkaSn=0; TyNkaSn < 1; TyNkaSn++){
            [&](){
            if (ppMaxPrimitiveCounts[TyNkaSn]==NULL){
                arr_DfsqJWs[TyNkaSn]=boost::json::array();
            return; }
        auto& arr_kfQrDXL=arr_DfsqJWs[TyNkaSn].emplace_array();
        for(int SABezVP=0; SABezVP < infoCount; SABezVP++){
            [&](){arr_kfQrDXL[SABezVP]=ppMaxPrimitiveCounts[TyNkaSn][SABezVP];}();
        }
        }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();





debug_printf("Ending vkCmdBuildAccelerationStructuresIndirectKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBuildAccelerationStructuresKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos ){
//Will only be called by the client
debug_printf("Executing vkBuildAccelerationStructuresKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBUILDACCELERATIONSTRUCTURESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_lswJvjt=json["pInfos"].emplace_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=boost::json::array();
            return; }
        auto& arr_FMxYLmq=json["ppBuildRangeInfos"].emplace_array();
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=boost::json::array();
            return; }
        auto& arr_PKxEvVS=arr_FMxYLmq[CRaOjpb].emplace_array();
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto& temp=arr_PKxEvVS[IUJrDJF].emplace_object();
            return serialize_struct(temp, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            }();
        }
        }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBUILDACCELERATIONSTRUCTURESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();


VkResult result;
[&](){[&](){int temp_mWNDixi;[&](){temp_mWNDixi=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_mWNDixi;}();}();

debug_printf("Ending vkBuildAccelerationStructuresKHR...\n");
debug_printf("Return value of vkBuildAccelerationStructuresKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR( VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureDeviceAddressKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_CAfLmMn=json["pInfo"].emplace_array();
        for(int DozYfEa=0; DozYfEa < 1; DozYfEa++){
            [&](){
            auto& temp=arr_CAfLmMn[DozYfEa].emplace_object();
            return serialize_struct(temp, pInfo[DozYfEa]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkDeviceAddress result;
[&](){uint64_t temp_FctqCQd;[&](){temp_FctqCQd=static_cast<uint64_t>(value_to<int>(json["result"]));}();result=(VkDeviceAddress)temp_FctqCQd;}();

debug_printf("Ending vkGetAccelerationStructureDeviceAddressKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDeferredOperationKHR( VkDevice device, const VkAllocationCallbacks* pAllocator, VkDeferredOperationKHR* pDeferredOperation ){
//Will only be called by the client
debug_printf("Executing vkCreateDeferredOperationKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEDEFERREDOPERATIONKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDeferredOperation==NULL){
                json["pDeferredOperation"]=boost::json::array();
            return; }
        auto& arr_fPVilHH=json["pDeferredOperation"].emplace_array();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){serialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX],pDeferredOperation[BrrtHdX]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEFERREDOPERATIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pDeferredOperation"].as_array().size()==0){
                pDeferredOperation=NULL;
            return; }
        auto& arr_fPVilHH=json["pDeferredOperation"].as_array();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){deserialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX], pDeferredOperation[BrrtHdX]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_MHVUWnu;[&](){temp_MHVUWnu=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_MHVUWnu;}();}();

                if (pDeferredOperation!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDeferredOperation[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDeferredOperationKHR...\n");
debug_printf("Return value of vkCreateDeferredOperationKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDeferredOperationKHR( VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDeferredOperationKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYDEFERREDOPERATIONKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEFERREDOPERATIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();


debug_printf("Ending vkDestroyDeferredOperationKHR...\n");
}
__attribute__((visibility ("hidden"))) uint32_t vkGetDeferredOperationMaxConcurrencyKHR( VkDevice device, VkDeferredOperationKHR operation ){
//Will only be called by the client
debug_printf("Executing vkGetDeferredOperationMaxConcurrencyKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
uint32_t result;
[&](){result=static_cast<uint32_t>(value_to<int>(json["result"]));}();

debug_printf("Ending vkGetDeferredOperationMaxConcurrencyKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeferredOperationResultKHR( VkDevice device, VkDeferredOperationKHR operation ){
//Will only be called by the client
debug_printf("Executing vkGetDeferredOperationResultKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEFERREDOPERATIONRESULTKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEFERREDOPERATIONRESULTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
VkResult result;
[&](){[&](){int temp_qYqlPqC;[&](){temp_qYqlPqC=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_qYqlPqC;}();}();

debug_printf("Ending vkGetDeferredOperationResultKHR...\n");
debug_printf("Return value of vkGetDeferredOperationResultKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDeferredOperationJoinKHR( VkDevice device, VkDeferredOperationKHR operation ){
//Will only be called by the client
debug_printf("Executing vkDeferredOperationJoinKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDEFERREDOPERATIONJOINKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEFERREDOPERATIONJOINKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
VkResult result;
[&](){[&](){int temp_lIpaDoP;[&](){temp_lIpaDoP=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_lIpaDoP;}();}();

debug_printf("Ending vkDeferredOperationJoinKHR...\n");
debug_printf("Return value of vkDeferredOperationJoinKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPipelineIndirectMemoryRequirementsNV( VkDevice device, const VkComputePipelineCreateInfo* pCreateInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineIndirectMemoryRequirementsNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_XLStDVY=json["pCreateInfo"].emplace_array();
        for(int FoBxBjF=0; FoBxBjF < 1; FoBxBjF++){
            [&](){
            auto& temp=arr_XLStDVY[FoBxBjF].emplace_object();
            return serialize_struct(temp, pCreateInfo[FoBxBjF]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].emplace_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].as_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetPipelineIndirectMemoryRequirementsNV...\n");
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetPipelineIndirectDeviceAddressNV( VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineIndirectDeviceAddressNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPIPELINEINDIRECTDEVICEADDRESSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_iNXSdlN=json["pInfo"].emplace_array();
        for(int EeNdDDD=0; EeNdDDD < 1; EeNdDDD++){
            [&](){
            auto& temp=arr_iNXSdlN[EeNdDDD].emplace_object();
            return serialize_struct(temp, pInfo[EeNdDDD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEINDIRECTDEVICEADDRESSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkDeviceAddress result;
[&](){uint64_t temp_UYfSvRJ;[&](){temp_UYfSvRJ=static_cast<uint64_t>(value_to<int>(json["result"]));}();result=(VkDeviceAddress)temp_UYfSvRJ;}();

debug_printf("Ending vkGetPipelineIndirectDeviceAddressNV...\n");
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetCullMode( VkCommandBuffer commandBuffer, VkCullModeFlags cullMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCullMode\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCULLMODE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["cullMode"]=cullMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCULLMODE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_JocwJIC;[&](){temp_JocwJIC=static_cast<int>(value_to<int>(json["cullMode"]));}();cullMode=(VkCullModeFlags)temp_JocwJIC;}();}();

debug_printf("Ending vkCmdSetCullMode...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCullModeEXT( VkCommandBuffer commandBuffer, VkCullModeFlags cullMode ){
return vkCmdSetCullMode(commandBuffer, cullMode);
}
__attribute__((visibility ("hidden"))) void vkCmdSetFrontFace( VkCommandBuffer commandBuffer, VkFrontFace frontFace ){
//Will only be called by the client
debug_printf("Executing vkCmdSetFrontFace\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETFRONTFACE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["frontFace"]=frontFace;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETFRONTFACE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_ZBubEzp;[&](){temp_ZBubEzp=static_cast<int>(value_to<int>(json["frontFace"]));}();frontFace=(VkFrontFace)temp_ZBubEzp;}();}();

debug_printf("Ending vkCmdSetFrontFace...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetFrontFaceEXT( VkCommandBuffer commandBuffer, VkFrontFace frontFace ){
return vkCmdSetFrontFace(commandBuffer, frontFace);
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveTopology( VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPrimitiveTopology\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETPRIMITIVETOPOLOGY;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["primitiveTopology"]=primitiveTopology;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPRIMITIVETOPOLOGY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_jzAnfAA;[&](){temp_jzAnfAA=static_cast<int>(value_to<int>(json["primitiveTopology"]));}();primitiveTopology=(VkPrimitiveTopology)temp_jzAnfAA;}();}();

debug_printf("Ending vkCmdSetPrimitiveTopology...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveTopologyEXT( VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology ){
return vkCmdSetPrimitiveTopology(commandBuffer, primitiveTopology);
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWithCount( VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportWithCount\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETVIEWPORTWITHCOUNT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=boost::json::array();
            return; }
        auto& arr_SyYryUE=json["pViewports"].emplace_array();
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto& temp=arr_SyYryUE[HAuJlzw].emplace_object();
            return serialize_struct(temp, pViewports[HAuJlzw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTWITHCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();


debug_printf("Ending vkCmdSetViewportWithCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWithCountEXT( VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports ){
return vkCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports);
}
__attribute__((visibility ("hidden"))) void vkCmdSetScissorWithCount( VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors ){
//Will only be called by the client
debug_printf("Executing vkCmdSetScissorWithCount\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSCISSORWITHCOUNT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["scissorCount"]=scissorCount;}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=boost::json::array();
            return; }
        auto& arr_RpUaBcS=json["pScissors"].emplace_array();
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto& temp=arr_RpUaBcS[XBYGvVT].emplace_object();
            return serialize_struct(temp, pScissors[XBYGvVT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSCISSORWITHCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){scissorCount=static_cast<uint32_t>(value_to<int>(json["scissorCount"]));}();


debug_printf("Ending vkCmdSetScissorWithCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetScissorWithCountEXT( VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors ){
return vkCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors);
}
__attribute__((visibility ("hidden"))) void vkCmdBindIndexBuffer2KHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType ){
//Will only be called by the client
debug_printf("Executing vkCmdBindIndexBuffer2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDINDEXBUFFER2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){[&](){[&](){json["indexType"]=indexType;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDINDEXBUFFER2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){temp_aceTSRc=static_cast<uint64_t>(value_to<int>(json["offset"]));}();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){uint64_t temp_PlNcOBd;[&](){temp_PlNcOBd=static_cast<uint64_t>(value_to<int>(json["size"]));}();size=(VkDeviceSize)temp_PlNcOBd;}();
[&](){[&](){int temp_GdrXdVh;[&](){temp_GdrXdVh=static_cast<int>(value_to<int>(json["indexType"]));}();indexType=(VkIndexType)temp_GdrXdVh;}();}();

debug_printf("Ending vkCmdBindIndexBuffer2KHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindVertexBuffers2( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides ){
//Will only be called by the client
debug_printf("Executing vkCmdBindVertexBuffers2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDVERTEXBUFFERS2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }
        auto& arr_ENtnMTo=json["pBuffers"].emplace_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }
        auto& arr_YvpyTDd=json["pOffsets"].emplace_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=boost::json::array();
            return; }
        auto& arr_OwyEmcF=json["pSizes"].emplace_array();
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=pSizes[YFhxzVl];}();}();
        }
        }();
[&](){
            if (pStrides==NULL){
                json["pStrides"]=boost::json::array();
            return; }
        auto& arr_YFLMtWg=json["pStrides"].emplace_array();
        for(int qlkJtZj=0; qlkJtZj < bindingCount; qlkJtZj++){
            [&](){[&](){arr_YFLMtWg[qlkJtZj]=pStrides[qlkJtZj];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDVERTEXBUFFERS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstBinding=static_cast<uint32_t>(value_to<int>(json["firstBinding"]));}();
[&](){bindingCount=static_cast<uint32_t>(value_to<int>(json["bindingCount"]));}();





debug_printf("Ending vkCmdBindVertexBuffers2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindVertexBuffers2EXT( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides ){
return vkCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthTestEnable( VkCommandBuffer commandBuffer, VkBool32 depthTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthTestEnable\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHTESTENABLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthTestEnable"]=depthTestEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHTESTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_WLSKeYp;[&](){temp_WLSKeYp=static_cast<uint32_t>(value_to<int>(json["depthTestEnable"]));}();depthTestEnable=(VkBool32)temp_WLSKeYp;}();

debug_printf("Ending vkCmdSetDepthTestEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthTestEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthTestEnable ){
return vkCmdSetDepthTestEnable(commandBuffer, depthTestEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthWriteEnable( VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthWriteEnable\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHWRITEENABLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthWriteEnable"]=depthWriteEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHWRITEENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_qztdWhG;[&](){temp_qztdWhG=static_cast<uint32_t>(value_to<int>(json["depthWriteEnable"]));}();depthWriteEnable=(VkBool32)temp_qztdWhG;}();

debug_printf("Ending vkCmdSetDepthWriteEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthWriteEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable ){
return vkCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthCompareOp( VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthCompareOp\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHCOMPAREOP;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["depthCompareOp"]=depthCompareOp;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCOMPAREOP):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_GommENv;[&](){temp_GommENv=static_cast<int>(value_to<int>(json["depthCompareOp"]));}();depthCompareOp=(VkCompareOp)temp_GommENv;}();}();

debug_printf("Ending vkCmdSetDepthCompareOp...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthCompareOpEXT( VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp ){
return vkCmdSetDepthCompareOp(commandBuffer, depthCompareOp);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBoundsTestEnable( VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBoundsTestEnable\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHBOUNDSTESTENABLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBoundsTestEnable"]=depthBoundsTestEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBOUNDSTESTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_qmudcyJ;[&](){temp_qmudcyJ=static_cast<uint32_t>(value_to<int>(json["depthBoundsTestEnable"]));}();depthBoundsTestEnable=(VkBool32)temp_qmudcyJ;}();

debug_printf("Ending vkCmdSetDepthBoundsTestEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBoundsTestEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable ){
return vkCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilTestEnable( VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilTestEnable\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSTENCILTESTENABLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stencilTestEnable"]=stencilTestEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILTESTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_qPvOEDS;[&](){temp_qPvOEDS=static_cast<uint32_t>(value_to<int>(json["stencilTestEnable"]));}();stencilTestEnable=(VkBool32)temp_qPvOEDS;}();

debug_printf("Ending vkCmdSetStencilTestEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilTestEnableEXT( VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable ){
return vkCmdSetStencilTestEnable(commandBuffer, stencilTestEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilOp( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilOp\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSTENCILOP;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){[&](){[&](){json["failOp"]=failOp;}();}();}();
[&](){[&](){[&](){json["passOp"]=passOp;}();}();}();
[&](){[&](){[&](){json["depthFailOp"]=depthFailOp;}();}();}();
[&](){[&](){[&](){json["compareOp"]=compareOp;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILOP):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){temp_VFXTqgy=static_cast<int>(value_to<int>(json["faceMask"]));}();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){[&](){int temp_lKXncFy;[&](){temp_lKXncFy=static_cast<int>(value_to<int>(json["failOp"]));}();failOp=(VkStencilOp)temp_lKXncFy;}();}();
[&](){[&](){int temp_SPMLjKg;[&](){temp_SPMLjKg=static_cast<int>(value_to<int>(json["passOp"]));}();passOp=(VkStencilOp)temp_SPMLjKg;}();}();
[&](){[&](){int temp_TdIKNtG;[&](){temp_TdIKNtG=static_cast<int>(value_to<int>(json["depthFailOp"]));}();depthFailOp=(VkStencilOp)temp_TdIKNtG;}();}();
[&](){[&](){int temp_NLoCySV;[&](){temp_NLoCySV=static_cast<int>(value_to<int>(json["compareOp"]));}();compareOp=(VkCompareOp)temp_NLoCySV;}();}();

debug_printf("Ending vkCmdSetStencilOp...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilOpEXT( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp ){
return vkCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
__attribute__((visibility ("hidden"))) void vkCmdSetPatchControlPointsEXT( VkCommandBuffer commandBuffer, uint32_t patchControlPoints ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPatchControlPointsEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETPATCHCONTROLPOINTSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["patchControlPoints"]=patchControlPoints;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPATCHCONTROLPOINTSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){patchControlPoints=static_cast<uint32_t>(value_to<int>(json["patchControlPoints"]));}();

debug_printf("Ending vkCmdSetPatchControlPointsEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizerDiscardEnable( VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRasterizerDiscardEnable\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETRASTERIZERDISCARDENABLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["rasterizerDiscardEnable"]=rasterizerDiscardEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRASTERIZERDISCARDENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_bdbWnok;[&](){temp_bdbWnok=static_cast<uint32_t>(value_to<int>(json["rasterizerDiscardEnable"]));}();rasterizerDiscardEnable=(VkBool32)temp_bdbWnok;}();

debug_printf("Ending vkCmdSetRasterizerDiscardEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizerDiscardEnableEXT( VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable ){
return vkCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBiasEnable( VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBiasEnable\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHBIASENABLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBiasEnable"]=depthBiasEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBIASENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_ewcVkBi;[&](){temp_ewcVkBi=static_cast<uint32_t>(value_to<int>(json["depthBiasEnable"]));}();depthBiasEnable=(VkBool32)temp_ewcVkBi;}();

debug_printf("Ending vkCmdSetDepthBiasEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBiasEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable ){
return vkCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetLogicOpEXT( VkCommandBuffer commandBuffer, VkLogicOp logicOp ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLogicOpEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETLOGICOPEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["logicOp"]=logicOp;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLOGICOPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_KRaggtp;[&](){temp_KRaggtp=static_cast<int>(value_to<int>(json["logicOp"]));}();logicOp=(VkLogicOp)temp_KRaggtp;}();}();

debug_printf("Ending vkCmdSetLogicOpEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveRestartEnable( VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPrimitiveRestartEnable\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETPRIMITIVERESTARTENABLE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["primitiveRestartEnable"]=primitiveRestartEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPRIMITIVERESTARTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_mDszbuh;[&](){temp_mDszbuh=static_cast<uint32_t>(value_to<int>(json["primitiveRestartEnable"]));}();primitiveRestartEnable=(VkBool32)temp_mDszbuh;}();

debug_printf("Ending vkCmdSetPrimitiveRestartEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveRestartEnableEXT( VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable ){
return vkCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetTessellationDomainOriginEXT( VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin ){
//Will only be called by the client
debug_printf("Executing vkCmdSetTessellationDomainOriginEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETTESSELLATIONDOMAINORIGINEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["domainOrigin"]=domainOrigin;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETTESSELLATIONDOMAINORIGINEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_MhaRSZf;[&](){temp_MhaRSZf=static_cast<int>(value_to<int>(json["domainOrigin"]));}();domainOrigin=(VkTessellationDomainOrigin)temp_MhaRSZf;}();}();

debug_printf("Ending vkCmdSetTessellationDomainOriginEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthClampEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthClampEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthClampEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHCLAMPENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClampEnable"]=depthClampEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCLAMPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_DzsSqgr;[&](){temp_DzsSqgr=static_cast<uint32_t>(value_to<int>(json["depthClampEnable"]));}();depthClampEnable=(VkBool32)temp_DzsSqgr;}();

debug_printf("Ending vkCmdSetDepthClampEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPolygonModeEXT( VkCommandBuffer commandBuffer, VkPolygonMode polygonMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPolygonModeEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETPOLYGONMODEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["polygonMode"]=polygonMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPOLYGONMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_XzCpfxJ;[&](){temp_XzCpfxJ=static_cast<int>(value_to<int>(json["polygonMode"]));}();polygonMode=(VkPolygonMode)temp_XzCpfxJ;}();}();

debug_printf("Ending vkCmdSetPolygonModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizationSamplesEXT( VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRasterizationSamplesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETRASTERIZATIONSAMPLESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["rasterizationSamples"]=rasterizationSamples;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRASTERIZATIONSAMPLESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_YCyLybT;[&](){temp_YCyLybT=static_cast<int>(value_to<int>(json["rasterizationSamples"]));}();rasterizationSamples=(VkSampleCountFlagBits)temp_YCyLybT;}();}();

debug_printf("Ending vkCmdSetRasterizationSamplesEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetSampleMaskEXT( VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask* pSampleMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetSampleMaskEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSAMPLEMASKEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){
            if (pSampleMask==NULL){
                json["pSampleMask"]=boost::json::array();
            return; }
        auto& arr_nepOVVF=json["pSampleMask"].emplace_array();
        for(int ASCUBEW=0; ASCUBEW < (samples + 31) / 32; ASCUBEW++){
            [&](){[&](){arr_nepOVVF[ASCUBEW]=pSampleMask[ASCUBEW];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSAMPLEMASKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_lbKgbKj;[&](){temp_lbKgbKj=static_cast<int>(value_to<int>(json["samples"]));}();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();


debug_printf("Ending vkCmdSetSampleMaskEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetAlphaToCoverageEnableEXT( VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetAlphaToCoverageEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETALPHATOCOVERAGEENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToCoverageEnable"]=alphaToCoverageEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETALPHATOCOVERAGEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_GXlPpxl;[&](){temp_GXlPpxl=static_cast<uint32_t>(value_to<int>(json["alphaToCoverageEnable"]));}();alphaToCoverageEnable=(VkBool32)temp_GXlPpxl;}();

debug_printf("Ending vkCmdSetAlphaToCoverageEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetAlphaToOneEnableEXT( VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetAlphaToOneEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETALPHATOONEENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToOneEnable"]=alphaToOneEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETALPHATOONEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_vIViDmy;[&](){temp_vIViDmy=static_cast<uint32_t>(value_to<int>(json["alphaToOneEnable"]));}();alphaToOneEnable=(VkBool32)temp_vIViDmy;}();

debug_printf("Ending vkCmdSetAlphaToOneEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLogicOpEnableEXT( VkCommandBuffer commandBuffer, VkBool32 logicOpEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLogicOpEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETLOGICOPENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["logicOpEnable"]=logicOpEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLOGICOPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_efIIzNf;[&](){temp_efIIzNf=static_cast<uint32_t>(value_to<int>(json["logicOpEnable"]));}();logicOpEnable=(VkBool32)temp_efIIzNf;}();

debug_printf("Ending vkCmdSetLogicOpEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorBlendEnableEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32* pColorBlendEnables ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorBlendEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOLORBLENDENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendEnables==NULL){
                json["pColorBlendEnables"]=boost::json::array();
            return; }
        auto& arr_saqDhTV=json["pColorBlendEnables"].emplace_array();
        for(int VGuJXMd=0; VGuJXMd < attachmentCount; VGuJXMd++){
            [&](){[&](){arr_saqDhTV[VGuJXMd]=pColorBlendEnables[VGuJXMd];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORBLENDENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstAttachment=static_cast<uint32_t>(value_to<int>(json["firstAttachment"]));}();
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();


debug_printf("Ending vkCmdSetColorBlendEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorBlendEquationEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT* pColorBlendEquations ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorBlendEquationEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOLORBLENDEQUATIONEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendEquations==NULL){
                json["pColorBlendEquations"]=boost::json::array();
            return; }
        auto& arr_hKUQljx=json["pColorBlendEquations"].emplace_array();
        for(int EHggOtN=0; EHggOtN < attachmentCount; EHggOtN++){
            [&](){
            auto& temp=arr_hKUQljx[EHggOtN].emplace_object();
            return serialize_struct(temp, pColorBlendEquations[EHggOtN]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORBLENDEQUATIONEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstAttachment=static_cast<uint32_t>(value_to<int>(json["firstAttachment"]));}();
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();


debug_printf("Ending vkCmdSetColorBlendEquationEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorWriteMaskEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags* pColorWriteMasks ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorWriteMaskEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOLORWRITEMASKEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorWriteMasks==NULL){
                json["pColorWriteMasks"]=boost::json::array();
            return; }
        auto& arr_VFhepws=json["pColorWriteMasks"].emplace_array();
        for(int PbQLtdZ=0; PbQLtdZ < attachmentCount; PbQLtdZ++){
            [&](){[&](){[&](){arr_VFhepws[PbQLtdZ]=pColorWriteMasks[PbQLtdZ];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORWRITEMASKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstAttachment=static_cast<uint32_t>(value_to<int>(json["firstAttachment"]));}();
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();


debug_printf("Ending vkCmdSetColorWriteMaskEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizationStreamEXT( VkCommandBuffer commandBuffer, uint32_t rasterizationStream ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRasterizationStreamEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETRASTERIZATIONSTREAMEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["rasterizationStream"]=rasterizationStream;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRASTERIZATIONSTREAMEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){rasterizationStream=static_cast<uint32_t>(value_to<int>(json["rasterizationStream"]));}();

debug_printf("Ending vkCmdSetRasterizationStreamEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetConservativeRasterizationModeEXT( VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetConservativeRasterizationModeEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["conservativeRasterizationMode"]=conservativeRasterizationMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_foXltQC;[&](){temp_foXltQC=static_cast<int>(value_to<int>(json["conservativeRasterizationMode"]));}();conservativeRasterizationMode=(VkConservativeRasterizationModeEXT)temp_foXltQC;}();}();

debug_printf("Ending vkCmdSetConservativeRasterizationModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetExtraPrimitiveOverestimationSizeEXT( VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize ){
//Will only be called by the client
debug_printf("Executing vkCmdSetExtraPrimitiveOverestimationSizeEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["extraPrimitiveOverestimationSize"]=extraPrimitiveOverestimationSize;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){extraPrimitiveOverestimationSize=static_cast<float>(value_to<int>(json["extraPrimitiveOverestimationSize"]));}();

debug_printf("Ending vkCmdSetExtraPrimitiveOverestimationSizeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthClipEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthClipEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthClipEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHCLIPENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClipEnable"]=depthClipEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCLIPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_xexuvpr;[&](){temp_xexuvpr=static_cast<uint32_t>(value_to<int>(json["depthClipEnable"]));}();depthClipEnable=(VkBool32)temp_xexuvpr;}();

debug_printf("Ending vkCmdSetDepthClipEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetSampleLocationsEnableEXT( VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetSampleLocationsEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSAMPLELOCATIONSENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["sampleLocationsEnable"]=sampleLocationsEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSAMPLELOCATIONSENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_dFVPXvO;[&](){temp_dFVPXvO=static_cast<uint32_t>(value_to<int>(json["sampleLocationsEnable"]));}();sampleLocationsEnable=(VkBool32)temp_dFVPXvO;}();

debug_printf("Ending vkCmdSetSampleLocationsEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorBlendAdvancedEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT* pColorBlendAdvanced ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorBlendAdvancedEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOLORBLENDADVANCEDEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendAdvanced==NULL){
                json["pColorBlendAdvanced"]=boost::json::array();
            return; }
        auto& arr_VhJvkCW=json["pColorBlendAdvanced"].emplace_array();
        for(int rBcMzuv=0; rBcMzuv < attachmentCount; rBcMzuv++){
            [&](){
            auto& temp=arr_VhJvkCW[rBcMzuv].emplace_object();
            return serialize_struct(temp, pColorBlendAdvanced[rBcMzuv]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORBLENDADVANCEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstAttachment=static_cast<uint32_t>(value_to<int>(json["firstAttachment"]));}();
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();


debug_printf("Ending vkCmdSetColorBlendAdvancedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetProvokingVertexModeEXT( VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetProvokingVertexModeEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETPROVOKINGVERTEXMODEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["provokingVertexMode"]=provokingVertexMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPROVOKINGVERTEXMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_unvGJcm;[&](){temp_unvGJcm=static_cast<int>(value_to<int>(json["provokingVertexMode"]));}();provokingVertexMode=(VkProvokingVertexModeEXT)temp_unvGJcm;}();}();

debug_printf("Ending vkCmdSetProvokingVertexModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineRasterizationModeEXT( VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineRasterizationModeEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETLINERASTERIZATIONMODEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["lineRasterizationMode"]=lineRasterizationMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINERASTERIZATIONMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_TzHFAEB;[&](){temp_TzHFAEB=static_cast<int>(value_to<int>(json["lineRasterizationMode"]));}();lineRasterizationMode=(VkLineRasterizationModeEXT)temp_TzHFAEB;}();}();

debug_printf("Ending vkCmdSetLineRasterizationModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineStippleEnableEXT( VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineStippleEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETLINESTIPPLEENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stippledLineEnable"]=stippledLineEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINESTIPPLEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_lOgURYj;[&](){temp_lOgURYj=static_cast<uint32_t>(value_to<int>(json["stippledLineEnable"]));}();stippledLineEnable=(VkBool32)temp_lOgURYj;}();

debug_printf("Ending vkCmdSetLineStippleEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthClipNegativeOneToOneEXT( VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthClipNegativeOneToOneEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["negativeOneToOne"]=negativeOneToOne;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_KbgfkEI;[&](){temp_KbgfkEI=static_cast<uint32_t>(value_to<int>(json["negativeOneToOne"]));}();negativeOneToOne=(VkBool32)temp_KbgfkEI;}();

debug_printf("Ending vkCmdSetDepthClipNegativeOneToOneEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWScalingEnableNV( VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportWScalingEnableNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETVIEWPORTWSCALINGENABLENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["viewportWScalingEnable"]=viewportWScalingEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTWSCALINGENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_FBvKoOa;[&](){temp_FBvKoOa=static_cast<uint32_t>(value_to<int>(json["viewportWScalingEnable"]));}();viewportWScalingEnable=(VkBool32)temp_FBvKoOa;}();

debug_printf("Ending vkCmdSetViewportWScalingEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportSwizzleNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV* pViewportSwizzles ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportSwizzleNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETVIEWPORTSWIZZLENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewportSwizzles==NULL){
                json["pViewportSwizzles"]=boost::json::array();
            return; }
        auto& arr_mlTjeMw=json["pViewportSwizzles"].emplace_array();
        for(int jvBpVNx=0; jvBpVNx < viewportCount; jvBpVNx++){
            [&](){
            auto& temp=arr_mlTjeMw[jvBpVNx].emplace_object();
            return serialize_struct(temp, pViewportSwizzles[jvBpVNx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTSWIZZLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){firstViewport=static_cast<uint32_t>(value_to<int>(json["firstViewport"]));}();
[&](){viewportCount=static_cast<uint32_t>(value_to<int>(json["viewportCount"]));}();


debug_printf("Ending vkCmdSetViewportSwizzleNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageToColorEnableNV( VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageToColorEnableNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOVERAGETOCOLORENABLENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageToColorEnable"]=coverageToColorEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGETOCOLORENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_StrBHxz;[&](){temp_StrBHxz=static_cast<uint32_t>(value_to<int>(json["coverageToColorEnable"]));}();coverageToColorEnable=(VkBool32)temp_StrBHxz;}();

debug_printf("Ending vkCmdSetCoverageToColorEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageToColorLocationNV( VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageToColorLocationNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOVERAGETOCOLORLOCATIONNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageToColorLocation"]=coverageToColorLocation;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGETOCOLORLOCATIONNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){coverageToColorLocation=static_cast<uint32_t>(value_to<int>(json["coverageToColorLocation"]));}();

debug_printf("Ending vkCmdSetCoverageToColorLocationNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageModulationModeNV( VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageModulationModeNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOVERAGEMODULATIONMODENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageModulationMode"]=coverageModulationMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEMODULATIONMODENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_BTSRuJL;[&](){temp_BTSRuJL=static_cast<int>(value_to<int>(json["coverageModulationMode"]));}();coverageModulationMode=(VkCoverageModulationModeNV)temp_BTSRuJL;}();}();

debug_printf("Ending vkCmdSetCoverageModulationModeNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageModulationTableEnableNV( VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageModulationTableEnableNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOVERAGEMODULATIONTABLEENABLENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageModulationTableEnable"]=coverageModulationTableEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEMODULATIONTABLEENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_lmSvUmH;[&](){temp_lmSvUmH=static_cast<uint32_t>(value_to<int>(json["coverageModulationTableEnable"]));}();coverageModulationTableEnable=(VkBool32)temp_lmSvUmH;}();

debug_printf("Ending vkCmdSetCoverageModulationTableEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageModulationTableNV( VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float* pCoverageModulationTable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageModulationTableNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOVERAGEMODULATIONTABLENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageModulationTableCount"]=coverageModulationTableCount;}();
[&](){
            if (pCoverageModulationTable==NULL){
                json["pCoverageModulationTable"]=boost::json::array();
            return; }
        auto& arr_FKEHfYD=json["pCoverageModulationTable"].emplace_array();
        for(int pMqhQqL=0; pMqhQqL < coverageModulationTableCount; pMqhQqL++){
            [&](){arr_FKEHfYD[pMqhQqL]=pCoverageModulationTable[pMqhQqL];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEMODULATIONTABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){coverageModulationTableCount=static_cast<uint32_t>(value_to<int>(json["coverageModulationTableCount"]));}();


debug_printf("Ending vkCmdSetCoverageModulationTableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetShadingRateImageEnableNV( VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetShadingRateImageEnableNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETSHADINGRATEIMAGEENABLENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["shadingRateImageEnable"]=shadingRateImageEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSHADINGRATEIMAGEENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_BQfvSQF;[&](){temp_BQfvSQF=static_cast<uint32_t>(value_to<int>(json["shadingRateImageEnable"]));}();shadingRateImageEnable=(VkBool32)temp_BQfvSQF;}();

debug_printf("Ending vkCmdSetShadingRateImageEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageReductionModeNV( VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageReductionModeNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOVERAGEREDUCTIONMODENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageReductionMode"]=coverageReductionMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEREDUCTIONMODENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_MbjGgOv;[&](){temp_MbjGgOv=static_cast<int>(value_to<int>(json["coverageReductionMode"]));}();coverageReductionMode=(VkCoverageReductionModeNV)temp_MbjGgOv;}();}();

debug_printf("Ending vkCmdSetCoverageReductionModeNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRepresentativeFragmentTestEnableNV( VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRepresentativeFragmentTestEnableNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["representativeFragmentTestEnable"]=representativeFragmentTestEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_VmtUEuY;[&](){temp_VmtUEuY=static_cast<uint32_t>(value_to<int>(json["representativeFragmentTestEnable"]));}();representativeFragmentTestEnable=(VkBool32)temp_VmtUEuY;}();

debug_printf("Ending vkCmdSetRepresentativeFragmentTestEnableNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePrivateDataSlot( VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot ){
//Will only be called by the client
debug_printf("Executing vkCreatePrivateDataSlot\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEPRIVATEDATASLOT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_OhzuPlW=json["pCreateInfo"].emplace_array();
        for(int KUjUcQv=0; KUjUcQv < 1; KUjUcQv++){
            [&](){
            auto& temp=arr_OhzuPlW[KUjUcQv].emplace_object();
            return serialize_struct(temp, pCreateInfo[KUjUcQv]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPrivateDataSlot==NULL){
                json["pPrivateDataSlot"]=boost::json::array();
            return; }
        auto& arr_EOSkjPn=json["pPrivateDataSlot"].emplace_array();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){serialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt],pPrivateDataSlot[QtkHhpt]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEPRIVATEDATASLOT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pPrivateDataSlot"].as_array().size()==0){
                pPrivateDataSlot=NULL;
            return; }
        auto& arr_EOSkjPn=json["pPrivateDataSlot"].as_array();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){deserialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt], pPrivateDataSlot[QtkHhpt]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_PIfQXAF;[&](){temp_PIfQXAF=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_PIfQXAF;}();}();

                if (pPrivateDataSlot!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPrivateDataSlot[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreatePrivateDataSlot...\n");
debug_printf("Return value of vkCreatePrivateDataSlot is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePrivateDataSlotEXT( VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot ){
return vkCreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
__attribute__((visibility ("hidden"))) void vkDestroyPrivateDataSlot( VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPrivateDataSlot\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYPRIVATEDATASLOT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPRIVATEDATASLOT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();


debug_printf("Ending vkDestroyPrivateDataSlot...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyPrivateDataSlotEXT( VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator ){
return vkDestroyPrivateDataSlot(device, privateDataSlot, pAllocator);
}
__attribute__((visibility ("hidden"))) VkResult vkSetPrivateData( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data ){
//Will only be called by the client
debug_printf("Executing vkSetPrivateData\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKSETPRIVATEDATA;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["objectHandle"]=objectHandle;}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){json["data"]=data;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETPRIVATEDATA):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_xzhtvEi;[&](){temp_xzhtvEi=static_cast<int>(value_to<int>(json["objectType"]));}();objectType=(VkObjectType)temp_xzhtvEi;}();}();
[&](){objectHandle=static_cast<uint64_t>(value_to<int>(json["objectHandle"]));}();
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
[&](){data=static_cast<uint64_t>(value_to<int>(json["data"]));}();
VkResult result;
[&](){[&](){int temp_WuDtERc;[&](){temp_WuDtERc=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_WuDtERc;}();}();

debug_printf("Ending vkSetPrivateData...\n");
debug_printf("Return value of vkSetPrivateData is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetPrivateDataEXT( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data ){
return vkSetPrivateData(device, objectType, objectHandle, privateDataSlot, data);
}
__attribute__((visibility ("hidden"))) void vkGetPrivateData( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData ){
//Will only be called by the client
debug_printf("Executing vkGetPrivateData\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPRIVATEDATA;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["objectHandle"]=objectHandle;}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_niIcbqy=json["pData"].emplace_array();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){arr_niIcbqy[rXHtNoy]=pData[rXHtNoy];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPRIVATEDATA):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_xzhtvEi;[&](){temp_xzhtvEi=static_cast<int>(value_to<int>(json["objectType"]));}();objectType=(VkObjectType)temp_xzhtvEi;}();}();
[&](){objectHandle=static_cast<uint64_t>(value_to<int>(json["objectHandle"]));}();
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }
        auto& arr_niIcbqy=json["pData"].as_array();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){pData[rXHtNoy]=static_cast<uint64_t>(value_to<int>(arr_niIcbqy[rXHtNoy]));}();
        }
        }();

debug_printf("Ending vkGetPrivateData...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPrivateDataEXT( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData ){
return vkGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBuffer2( VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBuffer2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYBUFFER2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferInfo==NULL){
                json["pCopyBufferInfo"]=boost::json::array();
            return; }
        auto& arr_RrXlJAO=json["pCopyBufferInfo"].emplace_array();
        for(int tCibIjb=0; tCibIjb < 1; tCibIjb++){
            [&](){
            auto& temp=arr_RrXlJAO[tCibIjb].emplace_object();
            return serialize_struct(temp, pCopyBufferInfo[tCibIjb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFER2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyBuffer2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBuffer2KHR( VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo ){
return vkCmdCopyBuffer2(commandBuffer, pCopyBufferInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImage2( VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImage2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYIMAGE2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageInfo==NULL){
                json["pCopyImageInfo"]=boost::json::array();
            return; }
        auto& arr_fhmwDMM=json["pCopyImageInfo"].emplace_array();
        for(int vtScDqF=0; vtScDqF < 1; vtScDqF++){
            [&](){
            auto& temp=arr_fhmwDMM[vtScDqF].emplace_object();
            return serialize_struct(temp, pCopyImageInfo[vtScDqF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImage2KHR( VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo ){
return vkCmdCopyImage2(commandBuffer, pCopyImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdBlitImage2( VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBlitImage2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBLITIMAGE2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBlitImageInfo==NULL){
                json["pBlitImageInfo"]=boost::json::array();
            return; }
        auto& arr_uMZBSOh=json["pBlitImageInfo"].emplace_array();
        for(int mMDYqpe=0; mMDYqpe < 1; mMDYqpe++){
            [&](){
            auto& temp=arr_uMZBSOh[mMDYqpe].emplace_object();
            return serialize_struct(temp, pBlitImageInfo[mMDYqpe]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBLITIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBlitImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBlitImage2KHR( VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo ){
return vkCmdBlitImage2(commandBuffer, pBlitImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBufferToImage2( VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBufferToImage2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYBUFFERTOIMAGE2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferToImageInfo==NULL){
                json["pCopyBufferToImageInfo"]=boost::json::array();
            return; }
        auto& arr_GgxIzVF=json["pCopyBufferToImageInfo"].emplace_array();
        for(int kZlUXOa=0; kZlUXOa < 1; kZlUXOa++){
            [&](){
            auto& temp=arr_GgxIzVF[kZlUXOa].emplace_object();
            return serialize_struct(temp, pCopyBufferToImageInfo[kZlUXOa]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFERTOIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyBufferToImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBufferToImage2KHR( VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo ){
return vkCmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImageToBuffer2( VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImageToBuffer2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYIMAGETOBUFFER2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageToBufferInfo==NULL){
                json["pCopyImageToBufferInfo"]=boost::json::array();
            return; }
        auto& arr_dKwPEQq=json["pCopyImageToBufferInfo"].emplace_array();
        for(int SXwhnUi=0; SXwhnUi < 1; SXwhnUi++){
            [&](){
            auto& temp=arr_dKwPEQq[SXwhnUi].emplace_object();
            return serialize_struct(temp, pCopyImageToBufferInfo[SXwhnUi]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGETOBUFFER2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyImageToBuffer2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImageToBuffer2KHR( VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo ){
return vkCmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdResolveImage2( VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdResolveImage2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDRESOLVEIMAGE2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pResolveImageInfo==NULL){
                json["pResolveImageInfo"]=boost::json::array();
            return; }
        auto& arr_WXEMxut=json["pResolveImageInfo"].emplace_array();
        for(int oSccZaz=0; oSccZaz < 1; oSccZaz++){
            [&](){
            auto& temp=arr_WXEMxut[oSccZaz].emplace_object();
            return serialize_struct(temp, pResolveImageInfo[oSccZaz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESOLVEIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdResolveImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResolveImage2KHR( VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo ){
return vkCmdResolveImage2(commandBuffer, pResolveImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdSetFragmentShadingRateKHR( VkCommandBuffer commandBuffer, const VkExtent2D* pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2] ){
//Will only be called by the client
debug_printf("Executing vkCmdSetFragmentShadingRateKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETFRAGMENTSHADINGRATEKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pFragmentSize==NULL){
                json["pFragmentSize"]=boost::json::array();
            return; }
        auto& arr_RBQYqfx=json["pFragmentSize"].emplace_array();
        for(int rHAqvQQ=0; rHAqvQQ < 1; rHAqvQQ++){
            [&](){
            auto& temp=arr_RBQYqfx[rHAqvQQ].emplace_object();
            return serialize_struct(temp, pFragmentSize[rHAqvQQ]);
            }();
        }
        }();
[&](){
        auto& arr_jtjRLJW=json["combinerOps"].emplace_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_jtjRLJW[uBsarms]=combinerOps[uBsarms];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETFRAGMENTSHADINGRATEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

[&](){
        auto& arr_jtjRLJW=json["combinerOps"].as_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            
        }
        }();

debug_printf("Ending vkCmdSetFragmentShadingRateKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceFragmentShadingRatesKHR( VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFragmentShadingRatesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFragmentShadingRateCount==NULL){
                json["pFragmentShadingRateCount"]=boost::json::array();
            return; }
        auto& arr_CjAZByp=json["pFragmentShadingRateCount"].emplace_array();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){arr_CjAZByp[vQwTqIV]=pFragmentShadingRateCount[vQwTqIV];}();
        }
        }();
[&](){
            if (pFragmentShadingRates==NULL){
                json["pFragmentShadingRates"]=boost::json::array();
            return; }
        auto& arr_UdwJpYv=json["pFragmentShadingRates"].emplace_array();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto& temp=arr_UdwJpYv[bVRSXYW].emplace_object();
            return serialize_struct(temp, pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pFragmentShadingRateCount"].as_array().size()==0){
                pFragmentShadingRateCount=NULL;
            return; }
        auto& arr_CjAZByp=json["pFragmentShadingRateCount"].as_array();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(value_to<int>(arr_CjAZByp[vQwTqIV]));}();
        }
        }();
[&](){
            if (json["pFragmentShadingRates"].as_array().size()==0){
                pFragmentShadingRates=NULL;
            return; }
        auto& arr_UdwJpYv=json["pFragmentShadingRates"].as_array();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto& temp=arr_UdwJpYv[bVRSXYW].as_object();
            deserialize_struct(temp,pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_kDRUeAG;[&](){temp_kDRUeAG=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_kDRUeAG;}();}();

debug_printf("Ending vkGetPhysicalDeviceFragmentShadingRatesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceFragmentShadingRatesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetFragmentShadingRateEnumNV( VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2] ){
//Will only be called by the client
debug_printf("Executing vkCmdSetFragmentShadingRateEnumNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETFRAGMENTSHADINGRATEENUMNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["shadingRate"]=shadingRate;}();}();}();
[&](){
        auto& arr_jtjRLJW=json["combinerOps"].emplace_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_jtjRLJW[uBsarms]=combinerOps[uBsarms];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETFRAGMENTSHADINGRATEENUMNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_CqLMxeN;[&](){temp_CqLMxeN=static_cast<int>(value_to<int>(json["shadingRate"]));}();shadingRate=(VkFragmentShadingRateNV)temp_CqLMxeN;}();}();
[&](){
        auto& arr_jtjRLJW=json["combinerOps"].as_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            
        }
        }();

debug_printf("Ending vkCmdSetFragmentShadingRateEnumNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetAccelerationStructureBuildSizesKHR( VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, const uint32_t* pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureBuildSizesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=buildType;}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=boost::json::array();
            return; }
        auto& arr_rNWxDog=json["pBuildInfo"].emplace_array();
        for(int DpqeGQs=0; DpqeGQs < 1; DpqeGQs++){
            [&](){
            auto& temp=arr_rNWxDog[DpqeGQs].emplace_object();
            return serialize_struct(temp, pBuildInfo[DpqeGQs]);
            }();
        }
        }();
[&](){
            if (pMaxPrimitiveCounts==NULL){
                json["pMaxPrimitiveCounts"]=boost::json::array();
            return; }
        auto& arr_vNFCnZs=json["pMaxPrimitiveCounts"].emplace_array();
        for(int KHWuVmo=0; KHWuVmo < pBuildInfo->geometryCount; KHWuVmo++){
            [&](){arr_vNFCnZs[KHWuVmo]=pMaxPrimitiveCounts[KHWuVmo];}();
        }
        }();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=boost::json::array();
            return; }
        auto& arr_aJATMZS=json["pSizeInfo"].emplace_array();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto& temp=arr_aJATMZS[pwtSWhd].emplace_object();
            return serialize_struct(temp, pSizeInfo[pwtSWhd]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_XouAsBI;[&](){temp_XouAsBI=static_cast<int>(value_to<int>(json["buildType"]));}();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();


[&](){
            if (json["pSizeInfo"].as_array().size()==0){
                pSizeInfo=NULL;
            return; }
        auto& arr_aJATMZS=json["pSizeInfo"].as_array();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto& temp=arr_aJATMZS[pwtSWhd].as_object();
            deserialize_struct(temp,pSizeInfo[pwtSWhd]);
            }();
        }
        }();

debug_printf("Ending vkGetAccelerationStructureBuildSizesKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetVertexInputEXT( VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions ){
//Will only be called by the client
debug_printf("Executing vkCmdSetVertexInputEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETVERTEXINPUTEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexBindingDescriptionCount"]=vertexBindingDescriptionCount;}();
[&](){
            if (pVertexBindingDescriptions==NULL){
                json["pVertexBindingDescriptions"]=boost::json::array();
            return; }
        auto& arr_CLcpEBv=json["pVertexBindingDescriptions"].emplace_array();
        for(int BlSYyCp=0; BlSYyCp < vertexBindingDescriptionCount; BlSYyCp++){
            [&](){
            auto& temp=arr_CLcpEBv[BlSYyCp].emplace_object();
            return serialize_struct(temp, pVertexBindingDescriptions[BlSYyCp]);
            }();
        }
        }();
[&](){json["vertexAttributeDescriptionCount"]=vertexAttributeDescriptionCount;}();
[&](){
            if (pVertexAttributeDescriptions==NULL){
                json["pVertexAttributeDescriptions"]=boost::json::array();
            return; }
        auto& arr_nigNRkL=json["pVertexAttributeDescriptions"].emplace_array();
        for(int UWEyBUU=0; UWEyBUU < vertexAttributeDescriptionCount; UWEyBUU++){
            [&](){
            auto& temp=arr_nigNRkL[UWEyBUU].emplace_object();
            return serialize_struct(temp, pVertexAttributeDescriptions[UWEyBUU]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVERTEXINPUTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){vertexBindingDescriptionCount=static_cast<uint32_t>(value_to<int>(json["vertexBindingDescriptionCount"]));}();

[&](){vertexAttributeDescriptionCount=static_cast<uint32_t>(value_to<int>(json["vertexAttributeDescriptionCount"]));}();


debug_printf("Ending vkCmdSetVertexInputEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorWriteEnableEXT( VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32* pColorWriteEnables ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorWriteEnableEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETCOLORWRITEENABLEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorWriteEnables==NULL){
                json["pColorWriteEnables"]=boost::json::array();
            return; }
        auto& arr_jmtmyTP=json["pColorWriteEnables"].emplace_array();
        for(int yHXwpvy=0; yHXwpvy < attachmentCount; yHXwpvy++){
            [&](){[&](){arr_jmtmyTP[yHXwpvy]=pColorWriteEnables[yHXwpvy];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORWRITEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){attachmentCount=static_cast<uint32_t>(value_to<int>(json["attachmentCount"]));}();


debug_printf("Ending vkCmdSetColorWriteEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetEvent2( VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetEvent2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETEVENT2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=boost::json::array();
            return; }
        auto& arr_RUiZhht=json["pDependencyInfo"].emplace_array();
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto& temp=arr_RUiZhht[rtSvYgr].emplace_object();
            return serialize_struct(temp, pDependencyInfo[rtSvYgr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEVENT2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();


debug_printf("Ending vkCmdSetEvent2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetEvent2KHR( VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo ){
return vkCmdSetEvent2(commandBuffer, event, pDependencyInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdResetEvent2( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask ){
//Will only be called by the client
debug_printf("Executing vkCmdResetEvent2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDRESETEVENT2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESETEVENT2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();
[&](){[&](){int temp_bRKcCBq;[&](){temp_bRKcCBq=static_cast<int>(value_to<int>(json["stageMask"]));}();stageMask=(VkPipelineStageFlags2)temp_bRKcCBq;}();}();

debug_printf("Ending vkCmdResetEvent2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResetEvent2KHR( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask ){
return vkCmdResetEvent2(commandBuffer, event, stageMask);
}
__attribute__((visibility ("hidden"))) void vkCmdWaitEvents2( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdWaitEvents2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDWAITEVENTS2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=eventCount;}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=boost::json::array();
            return; }
        auto& arr_tUuyOPJ=json["pEvents"].emplace_array();
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        }();
[&](){
            if (pDependencyInfos==NULL){
                json["pDependencyInfos"]=boost::json::array();
            return; }
        auto& arr_ZVkfhDe=json["pDependencyInfos"].emplace_array();
        for(int jvYalYw=0; jvYalYw < eventCount; jvYalYw++){
            [&](){
            auto& temp=arr_ZVkfhDe[jvYalYw].emplace_object();
            return serialize_struct(temp, pDependencyInfos[jvYalYw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWAITEVENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){eventCount=static_cast<uint32_t>(value_to<int>(json["eventCount"]));}();



debug_printf("Ending vkCmdWaitEvents2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWaitEvents2KHR( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos ){
return vkCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
__attribute__((visibility ("hidden"))) void vkCmdPipelineBarrier2( VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdPipelineBarrier2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDPIPELINEBARRIER2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=boost::json::array();
            return; }
        auto& arr_RUiZhht=json["pDependencyInfo"].emplace_array();
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto& temp=arr_RUiZhht[rtSvYgr].emplace_object();
            return serialize_struct(temp, pDependencyInfo[rtSvYgr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPIPELINEBARRIER2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdPipelineBarrier2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPipelineBarrier2KHR( VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo ){
return vkCmdPipelineBarrier2(commandBuffer, pDependencyInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSubmit2( VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkQueueSubmit2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKQUEUESUBMIT2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=submitCount;}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=boost::json::array();
            return; }
        auto& arr_shQKWeV=json["pSubmits"].emplace_array();
        for(int uwYUklT=0; uwYUklT < submitCount; uwYUklT++){
            [&](){
            auto& temp=arr_shQKWeV[uwYUklT].emplace_object();
            return serialize_struct(temp, pSubmits[uwYUklT]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUESUBMIT2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){submitCount=static_cast<uint32_t>(value_to<int>(json["submitCount"]));}();

[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_yhCllWM;[&](){temp_yhCllWM=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_yhCllWM;}();}();

debug_printf("Ending vkQueueSubmit2...\n");
debug_printf("Return value of vkQueueSubmit2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSubmit2KHR( VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence ){
return vkQueueSubmit2(queue, submitCount, pSubmits, fence);
}
__attribute__((visibility ("hidden"))) void vkCmdWriteTimestamp2( VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteTimestamp2\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDWRITETIMESTAMP2;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=stage;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITETIMESTAMP2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_XkgNLEZ;[&](){temp_XkgNLEZ=static_cast<int>(value_to<int>(json["stage"]));}();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){query=static_cast<uint32_t>(value_to<int>(json["query"]));}();

debug_printf("Ending vkCmdWriteTimestamp2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWriteTimestamp2KHR( VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query ){
return vkCmdWriteTimestamp2(commandBuffer, stage, queryPool, query);
}
__attribute__((visibility ("hidden"))) void vkCmdWriteBufferMarker2AMD( VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteBufferMarker2AMD\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDWRITEBUFFERMARKER2AMD;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=stage;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){json["marker"]=marker;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEBUFFERMARKER2AMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_XkgNLEZ;[&](){temp_XkgNLEZ=static_cast<int>(value_to<int>(json["stage"]));}();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){temp_fIjfpOW=static_cast<uint64_t>(value_to<int>(json["dstOffset"]));}();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){marker=static_cast<uint32_t>(value_to<int>(json["marker"]));}();

debug_printf("Ending vkCmdWriteBufferMarker2AMD...\n");
}
__attribute__((visibility ("hidden"))) void vkGetQueueCheckpointData2NV( VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData ){
//Will only be called by the client
debug_printf("Executing vkGetQueueCheckpointData2NV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETQUEUECHECKPOINTDATA2NV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=boost::json::array();
            return; }
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].emplace_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=pCheckpointDataCount[lgasnOP];}();
        }
        }();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=boost::json::array();
            return; }
        auto& arr_jIvYyZg=json["pCheckpointData"].emplace_array();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto& temp=arr_jIvYyZg[yGwfptp].emplace_object();
            return serialize_struct(temp, pCheckpointData[yGwfptp]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETQUEUECHECKPOINTDATA2NV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["pCheckpointDataCount"].as_array().size()==0){
                pCheckpointDataCount=NULL;
            return; }
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].as_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(value_to<int>(arr_LsYqVIK[lgasnOP]));}();
        }
        }();
[&](){
            if (json["pCheckpointData"].as_array().size()==0){
                pCheckpointData=NULL;
            return; }
        auto& arr_jIvYyZg=json["pCheckpointData"].as_array();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto& temp=arr_jIvYyZg[yGwfptp].as_object();
            deserialize_struct(temp,pCheckpointData[yGwfptp]);
            }();
        }
        }();

debug_printf("Ending vkGetQueueCheckpointData2NV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMemoryToImageEXT( VkDevice device, const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMemoryToImageEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOPYMEMORYTOIMAGEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyMemoryToImageInfo==NULL){
                json["pCopyMemoryToImageInfo"]=boost::json::array();
            return; }
        auto& arr_VVrQQGW=json["pCopyMemoryToImageInfo"].emplace_array();
        for(int pVINPWa=0; pVINPWa < 1; pVINPWa++){
            [&](){
            auto& temp=arr_VVrQQGW[pVINPWa].emplace_object();
            return serialize_struct(temp, pCopyMemoryToImageInfo[pVINPWa]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMEMORYTOIMAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_XYlspZI;[&](){temp_XYlspZI=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_XYlspZI;}();}();

debug_printf("Ending vkCopyMemoryToImageEXT...\n");
debug_printf("Return value of vkCopyMemoryToImageEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCopyImageToMemoryEXT( VkDevice device, const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyImageToMemoryEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOPYIMAGETOMEMORYEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToMemoryInfo==NULL){
                json["pCopyImageToMemoryInfo"]=boost::json::array();
            return; }
        auto& arr_uAVSOVI=json["pCopyImageToMemoryInfo"].emplace_array();
        for(int vveMAPG=0; vveMAPG < 1; vveMAPG++){
            [&](){
            auto& temp=arr_uAVSOVI[vveMAPG].emplace_object();
            return serialize_struct(temp, pCopyImageToMemoryInfo[vveMAPG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYIMAGETOMEMORYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_EBlIlcA;[&](){temp_EBlIlcA=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_EBlIlcA;}();}();

debug_printf("Ending vkCopyImageToMemoryEXT...\n");
debug_printf("Return value of vkCopyImageToMemoryEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCopyImageToImageEXT( VkDevice device, const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyImageToImageEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOPYIMAGETOIMAGEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToImageInfo==NULL){
                json["pCopyImageToImageInfo"]=boost::json::array();
            return; }
        auto& arr_mMvIKFh=json["pCopyImageToImageInfo"].emplace_array();
        for(int vOMFrGb=0; vOMFrGb < 1; vOMFrGb++){
            [&](){
            auto& temp=arr_mMvIKFh[vOMFrGb].emplace_object();
            return serialize_struct(temp, pCopyImageToImageInfo[vOMFrGb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYIMAGETOIMAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_llTiROc;[&](){temp_llTiROc=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_llTiROc;}();}();

debug_printf("Ending vkCopyImageToImageEXT...\n");
debug_printf("Return value of vkCopyImageToImageEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkTransitionImageLayoutEXT( VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfoEXT* pTransitions ){
//Will only be called by the client
debug_printf("Executing vkTransitionImageLayoutEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKTRANSITIONIMAGELAYOUTEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["transitionCount"]=transitionCount;}();
[&](){
            if (pTransitions==NULL){
                json["pTransitions"]=boost::json::array();
            return; }
        auto& arr_KQaENWu=json["pTransitions"].emplace_array();
        for(int EeppCgm=0; EeppCgm < transitionCount; EeppCgm++){
            [&](){
            auto& temp=arr_KQaENWu[EeppCgm].emplace_object();
            return serialize_struct(temp, pTransitions[EeppCgm]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKTRANSITIONIMAGELAYOUTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){transitionCount=static_cast<uint32_t>(value_to<int>(json["transitionCount"]));}();

VkResult result;
[&](){[&](){int temp_gLeRVxE;[&](){temp_gLeRVxE=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_gLeRVxE;}();}();

debug_printf("Ending vkTransitionImageLayoutEXT...\n");
debug_printf("Return value of vkTransitionImageLayoutEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceVideoCapabilitiesKHR( VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR* pVideoProfile, VkVideoCapabilitiesKHR* pCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceVideoCapabilitiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoProfile==NULL){
                json["pVideoProfile"]=boost::json::array();
            return; }
        auto& arr_eFObkVe=json["pVideoProfile"].emplace_array();
        for(int YJbJtas=0; YJbJtas < 1; YJbJtas++){
            [&](){
            auto& temp=arr_eFObkVe[YJbJtas].emplace_object();
            return serialize_struct(temp, pVideoProfile[YJbJtas]);
            }();
        }
        }();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }
        auto& arr_rprZzlH=json["pCapabilities"].emplace_array();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto& temp=arr_rprZzlH[NPLkdlm].emplace_object();
            return serialize_struct(temp, pCapabilities[NPLkdlm]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pCapabilities"].as_array().size()==0){
                pCapabilities=NULL;
            return; }
        auto& arr_rprZzlH=json["pCapabilities"].as_array();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto& temp=arr_rprZzlH[NPLkdlm].as_object();
            deserialize_struct(temp,pCapabilities[NPLkdlm]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_kUMqPKt;[&](){temp_kUMqPKt=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_kUMqPKt;}();}();

debug_printf("Ending vkGetPhysicalDeviceVideoCapabilitiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceVideoCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceVideoFormatPropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo, uint32_t* pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceVideoFormatPropertiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoFormatInfo==NULL){
                json["pVideoFormatInfo"]=boost::json::array();
            return; }
        auto& arr_JJWKnHz=json["pVideoFormatInfo"].emplace_array();
        for(int FIocPZR=0; FIocPZR < 1; FIocPZR++){
            [&](){
            auto& temp=arr_JJWKnHz[FIocPZR].emplace_object();
            return serialize_struct(temp, pVideoFormatInfo[FIocPZR]);
            }();
        }
        }();
[&](){
            if (pVideoFormatPropertyCount==NULL){
                json["pVideoFormatPropertyCount"]=boost::json::array();
            return; }
        auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].emplace_array();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){arr_kJoqfTP[hCeCDXk]=pVideoFormatPropertyCount[hCeCDXk];}();
        }
        }();
[&](){
            if (pVideoFormatProperties==NULL){
                json["pVideoFormatProperties"]=boost::json::array();
            return; }
        auto& arr_GhjQGHj=json["pVideoFormatProperties"].emplace_array();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto& temp=arr_GhjQGHj[mUXWOpX].emplace_object();
            return serialize_struct(temp, pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pVideoFormatPropertyCount"].as_array().size()==0){
                pVideoFormatPropertyCount=NULL;
            return; }
        auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].as_array();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(value_to<int>(arr_kJoqfTP[hCeCDXk]));}();
        }
        }();
[&](){
            if (json["pVideoFormatProperties"].as_array().size()==0){
                pVideoFormatProperties=NULL;
            return; }
        auto& arr_GhjQGHj=json["pVideoFormatProperties"].as_array();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto& temp=arr_GhjQGHj[mUXWOpX].as_object();
            deserialize_struct(temp,pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_xLlKefl;[&](){temp_xLlKefl=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_xLlKefl;}();}();

debug_printf("Ending vkGetPhysicalDeviceVideoFormatPropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceVideoFormatPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateVideoSessionKHR( VkDevice device, const VkVideoSessionCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionKHR* pVideoSession ){
//Will only be called by the client
debug_printf("Executing vkCreateVideoSessionKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEVIDEOSESSIONKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_mCuZMrp=json["pCreateInfo"].emplace_array();
        for(int tsYbFnY=0; tsYbFnY < 1; tsYbFnY++){
            [&](){
            auto& temp=arr_mCuZMrp[tsYbFnY].emplace_object();
            return serialize_struct(temp, pCreateInfo[tsYbFnY]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pVideoSession==NULL){
                json["pVideoSession"]=boost::json::array();
            return; }
        auto& arr_YUuHYdT=json["pVideoSession"].emplace_array();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){serialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX],pVideoSession[SJFoYbX]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEVIDEOSESSIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pVideoSession"].as_array().size()==0){
                pVideoSession=NULL;
            return; }
        auto& arr_YUuHYdT=json["pVideoSession"].as_array();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){deserialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX], pVideoSession[SJFoYbX]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_KvLdlOb;[&](){temp_KvLdlOb=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_KvLdlOb;}();}();

                if (pVideoSession!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pVideoSession[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateVideoSessionKHR...\n");
debug_printf("Return value of vkCreateVideoSessionKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyVideoSessionKHR( VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyVideoSessionKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYVIDEOSESSIONKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYVIDEOSESSIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();


debug_printf("Ending vkDestroyVideoSessionKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateVideoSessionParametersKHR( VkDevice device, const VkVideoSessionParametersCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionParametersKHR* pVideoSessionParameters ){
//Will only be called by the client
debug_printf("Executing vkCreateVideoSessionParametersKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEVIDEOSESSIONPARAMETERSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_PbbIaMM=json["pCreateInfo"].emplace_array();
        for(int uFIOrHK=0; uFIOrHK < 1; uFIOrHK++){
            [&](){
            auto& temp=arr_PbbIaMM[uFIOrHK].emplace_object();
            return serialize_struct(temp, pCreateInfo[uFIOrHK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pVideoSessionParameters==NULL){
                json["pVideoSessionParameters"]=boost::json::array();
            return; }
        auto& arr_drxJQhO=json["pVideoSessionParameters"].emplace_array();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){serialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP],pVideoSessionParameters[VQDtlbP]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEVIDEOSESSIONPARAMETERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pVideoSessionParameters"].as_array().size()==0){
                pVideoSessionParameters=NULL;
            return; }
        auto& arr_drxJQhO=json["pVideoSessionParameters"].as_array();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){deserialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP], pVideoSessionParameters[VQDtlbP]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_tOijjSH;[&](){temp_tOijjSH=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_tOijjSH;}();}();

                if (pVideoSessionParameters!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pVideoSessionParameters[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateVideoSessionParametersKHR...\n");
debug_printf("Return value of vkCreateVideoSessionParametersKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkUpdateVideoSessionParametersKHR( VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo ){
//Will only be called by the client
debug_printf("Executing vkUpdateVideoSessionParametersKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKUPDATEVIDEOSESSIONPARAMETERSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pUpdateInfo==NULL){
                json["pUpdateInfo"]=boost::json::array();
            return; }
        auto& arr_miOYaCQ=json["pUpdateInfo"].emplace_array();
        for(int gnypMkA=0; gnypMkA < 1; gnypMkA++){
            [&](){
            auto& temp=arr_miOYaCQ[gnypMkA].emplace_object();
            return serialize_struct(temp, pUpdateInfo[gnypMkA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUPDATEVIDEOSESSIONPARAMETERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();

VkResult result;
[&](){[&](){int temp_OrwQerQ;[&](){temp_OrwQerQ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_OrwQerQ;}();}();

debug_printf("Ending vkUpdateVideoSessionParametersKHR...\n");
debug_printf("Return value of vkUpdateVideoSessionParametersKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyVideoSessionParametersKHR( VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyVideoSessionParametersKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYVIDEOSESSIONPARAMETERSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYVIDEOSESSIONPARAMETERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();


debug_printf("Ending vkDestroyVideoSessionParametersKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetVideoSessionMemoryRequirementsKHR( VkDevice device, VkVideoSessionKHR videoSession, uint32_t* pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetVideoSessionMemoryRequirementsKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pMemoryRequirementsCount==NULL){
                json["pMemoryRequirementsCount"]=boost::json::array();
            return; }
        auto& arr_pJPineF=json["pMemoryRequirementsCount"].emplace_array();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){arr_pJPineF[NMpDmPR]=pMemoryRequirementsCount[NMpDmPR];}();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }
        auto& arr_UuJQZUu=json["pMemoryRequirements"].emplace_array();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto& temp=arr_UuJQZUu[FfNBlzG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
[&](){
            if (json["pMemoryRequirementsCount"].as_array().size()==0){
                pMemoryRequirementsCount=NULL;
            return; }
        auto& arr_pJPineF=json["pMemoryRequirementsCount"].as_array();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(value_to<int>(arr_pJPineF[NMpDmPR]));}();
        }
        }();
[&](){
            if (json["pMemoryRequirements"].as_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_UuJQZUu=json["pMemoryRequirements"].as_array();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto& temp=arr_UuJQZUu[FfNBlzG].as_object();
            deserialize_struct(temp,pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_wQRLlDp;[&](){temp_wQRLlDp=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_wQRLlDp;}();}();

debug_printf("Ending vkGetVideoSessionMemoryRequirementsKHR...\n");
debug_printf("Return value of vkGetVideoSessionMemoryRequirementsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkBindVideoSessionMemoryKHR( VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos ){
//Will only be called by the client
debug_printf("Executing vkBindVideoSessionMemoryKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBINDVIDEOSESSIONMEMORYKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){json["bindSessionMemoryInfoCount"]=bindSessionMemoryInfoCount;}();
[&](){
            if (pBindSessionMemoryInfos==NULL){
                json["pBindSessionMemoryInfos"]=boost::json::array();
            return; }
        auto& arr_XamFtca=json["pBindSessionMemoryInfos"].emplace_array();
        for(int bWiRCGV=0; bWiRCGV < bindSessionMemoryInfoCount; bWiRCGV++){
            [&](){
            auto& temp=arr_XamFtca[bWiRCGV].emplace_object();
            return serialize_struct(temp, pBindSessionMemoryInfos[bWiRCGV]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDVIDEOSESSIONMEMORYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
[&](){bindSessionMemoryInfoCount=static_cast<uint32_t>(value_to<int>(json["bindSessionMemoryInfoCount"]));}();

VkResult result;
[&](){[&](){int temp_YjMtOFB;[&](){temp_YjMtOFB=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_YjMtOFB;}();}();

debug_printf("Ending vkBindVideoSessionMemoryKHR...\n");
debug_printf("Return value of vkBindVideoSessionMemoryKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdDecodeVideoKHR( VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR* pDecodeInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdDecodeVideoKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDECODEVIDEOKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDecodeInfo==NULL){
                json["pDecodeInfo"]=boost::json::array();
            return; }
        auto& arr_FUuNCSo=json["pDecodeInfo"].emplace_array();
        for(int jmrOltD=0; jmrOltD < 1; jmrOltD++){
            [&](){
            auto& temp=arr_FUuNCSo[jmrOltD].emplace_object();
            return serialize_struct(temp, pDecodeInfo[jmrOltD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDECODEVIDEOKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdDecodeVideoKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginVideoCodingKHR( VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR* pBeginInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginVideoCodingKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBEGINVIDEOCODINGKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=boost::json::array();
            return; }
        auto& arr_pSWbqZw=json["pBeginInfo"].emplace_array();
        for(int tVSxYNW=0; tVSxYNW < 1; tVSxYNW++){
            [&](){
            auto& temp=arr_pSWbqZw[tVSxYNW].emplace_object();
            return serialize_struct(temp, pBeginInfo[tVSxYNW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINVIDEOCODINGKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginVideoCodingKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdControlVideoCodingKHR( VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR* pCodingControlInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdControlVideoCodingKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCONTROLVIDEOCODINGKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCodingControlInfo==NULL){
                json["pCodingControlInfo"]=boost::json::array();
            return; }
        auto& arr_vJmaWsp=json["pCodingControlInfo"].emplace_array();
        for(int MLwaMsn=0; MLwaMsn < 1; MLwaMsn++){
            [&](){
            auto& temp=arr_vJmaWsp[MLwaMsn].emplace_object();
            return serialize_struct(temp, pCodingControlInfo[MLwaMsn]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCONTROLVIDEOCODINGKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdControlVideoCodingKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndVideoCodingKHR( VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR* pEndCodingInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdEndVideoCodingKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDENDVIDEOCODINGKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pEndCodingInfo==NULL){
                json["pEndCodingInfo"]=boost::json::array();
            return; }
        auto& arr_OpexQSo=json["pEndCodingInfo"].emplace_array();
        for(int KxwYkSG=0; KxwYkSG < 1; KxwYkSG++){
            [&](){
            auto& temp=arr_OpexQSo[KxwYkSG].emplace_object();
            return serialize_struct(temp, pEndCodingInfo[KxwYkSG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDVIDEOCODINGKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdEndVideoCodingKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDecompressMemoryNV( VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV* pDecompressMemoryRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdDecompressMemoryNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDECOMPRESSMEMORYNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["decompressRegionCount"]=decompressRegionCount;}();
[&](){
            if (pDecompressMemoryRegions==NULL){
                json["pDecompressMemoryRegions"]=boost::json::array();
            return; }
        auto& arr_oMszjDS=json["pDecompressMemoryRegions"].emplace_array();
        for(int PnFzdhd=0; PnFzdhd < decompressRegionCount; PnFzdhd++){
            [&](){
            auto& temp=arr_oMszjDS[PnFzdhd].emplace_object();
            return serialize_struct(temp, pDecompressMemoryRegions[PnFzdhd]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDECOMPRESSMEMORYNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){decompressRegionCount=static_cast<uint32_t>(value_to<int>(json["decompressRegionCount"]));}();


debug_printf("Ending vkCmdDecompressMemoryNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDecompressMemoryIndirectCountNV( VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDecompressMemoryIndirectCountNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectCommandsAddress"]=indirectCommandsAddress;}();}();
[&](){[&](){json["indirectCommandsCountAddress"]=indirectCommandsCountAddress;}();}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_nwmsRdL;[&](){temp_nwmsRdL=static_cast<uint64_t>(value_to<int>(json["indirectCommandsAddress"]));}();indirectCommandsAddress=(VkDeviceAddress)temp_nwmsRdL;}();
[&](){uint64_t temp_TcxQHrV;[&](){temp_TcxQHrV=static_cast<uint64_t>(value_to<int>(json["indirectCommandsCountAddress"]));}();indirectCommandsCountAddress=(VkDeviceAddress)temp_TcxQHrV;}();
[&](){stride=static_cast<uint32_t>(value_to<int>(json["stride"]));}();

debug_printf("Ending vkCmdDecompressMemoryIndirectCountNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateCuModuleNVX( VkDevice device, const VkCuModuleCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuModuleNVX* pModule ){
//Will only be called by the client
debug_printf("Executing vkCreateCuModuleNVX\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATECUMODULENVX;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_FjdqPXh=json["pCreateInfo"].emplace_array();
        for(int TUVhIjf=0; TUVhIjf < 1; TUVhIjf++){
            [&](){
            auto& temp=arr_FjdqPXh[TUVhIjf].emplace_object();
            return serialize_struct(temp, pCreateInfo[TUVhIjf]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pModule==NULL){
                json["pModule"]=boost::json::array();
            return; }
        auto& arr_FnQIexZ=json["pModule"].emplace_array();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){serialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko],pModule[ozltKko]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECUMODULENVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pModule"].as_array().size()==0){
                pModule=NULL;
            return; }
        auto& arr_FnQIexZ=json["pModule"].as_array();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){deserialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko], pModule[ozltKko]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_YYTFaBo;[&](){temp_YYTFaBo=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_YYTFaBo;}();}();

                if (pModule!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pModule[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateCuModuleNVX...\n");
debug_printf("Return value of vkCreateCuModuleNVX is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateCuFunctionNVX( VkDevice device, const VkCuFunctionCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuFunctionNVX* pFunction ){
//Will only be called by the client
debug_printf("Executing vkCreateCuFunctionNVX\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATECUFUNCTIONNVX;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_XkBojZi=json["pCreateInfo"].emplace_array();
        for(int twsSgji=0; twsSgji < 1; twsSgji++){
            [&](){
            auto& temp=arr_XkBojZi[twsSgji].emplace_object();
            return serialize_struct(temp, pCreateInfo[twsSgji]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFunction==NULL){
                json["pFunction"]=boost::json::array();
            return; }
        auto& arr_TrIYEcP=json["pFunction"].emplace_array();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){serialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF],pFunction[zzRpTQF]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECUFUNCTIONNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFunction"].as_array().size()==0){
                pFunction=NULL;
            return; }
        auto& arr_TrIYEcP=json["pFunction"].as_array();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){deserialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF], pFunction[zzRpTQF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_txvDXBI;[&](){temp_txvDXBI=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_txvDXBI;}();}();

                if (pFunction!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pFunction[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateCuFunctionNVX...\n");
debug_printf("Return value of vkCreateCuFunctionNVX is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyCuModuleNVX( VkDevice device, VkCuModuleNVX module, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyCuModuleNVX\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYCUMODULENVX;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuModuleNVX(json["module"],module);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYCUMODULENVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCuModuleNVX(json["module"], module);}();


debug_printf("Ending vkDestroyCuModuleNVX...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyCuFunctionNVX( VkDevice device, VkCuFunctionNVX function, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyCuFunctionNVX\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYCUFUNCTIONNVX;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuFunctionNVX(json["function"],function);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYCUFUNCTIONNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCuFunctionNVX(json["function"], function);}();


debug_printf("Ending vkDestroyCuFunctionNVX...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCuLaunchKernelNVX( VkCommandBuffer commandBuffer, const VkCuLaunchInfoNVX* pLaunchInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCuLaunchKernelNVX\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCULAUNCHKERNELNVX;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLaunchInfo==NULL){
                json["pLaunchInfo"]=boost::json::array();
            return; }
        auto& arr_UKYVund=json["pLaunchInfo"].emplace_array();
        for(int eUSpbRB=0; eUSpbRB < 1; eUSpbRB++){
            [&](){
            auto& temp=arr_UKYVund[eUSpbRB].emplace_object();
            return serialize_struct(temp, pLaunchInfo[eUSpbRB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCULAUNCHKERNELNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCuLaunchKernelNVX...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutSizeEXT( VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize* pLayoutSizeInBytes ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutSizeEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDESCRIPTORSETLAYOUTSIZEEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){
            if (pLayoutSizeInBytes==NULL){
                json["pLayoutSizeInBytes"]=boost::json::array();
            return; }
        auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].emplace_array();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){[&](){arr_xOYiCiO[QcQjmSi]=pLayoutSizeInBytes[QcQjmSi];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTSIZEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
[&](){
            if (json["pLayoutSizeInBytes"].as_array().size()==0){
                pLayoutSizeInBytes=NULL;
            return; }
        auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].as_array();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){uint64_t temp_xOYiCiO;[&](){temp_xOYiCiO=static_cast<uint64_t>(value_to<int>(arr_xOYiCiO[QcQjmSi]));}();pLayoutSizeInBytes[QcQjmSi]=(VkDeviceSize)temp_xOYiCiO;}();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutSizeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutBindingOffsetEXT( VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize* pOffset ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutBindingOffsetEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){json["binding"]=binding;}();
[&](){
            if (pOffset==NULL){
                json["pOffset"]=boost::json::array();
            return; }
        auto& arr_dquZgZN=json["pOffset"].emplace_array();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){[&](){arr_dquZgZN[LNetLnu]=pOffset[LNetLnu];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
[&](){binding=static_cast<uint32_t>(value_to<int>(json["binding"]));}();
[&](){
            if (json["pOffset"].as_array().size()==0){
                pOffset=NULL;
            return; }
        auto& arr_dquZgZN=json["pOffset"].as_array();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){uint64_t temp_dquZgZN;[&](){temp_dquZgZN=static_cast<uint64_t>(value_to<int>(arr_dquZgZN[LNetLnu]));}();pOffset[LNetLnu]=(VkDeviceSize)temp_dquZgZN;}();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutBindingOffsetEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorEXT( VkDevice device, const VkDescriptorGetInfoEXT* pDescriptorInfo, size_t dataSize, void* pDescriptor ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDESCRIPTOREXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDescriptorInfo==NULL){
                json["pDescriptorInfo"]=boost::json::array();
            return; }
        auto& arr_RGgHhwd=json["pDescriptorInfo"].emplace_array();
        for(int cdcTeyn=0; cdcTeyn < 1; cdcTeyn++){
            [&](){
            auto& temp=arr_RGgHhwd[cdcTeyn].emplace_object();
            return serialize_struct(temp, pDescriptorInfo[cdcTeyn]);
            }();
        }
        }();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pDescriptor==NULL){
                json["pDescriptor"]=boost::json::array();
            return; }[&](){
            if (((char*)(pDescriptor))==NULL){
                json["pDescriptor"]=boost::json::array();
            return; }
        auto& arr_LMyOepF=json["pDescriptor"].emplace_array();
        for(int FBuPGmd=0; FBuPGmd < dataSize; FBuPGmd++){
            [&](){arr_LMyOepF[FBuPGmd]=((char*)(pDescriptor))[FBuPGmd];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTOREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
[&](){
            if (json["pDescriptor"].as_array().size()==0){
                pDescriptor=NULL;
            return; }char* temp_mEHYUhJ;[&](){
            if (json["pDescriptor"].as_array().size()==0){
                temp_mEHYUhJ=NULL;
            return; }
        auto& arr_LMyOepF=json["pDescriptor"].as_array();
        for(int FBuPGmd=0; FBuPGmd < dataSize; FBuPGmd++){
            [&](){temp_mEHYUhJ[FBuPGmd]=static_cast<char>(value_to<int>(arr_LMyOepF[FBuPGmd]));}();
        }
        }();pDescriptor=temp_mEHYUhJ;}();

debug_printf("Ending vkGetDescriptorEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindDescriptorBuffersEXT( VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT* pBindingInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdBindDescriptorBuffersEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDDESCRIPTORBUFFERSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["bufferCount"]=bufferCount;}();
[&](){
            if (pBindingInfos==NULL){
                json["pBindingInfos"]=boost::json::array();
            return; }
        auto& arr_guwgqGC=json["pBindingInfos"].emplace_array();
        for(int btgeqwi=0; btgeqwi < bufferCount; btgeqwi++){
            [&](){
            auto& temp=arr_guwgqGC[btgeqwi].emplace_object();
            return serialize_struct(temp, pBindingInfos[btgeqwi]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDDESCRIPTORBUFFERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){bufferCount=static_cast<uint32_t>(value_to<int>(json["bufferCount"]));}();


debug_printf("Ending vkCmdBindDescriptorBuffersEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDescriptorBufferOffsetsEXT( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDescriptorBufferOffsetsEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDESCRIPTORBUFFEROFFSETSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=firstSet;}();
[&](){json["setCount"]=setCount;}();
[&](){
            if (pBufferIndices==NULL){
                json["pBufferIndices"]=boost::json::array();
            return; }
        auto& arr_zejaAgt=json["pBufferIndices"].emplace_array();
        for(int tuuKbsL=0; tuuKbsL < setCount; tuuKbsL++){
            [&](){arr_zejaAgt[tuuKbsL]=pBufferIndices[tuuKbsL];}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }
        auto& arr_YvpyTDd=json["pOffsets"].emplace_array();
        for(int ySwhvse=0; ySwhvse < setCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDESCRIPTORBUFFEROFFSETSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){firstSet=static_cast<uint32_t>(value_to<int>(json["firstSet"]));}();
[&](){setCount=static_cast<uint32_t>(value_to<int>(json["setCount"]));}();



debug_printf("Ending vkCmdSetDescriptorBufferOffsetsEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindDescriptorBufferEmbeddedSamplersEXT( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set ){
//Will only be called by the client
debug_printf("Executing vkCmdBindDescriptorBufferEmbeddedSamplersEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){temp_Hfcuzju=static_cast<int>(value_to<int>(json["pipelineBindPoint"]));}();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){set=static_cast<uint32_t>(value_to<int>(json["set"]));}();

debug_printf("Ending vkCmdBindDescriptorBufferEmbeddedSamplersEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetBufferOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetBufferOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_Hxvezrr=json["pInfo"].emplace_array();
        for(int VgzeNwX=0; VgzeNwX < 1; VgzeNwX++){
            [&](){
            auto& temp=arr_Hxvezrr[VgzeNwX].emplace_object();
            return serialize_struct(temp, pInfo[VgzeNwX]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_xwzikKs;[&](){temp_xwzikKs=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_xwzikKs;}();}();

debug_printf("Ending vkGetBufferOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetBufferOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkImageCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetImageOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_vrxBIsi=json["pInfo"].emplace_array();
        for(int swRpuDc=0; swRpuDc < 1; swRpuDc++){
            [&](){
            auto& temp=arr_vrxBIsi[swRpuDc].emplace_object();
            return serialize_struct(temp, pInfo[swRpuDc]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_TPyqMAV;[&](){temp_TPyqMAV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_TPyqMAV;}();}();

debug_printf("Ending vkGetImageOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetImageOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageViewOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetImageViewOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_CYlSaQv=json["pInfo"].emplace_array();
        for(int pmdADqD=0; pmdADqD < 1; pmdADqD++){
            [&](){
            auto& temp=arr_CYlSaQv[pmdADqD].emplace_object();
            return serialize_struct(temp, pInfo[pmdADqD]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_OdFZoNY;[&](){temp_OdFZoNY=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_OdFZoNY;}();}();

debug_printf("Ending vkGetImageViewOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetImageViewOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetSamplerOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetSamplerOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_RMPxsVS=json["pInfo"].emplace_array();
        for(int SScNLQN=0; SScNLQN < 1; SScNLQN++){
            [&](){
            auto& temp=arr_RMPxsVS[SScNLQN].emplace_object();
            return serialize_struct(temp, pInfo[SScNLQN]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_FcQRCfn;[&](){temp_FcQRCfn=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_FcQRCfn;}();}();

debug_printf("Ending vkGetSamplerOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetSamplerOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_iLnHGmk=json["pInfo"].emplace_array();
        for(int kbTuVMH=0; kbTuVMH < 1; kbTuVMH++){
            [&](){
            auto& temp=arr_iLnHGmk[kbTuVMH].emplace_object();
            return serialize_struct(temp, pInfo[kbTuVMH]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < strlen(((char*)(pData)))+1; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_array().size()==0){
                temp_lBHICWs=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < json["pData"].as_array().size(); BSRqoqj++){
            [&](){temp_lBHICWs[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_dMYyLsp;[&](){temp_dMYyLsp=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_dMYyLsp;}();}();

debug_printf("Ending vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkSetDeviceMemoryPriorityEXT( VkDevice device, VkDeviceMemory memory, float priority ){
//Will only be called by the client
debug_printf("Executing vkSetDeviceMemoryPriorityEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKSETDEVICEMEMORYPRIORITYEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){json["priority"]=priority;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETDEVICEMEMORYPRIORITYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){priority=static_cast<float>(value_to<int>(json["priority"]));}();

debug_printf("Ending vkSetDeviceMemoryPriorityEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireDrmDisplayEXT( VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display ){
//Will only be called by the client
debug_printf("Executing vkAcquireDrmDisplayEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKACQUIREDRMDISPLAYEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=drmFd;}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIREDRMDISPLAYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){drmFd=static_cast<int32_t>(value_to<int>(json["drmFd"]));}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
VkResult result;
[&](){[&](){int temp_YxBMtij;[&](){temp_YxBMtij=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_YxBMtij;}();}();

debug_printf("Ending vkAcquireDrmDisplayEXT...\n");
debug_printf("Return value of vkAcquireDrmDisplayEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDrmDisplayEXT( VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR* display ){
//Will only be called by the client
debug_printf("Executing vkGetDrmDisplayEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDRMDISPLAYEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=drmFd;}();
[&](){json["connectorId"]=connectorId;}();
[&](){
            if (display==NULL){
                json["display"]=boost::json::array();
            return; }
        auto& arr_DpFHFgI=json["display"].emplace_array();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){serialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA],display[AVVxOCA]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDRMDISPLAYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){drmFd=static_cast<int32_t>(value_to<int>(json["drmFd"]));}();
[&](){connectorId=static_cast<uint32_t>(value_to<int>(json["connectorId"]));}();
[&](){
            if (json["display"].as_array().size()==0){
                display=NULL;
            return; }
        auto& arr_DpFHFgI=json["display"].as_array();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){deserialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA], display[AVVxOCA]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_kqOIadV;[&](){temp_kqOIadV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_kqOIadV;}();}();

debug_printf("Ending vkGetDrmDisplayEXT...\n");
debug_printf("Return value of vkGetDrmDisplayEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkWaitForPresentKHR( VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout ){
//Will only be called by the client
debug_printf("Executing vkWaitForPresentKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKWAITFORPRESENTKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["presentId"]=presentId;}();
[&](){json["timeout"]=timeout;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWAITFORPRESENTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){presentId=static_cast<uint64_t>(value_to<int>(json["presentId"]));}();
[&](){timeout=static_cast<uint64_t>(value_to<int>(json["timeout"]));}();
VkResult result;
[&](){[&](){int temp_IJKocXl;[&](){temp_IJKocXl=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_IJKocXl;}();}();

debug_printf("Ending vkWaitForPresentKHR...\n");
debug_printf("Return value of vkWaitForPresentKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRendering( VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginRendering\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBEGINRENDERING;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=boost::json::array();
            return; }
        auto& arr_DOEgrev=json["pRenderingInfo"].emplace_array();
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto& temp=arr_DOEgrev[dAqQfxy].emplace_object();
            return serialize_struct(temp, pRenderingInfo[dAqQfxy]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINRENDERING):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginRendering...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderingKHR( VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo ){
return vkCmdBeginRendering(commandBuffer, pRenderingInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdEndRendering( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndRendering\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDENDRENDERING;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDRENDERING):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndRendering...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderingKHR( VkCommandBuffer commandBuffer ){
return vkCmdEndRendering(commandBuffer);
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutHostMappingInfoVALVE( VkDevice device, const VkDescriptorSetBindingReferenceVALVE* pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutHostMappingInfoVALVE\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pBindingReference==NULL){
                json["pBindingReference"]=boost::json::array();
            return; }
        auto& arr_JTmPGZt=json["pBindingReference"].emplace_array();
        for(int OEumPxJ=0; OEumPxJ < 1; OEumPxJ++){
            [&](){
            auto& temp=arr_JTmPGZt[OEumPxJ].emplace_object();
            return serialize_struct(temp, pBindingReference[OEumPxJ]);
            }();
        }
        }();
[&](){
            if (pHostMapping==NULL){
                json["pHostMapping"]=boost::json::array();
            return; }
        auto& arr_zODJzpL=json["pHostMapping"].emplace_array();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto& temp=arr_zODJzpL[jHGvhna].emplace_object();
            return serialize_struct(temp, pHostMapping[jHGvhna]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pHostMapping"].as_array().size()==0){
                pHostMapping=NULL;
            return; }
        auto& arr_zODJzpL=json["pHostMapping"].as_array();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto& temp=arr_zODJzpL[jHGvhna].as_object();
            deserialize_struct(temp,pHostMapping[jHGvhna]);
            }();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutHostMappingInfoVALVE...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetHostMappingVALVE( VkDevice device, VkDescriptorSet descriptorSet, void** ppData ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetHostMappingVALVE\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDESCRIPTORSETHOSTMAPPINGVALVE;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }
        auto& arr_JgRLJSK=json["ppData"].emplace_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }
        auto& arr_yHvgdEb=arr_JgRLJSK[NsRFkBj].emplace_array();
        for(int vgxltbA=0; vgxltbA < strlen(((char*)(ppData[NsRFkBj])))+1; vgxltbA++){
            [&](){arr_yHvgdEb[vgxltbA]=((char*)(ppData[NsRFkBj]))[vgxltbA];}();
        }
        }();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETHOSTMAPPINGVALVE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
[&](){
            if (json["ppData"].as_array().size()==0){
                ppData=NULL;
            return; }
        auto& arr_JgRLJSK=json["ppData"].as_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].as_array().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].as_array().size()==0){
                temp_JgRLJSK=NULL;
            return; }
        auto& arr_yHvgdEb=arr_JgRLJSK[NsRFkBj].as_array();
        for(int vgxltbA=0; vgxltbA < arr_JgRLJSK[NsRFkBj].as_array().size(); vgxltbA++){
            [&](){temp_JgRLJSK[vgxltbA]=static_cast<char>(value_to<int>(arr_yHvgdEb[vgxltbA]));}();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();

debug_printf("Ending vkGetDescriptorSetHostMappingVALVE...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateMicromapEXT( VkDevice device, const VkMicromapCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkMicromapEXT* pMicromap ){
//Will only be called by the client
debug_printf("Executing vkCreateMicromapEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEMICROMAPEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_vrQtrYo=json["pCreateInfo"].emplace_array();
        for(int cfhYIUK=0; cfhYIUK < 1; cfhYIUK++){
            [&](){
            auto& temp=arr_vrQtrYo[cfhYIUK].emplace_object();
            return serialize_struct(temp, pCreateInfo[cfhYIUK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMicromap==NULL){
                json["pMicromap"]=boost::json::array();
            return; }
        auto& arr_mHmzwPX=json["pMicromap"].emplace_array();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){serialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm],pMicromap[vcxNgSm]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pMicromap"].as_array().size()==0){
                pMicromap=NULL;
            return; }
        auto& arr_mHmzwPX=json["pMicromap"].as_array();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){deserialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm], pMicromap[vcxNgSm]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_HMbPbkA;[&](){temp_HMbPbkA=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_HMbPbkA;}();}();

                if (pMicromap!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pMicromap[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateMicromapEXT...\n");
debug_printf("Return value of vkCreateMicromapEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBuildMicromapsEXT( VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildMicromapsEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBUILDMICROMAPSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_KdoluBZ=json["pInfos"].emplace_array();
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto& temp=arr_KdoluBZ[bfMWBOA].emplace_object();
            return serialize_struct(temp, pInfos[bfMWBOA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDMICROMAPSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();


debug_printf("Ending vkCmdBuildMicromapsEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBuildMicromapsEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos ){
//Will only be called by the client
debug_printf("Executing vkBuildMicromapsEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBUILDMICROMAPSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }
        auto& arr_KdoluBZ=json["pInfos"].emplace_array();
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto& temp=arr_KdoluBZ[bfMWBOA].emplace_object();
            return serialize_struct(temp, pInfos[bfMWBOA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBUILDMICROMAPSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
[&](){infoCount=static_cast<uint32_t>(value_to<int>(json["infoCount"]));}();

VkResult result;
[&](){[&](){int temp_IKdsnOC;[&](){temp_IKdsnOC=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_IKdsnOC;}();}();

debug_printf("Ending vkBuildMicromapsEXT...\n");
debug_printf("Return value of vkBuildMicromapsEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyMicromapEXT( VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyMicromapEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYMICROMAPEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkMicromapEXT(json["micromap"],micromap);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkMicromapEXT(json["micromap"], micromap);}();


debug_printf("Ending vkDestroyMicromapEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMicromapEXT( VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMicromapEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYMICROMAPEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_UIlbXxp=json["pInfo"].emplace_array();
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto& temp=arr_UIlbXxp[vDMleIo].emplace_object();
            return serialize_struct(temp, pInfo[vDMleIo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMicromapEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMicromapEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMicromapEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOPYMICROMAPEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_UIlbXxp=json["pInfo"].emplace_array();
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto& temp=arr_UIlbXxp[vDMleIo].emplace_object();
            return serialize_struct(temp, pInfo[vDMleIo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_LwBoIWY;[&](){temp_LwBoIWY=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_LwBoIWY;}();}();

debug_printf("Ending vkCopyMicromapEXT...\n");
debug_printf("Return value of vkCopyMicromapEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMicromapToMemoryEXT( VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMicromapToMemoryEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYMICROMAPTOMEMORYEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_EiLirbT=json["pInfo"].emplace_array();
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto& temp=arr_EiLirbT[dzsAOWF].emplace_object();
            return serialize_struct(temp, pInfo[dzsAOWF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMICROMAPTOMEMORYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMicromapToMemoryEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMicromapToMemoryEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMicromapToMemoryEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOPYMICROMAPTOMEMORYEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_EiLirbT=json["pInfo"].emplace_array();
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto& temp=arr_EiLirbT[dzsAOWF].emplace_object();
            return serialize_struct(temp, pInfo[dzsAOWF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMICROMAPTOMEMORYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_UIvmryr;[&](){temp_UIvmryr=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_UIvmryr;}();}();

debug_printf("Ending vkCopyMicromapToMemoryEXT...\n");
debug_printf("Return value of vkCopyMicromapToMemoryEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryToMicromapEXT( VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryToMicromapEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDCOPYMEMORYTOMICROMAPEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_QufOGLT=json["pInfo"].emplace_array();
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto& temp=arr_QufOGLT[semZpgt].emplace_object();
            return serialize_struct(temp, pInfo[semZpgt]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYTOMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMemoryToMicromapEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMemoryToMicromapEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMemoryToMicromapEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCOPYMEMORYTOMICROMAPEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_QufOGLT=json["pInfo"].emplace_array();
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto& temp=arr_QufOGLT[semZpgt].emplace_object();
            return serialize_struct(temp, pInfo[semZpgt]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMEMORYTOMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_TMcEvWr;[&](){temp_TMcEvWr=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_TMcEvWr;}();}();

debug_printf("Ending vkCopyMemoryToMicromapEXT...\n");
debug_printf("Return value of vkCopyMemoryToMicromapEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdWriteMicromapsPropertiesEXT( VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteMicromapsPropertiesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDWRITEMICROMAPSPROPERTIESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["micromapCount"]=micromapCount;}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=boost::json::array();
            return; }
        auto& arr_NriAFXg=json["pMicromaps"].emplace_array();
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEMICROMAPSPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){micromapCount=static_cast<uint32_t>(value_to<int>(json["micromapCount"]));}();

[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){firstQuery=static_cast<uint32_t>(value_to<int>(json["firstQuery"]));}();

debug_printf("Ending vkCmdWriteMicromapsPropertiesEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkWriteMicromapsPropertiesEXT( VkDevice device, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, size_t dataSize, void* pData, size_t stride ){
//Will only be called by the client
debug_printf("Executing vkWriteMicromapsPropertiesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKWRITEMICROMAPSPROPERTIESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["micromapCount"]=micromapCount;}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=boost::json::array();
            return; }
        auto& arr_NriAFXg=json["pMicromaps"].emplace_array();
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWRITEMICROMAPSPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){micromapCount=static_cast<uint32_t>(value_to<int>(json["micromapCount"]));}();

[&](){[&](){int temp_VdJSktT;[&](){temp_VdJSktT=static_cast<int>(value_to<int>(json["queryType"]));}();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){dataSize=static_cast<size_t>(value_to<int>(json["dataSize"]));}();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < dataSize; BSRqoqj++){
            [&](){temp_hrhAtyM[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_hrhAtyM;}();
[&](){stride=static_cast<size_t>(value_to<int>(json["stride"]));}();
VkResult result;
[&](){[&](){int temp_oOtApCx;[&](){temp_oOtApCx=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_oOtApCx;}();}();

debug_printf("Ending vkWriteMicromapsPropertiesEXT...\n");
debug_printf("Return value of vkWriteMicromapsPropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceMicromapCompatibilityEXT( VkDevice device, const VkMicromapVersionInfoEXT* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceMicromapCompatibilityEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEMICROMAPCOMPATIBILITYEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=boost::json::array();
            return; }
        auto& arr_PYqUGEM=json["pVersionInfo"].emplace_array();
        for(int odfXDEI=0; odfXDEI < 1; odfXDEI++){
            [&](){
            auto& temp=arr_PYqUGEM[odfXDEI].emplace_object();
            return serialize_struct(temp, pVersionInfo[odfXDEI]);
            }();
        }
        }();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=boost::json::array();
            return; }
        auto& arr_dBMhFMX=json["pCompatibility"].emplace_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=pCompatibility[nzOFTGF];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEMICROMAPCOMPATIBILITYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pCompatibility"].as_array().size()==0){
                pCompatibility=NULL;
            return; }
        auto& arr_dBMhFMX=json["pCompatibility"].as_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){temp_guVSKHd=static_cast<int>(value_to<int>(arr_dBMhFMX[nzOFTGF]));}();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

debug_printf("Ending vkGetDeviceMicromapCompatibilityEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetMicromapBuildSizesEXT( VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT* pBuildInfo, VkMicromapBuildSizesInfoEXT* pSizeInfo ){
//Will only be called by the client
debug_printf("Executing vkGetMicromapBuildSizesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETMICROMAPBUILDSIZESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=buildType;}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=boost::json::array();
            return; }
        auto& arr_lREHNwp=json["pBuildInfo"].emplace_array();
        for(int nPItxru=0; nPItxru < 1; nPItxru++){
            [&](){
            auto& temp=arr_lREHNwp[nPItxru].emplace_object();
            return serialize_struct(temp, pBuildInfo[nPItxru]);
            }();
        }
        }();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=boost::json::array();
            return; }
        auto& arr_fJKSsZw=json["pSizeInfo"].emplace_array();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto& temp=arr_fJKSsZw[XgjgtXU].emplace_object();
            return serialize_struct(temp, pSizeInfo[XgjgtXU]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMICROMAPBUILDSIZESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_XouAsBI;[&](){temp_XouAsBI=static_cast<int>(value_to<int>(json["buildType"]));}();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();

[&](){
            if (json["pSizeInfo"].as_array().size()==0){
                pSizeInfo=NULL;
            return; }
        auto& arr_fJKSsZw=json["pSizeInfo"].as_array();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto& temp=arr_fJKSsZw[XgjgtXU].as_object();
            deserialize_struct(temp,pSizeInfo[XgjgtXU]);
            }();
        }
        }();

debug_printf("Ending vkGetMicromapBuildSizesEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetShaderModuleIdentifierEXT( VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT* pIdentifier ){
//Will only be called by the client
debug_printf("Executing vkGetShaderModuleIdentifierEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSHADERMODULEIDENTIFIEREXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=boost::json::array();
            return; }
        auto& arr_ICaFqGG=json["pIdentifier"].emplace_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].emplace_object();
            return serialize_struct(temp, pIdentifier[DSBkSwY]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERMODULEIDENTIFIEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();
[&](){
            if (json["pIdentifier"].as_array().size()==0){
                pIdentifier=NULL;
            return; }
        auto& arr_ICaFqGG=json["pIdentifier"].as_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].as_object();
            deserialize_struct(temp,pIdentifier[DSBkSwY]);
            }();
        }
        }();

debug_printf("Ending vkGetShaderModuleIdentifierEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetShaderModuleCreateInfoIdentifierEXT( VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, VkShaderModuleIdentifierEXT* pIdentifier ){
//Will only be called by the client
debug_printf("Executing vkGetShaderModuleCreateInfoIdentifierEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSHADERMODULECREATEINFOIDENTIFIEREXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_iSZUILM=json["pCreateInfo"].emplace_array();
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto& temp=arr_iSZUILM[dKxemXH].emplace_object();
            return serialize_struct(temp, pCreateInfo[dKxemXH]);
            }();
        }
        }();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=boost::json::array();
            return; }
        auto& arr_ICaFqGG=json["pIdentifier"].emplace_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].emplace_object();
            return serialize_struct(temp, pIdentifier[DSBkSwY]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERMODULECREATEINFOIDENTIFIEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pIdentifier"].as_array().size()==0){
                pIdentifier=NULL;
            return; }
        auto& arr_ICaFqGG=json["pIdentifier"].as_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].as_object();
            deserialize_struct(temp,pIdentifier[DSBkSwY]);
            }();
        }
        }();

debug_printf("Ending vkGetShaderModuleCreateInfoIdentifierEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSubresourceLayout2KHR( VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout ){
//Will only be called by the client
debug_printf("Executing vkGetImageSubresourceLayout2KHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETIMAGESUBRESOURCELAYOUT2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=boost::json::array();
            return; }
        auto& arr_xtdYssI=json["pSubresource"].emplace_array();
        for(int HvvKvoL=0; HvvKvoL < 1; HvvKvoL++){
            [&](){
            auto& temp=arr_xtdYssI[HvvKvoL].emplace_object();
            return serialize_struct(temp, pSubresource[HvvKvoL]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }
        auto& arr_JxnVeqW=json["pLayout"].emplace_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].emplace_object();
            return serialize_struct(temp, pLayout[jEkaLQP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESUBRESOURCELAYOUT2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();

[&](){
            if (json["pLayout"].as_array().size()==0){
                pLayout=NULL;
            return; }
        auto& arr_JxnVeqW=json["pLayout"].as_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].as_object();
            deserialize_struct(temp,pLayout[jEkaLQP]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSubresourceLayout2KHR...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSubresourceLayout2EXT( VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout ){
return vkGetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelinePropertiesEXT( VkDevice device, const VkPipelineInfoEXT* pPipelineInfo, VkBaseOutStructure* pPipelineProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPipelinePropertiesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPIPELINEPROPERTIESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=boost::json::array();
            return; }
        auto& arr_eGbOPJq=json["pPipelineInfo"].emplace_array();
        for(int iUjmOrp=0; iUjmOrp < 1; iUjmOrp++){
            [&](){
            auto& temp=arr_eGbOPJq[iUjmOrp].emplace_object();
            return serialize_struct(temp, pPipelineInfo[iUjmOrp]);
            }();
        }
        }();
[&](){
            if (pPipelineProperties==NULL){
                json["pPipelineProperties"]=boost::json::array();
            return; }
        auto& arr_eMgMlNc=json["pPipelineProperties"].emplace_array();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto& temp=arr_eMgMlNc[cJpCXwz].emplace_object();
            return serialize_struct(temp, pPipelineProperties[cJpCXwz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pPipelineProperties"].as_array().size()==0){
                pPipelineProperties=NULL;
            return; }
        auto& arr_eMgMlNc=json["pPipelineProperties"].as_array();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto& temp=arr_eMgMlNc[cJpCXwz].as_object();
            deserialize_struct(temp,pPipelineProperties[cJpCXwz]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_rtnEbkZ;[&](){temp_rtnEbkZ=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_rtnEbkZ;}();}();

debug_printf("Ending vkGetPipelinePropertiesEXT...\n");
debug_printf("Return value of vkGetPipelinePropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetFramebufferTilePropertiesQCOM( VkDevice device, VkFramebuffer framebuffer, uint32_t* pPropertiesCount, VkTilePropertiesQCOM* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetFramebufferTilePropertiesQCOM\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETFRAMEBUFFERTILEPROPERTIESQCOM;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pPropertiesCount==NULL){
                json["pPropertiesCount"]=boost::json::array();
            return; }
        auto& arr_vUkyKfO=json["pPropertiesCount"].emplace_array();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){arr_vUkyKfO[YhfeqPW]=pPropertiesCount[YhfeqPW];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_hYNBodF=json["pProperties"].emplace_array();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].emplace_object();
            return serialize_struct(temp, pProperties[oGElcJh]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETFRAMEBUFFERTILEPROPERTIESQCOM):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();
[&](){
            if (json["pPropertiesCount"].as_array().size()==0){
                pPropertiesCount=NULL;
            return; }
        auto& arr_vUkyKfO=json["pPropertiesCount"].as_array();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(value_to<int>(arr_vUkyKfO[YhfeqPW]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_hYNBodF=json["pProperties"].as_array();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].as_object();
            deserialize_struct(temp,pProperties[oGElcJh]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_CCkpolI;[&](){temp_CCkpolI=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_CCkpolI;}();}();

debug_printf("Ending vkGetFramebufferTilePropertiesQCOM...\n");
debug_printf("Return value of vkGetFramebufferTilePropertiesQCOM is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDynamicRenderingTilePropertiesQCOM( VkDevice device, const VkRenderingInfo* pRenderingInfo, VkTilePropertiesQCOM* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetDynamicRenderingTilePropertiesQCOM\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=boost::json::array();
            return; }
        auto& arr_DOEgrev=json["pRenderingInfo"].emplace_array();
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto& temp=arr_DOEgrev[dAqQfxy].emplace_object();
            return serialize_struct(temp, pRenderingInfo[dAqQfxy]);
            }();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_hYNBodF=json["pProperties"].emplace_array();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].emplace_object();
            return serialize_struct(temp, pProperties[oGElcJh]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_hYNBodF=json["pProperties"].as_array();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].as_object();
            deserialize_struct(temp,pProperties[oGElcJh]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_xXOYsds;[&](){temp_xXOYsds=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_xXOYsds;}();}();

debug_printf("Ending vkGetDynamicRenderingTilePropertiesQCOM...\n");
debug_printf("Return value of vkGetDynamicRenderingTilePropertiesQCOM is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceOpticalFlowImageFormatsNV( VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, uint32_t* pFormatCount, VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceOpticalFlowImageFormatsNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pOpticalFlowImageFormatInfo==NULL){
                json["pOpticalFlowImageFormatInfo"]=boost::json::array();
            return; }
        auto& arr_oyPfnWV=json["pOpticalFlowImageFormatInfo"].emplace_array();
        for(int HqzITOl=0; HqzITOl < 1; HqzITOl++){
            [&](){
            auto& temp=arr_oyPfnWV[HqzITOl].emplace_object();
            return serialize_struct(temp, pOpticalFlowImageFormatInfo[HqzITOl]);
            }();
        }
        }();
[&](){
            if (pFormatCount==NULL){
                json["pFormatCount"]=boost::json::array();
            return; }
        auto& arr_OWVxAsX=json["pFormatCount"].emplace_array();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){arr_OWVxAsX[AvMKjKj]=pFormatCount[AvMKjKj];}();
        }
        }();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }
        auto& arr_oZncgpa=json["pImageFormatProperties"].emplace_array();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto& temp=arr_oZncgpa[gkJgIzP].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pFormatCount"].as_array().size()==0){
                pFormatCount=NULL;
            return; }
        auto& arr_OWVxAsX=json["pFormatCount"].as_array();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){pFormatCount[AvMKjKj]=static_cast<uint32_t>(value_to<int>(arr_OWVxAsX[AvMKjKj]));}();
        }
        }();
[&](){
            if (json["pImageFormatProperties"].as_array().size()==0){
                pImageFormatProperties=NULL;
            return; }
        auto& arr_oZncgpa=json["pImageFormatProperties"].as_array();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto& temp=arr_oZncgpa[gkJgIzP].as_object();
            deserialize_struct(temp,pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_DDLaKkM;[&](){temp_DDLaKkM=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_DDLaKkM;}();}();

debug_printf("Ending vkGetPhysicalDeviceOpticalFlowImageFormatsNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceOpticalFlowImageFormatsNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateOpticalFlowSessionNV( VkDevice device, const VkOpticalFlowSessionCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkOpticalFlowSessionNV* pSession ){
//Will only be called by the client
debug_printf("Executing vkCreateOpticalFlowSessionNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATEOPTICALFLOWSESSIONNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }
        auto& arr_dKVOiZE=json["pCreateInfo"].emplace_array();
        for(int LaeeodD=0; LaeeodD < 1; LaeeodD++){
            [&](){
            auto& temp=arr_dKVOiZE[LaeeodD].emplace_object();
            return serialize_struct(temp, pCreateInfo[LaeeodD]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSession==NULL){
                json["pSession"]=boost::json::array();
            return; }
        auto& arr_PyNQerY=json["pSession"].emplace_array();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){serialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ],pSession[FnADpyZ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEOPTICALFLOWSESSIONNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSession"].as_array().size()==0){
                pSession=NULL;
            return; }
        auto& arr_PyNQerY=json["pSession"].as_array();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){deserialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ], pSession[FnADpyZ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_GMVZnva;[&](){temp_GMVZnva=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_GMVZnva;}();}();

                if (pSession!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSession[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateOpticalFlowSessionNV...\n");
debug_printf("Return value of vkCreateOpticalFlowSessionNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyOpticalFlowSessionNV( VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyOpticalFlowSessionNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYOPTICALFLOWSESSIONNV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYOPTICALFLOWSESSIONNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();


debug_printf("Ending vkDestroyOpticalFlowSessionNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindOpticalFlowSessionImageNV( VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout ){
//Will only be called by the client
debug_printf("Executing vkBindOpticalFlowSessionImageNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKBINDOPTICALFLOWSESSIONIMAGENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){[&](){[&](){json["bindingPoint"]=bindingPoint;}();}();}();
[&](){serialize_VkImageView(json["view"],view);}();
[&](){[&](){[&](){json["layout"]=layout;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDOPTICALFLOWSESSIONIMAGENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
[&](){[&](){int temp_dqYOkbF;[&](){temp_dqYOkbF=static_cast<int>(value_to<int>(json["bindingPoint"]));}();bindingPoint=(VkOpticalFlowSessionBindingPointNV)temp_dqYOkbF;}();}();
[&](){deserialize_VkImageView(json["view"], view);}();
[&](){[&](){int temp_IaQZtFR;[&](){temp_IaQZtFR=static_cast<int>(value_to<int>(json["layout"]));}();layout=(VkImageLayout)temp_IaQZtFR;}();}();
VkResult result;
[&](){[&](){int temp_xSrgGPB;[&](){temp_xSrgGPB=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_xSrgGPB;}();}();

debug_printf("Ending vkBindOpticalFlowSessionImageNV...\n");
debug_printf("Return value of vkBindOpticalFlowSessionImageNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdOpticalFlowExecuteNV( VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV* pExecuteInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdOpticalFlowExecuteNV\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDOPTICALFLOWEXECUTENV;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pExecuteInfo==NULL){
                json["pExecuteInfo"]=boost::json::array();
            return; }
        auto& arr_CyySpro=json["pExecuteInfo"].emplace_array();
        for(int XLHKKBA=0; XLHKKBA < 1; XLHKKBA++){
            [&](){
            auto& temp=arr_CyySpro[XLHKKBA].emplace_object();
            return serialize_struct(temp, pExecuteInfo[XLHKKBA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDOPTICALFLOWEXECUTENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();


debug_printf("Ending vkCmdOpticalFlowExecuteNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceFaultInfoEXT( VkDevice device, VkDeviceFaultCountsEXT* pFaultCounts, VkDeviceFaultInfoEXT* pFaultInfo ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceFaultInfoEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEFAULTINFOEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pFaultCounts==NULL){
                json["pFaultCounts"]=boost::json::array();
            return; }
        auto& arr_LWLqmdd=json["pFaultCounts"].emplace_array();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto& temp=arr_LWLqmdd[RexMRxZ].emplace_object();
            return serialize_struct(temp, pFaultCounts[RexMRxZ]);
            }();
        }
        }();
[&](){
            if (pFaultInfo==NULL){
                json["pFaultInfo"]=boost::json::array();
            return; }
        auto& arr_CRNBZxs=json["pFaultInfo"].emplace_array();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto& temp=arr_CRNBZxs[AHHHhvb].emplace_object();
            return serialize_struct(temp, pFaultInfo[AHHHhvb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEFAULTINFOEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["pFaultCounts"].as_array().size()==0){
                pFaultCounts=NULL;
            return; }
        auto& arr_LWLqmdd=json["pFaultCounts"].as_array();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto& temp=arr_LWLqmdd[RexMRxZ].as_object();
            deserialize_struct(temp,pFaultCounts[RexMRxZ]);
            }();
        }
        }();
[&](){
            if (json["pFaultInfo"].as_array().size()==0){
                pFaultInfo=NULL;
            return; }
        auto& arr_CRNBZxs=json["pFaultInfo"].as_array();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto& temp=arr_CRNBZxs[AHHHhvb].as_object();
            deserialize_struct(temp,pFaultInfo[AHHHhvb]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_gZDLICk;[&](){temp_gZDLICk=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_gZDLICk;}();}();

debug_printf("Ending vkGetDeviceFaultInfoEXT...\n");
debug_printf("Return value of vkGetDeviceFaultInfoEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBias2EXT( VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT* pDepthBiasInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBias2EXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDSETDEPTHBIAS2EXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDepthBiasInfo==NULL){
                json["pDepthBiasInfo"]=boost::json::array();
            return; }
        auto& arr_AKZgFGf=json["pDepthBiasInfo"].emplace_array();
        for(int kGsXYsB=0; kGsXYsB < 1; kGsXYsB++){
            [&](){
            auto& temp=arr_AKZgFGf[kGsXYsB].emplace_object();
            return serialize_struct(temp, pDepthBiasInfo[kGsXYsB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBIAS2EXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdSetDepthBias2EXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkReleaseSwapchainImagesEXT( VkDevice device, const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo ){
//Will only be called by the client
debug_printf("Executing vkReleaseSwapchainImagesEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKRELEASESWAPCHAINIMAGESEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pReleaseInfo==NULL){
                json["pReleaseInfo"]=boost::json::array();
            return; }
        auto& arr_jcnZDBn=json["pReleaseInfo"].emplace_array();
        for(int dRtPqPF=0; dRtPqPF < 1; dRtPqPF++){
            [&](){
            auto& temp=arr_jcnZDBn[dRtPqPF].emplace_object();
            return serialize_struct(temp, pReleaseInfo[dRtPqPF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASESWAPCHAINIMAGESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_kVLSBQV;[&](){temp_kVLSBQV=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_kVLSBQV;}();}();

debug_printf("Ending vkReleaseSwapchainImagesEXT...\n");
debug_printf("Return value of vkReleaseSwapchainImagesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageSubresourceLayoutKHR( VkDevice device, const VkDeviceImageSubresourceInfoKHR* pInfo, VkSubresourceLayout2KHR* pLayout ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceImageSubresourceLayoutKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }
        auto& arr_SwRDgPP=json["pInfo"].emplace_array();
        for(int wxoktPv=0; wxoktPv < 1; wxoktPv++){
            [&](){
            auto& temp=arr_SwRDgPP[wxoktPv].emplace_object();
            return serialize_struct(temp, pInfo[wxoktPv]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }
        auto& arr_JxnVeqW=json["pLayout"].emplace_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].emplace_object();
            return serialize_struct(temp, pLayout[jEkaLQP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pLayout"].as_array().size()==0){
                pLayout=NULL;
            return; }
        auto& arr_JxnVeqW=json["pLayout"].as_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].as_object();
            deserialize_struct(temp,pLayout[jEkaLQP]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceImageSubresourceLayoutKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkMapMemory2KHR( VkDevice device, const VkMemoryMapInfoKHR* pMemoryMapInfo, void** ppData ){
//Will only be called by the client
debug_printf("Executing vkMapMemory2KHR\n");
MemoryMapLock.lock();

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKMAPMEMORY2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        

        if (pMemoryMapInfo->size==VK_WHOLE_SIZE){
            VkMemoryMapInfoKHR new_map_info=*pMemoryMapInfo;
            new_map_info.size=devicememory_to_size[(uintptr_t)new_map_info.memory]-new_map_info.offset;
            pMemoryMapInfo=&new_map_info;
        }
        
{
*ppData=NULL;
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryMapInfo==NULL){
                json["pMemoryMapInfo"]=boost::json::array();
            return; }
        auto& arr_udcndbe=json["pMemoryMapInfo"].emplace_array();
        for(int iwSaLAe=0; iwSaLAe < 1; iwSaLAe++){
            [&](){
            auto& temp=arr_udcndbe[iwSaLAe].emplace_object();
            return serialize_struct(temp, pMemoryMapInfo[iwSaLAe]);
            }();
        }
        }();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }
        auto& arr_JgRLJSK=json["ppData"].emplace_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }
        auto& arr_yHvgdEb=arr_JgRLJSK[NsRFkBj].emplace_array();
        for(int vgxltbA=0; vgxltbA < strlen(((char*)(ppData[NsRFkBj])))+1; vgxltbA++){
            [&](){arr_yHvgdEb[vgxltbA]=((char*)(ppData[NsRFkBj]))[vgxltbA];}();
        }
        }();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMAPMEMORY2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["ppData"].as_array().size()==0){
                ppData=NULL;
            return; }
        auto& arr_JgRLJSK=json["ppData"].as_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].as_array().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].as_array().size()==0){
                temp_JgRLJSK=NULL;
            return; }
        auto& arr_yHvgdEb=arr_JgRLJSK[NsRFkBj].as_array();
        for(int vgxltbA=0; vgxltbA < arr_JgRLJSK[NsRFkBj].as_array().size(); vgxltbA++){
            [&](){temp_JgRLJSK[vgxltbA]=static_cast<char>(value_to<int>(arr_yHvgdEb[vgxltbA]));}();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_Zfsbwuz;[&](){temp_Zfsbwuz=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_Zfsbwuz;}();}();

        boost::json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, pMemoryMapInfo->memory);
        
        auto server_memory=value_to<uintptr_t>(server_memory_json); 
        
        *ppData=registerDeviceMemoryMap(server_memory, pMemoryMapInfo->memory,pMemoryMapInfo->size,*ppData,value_to<uintptr_t>(json["mem"]));
        
        #ifndef CLIENT
            json["mem"]=value_to<uintptr_t>(json["mem"]);
        #endif
        
MemoryMapLock.unlock();
debug_printf("Ending vkMapMemory2KHR...\n");
debug_printf("Return value of vkMapMemory2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkUnmapMemory2KHR( VkDevice device, const VkMemoryUnmapInfoKHR* pMemoryUnmapInfo ){
//Will only be called by the client
debug_printf("Executing vkUnmapMemory2KHR\n");
MemoryMapLock.lock();

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKUNMAPMEMORY2KHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryUnmapInfo==NULL){
                json["pMemoryUnmapInfo"]=boost::json::array();
            return; }
        auto& arr_hZlnXPf=json["pMemoryUnmapInfo"].emplace_array();
        for(int caczdhq=0; caczdhq < 1; caczdhq++){
            [&](){
            auto& temp=arr_hZlnXPf[caczdhq].emplace_object();
            return serialize_struct(temp, pMemoryUnmapInfo[caczdhq]);
            }();
        }
        }();
}
deregisterDeviceMemoryMap(pMemoryUnmapInfo->memory);

        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUNMAPMEMORY2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_OlaptaP;[&](){temp_OlaptaP=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_OlaptaP;}();}();

MemoryMapLock.unlock();
debug_printf("Ending vkUnmapMemory2KHR...\n");
debug_printf("Return value of vkUnmapMemory2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateShadersEXT( VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders ){
//Will only be called by the client
debug_printf("Executing vkCreateShadersEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCREATESHADERSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }
        auto& arr_mOfZnnW=json["pCreateInfos"].emplace_array();
        for(int bOiKywR=0; bOiKywR < createInfoCount; bOiKywR++){
            [&](){
            auto& temp=arr_mOfZnnW[bOiKywR].emplace_object();
            return serialize_struct(temp, pCreateInfos[bOiKywR]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=boost::json::array();
            return; }
        auto& arr_ndnxxFm=json["pShaders"].emplace_array();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){serialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN],pShaders[NwhTkPN]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESHADERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){createInfoCount=static_cast<uint32_t>(value_to<int>(json["createInfoCount"]));}();


[&](){
            if (json["pShaders"].as_array().size()==0){
                pShaders=NULL;
            return; }
        auto& arr_ndnxxFm=json["pShaders"].as_array();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){deserialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN], pShaders[NwhTkPN]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_MeDToGu;[&](){temp_MeDToGu=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_MeDToGu;}();}();

                if (pShaders!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pShaders[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateShadersEXT...\n");
debug_printf("Return value of vkCreateShadersEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyShaderEXT( VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyShaderEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKDESTROYSHADEREXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }
        auto& arr_daGjOqj=json["pAllocator"].emplace_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSHADEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();


debug_printf("Ending vkDestroyShaderEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetShaderBinaryDataEXT( VkDevice device, VkShaderEXT shader, size_t* pDataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetShaderBinaryDataEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETSHADERBINARYDATAEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].emplace_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }
        auto& arr_AnvCwFj=json["pData"].emplace_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){arr_AnvCwFj[BSRqoqj]=((char*)(pData))[BSRqoqj];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERBINARYDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();
[&](){
            if (json["pDataSize"].as_array().size()==0){
                pDataSize=NULL;
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].as_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){pDataSize[HCzJfGC]=static_cast<size_t>(value_to<int>(arr_Zcusyfw[HCzJfGC]));}();
        }
        }();
[&](){
            if (json["pData"].as_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }
        auto& arr_AnvCwFj=json["pData"].as_array();
        for(int BSRqoqj=0; BSRqoqj < *pDataSize; BSRqoqj++){
            [&](){temp_ZtBEjVJ[BSRqoqj]=static_cast<char>(value_to<int>(arr_AnvCwFj[BSRqoqj]));}();
        }
        }();pData=temp_ZtBEjVJ;}();
VkResult result;
[&](){[&](){int temp_opirLWL;[&](){temp_opirLWL=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_opirLWL;}();}();

debug_printf("Ending vkGetShaderBinaryDataEXT...\n");
debug_printf("Return value of vkGetShaderBinaryDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBindShadersEXT( VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits* pStages, const VkShaderEXT* pShaders ){
//Will only be called by the client
debug_printf("Executing vkCmdBindShadersEXT\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKCMDBINDSHADERSEXT;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["stageCount"]=stageCount;}();
[&](){
            if (pStages==NULL){
                json["pStages"]=boost::json::array();
            return; }
        auto& arr_phXrzxO=json["pStages"].emplace_array();
        for(int uFucfxh=0; uFucfxh < stageCount; uFucfxh++){
            [&](){[&](){[&](){arr_phXrzxO[uFucfxh]=pStages[uFucfxh];}();}();}();
        }
        }();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=boost::json::array();
            return; }
        auto& arr_ZjERyql=json["pShaders"].emplace_array();
        for(int DxWTbGC=0; DxWTbGC < stageCount; DxWTbGC++){
            [&](){serialize_VkShaderEXT(arr_ZjERyql[DxWTbGC],pShaders[DxWTbGC]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDSHADERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){stageCount=static_cast<uint32_t>(value_to<int>(json["stageCount"]));}();



debug_printf("Ending vkCmdBindShadersEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR\n");

    boost::json::object json;
    auto parent_json=json["parent"].emplace_object();
    json["type"]=VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR;
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].emplace_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }
        auto& arr_PEzgESc=json["pProperties"].emplace_array();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto& temp=arr_PEzgESc[iTGjLCh].emplace_object();
            return serialize_struct(temp, pProperties[iTGjLCh]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
break;}}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].as_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){pPropertyCount[srQaIwu]=static_cast<uint32_t>(value_to<int>(arr_ICoMmRG[srQaIwu]));}();
        }
        }();
[&](){
            if (json["pProperties"].as_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_PEzgESc=json["pProperties"].as_array();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto& temp=arr_PEzgESc[iTGjLCh].as_object();
            deserialize_struct(temp,pProperties[iTGjLCh]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_FrXDimv;[&](){temp_FrXDimv=static_cast<int>(value_to<int>(json["result"]));}();result=(VkResult)temp_FrXDimv;}();}();

debug_printf("Ending vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
}
#endif

#ifndef CLIENT
int main(int argc, char** argv){
    startServer();
}
#endif

