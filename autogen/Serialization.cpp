
#include <boost/json/src.hpp>
#include <boost/json.hpp>

#include <ThreadStruct.hpp>

#include <Serialization.hpp>
#include <Server.hpp>
#include <Synchronization.hpp>
#include <map>


void serialize_Sync(boost::json::object& json, Sync& sync){
    json["devicememory"]=sync.devicememory;
    json["mem"]=sync.mem;
    json["hashes"]=boost::json::value_from(sync.hashes);
    json["lengths"]=boost::json::value_from(sync.lengths);
    json["starts"]=boost::json::value_from(sync.starts);
    json["buffers"]=boost::json::value_from(sync.buffers);
}

void deserialize_Sync(boost::json::object& json, Sync& sync){
    sync.devicememory=boost::json::value_to<uintptr_t>(json["devicememory"]);
    sync.mem=boost::json::value_to<uintptr_t>(json["mem"]);
    sync.hashes=boost::json::value_to<std::vector<std::string>>(json["hashes"]);
    sync.lengths=boost::json::value_to<std::vector<size_t>>(json["lengths"]);
    sync.starts=boost::json::value_to<std::vector<size_t>>(json["starts"]);
    sync.buffers=boost::json::value_to<std::vector<std::string>>(json["buffers"]);
}


typedef struct {
    void* pUserData;

uintptr_t PFN_vkDeviceMemoryReportCallbackEXT;
uintptr_t PFN_vkInternalAllocationNotification;
uintptr_t PFN_vkInternalFreeNotification;
uintptr_t PFN_vkFreeFunction;
uintptr_t PFN_vkFaultCallbackFunction;
uintptr_t PFN_vkGetInstanceProcAddrLUNARG;
uintptr_t PFN_vkAllocationFunction;
uintptr_t PFN_vkReallocationFunction;
uintptr_t PFN_vkVoidFunction;
uintptr_t PFN_vkDebugUtilsMessengerCallbackEXT;
uintptr_t PFN_vkDebugReportCallbackEXT;
} pUserData_struct;

void serialize_pNext(boost::json::object& json, const void* member){
    if (member==NULL){
        json.erase("sType");
        return;
    }
    
    auto chain=((VkBaseInStructure*)member);
    switch(chain->sType){


    case VK_STRUCTURE_TYPE_APPLICATION_INFO:
        {
        return serialize_struct(json, ((VkApplicationInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkDeviceQueueCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkDeviceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkInstanceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
        {
        return serialize_struct(json, ((VkMemoryAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:
        {
        return serialize_struct(json, ((VkMappedMemoryRange*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
        {
        return serialize_struct(json, ((VkWriteDescriptorSet*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:
        {
        return serialize_struct(json, ((VkCopyDescriptorSet*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkBufferUsageFlags2CreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:
        {
        return serialize_struct(json, ((VkBufferCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:
        {
        return serialize_struct(json, ((VkBufferViewCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_BARRIER:
        {
        return serialize_struct(json, ((VkMemoryBarrier*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:
        {
        return serialize_struct(json, ((VkBufferMemoryBarrier*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:
        {
        return serialize_struct(json, ((VkImageMemoryBarrier*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkImageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:
        {
        return serialize_struct(json, ((VkImageViewCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
        {
        return serialize_struct(json, ((VkBindSparseInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkShaderModuleCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
        {
        return serialize_struct(json, ((VkDescriptorSetLayoutCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:
        {
        return serialize_struct(json, ((VkDescriptorPoolCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
        {
        return serialize_struct(json, ((VkDescriptorSetAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineShaderStageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkComputePipelineCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV:
        {
        return serialize_struct(json, ((VkComputePipelineIndirectBufferInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkPipelineCreateFlags2CreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineVertexInputStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineInputAssemblyStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineTessellationStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineViewportStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineRasterizationStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineMultisampleStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineColorBlendStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineDynamicStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineDepthStencilStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkGraphicsPipelineCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineCacheCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineLayoutCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:
        {
        return serialize_struct(json, ((VkSamplerCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:
        {
        return serialize_struct(json, ((VkCommandPoolCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:
        {
        return serialize_struct(json, ((VkCommandBufferAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:
        {
        return serialize_struct(json, ((VkCommandBufferInheritanceInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:
        {
        return serialize_struct(json, ((VkCommandBufferBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:
        {
        return serialize_struct(json, ((VkRenderPassBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
        {
        return serialize_struct(json, ((VkRenderPassCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:
        {
        return serialize_struct(json, ((VkEventCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkFenceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkSemaphoreCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:
        {
        return serialize_struct(json, ((VkQueryPoolCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
        {
        return serialize_struct(json, ((VkFramebufferCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBMIT_INFO:
        {
        return serialize_struct(json, ((VkSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkDisplayModeCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkDisplaySurfaceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
        return serialize_struct(json, ((VkDisplayPresentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkXlibSurfaceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkXcbSurfaceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkSwapchainCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
        {
        return serialize_struct(json, ((VkPresentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkDebugReportCallbackCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
        return serialize_struct(json, ((VkValidationFlagsEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkValidationFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
        return serialize_struct(json, ((VkPipelineRasterizationStateRasterizationOrderAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT:
        {
        return serialize_struct(json, ((VkDebugMarkerObjectNameInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
        {
        return serialize_struct(json, ((VkDebugMarkerObjectTagInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT:
        {
        return serialize_struct(json, ((VkDebugMarkerMarkerInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkDedicatedAllocationImageCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkDedicatedAllocationBufferCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
        return serialize_struct(json, ((VkDedicatedAllocationMemoryAllocateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkExternalMemoryImageCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
        return serialize_struct(json, ((VkExportMemoryAllocateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
        {
        return serialize_struct(json, ((VkDevicePrivateDataCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPrivateDataSlotCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDevicePrivateDataFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMultiDrawPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkGraphicsShaderGroupCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkGraphicsPipelineShaderGroupsCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV:
        {
        return serialize_struct(json, ((VkIndirectCommandsLayoutTokenNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkIndirectCommandsLayoutCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV:
        {
        return serialize_struct(json, ((VkGeneratedCommandsInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV:
        {
        return serialize_struct(json, ((VkGeneratedCommandsMemoryRequirementsInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineIndirectDeviceAddressInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFeatures2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
        {
        return serialize_struct(json, ((VkPhysicalDeviceProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:
        {
        return serialize_struct(json, ((VkFormatProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:
        {
        return serialize_struct(json, ((VkImageFormatProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageFormatInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:
        {
        return serialize_struct(json, ((VkQueueFamilyProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMemoryProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:
        {
        return serialize_struct(json, ((VkSparseImageFormatProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSparseImageFormatInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDevicePushDescriptorPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDriverProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
        return serialize_struct(json, ((VkPresentRegionsKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVariablePointersFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExternalImageFormatInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
        return serialize_struct(json, ((VkExternalImageFormatProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExternalBufferInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:
        {
        return serialize_struct(json, ((VkExternalBufferProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceIDProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkExternalMemoryImageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
        return serialize_struct(json, ((VkExternalMemoryBufferCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
        return serialize_struct(json, ((VkExportMemoryAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
        return serialize_struct(json, ((VkImportMemoryFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkMemoryFdPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR:
        {
        return serialize_struct(json, ((VkMemoryGetFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExternalSemaphoreInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:
        {
        return serialize_struct(json, ((VkExternalSemaphoreProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkExportSemaphoreCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR:
        {
        return serialize_struct(json, ((VkImportSemaphoreFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR:
        {
        return serialize_struct(json, ((VkSemaphoreGetFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExternalFenceInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:
        {
        return serialize_struct(json, ((VkExternalFenceProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkExportFenceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR:
        {
        return serialize_struct(json, ((VkImportFenceFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR:
        {
        return serialize_struct(json, ((VkFenceGetFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMultiviewFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMultiviewProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
        return serialize_struct(json, ((VkRenderPassMultiviewCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT:
        {
        return serialize_struct(json, ((VkSurfaceCapabilities2EXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT:
        {
        return serialize_struct(json, ((VkDisplayPowerInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT:
        {
        return serialize_struct(json, ((VkDeviceEventInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT:
        {
        return serialize_struct(json, ((VkDisplayEventInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkSwapchainCounterCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceGroupProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
        return serialize_struct(json, ((VkMemoryAllocateFlagsInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:
        {
        return serialize_struct(json, ((VkBindBufferMemoryInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
        return serialize_struct(json, ((VkBindBufferMemoryDeviceGroupInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:
        {
        return serialize_struct(json, ((VkBindImageMemoryInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
        return serialize_struct(json, ((VkBindImageMemoryDeviceGroupInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
        return serialize_struct(json, ((VkDeviceGroupRenderPassBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
        return serialize_struct(json, ((VkDeviceGroupCommandBufferBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
        return serialize_struct(json, ((VkDeviceGroupSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
        return serialize_struct(json, ((VkDeviceGroupBindSparseInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:
        {
        return serialize_struct(json, ((VkDeviceGroupPresentCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkImageSwapchainCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
        return serialize_struct(json, ((VkBindImageMemorySwapchainInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:
        {
        return serialize_struct(json, ((VkAcquireNextImageInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
        return serialize_struct(json, ((VkDeviceGroupPresentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkDeviceGroupDeviceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkDeviceGroupSwapchainCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkDescriptorUpdateTemplateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDevicePresentIdFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
        {
        return serialize_struct(json, ((VkPresentIdKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDevicePresentWaitFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_HDR_METADATA_EXT:
        {
        return serialize_struct(json, ((VkHdrMetadataEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
        return serialize_struct(json, ((VkDisplayNativeHdrSurfaceCapabilitiesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
        return serialize_struct(json, ((VkSwapchainDisplayNativeHdrCreateInfoAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
        return serialize_struct(json, ((VkPresentTimesInfoGOOGLE*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineViewportWScalingStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineViewportSwizzleStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDiscardRectanglePropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineDiscardRectangleStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
        return serialize_struct(json, ((VkRenderPassInputAttachmentAspectCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSurfaceInfo2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:
        {
        return serialize_struct(json, ((VkSurfaceCapabilities2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:
        {
        return serialize_struct(json, ((VkSurfaceFormat2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:
        {
        return serialize_struct(json, ((VkDisplayProperties2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:
        {
        return serialize_struct(json, ((VkDisplayPlaneProperties2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:
        {
        return serialize_struct(json, ((VkDisplayModeProperties2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:
        {
        return serialize_struct(json, ((VkDisplayPlaneInfo2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:
        {
        return serialize_struct(json, ((VkDisplayPlaneCapabilities2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
        return serialize_struct(json, ((VkSharedPresentSurfaceCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDevice16BitStorageFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSubgroupProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:
        {
        return serialize_struct(json, ((VkBufferMemoryRequirementsInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS:
        {
        return serialize_struct(json, ((VkDeviceBufferMemoryRequirements*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:
        {
        return serialize_struct(json, ((VkImageMemoryRequirementsInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
        {
        return serialize_struct(json, ((VkImageSparseMemoryRequirementsInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS:
        {
        return serialize_struct(json, ((VkDeviceImageMemoryRequirements*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:
        {
        return serialize_struct(json, ((VkMemoryRequirements2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:
        {
        return serialize_struct(json, ((VkSparseImageMemoryRequirements2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDevicePointClippingProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
        return serialize_struct(json, ((VkMemoryDedicatedRequirements*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
        return serialize_struct(json, ((VkMemoryDedicatedAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkImageViewUsageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkImageViewSlicedCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineTessellationDomainOriginStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
        return serialize_struct(json, ((VkSamplerYcbcrConversionInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:
        {
        return serialize_struct(json, ((VkSamplerYcbcrConversionCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
        return serialize_struct(json, ((VkBindImagePlaneMemoryInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
        return serialize_struct(json, ((VkImagePlaneMemoryRequirementsInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSamplerYcbcrConversionFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
        return serialize_struct(json, ((VkSamplerYcbcrConversionImageFormatProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
        return serialize_struct(json, ((VkTextureLODGatherFormatPropertiesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT:
        {
        return serialize_struct(json, ((VkConditionalRenderingBeginInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
        return serialize_struct(json, ((VkProtectedSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceProtectedMemoryFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceProtectedMemoryProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:
        {
        return serialize_struct(json, ((VkDeviceQueueInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineCoverageToColorStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSamplerFilterMinmaxProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
        return serialize_struct(json, ((VkSampleLocationsInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
        return serialize_struct(json, ((VkRenderPassSampleLocationsBeginInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineSampleLocationsStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSampleLocationsPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkMultisamplePropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkSamplerReductionModeCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMultiDrawFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineColorBlendAdvancedStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceInlineUniformBlockFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceInlineUniformBlockProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
        {
        return serialize_struct(json, ((VkWriteDescriptorSetInlineUniformBlock*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
        {
        return serialize_struct(json, ((VkDescriptorPoolInlineUniformBlockCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineCoverageModulationStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
        return serialize_struct(json, ((VkImageFormatListCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkValidationCacheCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkShaderModuleValidationCacheCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMaintenance3Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMaintenance4Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMaintenance4Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMaintenance5FeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMaintenance5PropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR:
        {
        return serialize_struct(json, ((VkRenderingAreaInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:
        {
        return serialize_struct(json, ((VkDescriptorSetLayoutSupport*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderDrawParametersFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderFloat16Int8Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFloatControlsProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceHostQueryResetFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkDeviceQueueGlobalPriorityCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkQueueFamilyGlobalPriorityPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
        {
        return serialize_struct(json, ((VkDebugUtilsObjectNameInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
        {
        return serialize_struct(json, ((VkDebugUtilsObjectTagInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT:
        {
        return serialize_struct(json, ((VkDebugUtilsLabelEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkDebugUtilsMessengerCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
        {
        return serialize_struct(json, ((VkDebugUtilsMessengerCallbackDataEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkDeviceDeviceMemoryReportCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT:
        {
        return serialize_struct(json, ((VkDeviceMemoryReportCallbackDataEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
        return serialize_struct(json, ((VkImportMemoryHostPointerInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkMemoryHostPointerPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExternalMemoryHostPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceConservativeRasterizationPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT:
        {
        return serialize_struct(json, ((VkCalibratedTimestampInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderCorePropertiesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderCoreProperties2AMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineRasterizationConservativeStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDescriptorIndexingFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDescriptorIndexingProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
        return serialize_struct(json, ((VkDescriptorSetLayoutBindingFlagsCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
        return serialize_struct(json, ((VkDescriptorSetVariableDescriptorCountAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
        return serialize_struct(json, ((VkDescriptorSetVariableDescriptorCountLayoutSupport*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2:
        {
        return serialize_struct(json, ((VkAttachmentDescription2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2:
        {
        return serialize_struct(json, ((VkAttachmentReference2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2:
        {
        return serialize_struct(json, ((VkSubpassDescription2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2:
        {
        return serialize_struct(json, ((VkSubpassDependency2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:
        {
        return serialize_struct(json, ((VkRenderPassCreateInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO:
        {
        return serialize_struct(json, ((VkSubpassBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_END_INFO:
        {
        return serialize_struct(json, ((VkSubpassEndInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceTimelineSemaphoreFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceTimelineSemaphoreProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkSemaphoreTypeCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
        return serialize_struct(json, ((VkTimelineSemaphoreSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO:
        {
        return serialize_struct(json, ((VkSemaphoreWaitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO:
        {
        return serialize_struct(json, ((VkSemaphoreSignalInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineVertexInputDivisorStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevicePCIBusInfoPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
        return serialize_struct(json, ((VkCommandBufferInheritanceConditionalRenderingInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDevice8BitStorageFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceConditionalRenderingFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVulkanMemoryModelFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderAtomicInt64Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkQueueFamilyCheckpointPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV:
        {
        return serialize_struct(json, ((VkCheckpointDataNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDepthStencilResolveProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
        return serialize_struct(json, ((VkSubpassDescriptionDepthStencilResolve*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
        return serialize_struct(json, ((VkImageViewASTCDecodeModeEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceASTCDecodeFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceTransformFeedbackFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceTransformFeedbackPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineRasterizationStateStreamCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineRepresentativeFragmentTestStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExclusiveScissorFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineViewportExclusiveScissorStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCornerSampledImageFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderImageFootprintFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMemoryDecompressionFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMemoryDecompressionPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineViewportShadingRateImageStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShadingRateImageFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShadingRateImagePropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
        return serialize_struct(json, ((VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMeshShaderFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMeshShaderPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMeshShaderFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMeshShaderPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkRayTracingShaderGroupCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkRayTracingShaderGroupCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkRayTracingPipelineCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkRayTracingPipelineCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV:
        {
        return serialize_struct(json, ((VkGeometryTrianglesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV:
        {
        return serialize_struct(json, ((VkGeometryAABBNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GEOMETRY_NV:
        {
        return serialize_struct(json, ((VkGeometryNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV:
        {
        return serialize_struct(json, ((VkAccelerationStructureInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkAccelerationStructureCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
        {
        return serialize_struct(json, ((VkBindAccelerationStructureMemoryInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
        return serialize_struct(json, ((VkWriteDescriptorSetAccelerationStructureKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
        return serialize_struct(json, ((VkWriteDescriptorSetAccelerationStructureNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
        {
        return serialize_struct(json, ((VkAccelerationStructureMemoryRequirementsInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceAccelerationStructureFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRayTracingPipelineFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRayQueryFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceAccelerationStructurePropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRayTracingPipelinePropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRayTracingPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
        return serialize_struct(json, ((VkDrmFormatModifierPropertiesListEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageDrmFormatModifierInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkImageDrmFormatModifierListCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkImageDrmFormatModifierExplicitCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkImageDrmFormatModifierPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkImageStencilUsageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
        return serialize_struct(json, ((VkDeviceMemoryOverallocationCreateInfoAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentDensityMapFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentDensityMapPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkRenderPassFragmentDensityMapCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM:
        {
        return serialize_struct(json, ((VkSubpassFragmentDensityMapOffsetEndInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceScalarBlockLayoutFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
        return serialize_struct(json, ((VkSurfaceProtectedCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceUniformBufferStandardLayoutFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDepthClipEnableFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineRasterizationDepthClipStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMemoryBudgetPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMemoryPriorityFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkMemoryPriorityAllocateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceBufferDeviceAddressFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO:
        {
        return serialize_struct(json, ((VkBufferDeviceAddressInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
        return serialize_struct(json, ((VkBufferOpaqueCaptureAddressCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkBufferDeviceAddressCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageViewImageFormatInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkFilterCubicImageViewImageFormatPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImagelessFramebufferFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
        return serialize_struct(json, ((VkFramebufferAttachmentsCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:
        {
        return serialize_struct(json, ((VkFramebufferAttachmentImageInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
        return serialize_struct(json, ((VkRenderPassAttachmentBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceTextureCompressionASTCHDRFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCooperativeMatrixFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCooperativeMatrixPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkCooperativeMatrixPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX:
        {
        return serialize_struct(json, ((VkImageViewHandleInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX:
        {
        return serialize_struct(json, ((VkImageViewAddressPropertiesNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineCreationFeedbackCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDevicePresentBarrierFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
        {
        return serialize_struct(json, ((VkSurfaceCapabilitiesPresentBarrierNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkSwapchainPresentBarrierCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDevicePerformanceQueryFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDevicePerformanceQueryPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR:
        {
        return serialize_struct(json, ((VkPerformanceCounterKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR:
        {
        return serialize_struct(json, ((VkPerformanceCounterDescriptionKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkQueryPoolPerformanceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR:
        {
        return serialize_struct(json, ((VkAcquireProfilingLockInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
        return serialize_struct(json, ((VkPerformanceQuerySubmitInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkHeadlessSurfaceCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCoverageReductionModeFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineCoverageReductionStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
        {
        return serialize_struct(json, ((VkFramebufferMixedSamplesCombinationNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL:
        {
        return serialize_struct(json, ((VkInitializePerformanceApiInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
        return serialize_struct(json, ((VkQueryPoolPerformanceQueryCreateInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL:
        {
        return serialize_struct(json, ((VkPerformanceMarkerInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL:
        {
        return serialize_struct(json, ((VkPerformanceStreamMarkerInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL:
        {
        return serialize_struct(json, ((VkPerformanceOverrideInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
        {
        return serialize_struct(json, ((VkPerformanceConfigurationAcquireInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderClockFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceIndexTypeUint8FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
        return serialize_struct(json, ((VkAttachmentReferenceStencilLayout*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
        return serialize_struct(json, ((VkAttachmentDescriptionStencilLayout*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR:
        {
        return serialize_struct(json, ((VkPipelineInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkPipelineExecutablePropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR:
        {
        return serialize_struct(json, ((VkPipelineExecutableInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR:
        {
        return serialize_struct(json, ((VkPipelineExecutableStatisticKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
        {
        return serialize_struct(json, ((VkPipelineExecutableInternalRepresentationKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceTexelBufferAlignmentProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSubgroupSizeControlFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSubgroupSizeControlProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
        {
        return serialize_struct(json, ((VkSubpassShadingPipelineCreateInfoHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
        {
        return serialize_struct(json, ((VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
        return serialize_struct(json, ((VkMemoryOpaqueCaptureAddressAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:
        {
        return serialize_struct(json, ((VkDeviceMemoryOpaqueCaptureAddressInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceLineRasterizationFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceLineRasterizationPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineRasterizationLineStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDevicePipelineCreationCacheControlFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVulkan11Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVulkan11Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVulkan12Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVulkan12Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVulkan13Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVulkan13Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
        return serialize_struct(json, ((VkPipelineCompilerControlCreateInfoAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCoherentMemoryFeaturesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceToolProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkSamplerCustomBorderColorCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCustomBorderColorPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCustomBorderColorFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkSamplerBorderColorComponentMappingCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR:
        {
        return serialize_struct(json, ((VkAccelerationStructureGeometryTrianglesDataKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR:
        {
        return serialize_struct(json, ((VkAccelerationStructureGeometryAabbsDataKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR:
        {
        return serialize_struct(json, ((VkAccelerationStructureGeometryInstancesDataKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR:
        {
        return serialize_struct(json, ((VkAccelerationStructureGeometryKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR:
        {
        return serialize_struct(json, ((VkAccelerationStructureBuildGeometryInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkAccelerationStructureCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR:
        {
        return serialize_struct(json, ((VkAccelerationStructureDeviceAddressInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR:
        {
        return serialize_struct(json, ((VkAccelerationStructureVersionInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR:
        {
        return serialize_struct(json, ((VkCopyAccelerationStructureInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR:
        {
        return serialize_struct(json, ((VkCopyAccelerationStructureToMemoryInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR:
        {
        return serialize_struct(json, ((VkCopyMemoryToAccelerationStructureInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkRayTracingPipelineInterfaceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkPipelineLibraryCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
        return serialize_struct(json, ((VkRenderPassTransformBeginInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
        return serialize_struct(json, ((VkCopyCommandTransformInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
        return serialize_struct(json, ((VkCommandBufferInheritanceRenderPassTransformInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDiagnosticsConfigFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkDeviceDiagnosticsConfigCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRobustness2FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRobustness2PropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageRobustnessFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevice4444FormatsFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
        return serialize_struct(json, ((VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_COPY_2:
        {
        return serialize_struct(json, ((VkBufferCopy2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_COPY_2:
        {
        return serialize_struct(json, ((VkImageCopy2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_BLIT_2:
        {
        return serialize_struct(json, ((VkImageBlit2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2:
        {
        return serialize_struct(json, ((VkBufferImageCopy2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2:
        {
        return serialize_struct(json, ((VkImageResolve2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2:
        {
        return serialize_struct(json, ((VkCopyBufferInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2:
        {
        return serialize_struct(json, ((VkCopyImageInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2:
        {
        return serialize_struct(json, ((VkBlitImageInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2:
        {
        return serialize_struct(json, ((VkCopyBufferToImageInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2:
        {
        return serialize_struct(json, ((VkCopyImageToBufferInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2:
        {
        return serialize_struct(json, ((VkResolveImageInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
        return serialize_struct(json, ((VkFragmentShadingRateAttachmentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkPipelineFragmentShadingRateStateCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentShadingRateFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentShadingRatePropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentShadingRateKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderTerminateInvocationFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkPipelineFragmentShadingRateEnumStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR:
        {
        return serialize_struct(json, ((VkAccelerationStructureBuildSizesInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkMutableDescriptorTypeCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDepthClipControlFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineViewportDepthClipControlCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT:
        {
        return serialize_struct(json, ((VkVertexInputBindingDescription2EXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT:
        {
        return serialize_struct(json, ((VkVertexInputAttributeDescription2EXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceColorWriteEnableFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineColorWriteCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:
        {
        return serialize_struct(json, ((VkMemoryBarrier2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2:
        {
        return serialize_struct(json, ((VkImageMemoryBarrier2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2:
        {
        return serialize_struct(json, ((VkBufferMemoryBarrier2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEPENDENCY_INFO:
        {
        return serialize_struct(json, ((VkDependencyInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO:
        {
        return serialize_struct(json, ((VkSemaphoreSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO:
        {
        return serialize_struct(json, ((VkCommandBufferSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBMIT_INFO_2:
        {
        return serialize_struct(json, ((VkSubmitInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
        {
        return serialize_struct(json, ((VkQueueFamilyCheckpointProperties2NV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV:
        {
        return serialize_struct(json, ((VkCheckpointData2NV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSynchronization2Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceHostImageCopyFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceHostImageCopyPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT:
        {
        return serialize_struct(json, ((VkMemoryToImageCopyEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT:
        {
        return serialize_struct(json, ((VkImageToMemoryCopyEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT:
        {
        return serialize_struct(json, ((VkCopyMemoryToImageInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT:
        {
        return serialize_struct(json, ((VkCopyImageToMemoryInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT:
        {
        return serialize_struct(json, ((VkCopyImageToImageInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT:
        {
        return serialize_struct(json, ((VkHostImageLayoutTransitionInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT:
        {
        return serialize_struct(json, ((VkSubresourceHostMemcpySizeEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT:
        {
        return serialize_struct(json, ((VkHostImageCopyDevicePerformanceQueryEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceLegacyDitheringFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
        {
        return serialize_struct(json, ((VkSubpassResolvePerformanceQueryEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
        {
        return serialize_struct(json, ((VkMultisampledRenderToSingleSampledInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkQueueFamilyVideoPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkQueueFamilyQueryResultStatusPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoProfileListInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceVideoFormatInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkVideoFormatPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoProfileInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR:
        {
        return serialize_struct(json, ((VkVideoCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR:
        {
        return serialize_struct(json, ((VkVideoSessionMemoryRequirementsKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR:
        {
        return serialize_struct(json, ((VkBindVideoSessionMemoryInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoPictureResourceInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoReferenceSlotInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeUsageInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH264ProfileInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH264CapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH264SessionParametersAddInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH264SessionParametersCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH264PictureInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH264DpbSlotInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH265ProfileInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH265CapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH265SessionParametersAddInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH265SessionParametersCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH265PictureInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoDecodeH265DpbSlotInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoSessionCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoSessionParametersCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoSessionParametersUpdateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoBeginCodingInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoEndCodingInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR:
        {
        return serialize_struct(json, ((VkVideoCodingControlInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceInheritedViewportScissorFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
        {
        return serialize_struct(json, ((VkCommandBufferInheritanceViewportScissorInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceProvokingVertexFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceProvokingVertexPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX:
        {
        return serialize_struct(json, ((VkCuModuleCreateInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX:
        {
        return serialize_struct(json, ((VkCuFunctionCreateInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX:
        {
        return serialize_struct(json, ((VkCuLaunchInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDescriptorBufferFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDescriptorBufferPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT:
        {
        return serialize_struct(json, ((VkDescriptorAddressInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT:
        {
        return serialize_struct(json, ((VkDescriptorBufferBindingInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT:
        {
        return serialize_struct(json, ((VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT:
        {
        return serialize_struct(json, ((VkDescriptorGetInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        return serialize_struct(json, ((VkBufferCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        return serialize_struct(json, ((VkImageCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        return serialize_struct(json, ((VkImageViewCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        return serialize_struct(json, ((VkSamplerCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        return serialize_struct(json, ((VkAccelerationStructureCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkOpaqueCaptureDescriptorDataCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderIntegerDotProductFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderIntegerDotProductProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDrmPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
        {
        return serialize_struct(json, ((VkAccelerationStructureGeometryMotionTrianglesDataNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
        {
        return serialize_struct(json, ((VkAccelerationStructureMotionInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV:
        {
        return serialize_struct(json, ((VkMemoryGetRemoteAddressInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
        {
        return serialize_struct(json, ((VkFormatProperties3*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
        {
        return serialize_struct(json, ((VkDrmFormatModifierPropertiesList2EXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
        {
        return serialize_struct(json, ((VkPipelineRenderingCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_INFO:
        {
        return serialize_struct(json, ((VkRenderingInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO:
        {
        return serialize_struct(json, ((VkRenderingAttachmentInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
        return serialize_struct(json, ((VkRenderingFragmentShadingRateAttachmentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
        {
        return serialize_struct(json, ((VkRenderingFragmentDensityMapAttachmentInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDynamicRenderingFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
        {
        return serialize_struct(json, ((VkCommandBufferInheritanceRenderingInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
        return serialize_struct(json, ((VkAttachmentSampleCountInfoAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
        {
        return serialize_struct(json, ((VkMultiviewPerViewAttributesInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageViewMinLodFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkImageViewMinLodCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceLinearColorAttachmentFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkGraphicsPipelineLibraryCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE:
        {
        return serialize_struct(json, ((VkDescriptorSetBindingReferenceVALVE*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE:
        {
        return serialize_struct(json, ((VkDescriptorSetLayoutHostMappingInfoVALVE*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineShaderStageModuleIdentifierCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT:
        {
        return serialize_struct(json, ((VkShaderModuleIdentifierEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
        return serialize_struct(json, ((VkImageCompressionControlEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageCompressionControlFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkImageCompressionPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR:
        {
        return serialize_struct(json, ((VkImageSubresource2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR:
        {
        return serialize_struct(json, ((VkSubresourceLayout2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
        {
        return serialize_struct(json, ((VkRenderPassCreationControlEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkRenderPassCreationFeedbackCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkRenderPassSubpassFeedbackCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT:
        {
        return serialize_struct(json, ((VkMicromapBuildInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkMicromapCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT:
        {
        return serialize_struct(json, ((VkMicromapVersionInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT:
        {
        return serialize_struct(json, ((VkCopyMicromapInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT:
        {
        return serialize_struct(json, ((VkCopyMicromapToMemoryInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT:
        {
        return serialize_struct(json, ((VkCopyMemoryToMicromapInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT:
        {
        return serialize_struct(json, ((VkMicromapBuildSizesInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceOpacityMicromapFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceOpacityMicromapPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:
        {
        return serialize_struct(json, ((VkAccelerationStructureTrianglesOpacityMicromapEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT:
        {
        return serialize_struct(json, ((VkPipelinePropertiesIdentifierEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevicePipelinePropertiesFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
        return serialize_struct(json, ((VkExternalMemoryAcquireUnmodifiedEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevicePipelineRobustnessFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkPipelineRobustnessCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevicePipelineRobustnessPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
        {
        return serialize_struct(json, ((VkImageViewSampleWeightCreateInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageProcessingFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageProcessingPropertiesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceTilePropertiesFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM:
        {
        return serialize_struct(json, ((VkTilePropertiesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:
        {
        return serialize_struct(json, ((VkPhysicalDeviceAmigoProfilingFeaturesSEC*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC:
        {
        return serialize_struct(json, ((VkAmigoProfilingSubmitInfoSEC*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDepthClampZeroOneFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceAddressBindingReportFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
        {
        return serialize_struct(json, ((VkDeviceAddressBindingCallbackDataEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceOpticalFlowFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceOpticalFlowPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
        return serialize_struct(json, ((VkOpticalFlowImageFormatInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkOpticalFlowImageFormatPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV:
        {
        return serialize_struct(json, ((VkOpticalFlowSessionCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
        {
        return serialize_struct(json, ((VkOpticalFlowSessionCreatePrivateDataInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV:
        {
        return serialize_struct(json, ((VkOpticalFlowExecuteInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFaultFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT:
        {
        return serialize_struct(json, ((VkDeviceFaultCountsEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT:
        {
        return serialize_struct(json, ((VkDeviceFaultInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT:
        {
        return serialize_struct(json, ((VkDepthBiasInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
        {
        return serialize_struct(json, ((VkDepthBiasRepresentationInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
        return serialize_struct(json, ((VkFrameBoundaryEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceFrameBoundaryFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT:
        {
        return serialize_struct(json, ((VkSurfacePresentModeEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT:
        {
        return serialize_struct(json, ((VkSurfacePresentScalingCapabilitiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT:
        {
        return serialize_struct(json, ((VkSurfacePresentModeCompatibilityEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT:
        {
        return serialize_struct(json, ((VkSwapchainPresentFenceInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkSwapchainPresentModesCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT:
        {
        return serialize_struct(json, ((VkSwapchainPresentModeInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkSwapchainPresentScalingCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT:
        {
        return serialize_struct(json, ((VkReleaseSwapchainImagesInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDepthBiasControlFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG:
        {
        return serialize_struct(json, ((VkDirectDriverLoadingInfoLUNARG*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG:
        {
        return serialize_struct(json, ((VkDirectDriverLoadingListLUNARG*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR:
        {
        return serialize_struct(json, ((VkDeviceImageSubresourceInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderCorePropertiesARM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
        {
        return serialize_struct(json, ((VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
        {
        return serialize_struct(json, ((VkQueryLowLatencySupportNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR:
        {
        return serialize_struct(json, ((VkMemoryMapInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR:
        {
        return serialize_struct(json, ((VkMemoryUnmapInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderObjectFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderObjectPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT:
        {
        return serialize_struct(json, ((VkShaderCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderTileImageFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceShaderTileImagePropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCooperativeMatrixFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkCooperativeMatrixPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCooperativeMatrixPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCubicClampFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM:
        {
        return serialize_struct(json, ((VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceCubicWeightsFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
        {
        return serialize_struct(json, ((VkSamplerCubicWeightsCreateInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM:
        {
        return serialize_struct(json, ((VkBlitImageCubicWeightsInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageProcessing2FeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
        {
        return serialize_struct(json, ((VkPhysicalDeviceImageProcessing2PropertiesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
        {
        return serialize_struct(json, ((VkSamplerBlockMatchWindowCreateInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
        return serialize_struct(json, ((VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
        {
        return serialize_struct(json, ((VkPhysicalDeviceLayeredDriverPropertiesMSFT*)(member))[0]);
        }
    

default:
    return serialize_pNext(json, (void*)(chain->pNext)); //Ignore invalid sTypes
}
}


void deserialize_pNext(boost::json::object& json, void*& member ){
    if (!json.contains("sType")){
        member=NULL;
        return;
    }
    
    switch (value_to<int>(json["sType"])){


    case VK_STRUCTURE_TYPE_APPLICATION_INFO:
        {
        auto result= new VkApplicationInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:
        {
        auto result= new VkDeviceQueueCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
        {
        auto result= new VkDeviceCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:
        {
        auto result= new VkInstanceCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
        {
        auto result= new VkMemoryAllocateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:
        {
        auto result= new VkMappedMemoryRange;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
        {
        auto result= new VkWriteDescriptorSet;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:
        {
        auto result= new VkCopyDescriptorSet;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR:
        {
        auto result= new VkBufferUsageFlags2CreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:
        {
        auto result= new VkBufferCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:
        {
        auto result= new VkBufferViewCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_BARRIER:
        {
        auto result= new VkMemoryBarrier;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:
        {
        auto result= new VkBufferMemoryBarrier;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:
        {
        auto result= new VkImageMemoryBarrier;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:
        {
        auto result= new VkImageCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:
        {
        auto result= new VkImageViewCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
        {
        auto result= new VkBindSparseInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
        {
        auto result= new VkShaderModuleCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
        {
        auto result= new VkDescriptorSetLayoutCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:
        {
        auto result= new VkDescriptorPoolCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
        {
        auto result= new VkDescriptorSetAllocateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:
        {
        auto result= new VkPipelineShaderStageCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
        {
        auto result= new VkComputePipelineCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV:
        {
        auto result= new VkComputePipelineIndirectBufferInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
        {
        auto result= new VkPipelineCreateFlags2CreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineVertexInputStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineInputAssemblyStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineTessellationStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineViewportStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineRasterizationStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineMultisampleStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineColorBlendStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineDynamicStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineDepthStencilStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
        {
        auto result= new VkGraphicsPipelineCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:
        {
        auto result= new VkPipelineCacheCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
        auto result= new VkPipelineLayoutCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:
        {
        auto result= new VkSamplerCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:
        {
        auto result= new VkCommandPoolCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:
        {
        auto result= new VkCommandBufferAllocateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:
        {
        auto result= new VkCommandBufferInheritanceInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:
        {
        auto result= new VkCommandBufferBeginInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:
        {
        auto result= new VkRenderPassBeginInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
        {
        auto result= new VkRenderPassCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:
        {
        auto result= new VkEventCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:
        {
        auto result= new VkFenceCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:
        {
        auto result= new VkSemaphoreCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:
        {
        auto result= new VkQueryPoolCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
        {
        auto result= new VkFramebufferCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBMIT_INFO:
        {
        auto result= new VkSubmitInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:
        {
        auto result= new VkDisplayModeCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:
        {
        auto result= new VkDisplaySurfaceCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
        auto result= new VkDisplayPresentInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:
        {
        auto result= new VkXlibSurfaceCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR:
        {
        auto result= new VkXcbSurfaceCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:
        {
        auto result= new VkSwapchainCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
        {
        auto result= new VkPresentInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
        auto result= new VkDebugReportCallbackCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
        auto result= new VkValidationFlagsEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
        auto result= new VkValidationFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
        auto result= new VkPipelineRasterizationStateRasterizationOrderAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT:
        {
        auto result= new VkDebugMarkerObjectNameInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
        {
        auto result= new VkDebugMarkerObjectTagInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT:
        {
        auto result= new VkDebugMarkerMarkerInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
        auto result= new VkDedicatedAllocationImageCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
        auto result= new VkDedicatedAllocationBufferCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
        auto result= new VkDedicatedAllocationMemoryAllocateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
        auto result= new VkExternalMemoryImageCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
        auto result= new VkExportMemoryAllocateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
        {
        auto result= new VkDevicePrivateDataCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO:
        {
        auto result= new VkPrivateDataSlotCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
        auto result= new VkPhysicalDevicePrivateDataFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceMultiDrawPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV:
        {
        auto result= new VkGraphicsShaderGroupCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
        auto result= new VkGraphicsPipelineShaderGroupsCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV:
        {
        auto result= new VkIndirectCommandsLayoutTokenNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV:
        {
        auto result= new VkIndirectCommandsLayoutCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV:
        {
        auto result= new VkGeneratedCommandsInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV:
        {
        auto result= new VkGeneratedCommandsMemoryRequirementsInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV:
        {
        auto result= new VkPipelineIndirectDeviceAddressInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
        auto result= new VkPhysicalDeviceFeatures2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
        {
        auto result= new VkPhysicalDeviceProperties2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:
        {
        auto result= new VkFormatProperties2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:
        {
        auto result= new VkImageFormatProperties2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:
        {
        auto result= new VkPhysicalDeviceImageFormatInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:
        {
        auto result= new VkQueueFamilyProperties2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:
        {
        auto result= new VkPhysicalDeviceMemoryProperties2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:
        {
        auto result= new VkSparseImageFormatProperties2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
        {
        auto result= new VkPhysicalDeviceSparseImageFormatInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
        auto result= new VkPhysicalDevicePushDescriptorPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceDriverProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
        auto result= new VkPresentRegionsKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
        auto result= new VkPhysicalDeviceVariablePointersFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
        auto result= new VkPhysicalDeviceExternalImageFormatInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
        auto result= new VkExternalImageFormatProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:
        {
        auto result= new VkPhysicalDeviceExternalBufferInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:
        {
        auto result= new VkExternalBufferProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceIDProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
        auto result= new VkExternalMemoryImageCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
        auto result= new VkExternalMemoryBufferCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
        auto result= new VkExportMemoryAllocateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
        auto result= new VkImportMemoryFdInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR:
        {
        auto result= new VkMemoryFdPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR:
        {
        auto result= new VkMemoryGetFdInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
        {
        auto result= new VkPhysicalDeviceExternalSemaphoreInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:
        {
        auto result= new VkExternalSemaphoreProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
        auto result= new VkExportSemaphoreCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR:
        {
        auto result= new VkImportSemaphoreFdInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR:
        {
        auto result= new VkSemaphoreGetFdInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:
        {
        auto result= new VkPhysicalDeviceExternalFenceInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:
        {
        auto result= new VkExternalFenceProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
        auto result= new VkExportFenceCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR:
        {
        auto result= new VkImportFenceFdInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR:
        {
        auto result= new VkFenceGetFdInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
        auto result= new VkPhysicalDeviceMultiviewFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceMultiviewProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
        auto result= new VkRenderPassMultiviewCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT:
        {
        auto result= new VkSurfaceCapabilities2EXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT:
        {
        auto result= new VkDisplayPowerInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT:
        {
        auto result= new VkDeviceEventInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT:
        {
        auto result= new VkDisplayEventInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
        auto result= new VkSwapchainCounterCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceGroupProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
        auto result= new VkMemoryAllocateFlagsInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:
        {
        auto result= new VkBindBufferMemoryInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
        auto result= new VkBindBufferMemoryDeviceGroupInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:
        {
        auto result= new VkBindImageMemoryInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
        auto result= new VkBindImageMemoryDeviceGroupInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
        auto result= new VkDeviceGroupRenderPassBeginInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
        auto result= new VkDeviceGroupCommandBufferBeginInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
        auto result= new VkDeviceGroupSubmitInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
        auto result= new VkDeviceGroupBindSparseInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:
        {
        auto result= new VkDeviceGroupPresentCapabilitiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
        auto result= new VkImageSwapchainCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
        auto result= new VkBindImageMemorySwapchainInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:
        {
        auto result= new VkAcquireNextImageInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
        auto result= new VkDeviceGroupPresentInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
        auto result= new VkDeviceGroupDeviceCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
        auto result= new VkDeviceGroupSwapchainCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
        {
        auto result= new VkDescriptorUpdateTemplateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
        auto result= new VkPhysicalDevicePresentIdFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
        {
        auto result= new VkPresentIdKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
        auto result= new VkPhysicalDevicePresentWaitFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_HDR_METADATA_EXT:
        {
        auto result= new VkHdrMetadataEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
        auto result= new VkDisplayNativeHdrSurfaceCapabilitiesAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
        auto result= new VkSwapchainDisplayNativeHdrCreateInfoAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
        auto result= new VkPresentTimesInfoGOOGLE;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineViewportWScalingStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineViewportSwizzleStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceDiscardRectanglePropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineDiscardRectangleStateCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
        auto result= new VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
        auto result= new VkRenderPassInputAttachmentAspectCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:
        {
        auto result= new VkPhysicalDeviceSurfaceInfo2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:
        {
        auto result= new VkSurfaceCapabilities2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:
        {
        auto result= new VkSurfaceFormat2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:
        {
        auto result= new VkDisplayProperties2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:
        {
        auto result= new VkDisplayPlaneProperties2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:
        {
        auto result= new VkDisplayModeProperties2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:
        {
        auto result= new VkDisplayPlaneInfo2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:
        {
        auto result= new VkDisplayPlaneCapabilities2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
        auto result= new VkSharedPresentSurfaceCapabilitiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
        auto result= new VkPhysicalDevice16BitStorageFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceSubgroupProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
        auto result= new VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:
        {
        auto result= new VkBufferMemoryRequirementsInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS:
        {
        auto result= new VkDeviceBufferMemoryRequirements;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:
        {
        auto result= new VkImageMemoryRequirementsInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
        {
        auto result= new VkImageSparseMemoryRequirementsInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS:
        {
        auto result= new VkDeviceImageMemoryRequirements;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:
        {
        auto result= new VkMemoryRequirements2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:
        {
        auto result= new VkSparseImageMemoryRequirements2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
        auto result= new VkPhysicalDevicePointClippingProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
        auto result= new VkMemoryDedicatedRequirements;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
        auto result= new VkMemoryDedicatedAllocateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
        auto result= new VkImageViewUsageCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT:
        {
        auto result= new VkImageViewSlicedCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
        auto result= new VkPipelineTessellationDomainOriginStateCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
        auto result= new VkSamplerYcbcrConversionInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:
        {
        auto result= new VkSamplerYcbcrConversionCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
        auto result= new VkBindImagePlaneMemoryInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
        auto result= new VkImagePlaneMemoryRequirementsInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
        auto result= new VkPhysicalDeviceSamplerYcbcrConversionFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
        auto result= new VkSamplerYcbcrConversionImageFormatProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
        auto result= new VkTextureLODGatherFormatPropertiesAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT:
        {
        auto result= new VkConditionalRenderingBeginInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
        auto result= new VkProtectedSubmitInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
        auto result= new VkPhysicalDeviceProtectedMemoryFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceProtectedMemoryProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:
        {
        auto result= new VkDeviceQueueInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineCoverageToColorStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceSamplerFilterMinmaxProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
        auto result= new VkSampleLocationsInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
        auto result= new VkRenderPassSampleLocationsBeginInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineSampleLocationsStateCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceSampleLocationsPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT:
        {
        auto result= new VkMultisamplePropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
        auto result= new VkSamplerReductionModeCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceMultiDrawFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineColorBlendAdvancedStateCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
        auto result= new VkPhysicalDeviceInlineUniformBlockFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceInlineUniformBlockProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
        {
        auto result= new VkWriteDescriptorSetInlineUniformBlock;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
        {
        auto result= new VkDescriptorPoolInlineUniformBlockCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineCoverageModulationStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
        auto result= new VkImageFormatListCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
        auto result= new VkValidationCacheCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
        auto result= new VkShaderModuleValidationCacheCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceMaintenance3Properties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
        auto result= new VkPhysicalDeviceMaintenance4Features;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceMaintenance4Properties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceMaintenance5FeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR:
        {
        auto result= new VkPhysicalDeviceMaintenance5PropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR:
        {
        auto result= new VkRenderingAreaInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:
        {
        auto result= new VkDescriptorSetLayoutSupport;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
        auto result= new VkPhysicalDeviceShaderDrawParametersFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
        auto result= new VkPhysicalDeviceShaderFloat16Int8Features;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceFloatControlsProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
        auto result= new VkPhysicalDeviceHostQueryResetFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR:
        {
        auto result= new VkDeviceQueueGlobalPriorityCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR:
        {
        auto result= new VkQueueFamilyGlobalPriorityPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
        {
        auto result= new VkDebugUtilsObjectNameInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
        {
        auto result= new VkDebugUtilsObjectTagInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT:
        {
        auto result= new VkDebugUtilsLabelEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
        auto result= new VkDebugUtilsMessengerCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
        {
        auto result= new VkDebugUtilsMessengerCallbackDataEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceDeviceMemoryReportFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
        auto result= new VkDeviceDeviceMemoryReportCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT:
        {
        auto result= new VkDeviceMemoryReportCallbackDataEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
        auto result= new VkImportMemoryHostPointerInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT:
        {
        auto result= new VkMemoryHostPointerPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceExternalMemoryHostPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceConservativeRasterizationPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT:
        {
        auto result= new VkCalibratedTimestampInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
        auto result= new VkPhysicalDeviceShaderCorePropertiesAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
        auto result= new VkPhysicalDeviceShaderCoreProperties2AMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineRasterizationConservativeStateCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
        auto result= new VkPhysicalDeviceDescriptorIndexingFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceDescriptorIndexingProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
        auto result= new VkDescriptorSetLayoutBindingFlagsCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
        auto result= new VkDescriptorSetVariableDescriptorCountAllocateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
        auto result= new VkDescriptorSetVariableDescriptorCountLayoutSupport;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2:
        {
        auto result= new VkAttachmentDescription2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2:
        {
        auto result= new VkAttachmentReference2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2:
        {
        auto result= new VkSubpassDescription2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2:
        {
        auto result= new VkSubpassDependency2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:
        {
        auto result= new VkRenderPassCreateInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO:
        {
        auto result= new VkSubpassBeginInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_END_INFO:
        {
        auto result= new VkSubpassEndInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
        auto result= new VkPhysicalDeviceTimelineSemaphoreFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceTimelineSemaphoreProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
        auto result= new VkSemaphoreTypeCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
        auto result= new VkTimelineSemaphoreSubmitInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO:
        {
        auto result= new VkSemaphoreWaitInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO:
        {
        auto result= new VkSemaphoreSignalInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineVertexInputDivisorStateCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDevicePCIBusInfoPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
        auto result= new VkCommandBufferInheritanceConditionalRenderingInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
        auto result= new VkPhysicalDevice8BitStorageFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceConditionalRenderingFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
        auto result= new VkPhysicalDeviceVulkanMemoryModelFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
        auto result= new VkPhysicalDeviceShaderAtomicInt64Features;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
        auto result= new VkQueueFamilyCheckpointPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV:
        {
        auto result= new VkCheckpointDataNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceDepthStencilResolveProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
        auto result= new VkSubpassDescriptionDepthStencilResolve;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
        auto result= new VkImageViewASTCDecodeModeEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceASTCDecodeFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceTransformFeedbackFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceTransformFeedbackPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineRasterizationStateStreamCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineRepresentativeFragmentTestStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceExclusiveScissorFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineViewportExclusiveScissorStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceCornerSampledImageFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceComputeShaderDerivativesFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceShaderImageFootprintFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceCopyMemoryIndirectFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceCopyMemoryIndirectPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceMemoryDecompressionFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceMemoryDecompressionPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineViewportShadingRateImageStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceShadingRateImageFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceShadingRateImagePropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
        auto result= new VkPhysicalDeviceInvocationMaskFeaturesHUAWEI;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineViewportCoarseSampleOrderStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceMeshShaderFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceMeshShaderPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceMeshShaderFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceMeshShaderPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
        {
        auto result= new VkRayTracingShaderGroupCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR:
        {
        auto result= new VkRayTracingShaderGroupCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV:
        {
        auto result= new VkRayTracingPipelineCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR:
        {
        auto result= new VkRayTracingPipelineCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV:
        {
        auto result= new VkGeometryTrianglesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV:
        {
        auto result= new VkGeometryAABBNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_GEOMETRY_NV:
        {
        auto result= new VkGeometryNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV:
        {
        auto result= new VkAccelerationStructureInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
        {
        auto result= new VkAccelerationStructureCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
        {
        auto result= new VkBindAccelerationStructureMemoryInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
        auto result= new VkWriteDescriptorSetAccelerationStructureKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
        auto result= new VkWriteDescriptorSetAccelerationStructureNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
        {
        auto result= new VkAccelerationStructureMemoryRequirementsInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceAccelerationStructureFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceRayTracingPipelineFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceRayQueryFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
        auto result= new VkPhysicalDeviceAccelerationStructurePropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
        auto result= new VkPhysicalDeviceRayTracingPipelinePropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceRayTracingPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
        auto result= new VkDrmFormatModifierPropertiesListEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
        auto result= new VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
        auto result= new VkImageDrmFormatModifierListCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
        auto result= new VkImageDrmFormatModifierExplicitCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
        {
        auto result= new VkImageDrmFormatModifierPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
        auto result= new VkImageStencilUsageCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
        auto result= new VkDeviceMemoryOverallocationCreateInfoAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceFragmentDensityMapFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceFragmentDensityMap2FeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
        {
        auto result= new VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceFragmentDensityMapPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceFragmentDensityMap2PropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM:
        {
        auto result= new VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
        auto result= new VkRenderPassFragmentDensityMapCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM:
        {
        auto result= new VkSubpassFragmentDensityMapOffsetEndInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
        auto result= new VkPhysicalDeviceScalarBlockLayoutFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
        auto result= new VkSurfaceProtectedCapabilitiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
        auto result= new VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceDepthClipEnableFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineRasterizationDepthClipStateCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceMemoryBudgetPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceMemoryPriorityFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
        auto result= new VkMemoryPriorityAllocateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
        auto result= new VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
        auto result= new VkPhysicalDeviceBufferDeviceAddressFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO:
        {
        auto result= new VkBufferDeviceAddressInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
        auto result= new VkBufferOpaqueCaptureAddressCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
        auto result= new VkBufferDeviceAddressCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
        auto result= new VkPhysicalDeviceImageViewImageFormatInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
        auto result= new VkFilterCubicImageViewImageFormatPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
        auto result= new VkPhysicalDeviceImagelessFramebufferFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
        auto result= new VkFramebufferAttachmentsCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:
        {
        auto result= new VkFramebufferAttachmentImageInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
        auto result= new VkRenderPassAttachmentBeginInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
        auto result= new VkPhysicalDeviceTextureCompressionASTCHDRFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceCooperativeMatrixFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceCooperativeMatrixPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
        auto result= new VkCooperativeMatrixPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceYcbcrImageArraysFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX:
        {
        auto result= new VkImageViewHandleInfoNVX;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX:
        {
        auto result= new VkImageViewAddressPropertiesNVX;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
        auto result= new VkPipelineCreationFeedbackCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
        auto result= new VkPhysicalDevicePresentBarrierFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
        {
        auto result= new VkSurfaceCapabilitiesPresentBarrierNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
        {
        auto result= new VkSwapchainPresentBarrierCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
        auto result= new VkPhysicalDevicePerformanceQueryFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
        auto result= new VkPhysicalDevicePerformanceQueryPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR:
        {
        auto result= new VkPerformanceCounterKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR:
        {
        auto result= new VkPerformanceCounterDescriptionKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
        auto result= new VkQueryPoolPerformanceCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR:
        {
        auto result= new VkAcquireProfilingLockInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
        auto result= new VkPerformanceQuerySubmitInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT:
        {
        auto result= new VkHeadlessSurfaceCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceCoverageReductionModeFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineCoverageReductionStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
        {
        auto result= new VkFramebufferMixedSamplesCombinationNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
        auto result= new VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL:
        {
        auto result= new VkInitializePerformanceApiInfoINTEL;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
        auto result= new VkQueryPoolPerformanceQueryCreateInfoINTEL;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL:
        {
        auto result= new VkPerformanceMarkerInfoINTEL;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL:
        {
        auto result= new VkPerformanceStreamMarkerInfoINTEL;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL:
        {
        auto result= new VkPerformanceOverrideInfoINTEL;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
        {
        auto result= new VkPerformanceConfigurationAcquireInfoINTEL;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceShaderClockFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceIndexTypeUint8FeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceShaderSMBuiltinsPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceShaderSMBuiltinsFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
        auto result= new VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
        auto result= new VkAttachmentReferenceStencilLayout;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
        auto result= new VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
        auto result= new VkAttachmentDescriptionStencilLayout;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
        auto result= new VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR:
        {
        auto result= new VkPipelineInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR:
        {
        auto result= new VkPipelineExecutablePropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR:
        {
        auto result= new VkPipelineExecutableInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR:
        {
        auto result= new VkPipelineExecutableStatisticKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
        {
        auto result= new VkPipelineExecutableInternalRepresentationKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
        auto result= new VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceTexelBufferAlignmentProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
        auto result= new VkPhysicalDeviceSubgroupSizeControlFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceSubgroupSizeControlProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
        auto result= new VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
        {
        auto result= new VkSubpassShadingPipelineCreateInfoHUAWEI;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
        {
        auto result= new VkPhysicalDeviceSubpassShadingPropertiesHUAWEI;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
        {
        auto result= new VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
        auto result= new VkMemoryOpaqueCaptureAddressAllocateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:
        {
        auto result= new VkDeviceMemoryOpaqueCaptureAddressInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceLineRasterizationFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceLineRasterizationPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineRasterizationLineStateCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
        auto result= new VkPhysicalDevicePipelineCreationCacheControlFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
        auto result= new VkPhysicalDeviceVulkan11Features;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceVulkan11Properties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
        auto result= new VkPhysicalDeviceVulkan12Features;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceVulkan12Properties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
        auto result= new VkPhysicalDeviceVulkan13Features;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceVulkan13Properties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
        auto result= new VkPipelineCompilerControlCreateInfoAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
        auto result= new VkPhysicalDeviceCoherentMemoryFeaturesAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceToolProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
        auto result= new VkSamplerCustomBorderColorCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceCustomBorderColorPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceCustomBorderColorFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
        {
        auto result= new VkSamplerBorderColorComponentMappingCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceBorderColorSwizzleFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR:
        {
        auto result= new VkAccelerationStructureGeometryTrianglesDataKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR:
        {
        auto result= new VkAccelerationStructureGeometryAabbsDataKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR:
        {
        auto result= new VkAccelerationStructureGeometryInstancesDataKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR:
        {
        auto result= new VkAccelerationStructureGeometryKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR:
        {
        auto result= new VkAccelerationStructureBuildGeometryInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR:
        {
        auto result= new VkAccelerationStructureCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR:
        {
        auto result= new VkAccelerationStructureDeviceAddressInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR:
        {
        auto result= new VkAccelerationStructureVersionInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR:
        {
        auto result= new VkCopyAccelerationStructureInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR:
        {
        auto result= new VkCopyAccelerationStructureToMemoryInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR:
        {
        auto result= new VkCopyMemoryToAccelerationStructureInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR:
        {
        auto result= new VkRayTracingPipelineInterfaceCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
        {
        auto result= new VkPipelineLibraryCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceExtendedDynamicStateFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceExtendedDynamicState2FeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceExtendedDynamicState3FeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceExtendedDynamicState3PropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
        auto result= new VkRenderPassTransformBeginInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
        auto result= new VkCopyCommandTransformInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
        auto result= new VkCommandBufferInheritanceRenderPassTransformInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceDiagnosticsConfigFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
        auto result= new VkDeviceDiagnosticsConfigCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
        auto result= new VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceRobustness2FeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceRobustness2PropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
        auto result= new VkPhysicalDeviceImageRobustnessFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
        auto result= new VkPhysicalDevice4444FormatsFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
        auto result= new VkPhysicalDeviceSubpassShadingFeaturesHUAWEI;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
        auto result= new VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_COPY_2:
        {
        auto result= new VkBufferCopy2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_COPY_2:
        {
        auto result= new VkImageCopy2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_BLIT_2:
        {
        auto result= new VkImageBlit2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2:
        {
        auto result= new VkBufferImageCopy2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2:
        {
        auto result= new VkImageResolve2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2:
        {
        auto result= new VkCopyBufferInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2:
        {
        auto result= new VkCopyImageInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2:
        {
        auto result= new VkBlitImageInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2:
        {
        auto result= new VkCopyBufferToImageInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2:
        {
        auto result= new VkCopyImageToBufferInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2:
        {
        auto result= new VkResolveImageInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
        auto result= new VkFragmentShadingRateAttachmentInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
        auto result= new VkPipelineFragmentShadingRateStateCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceFragmentShadingRateFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
        auto result= new VkPhysicalDeviceFragmentShadingRatePropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR:
        {
        auto result= new VkPhysicalDeviceFragmentShadingRateKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
        auto result= new VkPhysicalDeviceShaderTerminateInvocationFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
        auto result= new VkPipelineFragmentShadingRateEnumStateCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR:
        {
        auto result= new VkAccelerationStructureBuildSizesInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceImage2DViewOf3DFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
        {
        auto result= new VkMutableDescriptorTypeCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceDepthClipControlFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineViewportDepthClipControlCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceExternalMemoryRDMAFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT:
        {
        auto result= new VkVertexInputBindingDescription2EXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT:
        {
        auto result= new VkVertexInputAttributeDescription2EXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceColorWriteEnableFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineColorWriteCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:
        {
        auto result= new VkMemoryBarrier2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2:
        {
        auto result= new VkImageMemoryBarrier2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2:
        {
        auto result= new VkBufferMemoryBarrier2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEPENDENCY_INFO:
        {
        auto result= new VkDependencyInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO:
        {
        auto result= new VkSemaphoreSubmitInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO:
        {
        auto result= new VkCommandBufferSubmitInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBMIT_INFO_2:
        {
        auto result= new VkSubmitInfo2;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
        {
        auto result= new VkQueueFamilyCheckpointProperties2NV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV:
        {
        auto result= new VkCheckpointData2NV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
        auto result= new VkPhysicalDeviceSynchronization2Features;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceHostImageCopyFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceHostImageCopyPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT:
        {
        auto result= new VkMemoryToImageCopyEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT:
        {
        auto result= new VkImageToMemoryCopyEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT:
        {
        auto result= new VkCopyMemoryToImageInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT:
        {
        auto result= new VkCopyImageToMemoryInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT:
        {
        auto result= new VkCopyImageToImageInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT:
        {
        auto result= new VkHostImageLayoutTransitionInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT:
        {
        auto result= new VkSubresourceHostMemcpySizeEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT:
        {
        auto result= new VkHostImageCopyDevicePerformanceQueryEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
        auto result= new VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceLegacyDitheringFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
        {
        auto result= new VkSubpassResolvePerformanceQueryEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
        {
        auto result= new VkMultisampledRenderToSingleSampledInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT:
        {
        auto result= new VkPhysicalDevicePipelineProtectedAccessFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR:
        {
        auto result= new VkQueueFamilyVideoPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
        {
        auto result= new VkQueueFamilyQueryResultStatusPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
        auto result= new VkVideoProfileListInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR:
        {
        auto result= new VkPhysicalDeviceVideoFormatInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR:
        {
        auto result= new VkVideoFormatPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR:
        {
        auto result= new VkVideoProfileInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR:
        {
        auto result= new VkVideoCapabilitiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR:
        {
        auto result= new VkVideoSessionMemoryRequirementsKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR:
        {
        auto result= new VkBindVideoSessionMemoryInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR:
        {
        auto result= new VkVideoPictureResourceInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR:
        {
        auto result= new VkVideoReferenceSlotInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR:
        {
        auto result= new VkVideoDecodeCapabilitiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR:
        {
        auto result= new VkVideoDecodeUsageInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR:
        {
        auto result= new VkVideoDecodeInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR:
        {
        auto result= new VkVideoDecodeH264ProfileInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR:
        {
        auto result= new VkVideoDecodeH264CapabilitiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
        {
        auto result= new VkVideoDecodeH264SessionParametersAddInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
        auto result= new VkVideoDecodeH264SessionParametersCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR:
        {
        auto result= new VkVideoDecodeH264PictureInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR:
        {
        auto result= new VkVideoDecodeH264DpbSlotInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR:
        {
        auto result= new VkVideoDecodeH265ProfileInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR:
        {
        auto result= new VkVideoDecodeH265CapabilitiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
        {
        auto result= new VkVideoDecodeH265SessionParametersAddInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
        auto result= new VkVideoDecodeH265SessionParametersCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR:
        {
        auto result= new VkVideoDecodeH265PictureInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR:
        {
        auto result= new VkVideoDecodeH265DpbSlotInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR:
        {
        auto result= new VkVideoSessionCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
        auto result= new VkVideoSessionParametersCreateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR:
        {
        auto result= new VkVideoSessionParametersUpdateInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR:
        {
        auto result= new VkVideoBeginCodingInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR:
        {
        auto result= new VkVideoEndCodingInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR:
        {
        auto result= new VkVideoCodingControlInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceInheritedViewportScissorFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
        {
        auto result= new VkCommandBufferInheritanceViewportScissorInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceProvokingVertexFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceProvokingVertexPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineRasterizationProvokingVertexStateCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX:
        {
        auto result= new VkCuModuleCreateInfoNVX;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX:
        {
        auto result= new VkCuFunctionCreateInfoNVX;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX:
        {
        auto result= new VkCuLaunchInfoNVX;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceDescriptorBufferFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceDescriptorBufferPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT:
        {
        auto result= new VkDescriptorAddressInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT:
        {
        auto result= new VkDescriptorBufferBindingInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT:
        {
        auto result= new VkDescriptorBufferBindingPushDescriptorBufferHandleEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT:
        {
        auto result= new VkDescriptorGetInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto result= new VkBufferCaptureDescriptorDataInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto result= new VkImageCaptureDescriptorDataInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto result= new VkImageViewCaptureDescriptorDataInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto result= new VkSamplerCaptureDescriptorDataInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto result= new VkAccelerationStructureCaptureDescriptorDataInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
        auto result= new VkOpaqueCaptureDescriptorDataCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
        auto result= new VkPhysicalDeviceShaderIntegerDotProductFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
        {
        auto result= new VkPhysicalDeviceShaderIntegerDotProductProperties;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceDrmPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
        {
        auto result= new VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceRayTracingMotionBlurFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
        {
        auto result= new VkAccelerationStructureGeometryMotionTrianglesDataNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
        {
        auto result= new VkAccelerationStructureMotionInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV:
        {
        auto result= new VkMemoryGetRemoteAddressInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
        {
        auto result= new VkFormatProperties3;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
        {
        auto result= new VkDrmFormatModifierPropertiesList2EXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
        {
        auto result= new VkPipelineRenderingCreateInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_INFO:
        {
        auto result= new VkRenderingInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO:
        {
        auto result= new VkRenderingAttachmentInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
        auto result= new VkRenderingFragmentShadingRateAttachmentInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
        {
        auto result= new VkRenderingFragmentDensityMapAttachmentInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
        auto result= new VkPhysicalDeviceDynamicRenderingFeatures;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
        {
        auto result= new VkCommandBufferInheritanceRenderingInfo;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
        auto result= new VkAttachmentSampleCountInfoAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
        {
        auto result= new VkMultiviewPerViewAttributesInfoNVX;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceImageViewMinLodFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT:
        {
        auto result= new VkImageViewMinLodCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceLinearColorAttachmentFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
        {
        auto result= new VkGraphicsPipelineLibraryCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
        auto result= new VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE:
        {
        auto result= new VkDescriptorSetBindingReferenceVALVE;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE:
        {
        auto result= new VkDescriptorSetLayoutHostMappingInfoVALVE;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineShaderStageModuleIdentifierCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT:
        {
        auto result= new VkShaderModuleIdentifierEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
        auto result= new VkImageCompressionControlEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceImageCompressionControlFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
        auto result= new VkImageCompressionPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR:
        {
        auto result= new VkImageSubresource2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR:
        {
        auto result= new VkSubresourceLayout2KHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
        {
        auto result= new VkRenderPassCreationControlEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
        auto result= new VkRenderPassCreationFeedbackCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
        {
        auto result= new VkRenderPassSubpassFeedbackCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT:
        {
        auto result= new VkMicromapBuildInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT:
        {
        auto result= new VkMicromapCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT:
        {
        auto result= new VkMicromapVersionInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT:
        {
        auto result= new VkCopyMicromapInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT:
        {
        auto result= new VkCopyMicromapToMemoryInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT:
        {
        auto result= new VkCopyMemoryToMicromapInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT:
        {
        auto result= new VkMicromapBuildSizesInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceOpacityMicromapFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceOpacityMicromapPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:
        {
        auto result= new VkAccelerationStructureTrianglesOpacityMicromapEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT:
        {
        auto result= new VkPipelinePropertiesIdentifierEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
        auto result= new VkPhysicalDevicePipelinePropertiesFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
        auto result= new VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
        auto result= new VkExternalMemoryAcquireUnmodifiedEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
        {
        auto result= new VkPhysicalDevicePipelineRobustnessFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
        {
        auto result= new VkPipelineRobustnessCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDevicePipelineRobustnessPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
        {
        auto result= new VkImageViewSampleWeightCreateInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
        auto result= new VkPhysicalDeviceImageProcessingFeaturesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
        {
        auto result= new VkPhysicalDeviceImageProcessingPropertiesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
        auto result= new VkPhysicalDeviceTilePropertiesFeaturesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM:
        {
        auto result= new VkTilePropertiesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:
        {
        auto result= new VkPhysicalDeviceAmigoProfilingFeaturesSEC;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC:
        {
        auto result= new VkAmigoProfilingSubmitInfoSEC;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceDepthClampZeroOneFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceAddressBindingReportFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
        {
        auto result= new VkDeviceAddressBindingCallbackDataEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceOpticalFlowFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceOpticalFlowPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
        auto result= new VkOpticalFlowImageFormatInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV:
        {
        auto result= new VkOpticalFlowImageFormatPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV:
        {
        auto result= new VkOpticalFlowSessionCreateInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
        {
        auto result= new VkOpticalFlowSessionCreatePrivateDataInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV:
        {
        auto result= new VkOpticalFlowExecuteInfoNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceFaultFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT:
        {
        auto result= new VkDeviceFaultCountsEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT:
        {
        auto result= new VkDeviceFaultInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
        auto result= new VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT:
        {
        auto result= new VkDepthBiasInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
        {
        auto result= new VkDepthBiasRepresentationInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
        {
        auto result= new VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
        auto result= new VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
        auto result= new VkFrameBoundaryEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceFrameBoundaryFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT:
        {
        auto result= new VkSurfacePresentModeEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT:
        {
        auto result= new VkSurfacePresentScalingCapabilitiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT:
        {
        auto result= new VkSurfacePresentModeCompatibilityEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT:
        {
        auto result= new VkSwapchainPresentFenceInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT:
        {
        auto result= new VkSwapchainPresentModesCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT:
        {
        auto result= new VkSwapchainPresentModeInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT:
        {
        auto result= new VkSwapchainPresentScalingCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT:
        {
        auto result= new VkReleaseSwapchainImagesInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceDepthBiasControlFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
        {
        auto result= new VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG:
        {
        auto result= new VkDirectDriverLoadingInfoLUNARG;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG:
        {
        auto result= new VkDirectDriverLoadingListLUNARG;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
        auto result= new VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR:
        {
        auto result= new VkDeviceImageSubresourceInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
        {
        auto result= new VkPhysicalDeviceShaderCorePropertiesARM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
        auto result= new VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
        {
        auto result= new VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
        {
        auto result= new VkQueryLowLatencySupportNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR:
        {
        auto result= new VkMemoryMapInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR:
        {
        auto result= new VkMemoryUnmapInfoKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceShaderObjectFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceShaderObjectPropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT:
        {
        auto result= new VkShaderCreateInfoEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
        auto result= new VkPhysicalDeviceShaderTileImageFeaturesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
        {
        auto result= new VkPhysicalDeviceShaderTileImagePropertiesEXT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
        auto result= new VkPhysicalDeviceCooperativeMatrixFeaturesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
        auto result= new VkCooperativeMatrixPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
        auto result= new VkPhysicalDeviceCooperativeMatrixPropertiesKHR;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
        auto result= new VkPhysicalDeviceCubicClampFeaturesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
        auto result= new VkPhysicalDeviceYcbcrDegammaFeaturesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM:
        {
        auto result= new VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
        auto result= new VkPhysicalDeviceCubicWeightsFeaturesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
        {
        auto result= new VkSamplerCubicWeightsCreateInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM:
        {
        auto result= new VkBlitImageCubicWeightsInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
        auto result= new VkPhysicalDeviceImageProcessing2FeaturesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
        {
        auto result= new VkPhysicalDeviceImageProcessing2PropertiesQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
        {
        auto result= new VkSamplerBlockMatchWindowCreateInfoQCOM;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
        auto result= new VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
        {
        auto result= new VkPhysicalDeviceLayeredDriverPropertiesMSFT;
        deserialize_struct(json, result[0]);
        member=result;
        return;
        }
    
}}
std::map<VkStructureType, size_t> structure_type_to_size={
{VK_STRUCTURE_TYPE_APPLICATION_INFO, sizeof(VkApplicationInfo) },
{VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, sizeof(VkDeviceQueueCreateInfo) },
{VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, sizeof(VkDeviceCreateInfo) },
{VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, sizeof(VkInstanceCreateInfo) },
{VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, sizeof(VkMemoryAllocateInfo) },
{VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, sizeof(VkMappedMemoryRange) },
{VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, sizeof(VkWriteDescriptorSet) },
{VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET, sizeof(VkCopyDescriptorSet) },
{VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR, sizeof(VkBufferUsageFlags2CreateInfoKHR) },
{VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, sizeof(VkBufferCreateInfo) },
{VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO, sizeof(VkBufferViewCreateInfo) },
{VK_STRUCTURE_TYPE_MEMORY_BARRIER, sizeof(VkMemoryBarrier) },
{VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, sizeof(VkBufferMemoryBarrier) },
{VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, sizeof(VkImageMemoryBarrier) },
{VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, sizeof(VkImageCreateInfo) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, sizeof(VkImageViewCreateInfo) },
{VK_STRUCTURE_TYPE_BIND_SPARSE_INFO, sizeof(VkBindSparseInfo) },
{VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, sizeof(VkShaderModuleCreateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, sizeof(VkDescriptorSetLayoutCreateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, sizeof(VkDescriptorPoolCreateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, sizeof(VkDescriptorSetAllocateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, sizeof(VkPipelineShaderStageCreateInfo) },
{VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, sizeof(VkComputePipelineCreateInfo) },
{VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV, sizeof(VkComputePipelineIndirectBufferInfoNV) },
{VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR, sizeof(VkPipelineCreateFlags2CreateInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, sizeof(VkPipelineVertexInputStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, sizeof(VkPipelineInputAssemblyStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO, sizeof(VkPipelineTessellationStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, sizeof(VkPipelineViewportStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, sizeof(VkPipelineRasterizationStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, sizeof(VkPipelineMultisampleStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, sizeof(VkPipelineColorBlendStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, sizeof(VkPipelineDynamicStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO, sizeof(VkPipelineDepthStencilStateCreateInfo) },
{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, sizeof(VkGraphicsPipelineCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO, sizeof(VkPipelineCacheCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, sizeof(VkPipelineLayoutCreateInfo) },
{VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, sizeof(VkSamplerCreateInfo) },
{VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, sizeof(VkCommandPoolCreateInfo) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, sizeof(VkCommandBufferAllocateInfo) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO, sizeof(VkCommandBufferInheritanceInfo) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, sizeof(VkCommandBufferBeginInfo) },
{VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, sizeof(VkRenderPassBeginInfo) },
{VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, sizeof(VkRenderPassCreateInfo) },
{VK_STRUCTURE_TYPE_EVENT_CREATE_INFO, sizeof(VkEventCreateInfo) },
{VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, sizeof(VkFenceCreateInfo) },
{VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, sizeof(VkSemaphoreCreateInfo) },
{VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO, sizeof(VkQueryPoolCreateInfo) },
{VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, sizeof(VkFramebufferCreateInfo) },
{VK_STRUCTURE_TYPE_SUBMIT_INFO, sizeof(VkSubmitInfo) },
{VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR, sizeof(VkDisplayModeCreateInfoKHR) },
{VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR, sizeof(VkDisplaySurfaceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR, sizeof(VkDisplayPresentInfoKHR) },
{VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR, sizeof(VkXlibSurfaceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR, sizeof(VkXcbSurfaceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, sizeof(VkSwapchainCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, sizeof(VkPresentInfoKHR) },
{VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT, sizeof(VkDebugReportCallbackCreateInfoEXT) },
{VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT, sizeof(VkValidationFlagsEXT) },
{VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT, sizeof(VkValidationFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD, sizeof(VkPipelineRasterizationStateRasterizationOrderAMD) },
{VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT, sizeof(VkDebugMarkerObjectNameInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT, sizeof(VkDebugMarkerObjectTagInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, sizeof(VkDebugMarkerMarkerInfoEXT) },
{VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, sizeof(VkDedicatedAllocationImageCreateInfoNV) },
{VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV, sizeof(VkDedicatedAllocationBufferCreateInfoNV) },
{VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV, sizeof(VkDedicatedAllocationMemoryAllocateInfoNV) },
{VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, sizeof(VkExternalMemoryImageCreateInfoNV) },
{VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV, sizeof(VkExportMemoryAllocateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV, sizeof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV, sizeof(VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV) },
{VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO, sizeof(VkDevicePrivateDataCreateInfo) },
{VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO, sizeof(VkPrivateDataSlotCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES, sizeof(VkPhysicalDevicePrivateDataFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV, sizeof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT, sizeof(VkPhysicalDeviceMultiDrawPropertiesEXT) },
{VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV, sizeof(VkGraphicsShaderGroupCreateInfoNV) },
{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV, sizeof(VkGraphicsPipelineShaderGroupsCreateInfoNV) },
{VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV, sizeof(VkIndirectCommandsLayoutTokenNV) },
{VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV, sizeof(VkIndirectCommandsLayoutCreateInfoNV) },
{VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV, sizeof(VkGeneratedCommandsInfoNV) },
{VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV, sizeof(VkGeneratedCommandsMemoryRequirementsInfoNV) },
{VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV, sizeof(VkPipelineIndirectDeviceAddressInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, sizeof(VkPhysicalDeviceFeatures2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2, sizeof(VkPhysicalDeviceProperties2) },
{VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2, sizeof(VkFormatProperties2) },
{VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2, sizeof(VkImageFormatProperties2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2, sizeof(VkPhysicalDeviceImageFormatInfo2) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2, sizeof(VkQueueFamilyProperties2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2, sizeof(VkPhysicalDeviceMemoryProperties2) },
{VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2, sizeof(VkSparseImageFormatProperties2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2, sizeof(VkPhysicalDeviceSparseImageFormatInfo2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR, sizeof(VkPhysicalDevicePushDescriptorPropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES, sizeof(VkPhysicalDeviceDriverProperties) },
{VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR, sizeof(VkPresentRegionsKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES, sizeof(VkPhysicalDeviceVariablePointersFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO, sizeof(VkPhysicalDeviceExternalImageFormatInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES, sizeof(VkExternalImageFormatProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO, sizeof(VkPhysicalDeviceExternalBufferInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES, sizeof(VkExternalBufferProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES, sizeof(VkPhysicalDeviceIDProperties) },
{VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, sizeof(VkExternalMemoryImageCreateInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO, sizeof(VkExternalMemoryBufferCreateInfo) },
{VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO, sizeof(VkExportMemoryAllocateInfo) },
{VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR, sizeof(VkImportMemoryFdInfoKHR) },
{VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR, sizeof(VkMemoryFdPropertiesKHR) },
{VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR, sizeof(VkMemoryGetFdInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO, sizeof(VkPhysicalDeviceExternalSemaphoreInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES, sizeof(VkExternalSemaphoreProperties) },
{VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO, sizeof(VkExportSemaphoreCreateInfo) },
{VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR, sizeof(VkImportSemaphoreFdInfoKHR) },
{VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR, sizeof(VkSemaphoreGetFdInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO, sizeof(VkPhysicalDeviceExternalFenceInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES, sizeof(VkExternalFenceProperties) },
{VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO, sizeof(VkExportFenceCreateInfo) },
{VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR, sizeof(VkImportFenceFdInfoKHR) },
{VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR, sizeof(VkFenceGetFdInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES, sizeof(VkPhysicalDeviceMultiviewFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES, sizeof(VkPhysicalDeviceMultiviewProperties) },
{VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO, sizeof(VkRenderPassMultiviewCreateInfo) },
{VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT, sizeof(VkSurfaceCapabilities2EXT) },
{VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT, sizeof(VkDisplayPowerInfoEXT) },
{VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT, sizeof(VkDeviceEventInfoEXT) },
{VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT, sizeof(VkDisplayEventInfoEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT, sizeof(VkSwapchainCounterCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES, sizeof(VkPhysicalDeviceGroupProperties) },
{VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO, sizeof(VkMemoryAllocateFlagsInfo) },
{VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO, sizeof(VkBindBufferMemoryInfo) },
{VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO, sizeof(VkBindBufferMemoryDeviceGroupInfo) },
{VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO, sizeof(VkBindImageMemoryInfo) },
{VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO, sizeof(VkBindImageMemoryDeviceGroupInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO, sizeof(VkDeviceGroupRenderPassBeginInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO, sizeof(VkDeviceGroupCommandBufferBeginInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO, sizeof(VkDeviceGroupSubmitInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO, sizeof(VkDeviceGroupBindSparseInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR, sizeof(VkDeviceGroupPresentCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, sizeof(VkImageSwapchainCreateInfoKHR) },
{VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR, sizeof(VkBindImageMemorySwapchainInfoKHR) },
{VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR, sizeof(VkAcquireNextImageInfoKHR) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR, sizeof(VkDeviceGroupPresentInfoKHR) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO, sizeof(VkDeviceGroupDeviceCreateInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR, sizeof(VkDeviceGroupSwapchainCreateInfoKHR) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO, sizeof(VkDescriptorUpdateTemplateCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR, sizeof(VkPhysicalDevicePresentIdFeaturesKHR) },
{VK_STRUCTURE_TYPE_PRESENT_ID_KHR, sizeof(VkPresentIdKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR, sizeof(VkPhysicalDevicePresentWaitFeaturesKHR) },
{VK_STRUCTURE_TYPE_HDR_METADATA_EXT, sizeof(VkHdrMetadataEXT) },
{VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD, sizeof(VkDisplayNativeHdrSurfaceCapabilitiesAMD) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD, sizeof(VkSwapchainDisplayNativeHdrCreateInfoAMD) },
{VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE, sizeof(VkPresentTimesInfoGOOGLE) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportWScalingStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportSwizzleStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT, sizeof(VkPhysicalDeviceDiscardRectanglePropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT, sizeof(VkPipelineDiscardRectangleStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX, sizeof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) },
{VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO, sizeof(VkRenderPassInputAttachmentAspectCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR, sizeof(VkPhysicalDeviceSurfaceInfo2KHR) },
{VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR, sizeof(VkSurfaceCapabilities2KHR) },
{VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR, sizeof(VkSurfaceFormat2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR, sizeof(VkDisplayProperties2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR, sizeof(VkDisplayPlaneProperties2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR, sizeof(VkDisplayModeProperties2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR, sizeof(VkDisplayPlaneInfo2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR, sizeof(VkDisplayPlaneCapabilities2KHR) },
{VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR, sizeof(VkSharedPresentSurfaceCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES, sizeof(VkPhysicalDevice16BitStorageFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES, sizeof(VkPhysicalDeviceSubgroupProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES, sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures) },
{VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2, sizeof(VkBufferMemoryRequirementsInfo2) },
{VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS, sizeof(VkDeviceBufferMemoryRequirements) },
{VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, sizeof(VkImageMemoryRequirementsInfo2) },
{VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2, sizeof(VkImageSparseMemoryRequirementsInfo2) },
{VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, sizeof(VkDeviceImageMemoryRequirements) },
{VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, sizeof(VkMemoryRequirements2) },
{VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, sizeof(VkSparseImageMemoryRequirements2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES, sizeof(VkPhysicalDevicePointClippingProperties) },
{VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS, sizeof(VkMemoryDedicatedRequirements) },
{VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO, sizeof(VkMemoryDedicatedAllocateInfo) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO, sizeof(VkImageViewUsageCreateInfo) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT, sizeof(VkImageViewSlicedCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO, sizeof(VkPipelineTessellationDomainOriginStateCreateInfo) },
{VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO, sizeof(VkSamplerYcbcrConversionInfo) },
{VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO, sizeof(VkSamplerYcbcrConversionCreateInfo) },
{VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO, sizeof(VkBindImagePlaneMemoryInfo) },
{VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO, sizeof(VkImagePlaneMemoryRequirementsInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES, sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures) },
{VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES, sizeof(VkSamplerYcbcrConversionImageFormatProperties) },
{VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD, sizeof(VkTextureLODGatherFormatPropertiesAMD) },
{VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT, sizeof(VkConditionalRenderingBeginInfoEXT) },
{VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO, sizeof(VkProtectedSubmitInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES, sizeof(VkPhysicalDeviceProtectedMemoryFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES, sizeof(VkPhysicalDeviceProtectedMemoryProperties) },
{VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2, sizeof(VkDeviceQueueInfo2) },
{VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV, sizeof(VkPipelineCoverageToColorStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES, sizeof(VkPhysicalDeviceSamplerFilterMinmaxProperties) },
{VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, sizeof(VkSampleLocationsInfoEXT) },
{VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT, sizeof(VkRenderPassSampleLocationsBeginInfoEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT, sizeof(VkPipelineSampleLocationsStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT, sizeof(VkPhysicalDeviceSampleLocationsPropertiesEXT) },
{VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT, sizeof(VkMultisamplePropertiesEXT) },
{VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO, sizeof(VkSamplerReductionModeCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT, sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT, sizeof(VkPhysicalDeviceMultiDrawFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT, sizeof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT, sizeof(VkPipelineColorBlendAdvancedStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES, sizeof(VkPhysicalDeviceInlineUniformBlockFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES, sizeof(VkPhysicalDeviceInlineUniformBlockProperties) },
{VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK, sizeof(VkWriteDescriptorSetInlineUniformBlock) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO, sizeof(VkDescriptorPoolInlineUniformBlockCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV, sizeof(VkPipelineCoverageModulationStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, sizeof(VkImageFormatListCreateInfo) },
{VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT, sizeof(VkValidationCacheCreateInfoEXT) },
{VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT, sizeof(VkShaderModuleValidationCacheCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES, sizeof(VkPhysicalDeviceMaintenance3Properties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES, sizeof(VkPhysicalDeviceMaintenance4Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES, sizeof(VkPhysicalDeviceMaintenance4Properties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR, sizeof(VkPhysicalDeviceMaintenance5FeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR, sizeof(VkPhysicalDeviceMaintenance5PropertiesKHR) },
{VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR, sizeof(VkRenderingAreaInfoKHR) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT, sizeof(VkDescriptorSetLayoutSupport) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES, sizeof(VkPhysicalDeviceShaderDrawParametersFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES, sizeof(VkPhysicalDeviceShaderFloat16Int8Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES, sizeof(VkPhysicalDeviceFloatControlsProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES, sizeof(VkPhysicalDeviceHostQueryResetFeatures) },
{VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR, sizeof(VkDeviceQueueGlobalPriorityCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR, sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR, sizeof(VkQueueFamilyGlobalPriorityPropertiesKHR) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, sizeof(VkDebugUtilsObjectNameInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT, sizeof(VkDebugUtilsObjectTagInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, sizeof(VkDebugUtilsLabelEXT) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT, sizeof(VkDebugUtilsMessengerCreateInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT, sizeof(VkDebugUtilsMessengerCallbackDataEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT, sizeof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT) },
{VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT, sizeof(VkDeviceDeviceMemoryReportCreateInfoEXT) },
{VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT, sizeof(VkDeviceMemoryReportCallbackDataEXT) },
{VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT, sizeof(VkImportMemoryHostPointerInfoEXT) },
{VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT, sizeof(VkMemoryHostPointerPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT, sizeof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT, sizeof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT) },
{VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT, sizeof(VkCalibratedTimestampInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD, sizeof(VkPhysicalDeviceShaderCorePropertiesAMD) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD, sizeof(VkPhysicalDeviceShaderCoreProperties2AMD) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationConservativeStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES, sizeof(VkPhysicalDeviceDescriptorIndexingFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES, sizeof(VkPhysicalDeviceDescriptorIndexingProperties) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO, sizeof(VkDescriptorSetLayoutBindingFlagsCreateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO, sizeof(VkDescriptorSetVariableDescriptorCountAllocateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT, sizeof(VkDescriptorSetVariableDescriptorCountLayoutSupport) },
{VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, sizeof(VkAttachmentDescription2) },
{VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, sizeof(VkAttachmentReference2) },
{VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, sizeof(VkSubpassDescription2) },
{VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, sizeof(VkSubpassDependency2) },
{VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2, sizeof(VkRenderPassCreateInfo2) },
{VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, sizeof(VkSubpassBeginInfo) },
{VK_STRUCTURE_TYPE_SUBPASS_END_INFO, sizeof(VkSubpassEndInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES, sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES, sizeof(VkPhysicalDeviceTimelineSemaphoreProperties) },
{VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO, sizeof(VkSemaphoreTypeCreateInfo) },
{VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO, sizeof(VkTimelineSemaphoreSubmitInfo) },
{VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO, sizeof(VkSemaphoreWaitInfo) },
{VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO, sizeof(VkSemaphoreSignalInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT, sizeof(VkPipelineVertexInputDivisorStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT, sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT, sizeof(VkPhysicalDevicePCIBusInfoPropertiesEXT) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT, sizeof(VkCommandBufferInheritanceConditionalRenderingInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES, sizeof(VkPhysicalDevice8BitStorageFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT, sizeof(VkPhysicalDeviceConditionalRenderingFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES, sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES, sizeof(VkPhysicalDeviceShaderAtomicInt64Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT, sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV, sizeof(VkQueueFamilyCheckpointPropertiesNV) },
{VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV, sizeof(VkCheckpointDataNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES, sizeof(VkPhysicalDeviceDepthStencilResolveProperties) },
{VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE, sizeof(VkSubpassDescriptionDepthStencilResolve) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT, sizeof(VkImageViewASTCDecodeModeEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT, sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT, sizeof(VkPhysicalDeviceTransformFeedbackFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT, sizeof(VkPhysicalDeviceTransformFeedbackPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationStateStreamCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV, sizeof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV, sizeof(VkPipelineRepresentativeFragmentTestStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV, sizeof(VkPhysicalDeviceExclusiveScissorFeaturesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportExclusiveScissorStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV, sizeof(VkPhysicalDeviceCornerSampledImageFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV, sizeof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV, sizeof(VkPhysicalDeviceShaderImageFootprintFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV, sizeof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV, sizeof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV, sizeof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV, sizeof(VkPhysicalDeviceMemoryDecompressionFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV, sizeof(VkPhysicalDeviceMemoryDecompressionPropertiesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportShadingRateImageStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV, sizeof(VkPhysicalDeviceShadingRateImageFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV, sizeof(VkPhysicalDeviceShadingRateImagePropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI, sizeof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV, sizeof(VkPhysicalDeviceMeshShaderFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV, sizeof(VkPhysicalDeviceMeshShaderPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT, sizeof(VkPhysicalDeviceMeshShaderFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT, sizeof(VkPhysicalDeviceMeshShaderPropertiesEXT) },
{VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV, sizeof(VkRayTracingShaderGroupCreateInfoNV) },
{VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR, sizeof(VkRayTracingShaderGroupCreateInfoKHR) },
{VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV, sizeof(VkRayTracingPipelineCreateInfoNV) },
{VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR, sizeof(VkRayTracingPipelineCreateInfoKHR) },
{VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV, sizeof(VkGeometryTrianglesNV) },
{VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV, sizeof(VkGeometryAABBNV) },
{VK_STRUCTURE_TYPE_GEOMETRY_NV, sizeof(VkGeometryNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV, sizeof(VkAccelerationStructureInfoNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV, sizeof(VkAccelerationStructureCreateInfoNV) },
{VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV, sizeof(VkBindAccelerationStructureMemoryInfoNV) },
{VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR, sizeof(VkWriteDescriptorSetAccelerationStructureKHR) },
{VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV, sizeof(VkWriteDescriptorSetAccelerationStructureNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV, sizeof(VkAccelerationStructureMemoryRequirementsInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR, sizeof(VkPhysicalDeviceAccelerationStructureFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR, sizeof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR, sizeof(VkPhysicalDeviceRayQueryFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR, sizeof(VkPhysicalDeviceAccelerationStructurePropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR, sizeof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV, sizeof(VkPhysicalDeviceRayTracingPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR, sizeof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR) },
{VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT, sizeof(VkDrmFormatModifierPropertiesListEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT, sizeof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, sizeof(VkImageDrmFormatModifierListCreateInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, sizeof(VkImageDrmFormatModifierExplicitCreateInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT, sizeof(VkImageDrmFormatModifierPropertiesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, sizeof(VkImageStencilUsageCreateInfo) },
{VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD, sizeof(VkDeviceMemoryOverallocationCreateInfoAMD) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT, sizeof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT, sizeof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM, sizeof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT, sizeof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT, sizeof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM, sizeof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM) },
{VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT, sizeof(VkRenderPassFragmentDensityMapCreateInfoEXT) },
{VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM, sizeof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES, sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures) },
{VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR, sizeof(VkSurfaceProtectedCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES, sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT, sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationDepthClipStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT, sizeof(VkPhysicalDeviceMemoryBudgetPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT, sizeof(VkPhysicalDeviceMemoryPriorityFeaturesEXT) },
{VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT, sizeof(VkMemoryPriorityAllocateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT, sizeof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES, sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT, sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT) },
{VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, sizeof(VkBufferDeviceAddressInfo) },
{VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO, sizeof(VkBufferOpaqueCaptureAddressCreateInfo) },
{VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT, sizeof(VkBufferDeviceAddressCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT, sizeof(VkPhysicalDeviceImageViewImageFormatInfoEXT) },
{VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT, sizeof(VkFilterCubicImageViewImageFormatPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES, sizeof(VkPhysicalDeviceImagelessFramebufferFeatures) },
{VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO, sizeof(VkFramebufferAttachmentsCreateInfo) },
{VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO, sizeof(VkFramebufferAttachmentImageInfo) },
{VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO, sizeof(VkRenderPassAttachmentBeginInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES, sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV, sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV, sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesNV) },
{VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV, sizeof(VkCooperativeMatrixPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT, sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX, sizeof(VkImageViewHandleInfoNVX) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX, sizeof(VkImageViewAddressPropertiesNVX) },
{VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO, sizeof(VkPipelineCreationFeedbackCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV, sizeof(VkPhysicalDevicePresentBarrierFeaturesNV) },
{VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV, sizeof(VkSurfaceCapabilitiesPresentBarrierNV) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV, sizeof(VkSwapchainPresentBarrierCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR, sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR, sizeof(VkPhysicalDevicePerformanceQueryPropertiesKHR) },
{VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR, sizeof(VkPerformanceCounterKHR) },
{VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR, sizeof(VkPerformanceCounterDescriptionKHR) },
{VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR, sizeof(VkQueryPoolPerformanceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR, sizeof(VkAcquireProfilingLockInfoKHR) },
{VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR, sizeof(VkPerformanceQuerySubmitInfoKHR) },
{VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, sizeof(VkHeadlessSurfaceCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV, sizeof(VkPhysicalDeviceCoverageReductionModeFeaturesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV, sizeof(VkPipelineCoverageReductionStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV, sizeof(VkFramebufferMixedSamplesCombinationNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL, sizeof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) },
{VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL, sizeof(VkInitializePerformanceApiInfoINTEL) },
{VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL, sizeof(VkQueryPoolPerformanceQueryCreateInfoINTEL) },
{VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL, sizeof(VkPerformanceMarkerInfoINTEL) },
{VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL, sizeof(VkPerformanceStreamMarkerInfoINTEL) },
{VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL, sizeof(VkPerformanceOverrideInfoINTEL) },
{VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL, sizeof(VkPerformanceConfigurationAcquireInfoINTEL) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR, sizeof(VkPhysicalDeviceShaderClockFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT, sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV, sizeof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV, sizeof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT, sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES, sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures) },
{VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT, sizeof(VkAttachmentReferenceStencilLayout) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT, sizeof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT) },
{VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT, sizeof(VkAttachmentDescriptionStencilLayout) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR, sizeof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR, sizeof(VkPipelineInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR, sizeof(VkPipelineExecutablePropertiesKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR, sizeof(VkPipelineExecutableInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR, sizeof(VkPipelineExecutableStatisticKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR, sizeof(VkPipelineExecutableInternalRepresentationKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES, sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT, sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES, sizeof(VkPhysicalDeviceTexelBufferAlignmentProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES, sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES, sizeof(VkPhysicalDeviceSubgroupSizeControlProperties) },
{VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO, sizeof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo) },
{VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI, sizeof(VkSubpassShadingPipelineCreateInfoHUAWEI) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI, sizeof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI, sizeof(VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI) },
{VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO, sizeof(VkMemoryOpaqueCaptureAddressAllocateInfo) },
{VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO, sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT, sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT, sizeof(VkPhysicalDeviceLineRasterizationPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationLineStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES, sizeof(VkPhysicalDevicePipelineCreationCacheControlFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES, sizeof(VkPhysicalDeviceVulkan11Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES, sizeof(VkPhysicalDeviceVulkan11Properties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES, sizeof(VkPhysicalDeviceVulkan12Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES, sizeof(VkPhysicalDeviceVulkan12Properties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES, sizeof(VkPhysicalDeviceVulkan13Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES, sizeof(VkPhysicalDeviceVulkan13Properties) },
{VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD, sizeof(VkPipelineCompilerControlCreateInfoAMD) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD, sizeof(VkPhysicalDeviceCoherentMemoryFeaturesAMD) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES, sizeof(VkPhysicalDeviceToolProperties) },
{VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT, sizeof(VkSamplerCustomBorderColorCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT, sizeof(VkPhysicalDeviceCustomBorderColorPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT, sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT) },
{VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT, sizeof(VkSamplerBorderColorComponentMappingCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT, sizeof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR, sizeof(VkAccelerationStructureGeometryTrianglesDataKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR, sizeof(VkAccelerationStructureGeometryAabbsDataKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR, sizeof(VkAccelerationStructureGeometryInstancesDataKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, sizeof(VkAccelerationStructureGeometryKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, sizeof(VkAccelerationStructureBuildGeometryInfoKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR, sizeof(VkAccelerationStructureCreateInfoKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR, sizeof(VkAccelerationStructureDeviceAddressInfoKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR, sizeof(VkAccelerationStructureVersionInfoKHR) },
{VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR, sizeof(VkCopyAccelerationStructureInfoKHR) },
{VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR, sizeof(VkCopyAccelerationStructureToMemoryInfoKHR) },
{VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR, sizeof(VkCopyMemoryToAccelerationStructureInfoKHR) },
{VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR, sizeof(VkRayTracingPipelineInterfaceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR, sizeof(VkPipelineLibraryCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT, sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT, sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT, sizeof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT, sizeof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT) },
{VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM, sizeof(VkRenderPassTransformBeginInfoQCOM) },
{VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM, sizeof(VkCopyCommandTransformInfoQCOM) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM, sizeof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV, sizeof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV) },
{VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV, sizeof(VkDeviceDiagnosticsConfigCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES, sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR, sizeof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT, sizeof(VkPhysicalDeviceRobustness2FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT, sizeof(VkPhysicalDeviceRobustness2PropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES, sizeof(VkPhysicalDeviceImageRobustnessFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR, sizeof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT, sizeof(VkPhysicalDevice4444FormatsFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI, sizeof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI, sizeof(VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI) },
{VK_STRUCTURE_TYPE_BUFFER_COPY_2, sizeof(VkBufferCopy2) },
{VK_STRUCTURE_TYPE_IMAGE_COPY_2, sizeof(VkImageCopy2) },
{VK_STRUCTURE_TYPE_IMAGE_BLIT_2, sizeof(VkImageBlit2) },
{VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, sizeof(VkBufferImageCopy2) },
{VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2, sizeof(VkImageResolve2) },
{VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2, sizeof(VkCopyBufferInfo2) },
{VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2, sizeof(VkCopyImageInfo2) },
{VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2, sizeof(VkBlitImageInfo2) },
{VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2, sizeof(VkCopyBufferToImageInfo2) },
{VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2, sizeof(VkCopyImageToBufferInfo2) },
{VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2, sizeof(VkResolveImageInfo2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT) },
{VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR, sizeof(VkFragmentShadingRateAttachmentInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR, sizeof(VkPipelineFragmentShadingRateStateCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR, sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR, sizeof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR, sizeof(VkPhysicalDeviceFragmentShadingRateKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES, sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV, sizeof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV, sizeof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV, sizeof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR, sizeof(VkAccelerationStructureBuildSizesInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT, sizeof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT, sizeof(VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT, sizeof(VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT, sizeof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT) },
{VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT, sizeof(VkMutableDescriptorTypeCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT, sizeof(VkPhysicalDeviceDepthClipControlFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT, sizeof(VkPipelineViewportDepthClipControlCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT, sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV, sizeof(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV) },
{VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT, sizeof(VkVertexInputBindingDescription2EXT) },
{VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT, sizeof(VkVertexInputAttributeDescription2EXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT, sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT, sizeof(VkPipelineColorWriteCreateInfoEXT) },
{VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, sizeof(VkMemoryBarrier2) },
{VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, sizeof(VkImageMemoryBarrier2) },
{VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, sizeof(VkBufferMemoryBarrier2) },
{VK_STRUCTURE_TYPE_DEPENDENCY_INFO, sizeof(VkDependencyInfo) },
{VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, sizeof(VkSemaphoreSubmitInfo) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO, sizeof(VkCommandBufferSubmitInfo) },
{VK_STRUCTURE_TYPE_SUBMIT_INFO_2, sizeof(VkSubmitInfo2) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV, sizeof(VkQueueFamilyCheckpointProperties2NV) },
{VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV, sizeof(VkCheckpointData2NV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES, sizeof(VkPhysicalDeviceSynchronization2Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT, sizeof(VkPhysicalDeviceHostImageCopyFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT, sizeof(VkPhysicalDeviceHostImageCopyPropertiesEXT) },
{VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT, sizeof(VkMemoryToImageCopyEXT) },
{VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT, sizeof(VkImageToMemoryCopyEXT) },
{VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT, sizeof(VkCopyMemoryToImageInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT, sizeof(VkCopyImageToMemoryInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT, sizeof(VkCopyImageToImageInfoEXT) },
{VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT, sizeof(VkHostImageLayoutTransitionInfoEXT) },
{VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT, sizeof(VkSubresourceHostMemcpySizeEXT) },
{VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT, sizeof(VkHostImageCopyDevicePerformanceQueryEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT, sizeof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT, sizeof(VkPhysicalDeviceLegacyDitheringFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT, sizeof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT) },
{VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT, sizeof(VkSubpassResolvePerformanceQueryEXT) },
{VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT, sizeof(VkMultisampledRenderToSingleSampledInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT, sizeof(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR, sizeof(VkQueueFamilyVideoPropertiesKHR) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR, sizeof(VkQueueFamilyQueryResultStatusPropertiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR, sizeof(VkVideoProfileListInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR, sizeof(VkPhysicalDeviceVideoFormatInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR, sizeof(VkVideoFormatPropertiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, sizeof(VkVideoProfileInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR, sizeof(VkVideoCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR, sizeof(VkVideoSessionMemoryRequirementsKHR) },
{VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR, sizeof(VkBindVideoSessionMemoryInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, sizeof(VkVideoPictureResourceInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, sizeof(VkVideoReferenceSlotInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR, sizeof(VkVideoDecodeCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR, sizeof(VkVideoDecodeUsageInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR, sizeof(VkVideoDecodeInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR, sizeof(VkVideoDecodeH264ProfileInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR, sizeof(VkVideoDecodeH264CapabilitiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR, sizeof(VkVideoDecodeH264SessionParametersAddInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR, sizeof(VkVideoDecodeH264SessionParametersCreateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR, sizeof(VkVideoDecodeH264PictureInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR, sizeof(VkVideoDecodeH264DpbSlotInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR, sizeof(VkVideoDecodeH265ProfileInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR, sizeof(VkVideoDecodeH265CapabilitiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR, sizeof(VkVideoDecodeH265SessionParametersAddInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR, sizeof(VkVideoDecodeH265SessionParametersCreateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR, sizeof(VkVideoDecodeH265PictureInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, sizeof(VkVideoDecodeH265DpbSlotInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR, sizeof(VkVideoSessionCreateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR, sizeof(VkVideoSessionParametersCreateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR, sizeof(VkVideoSessionParametersUpdateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR, sizeof(VkVideoBeginCodingInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR, sizeof(VkVideoEndCodingInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR, sizeof(VkVideoCodingControlInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV, sizeof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV, sizeof(VkCommandBufferInheritanceViewportScissorInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT, sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT, sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT, sizeof(VkPhysicalDeviceProvokingVertexPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX, sizeof(VkCuModuleCreateInfoNVX) },
{VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX, sizeof(VkCuFunctionCreateInfoNVX) },
{VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX, sizeof(VkCuLaunchInfoNVX) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT, sizeof(VkPhysicalDeviceDescriptorBufferFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT, sizeof(VkPhysicalDeviceDescriptorBufferPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT, sizeof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT, sizeof(VkDescriptorAddressInfoEXT) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT, sizeof(VkDescriptorBufferBindingInfoEXT) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT, sizeof(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT, sizeof(VkDescriptorGetInfoEXT) },
{VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkBufferCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkImageCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkImageViewCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkSamplerCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkAccelerationStructureCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, sizeof(VkOpaqueCaptureDescriptorDataCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES, sizeof(VkPhysicalDeviceShaderIntegerDotProductFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES, sizeof(VkPhysicalDeviceShaderIntegerDotProductProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT, sizeof(VkPhysicalDeviceDrmPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR, sizeof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR, sizeof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV, sizeof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV, sizeof(VkAccelerationStructureGeometryMotionTrianglesDataNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV, sizeof(VkAccelerationStructureMotionInfoNV) },
{VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV, sizeof(VkMemoryGetRemoteAddressInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT, sizeof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT) },
{VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3, sizeof(VkFormatProperties3) },
{VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT, sizeof(VkDrmFormatModifierPropertiesList2EXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO, sizeof(VkPipelineRenderingCreateInfo) },
{VK_STRUCTURE_TYPE_RENDERING_INFO, sizeof(VkRenderingInfo) },
{VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, sizeof(VkRenderingAttachmentInfo) },
{VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR, sizeof(VkRenderingFragmentShadingRateAttachmentInfoKHR) },
{VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT, sizeof(VkRenderingFragmentDensityMapAttachmentInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES, sizeof(VkPhysicalDeviceDynamicRenderingFeatures) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO, sizeof(VkCommandBufferInheritanceRenderingInfo) },
{VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD, sizeof(VkAttachmentSampleCountInfoAMD) },
{VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX, sizeof(VkMultiviewPerViewAttributesInfoNVX) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT, sizeof(VkPhysicalDeviceImageViewMinLodFeaturesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT, sizeof(VkImageViewMinLodCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT, sizeof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV, sizeof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT, sizeof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT, sizeof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT) },
{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT, sizeof(VkGraphicsPipelineLibraryCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE, sizeof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE, sizeof(VkDescriptorSetBindingReferenceVALVE) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE, sizeof(VkDescriptorSetLayoutHostMappingInfoVALVE) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT, sizeof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT, sizeof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT) },
{VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT, sizeof(VkShaderModuleIdentifierEXT) },
{VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, sizeof(VkImageCompressionControlEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT, sizeof(VkPhysicalDeviceImageCompressionControlFeaturesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT, sizeof(VkImageCompressionPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT, sizeof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR, sizeof(VkImageSubresource2KHR) },
{VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, sizeof(VkSubresourceLayout2KHR) },
{VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT, sizeof(VkRenderPassCreationControlEXT) },
{VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT, sizeof(VkRenderPassCreationFeedbackCreateInfoEXT) },
{VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT, sizeof(VkRenderPassSubpassFeedbackCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT, sizeof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT) },
{VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, sizeof(VkMicromapBuildInfoEXT) },
{VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT, sizeof(VkMicromapCreateInfoEXT) },
{VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT, sizeof(VkMicromapVersionInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT, sizeof(VkCopyMicromapInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT, sizeof(VkCopyMicromapToMemoryInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT, sizeof(VkCopyMemoryToMicromapInfoEXT) },
{VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT, sizeof(VkMicromapBuildSizesInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT, sizeof(VkPhysicalDeviceOpacityMicromapFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT, sizeof(VkPhysicalDeviceOpacityMicromapPropertiesEXT) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT, sizeof(VkAccelerationStructureTrianglesOpacityMicromapEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT, sizeof(VkPipelinePropertiesIdentifierEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT, sizeof(VkPhysicalDevicePipelinePropertiesFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD, sizeof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD) },
{VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, sizeof(VkExternalMemoryAcquireUnmodifiedEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT, sizeof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT, sizeof(VkPhysicalDevicePipelineRobustnessFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT, sizeof(VkPipelineRobustnessCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT, sizeof(VkPhysicalDevicePipelineRobustnessPropertiesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM, sizeof(VkImageViewSampleWeightCreateInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM, sizeof(VkPhysicalDeviceImageProcessingFeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM, sizeof(VkPhysicalDeviceImageProcessingPropertiesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM, sizeof(VkPhysicalDeviceTilePropertiesFeaturesQCOM) },
{VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, sizeof(VkTilePropertiesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC, sizeof(VkPhysicalDeviceAmigoProfilingFeaturesSEC) },
{VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC, sizeof(VkAmigoProfilingSubmitInfoSEC) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT, sizeof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT, sizeof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT, sizeof(VkPhysicalDeviceAddressBindingReportFeaturesEXT) },
{VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT, sizeof(VkDeviceAddressBindingCallbackDataEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV, sizeof(VkPhysicalDeviceOpticalFlowFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV, sizeof(VkPhysicalDeviceOpticalFlowPropertiesNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, sizeof(VkOpticalFlowImageFormatInfoNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV, sizeof(VkOpticalFlowImageFormatPropertiesNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV, sizeof(VkOpticalFlowSessionCreateInfoNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV, sizeof(VkOpticalFlowSessionCreatePrivateDataInfoNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV, sizeof(VkOpticalFlowExecuteInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT, sizeof(VkPhysicalDeviceFaultFeaturesEXT) },
{VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT, sizeof(VkDeviceFaultCountsEXT) },
{VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT, sizeof(VkDeviceFaultInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT, sizeof(VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT) },
{VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT, sizeof(VkDepthBiasInfoEXT) },
{VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT, sizeof(VkDepthBiasRepresentationInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM, sizeof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM, sizeof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM) },
{VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT, sizeof(VkFrameBoundaryEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT, sizeof(VkPhysicalDeviceFrameBoundaryFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT, sizeof(VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT) },
{VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT, sizeof(VkSurfacePresentModeEXT) },
{VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT, sizeof(VkSurfacePresentScalingCapabilitiesEXT) },
{VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT, sizeof(VkSurfacePresentModeCompatibilityEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT, sizeof(VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT, sizeof(VkSwapchainPresentFenceInfoEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT, sizeof(VkSwapchainPresentModesCreateInfoEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT, sizeof(VkSwapchainPresentModeInfoEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT, sizeof(VkSwapchainPresentScalingCreateInfoEXT) },
{VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT, sizeof(VkReleaseSwapchainImagesInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT, sizeof(VkPhysicalDeviceDepthBiasControlFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV, sizeof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV, sizeof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV) },
{VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG, sizeof(VkDirectDriverLoadingInfoLUNARG) },
{VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG, sizeof(VkDirectDriverLoadingListLUNARG) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM, sizeof(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR, sizeof(VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR) },
{VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR, sizeof(VkDeviceImageSubresourceInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM, sizeof(VkPhysicalDeviceShaderCorePropertiesARM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM, sizeof(VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM) },
{VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM, sizeof(VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM) },
{VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV, sizeof(VkQueryLowLatencySupportNV) },
{VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR, sizeof(VkMemoryMapInfoKHR) },
{VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR, sizeof(VkMemoryUnmapInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderObjectFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT, sizeof(VkPhysicalDeviceShaderObjectPropertiesEXT) },
{VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT, sizeof(VkShaderCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderTileImageFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT, sizeof(VkPhysicalDeviceShaderTileImagePropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR, sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesKHR) },
{VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR, sizeof(VkCooperativeMatrixPropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR, sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM, sizeof(VkPhysicalDeviceCubicClampFeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM, sizeof(VkPhysicalDeviceYcbcrDegammaFeaturesQCOM) },
{VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM, sizeof(VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM, sizeof(VkPhysicalDeviceCubicWeightsFeaturesQCOM) },
{VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM, sizeof(VkSamplerCubicWeightsCreateInfoQCOM) },
{VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM, sizeof(VkBlitImageCubicWeightsInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM, sizeof(VkPhysicalDeviceImageProcessing2FeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM, sizeof(VkPhysicalDeviceImageProcessing2PropertiesQCOM) },
{VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM, sizeof(VkSamplerBlockMatchWindowCreateInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV, sizeof(VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT, sizeof(VkPhysicalDeviceLayeredDriverPropertiesMSFT) },
};

void* memdup(const void* mem, size_t size) { 
   void* out = malloc(size);

   if(out != NULL)
       memcpy(out, mem, size);

   return out;
}


void* copyVkStruct (const void* data){
    auto curr=data;
    while (true){
        if (curr==NULL){
        return NULL;
        }
        auto structure_type=((StreamStructure*)curr)->sType;
        if (!structure_type_to_size.contains(structure_type)){
            curr=((StreamStructure*)curr)->pNext;
            continue;
        }
        
        auto struct_size=structure_type_to_size[structure_type];
        auto result=memdup(curr, struct_size);
        
        return result;
    }
    
}


    void serialize_struct(boost::json::object& json, const VkBaseOutStructure& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            if (member.pNext==NULL){
                pNext_json=boost::json::array();
            return; }pNext_json=boost::json::array(1);
        auto& arr_jFqDlbO=pNext_json.as_array();
        for(int WzFtmOV=0; WzFtmOV < 1; WzFtmOV++){
            [&](){
            auto& temp=arr_jFqDlbO[WzFtmOV].emplace_object();
            return serialize_struct(temp, member.pNext[WzFtmOV]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkBaseOutStructure& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            if (pNext_json.as_array().size()==0){
                member.pNext=NULL;
            return; }member.pNext=(VkBaseOutStructure*)malloc(1*sizeof(VkBaseOutStructure));
        auto& arr_jFqDlbO=pNext_json.as_array();
        for(int WzFtmOV=0; WzFtmOV < 1; WzFtmOV++){
            [&](){
            auto& temp=arr_jFqDlbO[WzFtmOV].as_object();
            deserialize_struct(temp,member.pNext[WzFtmOV]);
            }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkBaseInStructure& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            if (member.pNext==NULL){
                pNext_json=boost::json::array();
            return; }pNext_json=boost::json::array(1);
        auto& arr_iGEwXrX=pNext_json.as_array();
        for(int zdqWKMj=0; zdqWKMj < 1; zdqWKMj++){
            [&](){
            auto& temp=arr_iGEwXrX[zdqWKMj].emplace_object();
            return serialize_struct(temp, member.pNext[zdqWKMj]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkBaseInStructure& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ struct VkBaseInStructure* temp_xDlUMAh;;[&](){
            if (pNext_json.as_array().size()==0){
                temp_xDlUMAh=NULL;
            return; }temp_xDlUMAh=(VkBaseInStructure*)malloc(1*sizeof(VkBaseInStructure));
        auto& arr_zNZknhB=pNext_json.as_array();
        for(int kHwtBcg=0; kHwtBcg < 1; kHwtBcg++){
            [&](){
            auto& temp=arr_zNZknhB[kHwtBcg].as_object();
            deserialize_struct(temp,temp_xDlUMAh[kHwtBcg]);
            }();
        }
        }();member.pNext=temp_xDlUMAh;}();
}

    void serialize_struct(boost::json::object& json, const VkOffset2D& member){
        
    
auto& x_json=json["x"];
[&](){x_json=member.x;}();
auto& y_json=json["y"];
[&](){y_json=member.y;}();
}
void deserialize_struct(boost::json::object& json, VkOffset2D& member){
auto& x_json=json["x"];
[&](){member.x=static_cast<int32_t>(value_to<int>(x_json));}();
auto& y_json=json["y"];
[&](){member.y=static_cast<int32_t>(value_to<int>(y_json));}();
}

    void serialize_struct(boost::json::object& json, const VkOffset3D& member){
        
    
auto& x_json=json["x"];
[&](){x_json=member.x;}();
auto& y_json=json["y"];
[&](){y_json=member.y;}();
auto& z_json=json["z"];
[&](){z_json=member.z;}();
}
void deserialize_struct(boost::json::object& json, VkOffset3D& member){
auto& x_json=json["x"];
[&](){member.x=static_cast<int32_t>(value_to<int>(x_json));}();
auto& y_json=json["y"];
[&](){member.y=static_cast<int32_t>(value_to<int>(y_json));}();
auto& z_json=json["z"];
[&](){member.z=static_cast<int32_t>(value_to<int>(z_json));}();
}

    void serialize_struct(boost::json::object& json, const VkExtent2D& member){
        
    
auto& width_json=json["width"];
[&](){width_json=member.width;}();
auto& height_json=json["height"];
[&](){height_json=member.height;}();
}
void deserialize_struct(boost::json::object& json, VkExtent2D& member){
auto& width_json=json["width"];
[&](){member.width=static_cast<uint32_t>(value_to<int>(width_json));}();
auto& height_json=json["height"];
[&](){member.height=static_cast<uint32_t>(value_to<int>(height_json));}();
}

    void serialize_struct(boost::json::object& json, const VkExtent3D& member){
        
    
auto& width_json=json["width"];
[&](){width_json=member.width;}();
auto& height_json=json["height"];
[&](){height_json=member.height;}();
auto& depth_json=json["depth"];
[&](){depth_json=member.depth;}();
}
void deserialize_struct(boost::json::object& json, VkExtent3D& member){
auto& width_json=json["width"];
[&](){member.width=static_cast<uint32_t>(value_to<int>(width_json));}();
auto& height_json=json["height"];
[&](){member.height=static_cast<uint32_t>(value_to<int>(height_json));}();
auto& depth_json=json["depth"];
[&](){member.depth=static_cast<uint32_t>(value_to<int>(depth_json));}();
}

    void serialize_struct(boost::json::object& json, const VkViewport& member){
        
    
auto& x_json=json["x"];
[&](){x_json=member.x;}();
auto& y_json=json["y"];
[&](){y_json=member.y;}();
auto& width_json=json["width"];
[&](){width_json=member.width;}();
auto& height_json=json["height"];
[&](){height_json=member.height;}();
auto& minDepth_json=json["minDepth"];
[&](){minDepth_json=member.minDepth;}();
auto& maxDepth_json=json["maxDepth"];
[&](){maxDepth_json=member.maxDepth;}();
}
void deserialize_struct(boost::json::object& json, VkViewport& member){
auto& x_json=json["x"];
[&](){member.x=static_cast<float>(value_to<int>(x_json));}();
auto& y_json=json["y"];
[&](){member.y=static_cast<float>(value_to<int>(y_json));}();
auto& width_json=json["width"];
[&](){member.width=static_cast<float>(value_to<int>(width_json));}();
auto& height_json=json["height"];
[&](){member.height=static_cast<float>(value_to<int>(height_json));}();
auto& minDepth_json=json["minDepth"];
[&](){member.minDepth=static_cast<float>(value_to<int>(minDepth_json));}();
auto& maxDepth_json=json["maxDepth"];
[&](){member.maxDepth=static_cast<float>(value_to<int>(maxDepth_json));}();
}

    void serialize_struct(boost::json::object& json, const VkRect2D& member){
        
    
auto& offset_json=json["offset"];
[&](){
            auto& temp=offset_json.emplace_object();
            return serialize_struct(temp, member.offset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.emplace_object();
            return serialize_struct(temp, member.extent);
            }();
}
void deserialize_struct(boost::json::object& json, VkRect2D& member){
auto& offset_json=json["offset"];
[&](){
            auto& temp=offset_json.as_object();
            deserialize_struct(temp,member.offset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.as_object();
            deserialize_struct(temp,member.extent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkClearRect& member){
        
    
auto& rect_json=json["rect"];
[&](){
            auto& temp=rect_json.emplace_object();
            return serialize_struct(temp, member.rect);
            }();
auto& baseArrayLayer_json=json["baseArrayLayer"];
[&](){baseArrayLayer_json=member.baseArrayLayer;}();
auto& layerCount_json=json["layerCount"];
[&](){layerCount_json=member.layerCount;}();
}
void deserialize_struct(boost::json::object& json, VkClearRect& member){
auto& rect_json=json["rect"];
[&](){
            auto& temp=rect_json.as_object();
            deserialize_struct(temp,member.rect);
            }();
auto& baseArrayLayer_json=json["baseArrayLayer"];
[&](){member.baseArrayLayer=static_cast<uint32_t>(value_to<int>(baseArrayLayer_json));}();
auto& layerCount_json=json["layerCount"];
[&](){member.layerCount=static_cast<uint32_t>(value_to<int>(layerCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkComponentMapping& member){
        
    
auto& r_json=json["r"];
[&](){[&](){[&](){r_json=member.r;}();}();}();
auto& g_json=json["g"];
[&](){[&](){[&](){g_json=member.g;}();}();}();
auto& b_json=json["b"];
[&](){[&](){[&](){b_json=member.b;}();}();}();
auto& a_json=json["a"];
[&](){[&](){[&](){a_json=member.a;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkComponentMapping& member){
auto& r_json=json["r"];
[&](){[&](){int temp_HvLnZMS;[&](){temp_HvLnZMS=static_cast<int>(value_to<int>(r_json));}();member.r=(VkComponentSwizzle)temp_HvLnZMS;}();}();
auto& g_json=json["g"];
[&](){[&](){int temp_JgGZCRw;[&](){temp_JgGZCRw=static_cast<int>(value_to<int>(g_json));}();member.g=(VkComponentSwizzle)temp_JgGZCRw;}();}();
auto& b_json=json["b"];
[&](){[&](){int temp_spxtiNB;[&](){temp_spxtiNB=static_cast<int>(value_to<int>(b_json));}();member.b=(VkComponentSwizzle)temp_spxtiNB;}();}();
auto& a_json=json["a"];
[&](){[&](){int temp_cnKUBjo;[&](){temp_cnKUBjo=static_cast<int>(value_to<int>(a_json));}();member.a=(VkComponentSwizzle)temp_cnKUBjo;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceProperties& member){
        
    
auto& apiVersion_json=json["apiVersion"];
[&](){apiVersion_json=member.apiVersion;}();
auto& driverVersion_json=json["driverVersion"];
[&](){driverVersion_json=member.driverVersion;}();
auto& vendorID_json=json["vendorID"];
[&](){vendorID_json=member.vendorID;}();
auto& deviceID_json=json["deviceID"];
[&](){deviceID_json=member.deviceID;}();
auto& deviceType_json=json["deviceType"];
[&](){[&](){[&](){deviceType_json=member.deviceType;}();}();}();
auto& deviceName_json=json["deviceName"];
[&](){deviceName_json=boost::json::array(VK_MAX_PHYSICAL_DEVICE_NAME_SIZE);
        auto& arr_tuuAjSF=deviceName_json.as_array();
        for(int VhmOmiG=0; VhmOmiG < VK_MAX_PHYSICAL_DEVICE_NAME_SIZE; VhmOmiG++){
            [&](){arr_tuuAjSF[VhmOmiG]=member.deviceName[VhmOmiG];}();
        }
        }();
auto& pipelineCacheUUID_json=json["pipelineCacheUUID"];
[&](){pipelineCacheUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_nLZmyOs=pipelineCacheUUID_json.as_array();
        for(int tnNOYvF=0; tnNOYvF < VK_UUID_SIZE; tnNOYvF++){
            [&](){arr_nLZmyOs[tnNOYvF]=member.pipelineCacheUUID[tnNOYvF];}();
        }
        }();
auto& limits_json=json["limits"];
[&](){
            auto& temp=limits_json.emplace_object();
            return serialize_struct(temp, member.limits);
            }();
auto& sparseProperties_json=json["sparseProperties"];
[&](){
            auto& temp=sparseProperties_json.emplace_object();
            return serialize_struct(temp, member.sparseProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceProperties& member){
auto& apiVersion_json=json["apiVersion"];
[&](){member.apiVersion=static_cast<uint32_t>(value_to<int>(apiVersion_json));}();
auto& driverVersion_json=json["driverVersion"];
[&](){member.driverVersion=static_cast<uint32_t>(value_to<int>(driverVersion_json));}();
auto& vendorID_json=json["vendorID"];
[&](){member.vendorID=static_cast<uint32_t>(value_to<int>(vendorID_json));}();
auto& deviceID_json=json["deviceID"];
[&](){member.deviceID=static_cast<uint32_t>(value_to<int>(deviceID_json));}();
auto& deviceType_json=json["deviceType"];
[&](){[&](){int temp_iuBXrhf;[&](){temp_iuBXrhf=static_cast<int>(value_to<int>(deviceType_json));}();member.deviceType=(VkPhysicalDeviceType)temp_iuBXrhf;}();}();
auto& deviceName_json=json["deviceName"];
[&](){
        auto& arr_tuuAjSF=deviceName_json.as_array();
        for(int VhmOmiG=0; VhmOmiG < VK_MAX_PHYSICAL_DEVICE_NAME_SIZE; VhmOmiG++){
            [&](){member.deviceName[VhmOmiG]=static_cast<char>(value_to<int>(arr_tuuAjSF[VhmOmiG]));}();
        }
        }();
auto& pipelineCacheUUID_json=json["pipelineCacheUUID"];
[&](){
        auto& arr_nLZmyOs=pipelineCacheUUID_json.as_array();
        for(int tnNOYvF=0; tnNOYvF < VK_UUID_SIZE; tnNOYvF++){
            [&](){member.pipelineCacheUUID[tnNOYvF]=static_cast<uint8_t>(value_to<int>(arr_nLZmyOs[tnNOYvF]));}();
        }
        }();
auto& limits_json=json["limits"];
[&](){
            auto& temp=limits_json.as_object();
            deserialize_struct(temp,member.limits);
            }();
auto& sparseProperties_json=json["sparseProperties"];
[&](){
            auto& temp=sparseProperties_json.as_object();
            deserialize_struct(temp,member.sparseProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkExtensionProperties& member){
        
    
auto& extensionName_json=json["extensionName"];
[&](){extensionName_json=boost::json::array(VK_MAX_EXTENSION_NAME_SIZE);
        auto& arr_HbZAuVY=extensionName_json.as_array();
        for(int QYXuVZG=0; QYXuVZG < VK_MAX_EXTENSION_NAME_SIZE; QYXuVZG++){
            [&](){arr_HbZAuVY[QYXuVZG]=member.extensionName[QYXuVZG];}();
        }
        }();
auto& specVersion_json=json["specVersion"];
[&](){specVersion_json=member.specVersion;}();
}
void deserialize_struct(boost::json::object& json, VkExtensionProperties& member){
auto& extensionName_json=json["extensionName"];
[&](){
        auto& arr_HbZAuVY=extensionName_json.as_array();
        for(int QYXuVZG=0; QYXuVZG < VK_MAX_EXTENSION_NAME_SIZE; QYXuVZG++){
            [&](){member.extensionName[QYXuVZG]=static_cast<char>(value_to<int>(arr_HbZAuVY[QYXuVZG]));}();
        }
        }();
auto& specVersion_json=json["specVersion"];
[&](){member.specVersion=static_cast<uint32_t>(value_to<int>(specVersion_json));}();
}

    void serialize_struct(boost::json::object& json, const VkLayerProperties& member){
        
    
auto& layerName_json=json["layerName"];
[&](){layerName_json=boost::json::array(VK_MAX_EXTENSION_NAME_SIZE);
        auto& arr_oWHRLFW=layerName_json.as_array();
        for(int xlfEifc=0; xlfEifc < VK_MAX_EXTENSION_NAME_SIZE; xlfEifc++){
            [&](){arr_oWHRLFW[xlfEifc]=member.layerName[xlfEifc];}();
        }
        }();
auto& specVersion_json=json["specVersion"];
[&](){specVersion_json=member.specVersion;}();
auto& implementationVersion_json=json["implementationVersion"];
[&](){implementationVersion_json=member.implementationVersion;}();
auto& description_json=json["description"];
[&](){description_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){arr_XKStCoi[xOHuflK]=member.description[xOHuflK];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkLayerProperties& member){
auto& layerName_json=json["layerName"];
[&](){
        auto& arr_oWHRLFW=layerName_json.as_array();
        for(int xlfEifc=0; xlfEifc < VK_MAX_EXTENSION_NAME_SIZE; xlfEifc++){
            [&](){member.layerName[xlfEifc]=static_cast<char>(value_to<int>(arr_oWHRLFW[xlfEifc]));}();
        }
        }();
auto& specVersion_json=json["specVersion"];
[&](){member.specVersion=static_cast<uint32_t>(value_to<int>(specVersion_json));}();
auto& implementationVersion_json=json["implementationVersion"];
[&](){member.implementationVersion=static_cast<uint32_t>(value_to<int>(implementationVersion_json));}();
auto& description_json=json["description"];
[&](){
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){member.description[xOHuflK]=static_cast<char>(value_to<int>(arr_XKStCoi[xOHuflK]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkApplicationInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pApplicationName_json=json["pApplicationName"];
[&](){
            if (member.pApplicationName==NULL){
                pApplicationName_json=boost::json::array();
            return; }pApplicationName_json=boost::json::array(strlen(member.pApplicationName)+1);
        auto& arr_CeSclhO=pApplicationName_json.as_array();
        for(int orjtDoi=0; orjtDoi < strlen(member.pApplicationName)+1; orjtDoi++){
            [&](){arr_CeSclhO[orjtDoi]=member.pApplicationName[orjtDoi];}();
        }
        }();
auto& applicationVersion_json=json["applicationVersion"];
[&](){applicationVersion_json=member.applicationVersion;}();
auto& pEngineName_json=json["pEngineName"];
[&](){
            if (member.pEngineName==NULL){
                pEngineName_json=boost::json::array();
            return; }pEngineName_json=boost::json::array(strlen(member.pEngineName)+1);
        auto& arr_kPbMKnf=pEngineName_json.as_array();
        for(int GsJQVyn=0; GsJQVyn < strlen(member.pEngineName)+1; GsJQVyn++){
            [&](){arr_kPbMKnf[GsJQVyn]=member.pEngineName[GsJQVyn];}();
        }
        }();
auto& engineVersion_json=json["engineVersion"];
[&](){engineVersion_json=member.engineVersion;}();
auto& apiVersion_json=json["apiVersion"];
[&](){apiVersion_json=member.apiVersion;}();
}
void deserialize_struct(boost::json::object& json, VkApplicationInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pApplicationName_json=json["pApplicationName"];
[&](){ char* temp_zwkFhcO;;[&](){
            if (pApplicationName_json.as_array().size()==0){
                temp_zwkFhcO=NULL;
            return; }temp_zwkFhcO=(char*)malloc(pApplicationName_json.as_array().size()*sizeof(char));
        auto& arr_lggPAwd=pApplicationName_json.as_array();
        for(int maVYKvO=0; maVYKvO < pApplicationName_json.as_array().size(); maVYKvO++){
            [&](){temp_zwkFhcO[maVYKvO]=static_cast<char>(value_to<int>(arr_lggPAwd[maVYKvO]));}();
        }
        }();member.pApplicationName=temp_zwkFhcO;}();
auto& applicationVersion_json=json["applicationVersion"];
[&](){member.applicationVersion=static_cast<uint32_t>(value_to<int>(applicationVersion_json));}();
auto& pEngineName_json=json["pEngineName"];
[&](){ char* temp_DaBUfqJ;;[&](){
            if (pEngineName_json.as_array().size()==0){
                temp_DaBUfqJ=NULL;
            return; }temp_DaBUfqJ=(char*)malloc(pEngineName_json.as_array().size()*sizeof(char));
        auto& arr_hNsoApN=pEngineName_json.as_array();
        for(int MradZZY=0; MradZZY < pEngineName_json.as_array().size(); MradZZY++){
            [&](){temp_DaBUfqJ[MradZZY]=static_cast<char>(value_to<int>(arr_hNsoApN[MradZZY]));}();
        }
        }();member.pEngineName=temp_DaBUfqJ;}();
auto& engineVersion_json=json["engineVersion"];
[&](){member.engineVersion=static_cast<uint32_t>(value_to<int>(engineVersion_json));}();
auto& apiVersion_json=json["apiVersion"];
[&](){member.apiVersion=static_cast<uint32_t>(value_to<int>(apiVersion_json));}();
}

        void serialize_pUserData(boost::json::object& json, const VkAllocationCallbacks& member){
        auto& pUserData_json=json["pUserData"];
        
[&](){
            if (member.pUserData==NULL){
                pUserData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pUserData))==NULL){
                pUserData_json=boost::json::array();
            return; }pUserData_json=boost::json::array(strlen(((char*)(member.pUserData)))+1);
        auto& arr_svgqjpy=pUserData_json.as_array();
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData)))+1; lQswvtW++){
            [&](){arr_svgqjpy[lQswvtW]=((char*)(member.pUserData))[lQswvtW];}();
        }
        }();}();
json["PFN_vkAllocationFunction"]=(uintptr_t)(member.pfnAllocation);
json["PFN_vkReallocationFunction"]=(uintptr_t)(member.pfnReallocation);
json["PFN_vkFreeFunction"]=(uintptr_t)(member.pfnFree);
json["PFN_vkInternalAllocationNotification"]=(uintptr_t)(member.pfnInternalAllocation);
json["PFN_vkInternalFreeNotification"]=(uintptr_t)(member.pfnInternalFree);
}

        void deserialize_pUserData(boost::json::object& json, VkAllocationCallbacks& member){
            #ifdef CLIENT
               void* pUserData;
               [&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData=temp_YghEUhF;}();
            #else 
                auto pUserData=new pUserData_struct();
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData->pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData->pUserData=temp_YghEUhF;}();
pUserData->PFN_vkAllocationFunction=(value_to<uintptr_t>(json["PFN_vkAllocationFunction"]));
pUserData->PFN_vkReallocationFunction=(value_to<uintptr_t>(json["PFN_vkReallocationFunction"]));
pUserData->PFN_vkFreeFunction=(value_to<uintptr_t>(json["PFN_vkFreeFunction"]));
pUserData->PFN_vkInternalAllocationNotification=(value_to<uintptr_t>(json["PFN_vkInternalAllocationNotification"]));
pUserData->PFN_vkInternalFreeNotification=(value_to<uintptr_t>(json["PFN_vkInternalFreeNotification"]));

        #endif
        member.pUserData=pUserData;
        }
        

    void serialize_struct(boost::json::object& json, const VkAllocationCallbacks& member){
        
    
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.emplace_object();
            serialize_pUserData(pUserData_json_1, member);
            
auto& pfnAllocation_json=json["pfnAllocation"];
[&](){
            auto& temp=pfnAllocation_json.emplace_object();
            return serialize_PFN_vkAllocationFunction(temp, member.pfnAllocation);
            }();
auto& pfnReallocation_json=json["pfnReallocation"];
[&](){
            auto& temp=pfnReallocation_json.emplace_object();
            return serialize_PFN_vkReallocationFunction(temp, member.pfnReallocation);
            }();
auto& pfnFree_json=json["pfnFree"];
[&](){
            auto& temp=pfnFree_json.emplace_object();
            return serialize_PFN_vkFreeFunction(temp, member.pfnFree);
            }();
auto& pfnInternalAllocation_json=json["pfnInternalAllocation"];
[&](){
            auto& temp=pfnInternalAllocation_json.emplace_object();
            return serialize_PFN_vkInternalAllocationNotification(temp, member.pfnInternalAllocation);
            }();
auto& pfnInternalFree_json=json["pfnInternalFree"];
[&](){
            auto& temp=pfnInternalFree_json.emplace_object();
            return serialize_PFN_vkInternalFreeNotification(temp, member.pfnInternalFree);
            }();
}
void deserialize_struct(boost::json::object& json, VkAllocationCallbacks& member){
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.as_object();
            deserialize_pUserData(pUserData_json_1, member);
            
auto& pfnAllocation_json=json["pfnAllocation"];
[&](){
            auto& temp=pfnAllocation_json.as_object();
            deserialize_PFN_vkAllocationFunction(temp,member.pfnAllocation);
            }();
auto& pfnReallocation_json=json["pfnReallocation"];
[&](){
            auto& temp=pfnReallocation_json.as_object();
            deserialize_PFN_vkReallocationFunction(temp,member.pfnReallocation);
            }();
auto& pfnFree_json=json["pfnFree"];
[&](){
            auto& temp=pfnFree_json.as_object();
            deserialize_PFN_vkFreeFunction(temp,member.pfnFree);
            }();
auto& pfnInternalAllocation_json=json["pfnInternalAllocation"];
[&](){
            auto& temp=pfnInternalAllocation_json.as_object();
            deserialize_PFN_vkInternalAllocationNotification(temp,member.pfnInternalAllocation);
            }();
auto& pfnInternalFree_json=json["pfnInternalFree"];
[&](){
            auto& temp=pfnInternalFree_json.as_object();
            deserialize_PFN_vkInternalFreeNotification(temp,member.pfnInternalFree);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDeviceQueueCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){queueFamilyIndex_json=member.queueFamilyIndex;}();
auto& queueCount_json=json["queueCount"];
[&](){queueCount_json=member.queueCount;}();
auto& pQueuePriorities_json=json["pQueuePriorities"];
[&](){
            if (member.pQueuePriorities==NULL){
                pQueuePriorities_json=boost::json::array();
            return; }pQueuePriorities_json=boost::json::array(member.queueCount);
        auto& arr_cuzPEWi=pQueuePriorities_json.as_array();
        for(int fezqjeq=0; fezqjeq < member.queueCount; fezqjeq++){
            [&](){arr_cuzPEWi[fezqjeq]=member.pQueuePriorities[fezqjeq];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDeviceQueueCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_IUWfgtC;[&](){temp_IUWfgtC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDeviceQueueCreateFlags)temp_IUWfgtC;}();}();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){member.queueFamilyIndex=static_cast<uint32_t>(value_to<int>(queueFamilyIndex_json));}();
auto& queueCount_json=json["queueCount"];
[&](){member.queueCount=static_cast<uint32_t>(value_to<int>(queueCount_json));}();
auto& pQueuePriorities_json=json["pQueuePriorities"];
[&](){ float* temp_gyGgkLY;;[&](){
            if (pQueuePriorities_json.as_array().size()==0){
                temp_gyGgkLY=NULL;
            return; }temp_gyGgkLY=(float*)malloc(member.queueCount*sizeof(float));
        auto& arr_ikrDclh=pQueuePriorities_json.as_array();
        for(int iCWvGRm=0; iCWvGRm < member.queueCount; iCWvGRm++){
            [&](){temp_gyGgkLY[iCWvGRm]=static_cast<float>(value_to<int>(arr_ikrDclh[iCWvGRm]));}();
        }
        }();member.pQueuePriorities=temp_gyGgkLY;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& queueCreateInfoCount_json=json["queueCreateInfoCount"];
[&](){queueCreateInfoCount_json=member.queueCreateInfoCount;}();
auto& pQueueCreateInfos_json=json["pQueueCreateInfos"];
[&](){
            if (member.pQueueCreateInfos==NULL){
                pQueueCreateInfos_json=boost::json::array();
            return; }pQueueCreateInfos_json=boost::json::array(member.queueCreateInfoCount);
        auto& arr_AyQtGcu=pQueueCreateInfos_json.as_array();
        for(int sagHnZa=0; sagHnZa < member.queueCreateInfoCount; sagHnZa++){
            [&](){
            auto& temp=arr_AyQtGcu[sagHnZa].emplace_object();
            return serialize_struct(temp, member.pQueueCreateInfos[sagHnZa]);
            }();
        }
        }();
auto& enabledLayerCount_json=json["enabledLayerCount"];
[&](){enabledLayerCount_json=member.enabledLayerCount;}();
auto& ppEnabledLayerNames_json=json["ppEnabledLayerNames"];
[&](){
            if (member.ppEnabledLayerNames==NULL){
                ppEnabledLayerNames_json=boost::json::array();
            return; }ppEnabledLayerNames_json=boost::json::array(member.enabledLayerCount);
        auto& arr_UZrMnJA=ppEnabledLayerNames_json.as_array();
        for(int TvVfmLO=0; TvVfmLO < member.enabledLayerCount; TvVfmLO++){
            [&](){
            if (member.ppEnabledLayerNames[TvVfmLO]==NULL){
                arr_UZrMnJA[TvVfmLO]=boost::json::array();
            return; }arr_UZrMnJA[TvVfmLO]=boost::json::array(strlen(member.ppEnabledLayerNames[TvVfmLO])+1);
        auto& arr_viCTnOh=arr_UZrMnJA[TvVfmLO].as_array();
        for(int xZQtAKv=0; xZQtAKv < strlen(member.ppEnabledLayerNames[TvVfmLO])+1; xZQtAKv++){
            [&](){arr_viCTnOh[xZQtAKv]=member.ppEnabledLayerNames[TvVfmLO][xZQtAKv];}();
        }
        }();
        }
        }();
auto& enabledExtensionCount_json=json["enabledExtensionCount"];
[&](){enabledExtensionCount_json=member.enabledExtensionCount;}();
auto& ppEnabledExtensionNames_json=json["ppEnabledExtensionNames"];
[&](){
            if (member.ppEnabledExtensionNames==NULL){
                ppEnabledExtensionNames_json=boost::json::array();
            return; }ppEnabledExtensionNames_json=boost::json::array(member.enabledExtensionCount);
        auto& arr_wQHCCIM=ppEnabledExtensionNames_json.as_array();
        for(int fwWaJEH=0; fwWaJEH < member.enabledExtensionCount; fwWaJEH++){
            [&](){
            if (member.ppEnabledExtensionNames[fwWaJEH]==NULL){
                arr_wQHCCIM[fwWaJEH]=boost::json::array();
            return; }arr_wQHCCIM[fwWaJEH]=boost::json::array(strlen(member.ppEnabledExtensionNames[fwWaJEH])+1);
        auto& arr_FVhnxCX=arr_wQHCCIM[fwWaJEH].as_array();
        for(int YrHftsW=0; YrHftsW < strlen(member.ppEnabledExtensionNames[fwWaJEH])+1; YrHftsW++){
            [&](){arr_FVhnxCX[YrHftsW]=member.ppEnabledExtensionNames[fwWaJEH][YrHftsW];}();
        }
        }();
        }
        }();
auto& pEnabledFeatures_json=json["pEnabledFeatures"];
[&](){
            if (member.pEnabledFeatures==NULL){
                pEnabledFeatures_json=boost::json::array();
            return; }pEnabledFeatures_json=boost::json::array(1);
        auto& arr_dmLnFnT=pEnabledFeatures_json.as_array();
        for(int ojHmheI=0; ojHmheI < 1; ojHmheI++){
            [&](){
            auto& temp=arr_dmLnFnT[ojHmheI].emplace_object();
            return serialize_struct(temp, member.pEnabledFeatures[ojHmheI]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDeviceCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_KpFotWi;[&](){temp_KpFotWi=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDeviceCreateFlags)temp_KpFotWi;}();}();
auto& queueCreateInfoCount_json=json["queueCreateInfoCount"];
[&](){member.queueCreateInfoCount=static_cast<uint32_t>(value_to<int>(queueCreateInfoCount_json));}();
auto& pQueueCreateInfos_json=json["pQueueCreateInfos"];
[&](){ VkDeviceQueueCreateInfo* temp_xWeTuPq;;[&](){
            if (pQueueCreateInfos_json.as_array().size()==0){
                temp_xWeTuPq=NULL;
            return; }temp_xWeTuPq=(VkDeviceQueueCreateInfo*)malloc(member.queueCreateInfoCount*sizeof(VkDeviceQueueCreateInfo));
        auto& arr_DctMYHh=pQueueCreateInfos_json.as_array();
        for(int XOfJaPl=0; XOfJaPl < member.queueCreateInfoCount; XOfJaPl++){
            [&](){
            auto& temp=arr_DctMYHh[XOfJaPl].as_object();
            deserialize_struct(temp,temp_xWeTuPq[XOfJaPl]);
            }();
        }
        }();member.pQueueCreateInfos=temp_xWeTuPq;}();
auto& enabledLayerCount_json=json["enabledLayerCount"];
[&](){member.enabledLayerCount=static_cast<uint32_t>(value_to<int>(enabledLayerCount_json));}();
auto& ppEnabledLayerNames_json=json["ppEnabledLayerNames"];
[&](){ char* * temp_yEdugWA;;[&](){
            if (ppEnabledLayerNames_json.as_array().size()==0){
                temp_yEdugWA=NULL;
            return; }temp_yEdugWA=(char**)malloc(member.enabledLayerCount*sizeof(char*));
        auto& arr_SwLvKsq=ppEnabledLayerNames_json.as_array();
        for(int jqRegHO=0; jqRegHO < member.enabledLayerCount; jqRegHO++){
            [&](){
            if (arr_SwLvKsq[jqRegHO].as_array().size()==0){
                temp_yEdugWA[jqRegHO]=NULL;
            return; }temp_yEdugWA[jqRegHO]=(char*)malloc(arr_SwLvKsq[jqRegHO].as_array().size()*sizeof(char));
        auto& arr_DLglqCw=arr_SwLvKsq[jqRegHO].as_array();
        for(int SNRioxI=0; SNRioxI < arr_SwLvKsq[jqRegHO].as_array().size(); SNRioxI++){
            [&](){temp_yEdugWA[jqRegHO][SNRioxI]=static_cast<char>(value_to<int>(arr_DLglqCw[SNRioxI]));}();
        }
        }();
        }
        }();member.ppEnabledLayerNames=temp_yEdugWA;}();
auto& enabledExtensionCount_json=json["enabledExtensionCount"];
[&](){member.enabledExtensionCount=static_cast<uint32_t>(value_to<int>(enabledExtensionCount_json));}();
auto& ppEnabledExtensionNames_json=json["ppEnabledExtensionNames"];
[&](){ char* * temp_QhElzZF;;[&](){
            if (ppEnabledExtensionNames_json.as_array().size()==0){
                temp_QhElzZF=NULL;
            return; }temp_QhElzZF=(char**)malloc(member.enabledExtensionCount*sizeof(char*));
        auto& arr_urOyZcL=ppEnabledExtensionNames_json.as_array();
        for(int GVEidWl=0; GVEidWl < member.enabledExtensionCount; GVEidWl++){
            [&](){
            if (arr_urOyZcL[GVEidWl].as_array().size()==0){
                temp_QhElzZF[GVEidWl]=NULL;
            return; }temp_QhElzZF[GVEidWl]=(char*)malloc(arr_urOyZcL[GVEidWl].as_array().size()*sizeof(char));
        auto& arr_tQTdUAy=arr_urOyZcL[GVEidWl].as_array();
        for(int XDYTrES=0; XDYTrES < arr_urOyZcL[GVEidWl].as_array().size(); XDYTrES++){
            [&](){temp_QhElzZF[GVEidWl][XDYTrES]=static_cast<char>(value_to<int>(arr_tQTdUAy[XDYTrES]));}();
        }
        }();
        }
        }();member.ppEnabledExtensionNames=temp_QhElzZF;}();
auto& pEnabledFeatures_json=json["pEnabledFeatures"];
[&](){ VkPhysicalDeviceFeatures* temp_qRIjVml;;[&](){
            if (pEnabledFeatures_json.as_array().size()==0){
                temp_qRIjVml=NULL;
            return; }temp_qRIjVml=(VkPhysicalDeviceFeatures*)malloc(1*sizeof(VkPhysicalDeviceFeatures));
        auto& arr_EiPynPL=pEnabledFeatures_json.as_array();
        for(int YKyBLeF=0; YKyBLeF < 1; YKyBLeF++){
            [&](){
            auto& temp=arr_EiPynPL[YKyBLeF].as_object();
            deserialize_struct(temp,temp_qRIjVml[YKyBLeF]);
            }();
        }
        }();member.pEnabledFeatures=temp_qRIjVml;}();
}

    void serialize_struct(boost::json::object& json, const VkInstanceCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pApplicationInfo_json=json["pApplicationInfo"];
[&](){
            if (member.pApplicationInfo==NULL){
                pApplicationInfo_json=boost::json::array();
            return; }pApplicationInfo_json=boost::json::array(1);
        auto& arr_ZBfqvMJ=pApplicationInfo_json.as_array();
        for(int fUoumfM=0; fUoumfM < 1; fUoumfM++){
            [&](){
            auto& temp=arr_ZBfqvMJ[fUoumfM].emplace_object();
            return serialize_struct(temp, member.pApplicationInfo[fUoumfM]);
            }();
        }
        }();
auto& enabledLayerCount_json=json["enabledLayerCount"];
[&](){enabledLayerCount_json=member.enabledLayerCount;}();
auto& ppEnabledLayerNames_json=json["ppEnabledLayerNames"];
[&](){
            if (member.ppEnabledLayerNames==NULL){
                ppEnabledLayerNames_json=boost::json::array();
            return; }ppEnabledLayerNames_json=boost::json::array(member.enabledLayerCount);
        auto& arr_UZrMnJA=ppEnabledLayerNames_json.as_array();
        for(int TvVfmLO=0; TvVfmLO < member.enabledLayerCount; TvVfmLO++){
            [&](){
            if (member.ppEnabledLayerNames[TvVfmLO]==NULL){
                arr_UZrMnJA[TvVfmLO]=boost::json::array();
            return; }arr_UZrMnJA[TvVfmLO]=boost::json::array(strlen(member.ppEnabledLayerNames[TvVfmLO])+1);
        auto& arr_viCTnOh=arr_UZrMnJA[TvVfmLO].as_array();
        for(int xZQtAKv=0; xZQtAKv < strlen(member.ppEnabledLayerNames[TvVfmLO])+1; xZQtAKv++){
            [&](){arr_viCTnOh[xZQtAKv]=member.ppEnabledLayerNames[TvVfmLO][xZQtAKv];}();
        }
        }();
        }
        }();
auto& enabledExtensionCount_json=json["enabledExtensionCount"];
[&](){enabledExtensionCount_json=member.enabledExtensionCount;}();
auto& ppEnabledExtensionNames_json=json["ppEnabledExtensionNames"];
[&](){
            if (member.ppEnabledExtensionNames==NULL){
                ppEnabledExtensionNames_json=boost::json::array();
            return; }ppEnabledExtensionNames_json=boost::json::array(member.enabledExtensionCount);
        auto& arr_wQHCCIM=ppEnabledExtensionNames_json.as_array();
        for(int fwWaJEH=0; fwWaJEH < member.enabledExtensionCount; fwWaJEH++){
            [&](){
            if (member.ppEnabledExtensionNames[fwWaJEH]==NULL){
                arr_wQHCCIM[fwWaJEH]=boost::json::array();
            return; }arr_wQHCCIM[fwWaJEH]=boost::json::array(strlen(member.ppEnabledExtensionNames[fwWaJEH])+1);
        auto& arr_FVhnxCX=arr_wQHCCIM[fwWaJEH].as_array();
        for(int YrHftsW=0; YrHftsW < strlen(member.ppEnabledExtensionNames[fwWaJEH])+1; YrHftsW++){
            [&](){arr_FVhnxCX[YrHftsW]=member.ppEnabledExtensionNames[fwWaJEH][YrHftsW];}();
        }
        }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkInstanceCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_zgxTjLZ;[&](){temp_zgxTjLZ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkInstanceCreateFlags)temp_zgxTjLZ;}();}();
auto& pApplicationInfo_json=json["pApplicationInfo"];
[&](){ VkApplicationInfo* temp_pzioVhk;;[&](){
            if (pApplicationInfo_json.as_array().size()==0){
                temp_pzioVhk=NULL;
            return; }temp_pzioVhk=(VkApplicationInfo*)malloc(1*sizeof(VkApplicationInfo));
        auto& arr_hfqwlnD=pApplicationInfo_json.as_array();
        for(int hAGHZAC=0; hAGHZAC < 1; hAGHZAC++){
            [&](){
            auto& temp=arr_hfqwlnD[hAGHZAC].as_object();
            deserialize_struct(temp,temp_pzioVhk[hAGHZAC]);
            }();
        }
        }();member.pApplicationInfo=temp_pzioVhk;}();
auto& enabledLayerCount_json=json["enabledLayerCount"];
[&](){member.enabledLayerCount=static_cast<uint32_t>(value_to<int>(enabledLayerCount_json));}();
auto& ppEnabledLayerNames_json=json["ppEnabledLayerNames"];
[&](){ char* * temp_yEdugWA;;[&](){
            if (ppEnabledLayerNames_json.as_array().size()==0){
                temp_yEdugWA=NULL;
            return; }temp_yEdugWA=(char**)malloc(member.enabledLayerCount*sizeof(char*));
        auto& arr_SwLvKsq=ppEnabledLayerNames_json.as_array();
        for(int jqRegHO=0; jqRegHO < member.enabledLayerCount; jqRegHO++){
            [&](){
            if (arr_SwLvKsq[jqRegHO].as_array().size()==0){
                temp_yEdugWA[jqRegHO]=NULL;
            return; }temp_yEdugWA[jqRegHO]=(char*)malloc(arr_SwLvKsq[jqRegHO].as_array().size()*sizeof(char));
        auto& arr_DLglqCw=arr_SwLvKsq[jqRegHO].as_array();
        for(int SNRioxI=0; SNRioxI < arr_SwLvKsq[jqRegHO].as_array().size(); SNRioxI++){
            [&](){temp_yEdugWA[jqRegHO][SNRioxI]=static_cast<char>(value_to<int>(arr_DLglqCw[SNRioxI]));}();
        }
        }();
        }
        }();member.ppEnabledLayerNames=temp_yEdugWA;}();
auto& enabledExtensionCount_json=json["enabledExtensionCount"];
[&](){member.enabledExtensionCount=static_cast<uint32_t>(value_to<int>(enabledExtensionCount_json));}();
auto& ppEnabledExtensionNames_json=json["ppEnabledExtensionNames"];
[&](){ char* * temp_QhElzZF;;[&](){
            if (ppEnabledExtensionNames_json.as_array().size()==0){
                temp_QhElzZF=NULL;
            return; }temp_QhElzZF=(char**)malloc(member.enabledExtensionCount*sizeof(char*));
        auto& arr_urOyZcL=ppEnabledExtensionNames_json.as_array();
        for(int GVEidWl=0; GVEidWl < member.enabledExtensionCount; GVEidWl++){
            [&](){
            if (arr_urOyZcL[GVEidWl].as_array().size()==0){
                temp_QhElzZF[GVEidWl]=NULL;
            return; }temp_QhElzZF[GVEidWl]=(char*)malloc(arr_urOyZcL[GVEidWl].as_array().size()*sizeof(char));
        auto& arr_tQTdUAy=arr_urOyZcL[GVEidWl].as_array();
        for(int XDYTrES=0; XDYTrES < arr_urOyZcL[GVEidWl].as_array().size(); XDYTrES++){
            [&](){temp_QhElzZF[GVEidWl][XDYTrES]=static_cast<char>(value_to<int>(arr_tQTdUAy[XDYTrES]));}();
        }
        }();
        }
        }();member.ppEnabledExtensionNames=temp_QhElzZF;}();
}

    void serialize_struct(boost::json::object& json, const VkQueueFamilyProperties& member){
        
    
auto& queueFlags_json=json["queueFlags"];
[&](){[&](){[&](){queueFlags_json=member.queueFlags;}();}();}();
auto& queueCount_json=json["queueCount"];
[&](){queueCount_json=member.queueCount;}();
auto& timestampValidBits_json=json["timestampValidBits"];
[&](){timestampValidBits_json=member.timestampValidBits;}();
auto& minImageTransferGranularity_json=json["minImageTransferGranularity"];
[&](){
            auto& temp=minImageTransferGranularity_json.emplace_object();
            return serialize_struct(temp, member.minImageTransferGranularity);
            }();
}
void deserialize_struct(boost::json::object& json, VkQueueFamilyProperties& member){
auto& queueFlags_json=json["queueFlags"];
[&](){[&](){int temp_jLmfeQF;[&](){temp_jLmfeQF=static_cast<int>(value_to<int>(queueFlags_json));}();member.queueFlags=(VkQueueFlags)temp_jLmfeQF;}();}();
auto& queueCount_json=json["queueCount"];
[&](){member.queueCount=static_cast<uint32_t>(value_to<int>(queueCount_json));}();
auto& timestampValidBits_json=json["timestampValidBits"];
[&](){member.timestampValidBits=static_cast<uint32_t>(value_to<int>(timestampValidBits_json));}();
auto& minImageTransferGranularity_json=json["minImageTransferGranularity"];
[&](){
            auto& temp=minImageTransferGranularity_json.as_object();
            deserialize_struct(temp,member.minImageTransferGranularity);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMemoryProperties& member){
        
    
auto& memoryTypeCount_json=json["memoryTypeCount"];
[&](){memoryTypeCount_json=member.memoryTypeCount;}();
auto& memoryTypes_json=json["memoryTypes"];
[&](){memoryTypes_json=boost::json::array(VK_MAX_MEMORY_TYPES);
        auto& arr_zLhIRqf=memoryTypes_json.as_array();
        for(int oIrFYub=0; oIrFYub < VK_MAX_MEMORY_TYPES; oIrFYub++){
            [&](){
            auto& temp=arr_zLhIRqf[oIrFYub].emplace_object();
            return serialize_struct(temp, member.memoryTypes[oIrFYub]);
            }();
        }
        }();
auto& memoryHeapCount_json=json["memoryHeapCount"];
[&](){memoryHeapCount_json=member.memoryHeapCount;}();
auto& memoryHeaps_json=json["memoryHeaps"];
[&](){memoryHeaps_json=boost::json::array(VK_MAX_MEMORY_HEAPS);
        auto& arr_IqWNxdQ=memoryHeaps_json.as_array();
        for(int ByzKyHe=0; ByzKyHe < VK_MAX_MEMORY_HEAPS; ByzKyHe++){
            [&](){
            auto& temp=arr_IqWNxdQ[ByzKyHe].emplace_object();
            return serialize_struct(temp, member.memoryHeaps[ByzKyHe]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMemoryProperties& member){
auto& memoryTypeCount_json=json["memoryTypeCount"];
[&](){member.memoryTypeCount=static_cast<uint32_t>(value_to<int>(memoryTypeCount_json));}();
auto& memoryTypes_json=json["memoryTypes"];
[&](){
        auto& arr_zLhIRqf=memoryTypes_json.as_array();
        for(int oIrFYub=0; oIrFYub < VK_MAX_MEMORY_TYPES; oIrFYub++){
            [&](){
            auto& temp=arr_zLhIRqf[oIrFYub].as_object();
            deserialize_struct(temp,member.memoryTypes[oIrFYub]);
            }();
        }
        }();
auto& memoryHeapCount_json=json["memoryHeapCount"];
[&](){member.memoryHeapCount=static_cast<uint32_t>(value_to<int>(memoryHeapCount_json));}();
auto& memoryHeaps_json=json["memoryHeaps"];
[&](){
        auto& arr_IqWNxdQ=memoryHeaps_json.as_array();
        for(int ByzKyHe=0; ByzKyHe < VK_MAX_MEMORY_HEAPS; ByzKyHe++){
            [&](){
            auto& temp=arr_IqWNxdQ[ByzKyHe].as_object();
            deserialize_struct(temp,member.memoryHeaps[ByzKyHe]);
            }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkMemoryAllocateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& allocationSize_json=json["allocationSize"];
[&](){[&](){allocationSize_json=member.allocationSize;}();}();
auto& memoryTypeIndex_json=json["memoryTypeIndex"];
[&](){memoryTypeIndex_json=member.memoryTypeIndex;}();
}
void deserialize_struct(boost::json::object& json, VkMemoryAllocateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& allocationSize_json=json["allocationSize"];
[&](){uint64_t temp_uibiuRT;[&](){temp_uibiuRT=static_cast<uint64_t>(value_to<int>(allocationSize_json));}();member.allocationSize=(VkDeviceSize)temp_uibiuRT;}();
auto& memoryTypeIndex_json=json["memoryTypeIndex"];
[&](){member.memoryTypeIndex=static_cast<uint32_t>(value_to<int>(memoryTypeIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryRequirements& member){
        
    
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& alignment_json=json["alignment"];
[&](){[&](){alignment_json=member.alignment;}();}();
auto& memoryTypeBits_json=json["memoryTypeBits"];
[&](){memoryTypeBits_json=member.memoryTypeBits;}();
}
void deserialize_struct(boost::json::object& json, VkMemoryRequirements& member){
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& alignment_json=json["alignment"];
[&](){uint64_t temp_NyhgnJA;[&](){temp_NyhgnJA=static_cast<uint64_t>(value_to<int>(alignment_json));}();member.alignment=(VkDeviceSize)temp_NyhgnJA;}();
auto& memoryTypeBits_json=json["memoryTypeBits"];
[&](){member.memoryTypeBits=static_cast<uint32_t>(value_to<int>(memoryTypeBits_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSparseImageFormatProperties& member){
        
    
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){[&](){aspectMask_json=member.aspectMask;}();}();}();
auto& imageGranularity_json=json["imageGranularity"];
[&](){
            auto& temp=imageGranularity_json.emplace_object();
            return serialize_struct(temp, member.imageGranularity);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSparseImageFormatProperties& member){
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){int temp_srmSgxC;[&](){temp_srmSgxC=static_cast<int>(value_to<int>(aspectMask_json));}();member.aspectMask=(VkImageAspectFlags)temp_srmSgxC;}();}();
auto& imageGranularity_json=json["imageGranularity"];
[&](){
            auto& temp=imageGranularity_json.as_object();
            deserialize_struct(temp,member.imageGranularity);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_ABDNANZ;[&](){temp_ABDNANZ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSparseImageFormatFlags)temp_ABDNANZ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSparseImageMemoryRequirements& member){
        
    
auto& formatProperties_json=json["formatProperties"];
[&](){
            auto& temp=formatProperties_json.emplace_object();
            return serialize_struct(temp, member.formatProperties);
            }();
auto& imageMipTailFirstLod_json=json["imageMipTailFirstLod"];
[&](){imageMipTailFirstLod_json=member.imageMipTailFirstLod;}();
auto& imageMipTailSize_json=json["imageMipTailSize"];
[&](){[&](){imageMipTailSize_json=member.imageMipTailSize;}();}();
auto& imageMipTailOffset_json=json["imageMipTailOffset"];
[&](){[&](){imageMipTailOffset_json=member.imageMipTailOffset;}();}();
auto& imageMipTailStride_json=json["imageMipTailStride"];
[&](){[&](){imageMipTailStride_json=member.imageMipTailStride;}();}();
}
void deserialize_struct(boost::json::object& json, VkSparseImageMemoryRequirements& member){
auto& formatProperties_json=json["formatProperties"];
[&](){
            auto& temp=formatProperties_json.as_object();
            deserialize_struct(temp,member.formatProperties);
            }();
auto& imageMipTailFirstLod_json=json["imageMipTailFirstLod"];
[&](){member.imageMipTailFirstLod=static_cast<uint32_t>(value_to<int>(imageMipTailFirstLod_json));}();
auto& imageMipTailSize_json=json["imageMipTailSize"];
[&](){uint64_t temp_BvJlAoF;[&](){temp_BvJlAoF=static_cast<uint64_t>(value_to<int>(imageMipTailSize_json));}();member.imageMipTailSize=(VkDeviceSize)temp_BvJlAoF;}();
auto& imageMipTailOffset_json=json["imageMipTailOffset"];
[&](){uint64_t temp_WpHWxGj;[&](){temp_WpHWxGj=static_cast<uint64_t>(value_to<int>(imageMipTailOffset_json));}();member.imageMipTailOffset=(VkDeviceSize)temp_WpHWxGj;}();
auto& imageMipTailStride_json=json["imageMipTailStride"];
[&](){uint64_t temp_BaTmNGu;[&](){temp_BaTmNGu=static_cast<uint64_t>(value_to<int>(imageMipTailStride_json));}();member.imageMipTailStride=(VkDeviceSize)temp_BaTmNGu;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryType& member){
        
    
auto& propertyFlags_json=json["propertyFlags"];
[&](){[&](){[&](){propertyFlags_json=member.propertyFlags;}();}();}();
auto& heapIndex_json=json["heapIndex"];
[&](){heapIndex_json=member.heapIndex;}();
}
void deserialize_struct(boost::json::object& json, VkMemoryType& member){
auto& propertyFlags_json=json["propertyFlags"];
[&](){[&](){int temp_aFeYgcu;[&](){temp_aFeYgcu=static_cast<int>(value_to<int>(propertyFlags_json));}();member.propertyFlags=(VkMemoryPropertyFlags)temp_aFeYgcu;}();}();
auto& heapIndex_json=json["heapIndex"];
[&](){member.heapIndex=static_cast<uint32_t>(value_to<int>(heapIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryHeap& member){
        
    
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkMemoryHeap& member){
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_vUoVbqM;[&](){temp_vUoVbqM=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkMemoryHeapFlags)temp_vUoVbqM;}();}();
}

    void serialize_struct(boost::json::object& json, const VkMappedMemoryRange& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkMappedMemoryRange& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkFormatProperties& member){
        
    
auto& linearTilingFeatures_json=json["linearTilingFeatures"];
[&](){[&](){[&](){linearTilingFeatures_json=member.linearTilingFeatures;}();}();}();
auto& optimalTilingFeatures_json=json["optimalTilingFeatures"];
[&](){[&](){[&](){optimalTilingFeatures_json=member.optimalTilingFeatures;}();}();}();
auto& bufferFeatures_json=json["bufferFeatures"];
[&](){[&](){[&](){bufferFeatures_json=member.bufferFeatures;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkFormatProperties& member){
auto& linearTilingFeatures_json=json["linearTilingFeatures"];
[&](){[&](){int temp_lBgxAYl;[&](){temp_lBgxAYl=static_cast<int>(value_to<int>(linearTilingFeatures_json));}();member.linearTilingFeatures=(VkFormatFeatureFlags)temp_lBgxAYl;}();}();
auto& optimalTilingFeatures_json=json["optimalTilingFeatures"];
[&](){[&](){int temp_yWxxykh;[&](){temp_yWxxykh=static_cast<int>(value_to<int>(optimalTilingFeatures_json));}();member.optimalTilingFeatures=(VkFormatFeatureFlags)temp_yWxxykh;}();}();
auto& bufferFeatures_json=json["bufferFeatures"];
[&](){[&](){int temp_vXmHRzi;[&](){temp_vXmHRzi=static_cast<int>(value_to<int>(bufferFeatures_json));}();member.bufferFeatures=(VkFormatFeatureFlags)temp_vXmHRzi;}();}();
}

    void serialize_struct(boost::json::object& json, const VkImageFormatProperties& member){
        
    
auto& maxExtent_json=json["maxExtent"];
[&](){
            auto& temp=maxExtent_json.emplace_object();
            return serialize_struct(temp, member.maxExtent);
            }();
auto& maxMipLevels_json=json["maxMipLevels"];
[&](){maxMipLevels_json=member.maxMipLevels;}();
auto& maxArrayLayers_json=json["maxArrayLayers"];
[&](){maxArrayLayers_json=member.maxArrayLayers;}();
auto& sampleCounts_json=json["sampleCounts"];
[&](){[&](){[&](){sampleCounts_json=member.sampleCounts;}();}();}();
auto& maxResourceSize_json=json["maxResourceSize"];
[&](){[&](){maxResourceSize_json=member.maxResourceSize;}();}();
}
void deserialize_struct(boost::json::object& json, VkImageFormatProperties& member){
auto& maxExtent_json=json["maxExtent"];
[&](){
            auto& temp=maxExtent_json.as_object();
            deserialize_struct(temp,member.maxExtent);
            }();
auto& maxMipLevels_json=json["maxMipLevels"];
[&](){member.maxMipLevels=static_cast<uint32_t>(value_to<int>(maxMipLevels_json));}();
auto& maxArrayLayers_json=json["maxArrayLayers"];
[&](){member.maxArrayLayers=static_cast<uint32_t>(value_to<int>(maxArrayLayers_json));}();
auto& sampleCounts_json=json["sampleCounts"];
[&](){[&](){int temp_LcBJWgU;[&](){temp_LcBJWgU=static_cast<int>(value_to<int>(sampleCounts_json));}();member.sampleCounts=(VkSampleCountFlags)temp_LcBJWgU;}();}();
auto& maxResourceSize_json=json["maxResourceSize"];
[&](){uint64_t temp_qdkRyIs;[&](){temp_qdkRyIs=static_cast<uint64_t>(value_to<int>(maxResourceSize_json));}();member.maxResourceSize=(VkDeviceSize)temp_qdkRyIs;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorBufferInfo& member){
        
    
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& range_json=json["range"];
[&](){[&](){range_json=member.range;}();}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorBufferInfo& member){
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& range_json=json["range"];
[&](){uint64_t temp_UVnzFRl;[&](){temp_UVnzFRl=static_cast<uint64_t>(value_to<int>(range_json));}();member.range=(VkDeviceSize)temp_UVnzFRl;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorImageInfo& member){
        
    
auto& sampler_json=json["sampler"];
[&](){serialize_VkSampler(sampler_json,member.sampler);}();
auto& imageView_json=json["imageView"];
[&](){serialize_VkImageView(imageView_json,member.imageView);}();
auto& imageLayout_json=json["imageLayout"];
[&](){[&](){[&](){imageLayout_json=member.imageLayout;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorImageInfo& member){
auto& sampler_json=json["sampler"];
[&](){deserialize_VkSampler(sampler_json, member.sampler);}();
auto& imageView_json=json["imageView"];
[&](){deserialize_VkImageView(imageView_json, member.imageView);}();
auto& imageLayout_json=json["imageLayout"];
[&](){[&](){int temp_FajwjgZ;[&](){temp_FajwjgZ=static_cast<int>(value_to<int>(imageLayout_json));}();member.imageLayout=(VkImageLayout)temp_FajwjgZ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkWriteDescriptorSet& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dstSet_json=json["dstSet"];
[&](){serialize_VkDescriptorSet(dstSet_json,member.dstSet);}();
auto& dstBinding_json=json["dstBinding"];
[&](){dstBinding_json=member.dstBinding;}();
auto& dstArrayElement_json=json["dstArrayElement"];
[&](){dstArrayElement_json=member.dstArrayElement;}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){descriptorCount_json=member.descriptorCount;}();
auto& descriptorType_json=json["descriptorType"];
[&](){[&](){[&](){descriptorType_json=member.descriptorType;}();}();}();
auto& pImageInfo_json=json["pImageInfo"];
[&](){
            if (member.pImageInfo==NULL){
                pImageInfo_json=boost::json::array();
            return; }pImageInfo_json=boost::json::array(member.descriptorCount);
        auto& arr_hKyqMBA=pImageInfo_json.as_array();
        for(int JKGzUnw=0; JKGzUnw < member.descriptorCount; JKGzUnw++){
            [&](){
            auto& temp=arr_hKyqMBA[JKGzUnw].emplace_object();
            return serialize_struct(temp, member.pImageInfo[JKGzUnw]);
            }();
        }
        }();
auto& pBufferInfo_json=json["pBufferInfo"];
[&](){
            if (member.pBufferInfo==NULL){
                pBufferInfo_json=boost::json::array();
            return; }pBufferInfo_json=boost::json::array(member.descriptorCount);
        auto& arr_kkLJfgf=pBufferInfo_json.as_array();
        for(int HSNwtZm=0; HSNwtZm < member.descriptorCount; HSNwtZm++){
            [&](){
            auto& temp=arr_kkLJfgf[HSNwtZm].emplace_object();
            return serialize_struct(temp, member.pBufferInfo[HSNwtZm]);
            }();
        }
        }();
auto& pTexelBufferView_json=json["pTexelBufferView"];
[&](){
            if (member.pTexelBufferView==NULL){
                pTexelBufferView_json=boost::json::array();
            return; }pTexelBufferView_json=boost::json::array(member.descriptorCount);
        auto& arr_aeRJWrd=pTexelBufferView_json.as_array();
        for(int zPsmhBm=0; zPsmhBm < member.descriptorCount; zPsmhBm++){
            [&](){serialize_VkBufferView(arr_aeRJWrd[zPsmhBm],member.pTexelBufferView[zPsmhBm]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkWriteDescriptorSet& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& dstSet_json=json["dstSet"];
[&](){deserialize_VkDescriptorSet(dstSet_json, member.dstSet);}();
auto& dstBinding_json=json["dstBinding"];
[&](){member.dstBinding=static_cast<uint32_t>(value_to<int>(dstBinding_json));}();
auto& dstArrayElement_json=json["dstArrayElement"];
[&](){member.dstArrayElement=static_cast<uint32_t>(value_to<int>(dstArrayElement_json));}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){member.descriptorCount=static_cast<uint32_t>(value_to<int>(descriptorCount_json));}();
auto& descriptorType_json=json["descriptorType"];
[&](){[&](){int temp_LETzuZb;[&](){temp_LETzuZb=static_cast<int>(value_to<int>(descriptorType_json));}();member.descriptorType=(VkDescriptorType)temp_LETzuZb;}();}();
auto& pImageInfo_json=json["pImageInfo"];
[&](){ VkDescriptorImageInfo* temp_uLUnZSC;;[&](){
            if (pImageInfo_json.as_array().size()==0){
                temp_uLUnZSC=NULL;
            return; }temp_uLUnZSC=(VkDescriptorImageInfo*)malloc(member.descriptorCount*sizeof(VkDescriptorImageInfo));
        auto& arr_wXDpfdT=pImageInfo_json.as_array();
        for(int nztYqgl=0; nztYqgl < member.descriptorCount; nztYqgl++){
            [&](){
            auto& temp=arr_wXDpfdT[nztYqgl].as_object();
            deserialize_struct(temp,temp_uLUnZSC[nztYqgl]);
            }();
        }
        }();member.pImageInfo=temp_uLUnZSC;}();
auto& pBufferInfo_json=json["pBufferInfo"];
[&](){ VkDescriptorBufferInfo* temp_TjOXJlI;;[&](){
            if (pBufferInfo_json.as_array().size()==0){
                temp_TjOXJlI=NULL;
            return; }temp_TjOXJlI=(VkDescriptorBufferInfo*)malloc(member.descriptorCount*sizeof(VkDescriptorBufferInfo));
        auto& arr_hRAeHXe=pBufferInfo_json.as_array();
        for(int bIMhCbR=0; bIMhCbR < member.descriptorCount; bIMhCbR++){
            [&](){
            auto& temp=arr_hRAeHXe[bIMhCbR].as_object();
            deserialize_struct(temp,temp_TjOXJlI[bIMhCbR]);
            }();
        }
        }();member.pBufferInfo=temp_TjOXJlI;}();
auto& pTexelBufferView_json=json["pTexelBufferView"];
[&](){ VkBufferView* temp_KgXLfCw;;[&](){
            if (pTexelBufferView_json.as_array().size()==0){
                temp_KgXLfCw=NULL;
            return; }temp_KgXLfCw=(VkBufferView*)malloc(member.descriptorCount*sizeof(VkBufferView));
        auto& arr_aZIjolk=pTexelBufferView_json.as_array();
        for(int KlquAhO=0; KlquAhO < member.descriptorCount; KlquAhO++){
            [&](){deserialize_VkBufferView(arr_aZIjolk[KlquAhO], temp_KgXLfCw[KlquAhO]);}();
        }
        }();member.pTexelBufferView=temp_KgXLfCw;}();
}

    void serialize_struct(boost::json::object& json, const VkCopyDescriptorSet& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcSet_json=json["srcSet"];
[&](){serialize_VkDescriptorSet(srcSet_json,member.srcSet);}();
auto& srcBinding_json=json["srcBinding"];
[&](){srcBinding_json=member.srcBinding;}();
auto& srcArrayElement_json=json["srcArrayElement"];
[&](){srcArrayElement_json=member.srcArrayElement;}();
auto& dstSet_json=json["dstSet"];
[&](){serialize_VkDescriptorSet(dstSet_json,member.dstSet);}();
auto& dstBinding_json=json["dstBinding"];
[&](){dstBinding_json=member.dstBinding;}();
auto& dstArrayElement_json=json["dstArrayElement"];
[&](){dstArrayElement_json=member.dstArrayElement;}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){descriptorCount_json=member.descriptorCount;}();
}
void deserialize_struct(boost::json::object& json, VkCopyDescriptorSet& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcSet_json=json["srcSet"];
[&](){deserialize_VkDescriptorSet(srcSet_json, member.srcSet);}();
auto& srcBinding_json=json["srcBinding"];
[&](){member.srcBinding=static_cast<uint32_t>(value_to<int>(srcBinding_json));}();
auto& srcArrayElement_json=json["srcArrayElement"];
[&](){member.srcArrayElement=static_cast<uint32_t>(value_to<int>(srcArrayElement_json));}();
auto& dstSet_json=json["dstSet"];
[&](){deserialize_VkDescriptorSet(dstSet_json, member.dstSet);}();
auto& dstBinding_json=json["dstBinding"];
[&](){member.dstBinding=static_cast<uint32_t>(value_to<int>(dstBinding_json));}();
auto& dstArrayElement_json=json["dstArrayElement"];
[&](){member.dstArrayElement=static_cast<uint32_t>(value_to<int>(dstArrayElement_json));}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){member.descriptorCount=static_cast<uint32_t>(value_to<int>(descriptorCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkBufferUsageFlags2CreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkBufferUsageFlags2CreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_IdJXpUi;[&](){temp_IdJXpUi=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkBufferUsageFlags2KHR)temp_IdJXpUi;}();}();
}

    void serialize_struct(boost::json::object& json, const VkBufferCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
auto& sharingMode_json=json["sharingMode"];
[&](){[&](){[&](){sharingMode_json=member.sharingMode;}();}();}();
auto& queueFamilyIndexCount_json=json["queueFamilyIndexCount"];
[&](){queueFamilyIndexCount_json=member.queueFamilyIndexCount;}();
auto& pQueueFamilyIndices_json=json["pQueueFamilyIndices"];
[&](){
            if (member.pQueueFamilyIndices==NULL){
                pQueueFamilyIndices_json=boost::json::array();
            return; }pQueueFamilyIndices_json=boost::json::array(member.queueFamilyIndexCount);
        auto& arr_miZGtyX=pQueueFamilyIndices_json.as_array();
        for(int VJZTqbB=0; VJZTqbB < member.queueFamilyIndexCount; VJZTqbB++){
            [&](){arr_miZGtyX[VJZTqbB]=member.pQueueFamilyIndices[VJZTqbB];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkBufferCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_NttNRTT;[&](){temp_NttNRTT=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkBufferCreateFlags)temp_NttNRTT;}();}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_xMTCOae;[&](){temp_xMTCOae=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkBufferUsageFlags)temp_xMTCOae;}();}();
auto& sharingMode_json=json["sharingMode"];
[&](){[&](){int temp_lEqLxkW;[&](){temp_lEqLxkW=static_cast<int>(value_to<int>(sharingMode_json));}();member.sharingMode=(VkSharingMode)temp_lEqLxkW;}();}();
auto& queueFamilyIndexCount_json=json["queueFamilyIndexCount"];
[&](){member.queueFamilyIndexCount=static_cast<uint32_t>(value_to<int>(queueFamilyIndexCount_json));}();
auto& pQueueFamilyIndices_json=json["pQueueFamilyIndices"];
[&](){ uint32_t* temp_RQIKvOJ;;[&](){
            if (pQueueFamilyIndices_json.as_array().size()==0){
                temp_RQIKvOJ=NULL;
            return; }temp_RQIKvOJ=(uint32_t*)malloc(member.queueFamilyIndexCount*sizeof(uint32_t));
        auto& arr_PLMLiyU=pQueueFamilyIndices_json.as_array();
        for(int CXBfdQH=0; CXBfdQH < member.queueFamilyIndexCount; CXBfdQH++){
            [&](){temp_RQIKvOJ[CXBfdQH]=static_cast<uint32_t>(value_to<int>(arr_PLMLiyU[CXBfdQH]));}();
        }
        }();member.pQueueFamilyIndices=temp_RQIKvOJ;}();
}

    void serialize_struct(boost::json::object& json, const VkBufferViewCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& range_json=json["range"];
[&](){[&](){range_json=member.range;}();}();
}
void deserialize_struct(boost::json::object& json, VkBufferViewCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_ckwVSHx;[&](){temp_ckwVSHx=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkBufferViewCreateFlags)temp_ckwVSHx;}();}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& range_json=json["range"];
[&](){uint64_t temp_UVnzFRl;[&](){temp_UVnzFRl=static_cast<uint64_t>(value_to<int>(range_json));}();member.range=(VkDeviceSize)temp_UVnzFRl;}();
}

    void serialize_struct(boost::json::object& json, const VkImageSubresource& member){
        
    
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){[&](){aspectMask_json=member.aspectMask;}();}();}();
auto& mipLevel_json=json["mipLevel"];
[&](){mipLevel_json=member.mipLevel;}();
auto& arrayLayer_json=json["arrayLayer"];
[&](){arrayLayer_json=member.arrayLayer;}();
}
void deserialize_struct(boost::json::object& json, VkImageSubresource& member){
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){int temp_srmSgxC;[&](){temp_srmSgxC=static_cast<int>(value_to<int>(aspectMask_json));}();member.aspectMask=(VkImageAspectFlags)temp_srmSgxC;}();}();
auto& mipLevel_json=json["mipLevel"];
[&](){member.mipLevel=static_cast<uint32_t>(value_to<int>(mipLevel_json));}();
auto& arrayLayer_json=json["arrayLayer"];
[&](){member.arrayLayer=static_cast<uint32_t>(value_to<int>(arrayLayer_json));}();
}

    void serialize_struct(boost::json::object& json, const VkImageSubresourceLayers& member){
        
    
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){[&](){aspectMask_json=member.aspectMask;}();}();}();
auto& mipLevel_json=json["mipLevel"];
[&](){mipLevel_json=member.mipLevel;}();
auto& baseArrayLayer_json=json["baseArrayLayer"];
[&](){baseArrayLayer_json=member.baseArrayLayer;}();
auto& layerCount_json=json["layerCount"];
[&](){layerCount_json=member.layerCount;}();
}
void deserialize_struct(boost::json::object& json, VkImageSubresourceLayers& member){
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){int temp_srmSgxC;[&](){temp_srmSgxC=static_cast<int>(value_to<int>(aspectMask_json));}();member.aspectMask=(VkImageAspectFlags)temp_srmSgxC;}();}();
auto& mipLevel_json=json["mipLevel"];
[&](){member.mipLevel=static_cast<uint32_t>(value_to<int>(mipLevel_json));}();
auto& baseArrayLayer_json=json["baseArrayLayer"];
[&](){member.baseArrayLayer=static_cast<uint32_t>(value_to<int>(baseArrayLayer_json));}();
auto& layerCount_json=json["layerCount"];
[&](){member.layerCount=static_cast<uint32_t>(value_to<int>(layerCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkImageSubresourceRange& member){
        
    
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){[&](){aspectMask_json=member.aspectMask;}();}();}();
auto& baseMipLevel_json=json["baseMipLevel"];
[&](){baseMipLevel_json=member.baseMipLevel;}();
auto& levelCount_json=json["levelCount"];
[&](){levelCount_json=member.levelCount;}();
auto& baseArrayLayer_json=json["baseArrayLayer"];
[&](){baseArrayLayer_json=member.baseArrayLayer;}();
auto& layerCount_json=json["layerCount"];
[&](){layerCount_json=member.layerCount;}();
}
void deserialize_struct(boost::json::object& json, VkImageSubresourceRange& member){
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){int temp_srmSgxC;[&](){temp_srmSgxC=static_cast<int>(value_to<int>(aspectMask_json));}();member.aspectMask=(VkImageAspectFlags)temp_srmSgxC;}();}();
auto& baseMipLevel_json=json["baseMipLevel"];
[&](){member.baseMipLevel=static_cast<uint32_t>(value_to<int>(baseMipLevel_json));}();
auto& levelCount_json=json["levelCount"];
[&](){member.levelCount=static_cast<uint32_t>(value_to<int>(levelCount_json));}();
auto& baseArrayLayer_json=json["baseArrayLayer"];
[&](){member.baseArrayLayer=static_cast<uint32_t>(value_to<int>(baseArrayLayer_json));}();
auto& layerCount_json=json["layerCount"];
[&](){member.layerCount=static_cast<uint32_t>(value_to<int>(layerCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryBarrier& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){[&](){srcAccessMask_json=member.srcAccessMask;}();}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){[&](){dstAccessMask_json=member.dstAccessMask;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkMemoryBarrier& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){int temp_YMhhQIt;[&](){temp_YMhhQIt=static_cast<int>(value_to<int>(srcAccessMask_json));}();member.srcAccessMask=(VkAccessFlags)temp_YMhhQIt;}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){int temp_cyeCcOP;[&](){temp_cyeCcOP=static_cast<int>(value_to<int>(dstAccessMask_json));}();member.dstAccessMask=(VkAccessFlags)temp_cyeCcOP;}();}();
}

    void serialize_struct(boost::json::object& json, const VkBufferMemoryBarrier& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){[&](){srcAccessMask_json=member.srcAccessMask;}();}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){[&](){dstAccessMask_json=member.dstAccessMask;}();}();}();
auto& srcQueueFamilyIndex_json=json["srcQueueFamilyIndex"];
[&](){srcQueueFamilyIndex_json=member.srcQueueFamilyIndex;}();
auto& dstQueueFamilyIndex_json=json["dstQueueFamilyIndex"];
[&](){dstQueueFamilyIndex_json=member.dstQueueFamilyIndex;}();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkBufferMemoryBarrier& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){int temp_YMhhQIt;[&](){temp_YMhhQIt=static_cast<int>(value_to<int>(srcAccessMask_json));}();member.srcAccessMask=(VkAccessFlags)temp_YMhhQIt;}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){int temp_cyeCcOP;[&](){temp_cyeCcOP=static_cast<int>(value_to<int>(dstAccessMask_json));}();member.dstAccessMask=(VkAccessFlags)temp_cyeCcOP;}();}();
auto& srcQueueFamilyIndex_json=json["srcQueueFamilyIndex"];
[&](){member.srcQueueFamilyIndex=static_cast<uint32_t>(value_to<int>(srcQueueFamilyIndex_json));}();
auto& dstQueueFamilyIndex_json=json["dstQueueFamilyIndex"];
[&](){member.dstQueueFamilyIndex=static_cast<uint32_t>(value_to<int>(dstQueueFamilyIndex_json));}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkImageMemoryBarrier& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){[&](){srcAccessMask_json=member.srcAccessMask;}();}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){[&](){dstAccessMask_json=member.dstAccessMask;}();}();}();
auto& oldLayout_json=json["oldLayout"];
[&](){[&](){[&](){oldLayout_json=member.oldLayout;}();}();}();
auto& newLayout_json=json["newLayout"];
[&](){[&](){[&](){newLayout_json=member.newLayout;}();}();}();
auto& srcQueueFamilyIndex_json=json["srcQueueFamilyIndex"];
[&](){srcQueueFamilyIndex_json=member.srcQueueFamilyIndex;}();
auto& dstQueueFamilyIndex_json=json["dstQueueFamilyIndex"];
[&](){dstQueueFamilyIndex_json=member.dstQueueFamilyIndex;}();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
auto& subresourceRange_json=json["subresourceRange"];
[&](){
            auto& temp=subresourceRange_json.emplace_object();
            return serialize_struct(temp, member.subresourceRange);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageMemoryBarrier& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){int temp_YMhhQIt;[&](){temp_YMhhQIt=static_cast<int>(value_to<int>(srcAccessMask_json));}();member.srcAccessMask=(VkAccessFlags)temp_YMhhQIt;}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){int temp_cyeCcOP;[&](){temp_cyeCcOP=static_cast<int>(value_to<int>(dstAccessMask_json));}();member.dstAccessMask=(VkAccessFlags)temp_cyeCcOP;}();}();
auto& oldLayout_json=json["oldLayout"];
[&](){[&](){int temp_IxSclWO;[&](){temp_IxSclWO=static_cast<int>(value_to<int>(oldLayout_json));}();member.oldLayout=(VkImageLayout)temp_IxSclWO;}();}();
auto& newLayout_json=json["newLayout"];
[&](){[&](){int temp_oJsXEmm;[&](){temp_oJsXEmm=static_cast<int>(value_to<int>(newLayout_json));}();member.newLayout=(VkImageLayout)temp_oJsXEmm;}();}();
auto& srcQueueFamilyIndex_json=json["srcQueueFamilyIndex"];
[&](){member.srcQueueFamilyIndex=static_cast<uint32_t>(value_to<int>(srcQueueFamilyIndex_json));}();
auto& dstQueueFamilyIndex_json=json["dstQueueFamilyIndex"];
[&](){member.dstQueueFamilyIndex=static_cast<uint32_t>(value_to<int>(dstQueueFamilyIndex_json));}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
auto& subresourceRange_json=json["subresourceRange"];
[&](){
            auto& temp=subresourceRange_json.as_object();
            deserialize_struct(temp,member.subresourceRange);
            }();
}

    void serialize_struct(boost::json::object& json, const VkImageCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& imageType_json=json["imageType"];
[&](){[&](){[&](){imageType_json=member.imageType;}();}();}();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.emplace_object();
            return serialize_struct(temp, member.extent);
            }();
auto& mipLevels_json=json["mipLevels"];
[&](){mipLevels_json=member.mipLevels;}();
auto& arrayLayers_json=json["arrayLayers"];
[&](){arrayLayers_json=member.arrayLayers;}();
auto& samples_json=json["samples"];
[&](){[&](){[&](){samples_json=member.samples;}();}();}();
auto& tiling_json=json["tiling"];
[&](){[&](){[&](){tiling_json=member.tiling;}();}();}();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
auto& sharingMode_json=json["sharingMode"];
[&](){[&](){[&](){sharingMode_json=member.sharingMode;}();}();}();
auto& queueFamilyIndexCount_json=json["queueFamilyIndexCount"];
[&](){queueFamilyIndexCount_json=member.queueFamilyIndexCount;}();
auto& pQueueFamilyIndices_json=json["pQueueFamilyIndices"];
[&](){
            if (member.pQueueFamilyIndices==NULL){
                pQueueFamilyIndices_json=boost::json::array();
            return; }pQueueFamilyIndices_json=boost::json::array(member.queueFamilyIndexCount);
        auto& arr_miZGtyX=pQueueFamilyIndices_json.as_array();
        for(int VJZTqbB=0; VJZTqbB < member.queueFamilyIndexCount; VJZTqbB++){
            [&](){arr_miZGtyX[VJZTqbB]=member.pQueueFamilyIndices[VJZTqbB];}();
        }
        }();
auto& initialLayout_json=json["initialLayout"];
[&](){[&](){[&](){initialLayout_json=member.initialLayout;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkImageCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_gikCMkV;[&](){temp_gikCMkV=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkImageCreateFlags)temp_gikCMkV;}();}();
auto& imageType_json=json["imageType"];
[&](){[&](){int temp_ORiRUzB;[&](){temp_ORiRUzB=static_cast<int>(value_to<int>(imageType_json));}();member.imageType=(VkImageType)temp_ORiRUzB;}();}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.as_object();
            deserialize_struct(temp,member.extent);
            }();
auto& mipLevels_json=json["mipLevels"];
[&](){member.mipLevels=static_cast<uint32_t>(value_to<int>(mipLevels_json));}();
auto& arrayLayers_json=json["arrayLayers"];
[&](){member.arrayLayers=static_cast<uint32_t>(value_to<int>(arrayLayers_json));}();
auto& samples_json=json["samples"];
[&](){[&](){int temp_HAQfesR;[&](){temp_HAQfesR=static_cast<int>(value_to<int>(samples_json));}();member.samples=(VkSampleCountFlagBits)temp_HAQfesR;}();}();
auto& tiling_json=json["tiling"];
[&](){[&](){int temp_ldSxudR;[&](){temp_ldSxudR=static_cast<int>(value_to<int>(tiling_json));}();member.tiling=(VkImageTiling)temp_ldSxudR;}();}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_FIcOdeK;[&](){temp_FIcOdeK=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkImageUsageFlags)temp_FIcOdeK;}();}();
auto& sharingMode_json=json["sharingMode"];
[&](){[&](){int temp_lEqLxkW;[&](){temp_lEqLxkW=static_cast<int>(value_to<int>(sharingMode_json));}();member.sharingMode=(VkSharingMode)temp_lEqLxkW;}();}();
auto& queueFamilyIndexCount_json=json["queueFamilyIndexCount"];
[&](){member.queueFamilyIndexCount=static_cast<uint32_t>(value_to<int>(queueFamilyIndexCount_json));}();
auto& pQueueFamilyIndices_json=json["pQueueFamilyIndices"];
[&](){ uint32_t* temp_RQIKvOJ;;[&](){
            if (pQueueFamilyIndices_json.as_array().size()==0){
                temp_RQIKvOJ=NULL;
            return; }temp_RQIKvOJ=(uint32_t*)malloc(member.queueFamilyIndexCount*sizeof(uint32_t));
        auto& arr_PLMLiyU=pQueueFamilyIndices_json.as_array();
        for(int CXBfdQH=0; CXBfdQH < member.queueFamilyIndexCount; CXBfdQH++){
            [&](){temp_RQIKvOJ[CXBfdQH]=static_cast<uint32_t>(value_to<int>(arr_PLMLiyU[CXBfdQH]));}();
        }
        }();member.pQueueFamilyIndices=temp_RQIKvOJ;}();
auto& initialLayout_json=json["initialLayout"];
[&](){[&](){int temp_TsZaHzS;[&](){temp_TsZaHzS=static_cast<int>(value_to<int>(initialLayout_json));}();member.initialLayout=(VkImageLayout)temp_TsZaHzS;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSubresourceLayout& member){
        
    
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& rowPitch_json=json["rowPitch"];
[&](){[&](){rowPitch_json=member.rowPitch;}();}();
auto& arrayPitch_json=json["arrayPitch"];
[&](){[&](){arrayPitch_json=member.arrayPitch;}();}();
auto& depthPitch_json=json["depthPitch"];
[&](){[&](){depthPitch_json=member.depthPitch;}();}();
}
void deserialize_struct(boost::json::object& json, VkSubresourceLayout& member){
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& rowPitch_json=json["rowPitch"];
[&](){uint64_t temp_mRLzfZk;[&](){temp_mRLzfZk=static_cast<uint64_t>(value_to<int>(rowPitch_json));}();member.rowPitch=(VkDeviceSize)temp_mRLzfZk;}();
auto& arrayPitch_json=json["arrayPitch"];
[&](){uint64_t temp_ehTFOuC;[&](){temp_ehTFOuC=static_cast<uint64_t>(value_to<int>(arrayPitch_json));}();member.arrayPitch=(VkDeviceSize)temp_ehTFOuC;}();
auto& depthPitch_json=json["depthPitch"];
[&](){uint64_t temp_IsTySIN;[&](){temp_IsTySIN=static_cast<uint64_t>(value_to<int>(depthPitch_json));}();member.depthPitch=(VkDeviceSize)temp_IsTySIN;}();
}

    void serialize_struct(boost::json::object& json, const VkImageViewCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
auto& viewType_json=json["viewType"];
[&](){[&](){[&](){viewType_json=member.viewType;}();}();}();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& components_json=json["components"];
[&](){
            auto& temp=components_json.emplace_object();
            return serialize_struct(temp, member.components);
            }();
auto& subresourceRange_json=json["subresourceRange"];
[&](){
            auto& temp=subresourceRange_json.emplace_object();
            return serialize_struct(temp, member.subresourceRange);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageViewCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_lvQwThL;[&](){temp_lvQwThL=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkImageViewCreateFlags)temp_lvQwThL;}();}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
auto& viewType_json=json["viewType"];
[&](){[&](){int temp_PiSyPUi;[&](){temp_PiSyPUi=static_cast<int>(value_to<int>(viewType_json));}();member.viewType=(VkImageViewType)temp_PiSyPUi;}();}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& components_json=json["components"];
[&](){
            auto& temp=components_json.as_object();
            deserialize_struct(temp,member.components);
            }();
auto& subresourceRange_json=json["subresourceRange"];
[&](){
            auto& temp=subresourceRange_json.as_object();
            deserialize_struct(temp,member.subresourceRange);
            }();
}

    void serialize_struct(boost::json::object& json, const VkBufferCopy& member){
        
    
auto& srcOffset_json=json["srcOffset"];
[&](){[&](){srcOffset_json=member.srcOffset;}();}();
auto& dstOffset_json=json["dstOffset"];
[&](){[&](){dstOffset_json=member.dstOffset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkBufferCopy& member){
auto& srcOffset_json=json["srcOffset"];
[&](){uint64_t temp_jpKCFAb;[&](){temp_jpKCFAb=static_cast<uint64_t>(value_to<int>(srcOffset_json));}();member.srcOffset=(VkDeviceSize)temp_jpKCFAb;}();
auto& dstOffset_json=json["dstOffset"];
[&](){uint64_t temp_krGwneR;[&](){temp_krGwneR=static_cast<uint64_t>(value_to<int>(dstOffset_json));}();member.dstOffset=(VkDeviceSize)temp_krGwneR;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkSparseMemoryBind& member){
        
    
auto& resourceOffset_json=json["resourceOffset"];
[&](){[&](){resourceOffset_json=member.resourceOffset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){[&](){memoryOffset_json=member.memoryOffset;}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSparseMemoryBind& member){
auto& resourceOffset_json=json["resourceOffset"];
[&](){uint64_t temp_nRyUORt;[&](){temp_nRyUORt=static_cast<uint64_t>(value_to<int>(resourceOffset_json));}();member.resourceOffset=(VkDeviceSize)temp_nRyUORt;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){uint64_t temp_VWSGqtD;[&](){temp_VWSGqtD=static_cast<uint64_t>(value_to<int>(memoryOffset_json));}();member.memoryOffset=(VkDeviceSize)temp_VWSGqtD;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_YjsJfos;[&](){temp_YjsJfos=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSparseMemoryBindFlags)temp_YjsJfos;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSparseImageMemoryBind& member){
        
    
auto& subresource_json=json["subresource"];
[&](){
            auto& temp=subresource_json.emplace_object();
            return serialize_struct(temp, member.subresource);
            }();
auto& offset_json=json["offset"];
[&](){
            auto& temp=offset_json.emplace_object();
            return serialize_struct(temp, member.offset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.emplace_object();
            return serialize_struct(temp, member.extent);
            }();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){[&](){memoryOffset_json=member.memoryOffset;}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSparseImageMemoryBind& member){
auto& subresource_json=json["subresource"];
[&](){
            auto& temp=subresource_json.as_object();
            deserialize_struct(temp,member.subresource);
            }();
auto& offset_json=json["offset"];
[&](){
            auto& temp=offset_json.as_object();
            deserialize_struct(temp,member.offset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.as_object();
            deserialize_struct(temp,member.extent);
            }();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){uint64_t temp_VWSGqtD;[&](){temp_VWSGqtD=static_cast<uint64_t>(value_to<int>(memoryOffset_json));}();member.memoryOffset=(VkDeviceSize)temp_VWSGqtD;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_YjsJfos;[&](){temp_YjsJfos=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSparseMemoryBindFlags)temp_YjsJfos;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSparseBufferMemoryBindInfo& member){
        
    
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& bindCount_json=json["bindCount"];
[&](){bindCount_json=member.bindCount;}();
auto& pBinds_json=json["pBinds"];
[&](){
            if (member.pBinds==NULL){
                pBinds_json=boost::json::array();
            return; }pBinds_json=boost::json::array(member.bindCount);
        auto& arr_lMooBUR=pBinds_json.as_array();
        for(int BPPAqwp=0; BPPAqwp < member.bindCount; BPPAqwp++){
            [&](){
            auto& temp=arr_lMooBUR[BPPAqwp].emplace_object();
            return serialize_struct(temp, member.pBinds[BPPAqwp]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSparseBufferMemoryBindInfo& member){
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& bindCount_json=json["bindCount"];
[&](){member.bindCount=static_cast<uint32_t>(value_to<int>(bindCount_json));}();
auto& pBinds_json=json["pBinds"];
[&](){ VkSparseMemoryBind* temp_ZDFEyZs;;[&](){
            if (pBinds_json.as_array().size()==0){
                temp_ZDFEyZs=NULL;
            return; }temp_ZDFEyZs=(VkSparseMemoryBind*)malloc(member.bindCount*sizeof(VkSparseMemoryBind));
        auto& arr_UBnYCQc=pBinds_json.as_array();
        for(int bXrCqBg=0; bXrCqBg < member.bindCount; bXrCqBg++){
            [&](){
            auto& temp=arr_UBnYCQc[bXrCqBg].as_object();
            deserialize_struct(temp,temp_ZDFEyZs[bXrCqBg]);
            }();
        }
        }();member.pBinds=temp_ZDFEyZs;}();
}

    void serialize_struct(boost::json::object& json, const VkSparseImageOpaqueMemoryBindInfo& member){
        
    
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
auto& bindCount_json=json["bindCount"];
[&](){bindCount_json=member.bindCount;}();
auto& pBinds_json=json["pBinds"];
[&](){
            if (member.pBinds==NULL){
                pBinds_json=boost::json::array();
            return; }pBinds_json=boost::json::array(member.bindCount);
        auto& arr_lMooBUR=pBinds_json.as_array();
        for(int BPPAqwp=0; BPPAqwp < member.bindCount; BPPAqwp++){
            [&](){
            auto& temp=arr_lMooBUR[BPPAqwp].emplace_object();
            return serialize_struct(temp, member.pBinds[BPPAqwp]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSparseImageOpaqueMemoryBindInfo& member){
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
auto& bindCount_json=json["bindCount"];
[&](){member.bindCount=static_cast<uint32_t>(value_to<int>(bindCount_json));}();
auto& pBinds_json=json["pBinds"];
[&](){ VkSparseMemoryBind* temp_ZDFEyZs;;[&](){
            if (pBinds_json.as_array().size()==0){
                temp_ZDFEyZs=NULL;
            return; }temp_ZDFEyZs=(VkSparseMemoryBind*)malloc(member.bindCount*sizeof(VkSparseMemoryBind));
        auto& arr_UBnYCQc=pBinds_json.as_array();
        for(int bXrCqBg=0; bXrCqBg < member.bindCount; bXrCqBg++){
            [&](){
            auto& temp=arr_UBnYCQc[bXrCqBg].as_object();
            deserialize_struct(temp,temp_ZDFEyZs[bXrCqBg]);
            }();
        }
        }();member.pBinds=temp_ZDFEyZs;}();
}

    void serialize_struct(boost::json::object& json, const VkSparseImageMemoryBindInfo& member){
        
    
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
auto& bindCount_json=json["bindCount"];
[&](){bindCount_json=member.bindCount;}();
auto& pBinds_json=json["pBinds"];
[&](){
            if (member.pBinds==NULL){
                pBinds_json=boost::json::array();
            return; }pBinds_json=boost::json::array(member.bindCount);
        auto& arr_mRRaRZD=pBinds_json.as_array();
        for(int ThKtLXw=0; ThKtLXw < member.bindCount; ThKtLXw++){
            [&](){
            auto& temp=arr_mRRaRZD[ThKtLXw].emplace_object();
            return serialize_struct(temp, member.pBinds[ThKtLXw]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSparseImageMemoryBindInfo& member){
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
auto& bindCount_json=json["bindCount"];
[&](){member.bindCount=static_cast<uint32_t>(value_to<int>(bindCount_json));}();
auto& pBinds_json=json["pBinds"];
[&](){ VkSparseImageMemoryBind* temp_DDjbXaN;;[&](){
            if (pBinds_json.as_array().size()==0){
                temp_DDjbXaN=NULL;
            return; }temp_DDjbXaN=(VkSparseImageMemoryBind*)malloc(member.bindCount*sizeof(VkSparseImageMemoryBind));
        auto& arr_njcMzwm=pBinds_json.as_array();
        for(int binVMVh=0; binVMVh < member.bindCount; binVMVh++){
            [&](){
            auto& temp=arr_njcMzwm[binVMVh].as_object();
            deserialize_struct(temp,temp_DDjbXaN[binVMVh]);
            }();
        }
        }();member.pBinds=temp_DDjbXaN;}();
}

    void serialize_struct(boost::json::object& json, const VkBindSparseInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& waitSemaphoreCount_json=json["waitSemaphoreCount"];
[&](){waitSemaphoreCount_json=member.waitSemaphoreCount;}();
auto& pWaitSemaphores_json=json["pWaitSemaphores"];
[&](){
            if (member.pWaitSemaphores==NULL){
                pWaitSemaphores_json=boost::json::array();
            return; }pWaitSemaphores_json=boost::json::array(member.waitSemaphoreCount);
        auto& arr_AxVizBE=pWaitSemaphores_json.as_array();
        for(int XBpvDer=0; XBpvDer < member.waitSemaphoreCount; XBpvDer++){
            [&](){serialize_VkSemaphore(arr_AxVizBE[XBpvDer],member.pWaitSemaphores[XBpvDer]);}();
        }
        }();
auto& bufferBindCount_json=json["bufferBindCount"];
[&](){bufferBindCount_json=member.bufferBindCount;}();
auto& pBufferBinds_json=json["pBufferBinds"];
[&](){
            if (member.pBufferBinds==NULL){
                pBufferBinds_json=boost::json::array();
            return; }pBufferBinds_json=boost::json::array(member.bufferBindCount);
        auto& arr_GgaLeag=pBufferBinds_json.as_array();
        for(int pwrymEJ=0; pwrymEJ < member.bufferBindCount; pwrymEJ++){
            [&](){
            auto& temp=arr_GgaLeag[pwrymEJ].emplace_object();
            return serialize_struct(temp, member.pBufferBinds[pwrymEJ]);
            }();
        }
        }();
auto& imageOpaqueBindCount_json=json["imageOpaqueBindCount"];
[&](){imageOpaqueBindCount_json=member.imageOpaqueBindCount;}();
auto& pImageOpaqueBinds_json=json["pImageOpaqueBinds"];
[&](){
            if (member.pImageOpaqueBinds==NULL){
                pImageOpaqueBinds_json=boost::json::array();
            return; }pImageOpaqueBinds_json=boost::json::array(member.imageOpaqueBindCount);
        auto& arr_uxLuNbq=pImageOpaqueBinds_json.as_array();
        for(int HfKQHJK=0; HfKQHJK < member.imageOpaqueBindCount; HfKQHJK++){
            [&](){
            auto& temp=arr_uxLuNbq[HfKQHJK].emplace_object();
            return serialize_struct(temp, member.pImageOpaqueBinds[HfKQHJK]);
            }();
        }
        }();
auto& imageBindCount_json=json["imageBindCount"];
[&](){imageBindCount_json=member.imageBindCount;}();
auto& pImageBinds_json=json["pImageBinds"];
[&](){
            if (member.pImageBinds==NULL){
                pImageBinds_json=boost::json::array();
            return; }pImageBinds_json=boost::json::array(member.imageBindCount);
        auto& arr_DFKvcex=pImageBinds_json.as_array();
        for(int amSYQzr=0; amSYQzr < member.imageBindCount; amSYQzr++){
            [&](){
            auto& temp=arr_DFKvcex[amSYQzr].emplace_object();
            return serialize_struct(temp, member.pImageBinds[amSYQzr]);
            }();
        }
        }();
auto& signalSemaphoreCount_json=json["signalSemaphoreCount"];
[&](){signalSemaphoreCount_json=member.signalSemaphoreCount;}();
auto& pSignalSemaphores_json=json["pSignalSemaphores"];
[&](){
            if (member.pSignalSemaphores==NULL){
                pSignalSemaphores_json=boost::json::array();
            return; }pSignalSemaphores_json=boost::json::array(member.signalSemaphoreCount);
        auto& arr_wTKZAbP=pSignalSemaphores_json.as_array();
        for(int zRpxMAc=0; zRpxMAc < member.signalSemaphoreCount; zRpxMAc++){
            [&](){serialize_VkSemaphore(arr_wTKZAbP[zRpxMAc],member.pSignalSemaphores[zRpxMAc]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkBindSparseInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& waitSemaphoreCount_json=json["waitSemaphoreCount"];
[&](){member.waitSemaphoreCount=static_cast<uint32_t>(value_to<int>(waitSemaphoreCount_json));}();
auto& pWaitSemaphores_json=json["pWaitSemaphores"];
[&](){ VkSemaphore* temp_ZOgWazs;;[&](){
            if (pWaitSemaphores_json.as_array().size()==0){
                temp_ZOgWazs=NULL;
            return; }temp_ZOgWazs=(VkSemaphore*)malloc(member.waitSemaphoreCount*sizeof(VkSemaphore));
        auto& arr_EtUHlJM=pWaitSemaphores_json.as_array();
        for(int JgknMrE=0; JgknMrE < member.waitSemaphoreCount; JgknMrE++){
            [&](){deserialize_VkSemaphore(arr_EtUHlJM[JgknMrE], temp_ZOgWazs[JgknMrE]);}();
        }
        }();member.pWaitSemaphores=temp_ZOgWazs;}();
auto& bufferBindCount_json=json["bufferBindCount"];
[&](){member.bufferBindCount=static_cast<uint32_t>(value_to<int>(bufferBindCount_json));}();
auto& pBufferBinds_json=json["pBufferBinds"];
[&](){ VkSparseBufferMemoryBindInfo* temp_qkvesWQ;;[&](){
            if (pBufferBinds_json.as_array().size()==0){
                temp_qkvesWQ=NULL;
            return; }temp_qkvesWQ=(VkSparseBufferMemoryBindInfo*)malloc(member.bufferBindCount*sizeof(VkSparseBufferMemoryBindInfo));
        auto& arr_CrEqlwm=pBufferBinds_json.as_array();
        for(int KdaOVBS=0; KdaOVBS < member.bufferBindCount; KdaOVBS++){
            [&](){
            auto& temp=arr_CrEqlwm[KdaOVBS].as_object();
            deserialize_struct(temp,temp_qkvesWQ[KdaOVBS]);
            }();
        }
        }();member.pBufferBinds=temp_qkvesWQ;}();
auto& imageOpaqueBindCount_json=json["imageOpaqueBindCount"];
[&](){member.imageOpaqueBindCount=static_cast<uint32_t>(value_to<int>(imageOpaqueBindCount_json));}();
auto& pImageOpaqueBinds_json=json["pImageOpaqueBinds"];
[&](){ VkSparseImageOpaqueMemoryBindInfo* temp_wiJxVSu;;[&](){
            if (pImageOpaqueBinds_json.as_array().size()==0){
                temp_wiJxVSu=NULL;
            return; }temp_wiJxVSu=(VkSparseImageOpaqueMemoryBindInfo*)malloc(member.imageOpaqueBindCount*sizeof(VkSparseImageOpaqueMemoryBindInfo));
        auto& arr_mbcOQmp=pImageOpaqueBinds_json.as_array();
        for(int wdnpJuy=0; wdnpJuy < member.imageOpaqueBindCount; wdnpJuy++){
            [&](){
            auto& temp=arr_mbcOQmp[wdnpJuy].as_object();
            deserialize_struct(temp,temp_wiJxVSu[wdnpJuy]);
            }();
        }
        }();member.pImageOpaqueBinds=temp_wiJxVSu;}();
auto& imageBindCount_json=json["imageBindCount"];
[&](){member.imageBindCount=static_cast<uint32_t>(value_to<int>(imageBindCount_json));}();
auto& pImageBinds_json=json["pImageBinds"];
[&](){ VkSparseImageMemoryBindInfo* temp_CytLcVW;;[&](){
            if (pImageBinds_json.as_array().size()==0){
                temp_CytLcVW=NULL;
            return; }temp_CytLcVW=(VkSparseImageMemoryBindInfo*)malloc(member.imageBindCount*sizeof(VkSparseImageMemoryBindInfo));
        auto& arr_VJMqqjF=pImageBinds_json.as_array();
        for(int eOwdePd=0; eOwdePd < member.imageBindCount; eOwdePd++){
            [&](){
            auto& temp=arr_VJMqqjF[eOwdePd].as_object();
            deserialize_struct(temp,temp_CytLcVW[eOwdePd]);
            }();
        }
        }();member.pImageBinds=temp_CytLcVW;}();
auto& signalSemaphoreCount_json=json["signalSemaphoreCount"];
[&](){member.signalSemaphoreCount=static_cast<uint32_t>(value_to<int>(signalSemaphoreCount_json));}();
auto& pSignalSemaphores_json=json["pSignalSemaphores"];
[&](){ VkSemaphore* temp_mrerffy;;[&](){
            if (pSignalSemaphores_json.as_array().size()==0){
                temp_mrerffy=NULL;
            return; }temp_mrerffy=(VkSemaphore*)malloc(member.signalSemaphoreCount*sizeof(VkSemaphore));
        auto& arr_UVSUapF=pSignalSemaphores_json.as_array();
        for(int ZmOmQdZ=0; ZmOmQdZ < member.signalSemaphoreCount; ZmOmQdZ++){
            [&](){deserialize_VkSemaphore(arr_UVSUapF[ZmOmQdZ], temp_mrerffy[ZmOmQdZ]);}();
        }
        }();member.pSignalSemaphores=temp_mrerffy;}();
}

    void serialize_struct(boost::json::object& json, const VkImageCopy& member){
        
    
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.emplace_object();
            return serialize_struct(temp, member.srcSubresource);
            }();
auto& srcOffset_json=json["srcOffset"];
[&](){
            auto& temp=srcOffset_json.emplace_object();
            return serialize_struct(temp, member.srcOffset);
            }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.emplace_object();
            return serialize_struct(temp, member.dstSubresource);
            }();
auto& dstOffset_json=json["dstOffset"];
[&](){
            auto& temp=dstOffset_json.emplace_object();
            return serialize_struct(temp, member.dstOffset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.emplace_object();
            return serialize_struct(temp, member.extent);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageCopy& member){
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.as_object();
            deserialize_struct(temp,member.srcSubresource);
            }();
auto& srcOffset_json=json["srcOffset"];
[&](){
            auto& temp=srcOffset_json.as_object();
            deserialize_struct(temp,member.srcOffset);
            }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.as_object();
            deserialize_struct(temp,member.dstSubresource);
            }();
auto& dstOffset_json=json["dstOffset"];
[&](){
            auto& temp=dstOffset_json.as_object();
            deserialize_struct(temp,member.dstOffset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.as_object();
            deserialize_struct(temp,member.extent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkImageBlit& member){
        
    
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.emplace_object();
            return serialize_struct(temp, member.srcSubresource);
            }();
auto& srcOffsets_json=json["srcOffsets"];
[&](){srcOffsets_json=boost::json::array(2);
        auto& arr_HKFUgIx=srcOffsets_json.as_array();
        for(int cffHdsm=0; cffHdsm < 2; cffHdsm++){
            [&](){
            auto& temp=arr_HKFUgIx[cffHdsm].emplace_object();
            return serialize_struct(temp, member.srcOffsets[cffHdsm]);
            }();
        }
        }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.emplace_object();
            return serialize_struct(temp, member.dstSubresource);
            }();
auto& dstOffsets_json=json["dstOffsets"];
[&](){dstOffsets_json=boost::json::array(2);
        auto& arr_EYgKCdH=dstOffsets_json.as_array();
        for(int YmWWFoI=0; YmWWFoI < 2; YmWWFoI++){
            [&](){
            auto& temp=arr_EYgKCdH[YmWWFoI].emplace_object();
            return serialize_struct(temp, member.dstOffsets[YmWWFoI]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkImageBlit& member){
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.as_object();
            deserialize_struct(temp,member.srcSubresource);
            }();
auto& srcOffsets_json=json["srcOffsets"];
[&](){
        auto& arr_HKFUgIx=srcOffsets_json.as_array();
        for(int cffHdsm=0; cffHdsm < 2; cffHdsm++){
            [&](){
            auto& temp=arr_HKFUgIx[cffHdsm].as_object();
            deserialize_struct(temp,member.srcOffsets[cffHdsm]);
            }();
        }
        }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.as_object();
            deserialize_struct(temp,member.dstSubresource);
            }();
auto& dstOffsets_json=json["dstOffsets"];
[&](){
        auto& arr_EYgKCdH=dstOffsets_json.as_array();
        for(int YmWWFoI=0; YmWWFoI < 2; YmWWFoI++){
            [&](){
            auto& temp=arr_EYgKCdH[YmWWFoI].as_object();
            deserialize_struct(temp,member.dstOffsets[YmWWFoI]);
            }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkBufferImageCopy& member){
        
    
auto& bufferOffset_json=json["bufferOffset"];
[&](){[&](){bufferOffset_json=member.bufferOffset;}();}();
auto& bufferRowLength_json=json["bufferRowLength"];
[&](){bufferRowLength_json=member.bufferRowLength;}();
auto& bufferImageHeight_json=json["bufferImageHeight"];
[&](){bufferImageHeight_json=member.bufferImageHeight;}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.emplace_object();
            return serialize_struct(temp, member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.emplace_object();
            return serialize_struct(temp, member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.emplace_object();
            return serialize_struct(temp, member.imageExtent);
            }();
}
void deserialize_struct(boost::json::object& json, VkBufferImageCopy& member){
auto& bufferOffset_json=json["bufferOffset"];
[&](){uint64_t temp_VmlvOye;[&](){temp_VmlvOye=static_cast<uint64_t>(value_to<int>(bufferOffset_json));}();member.bufferOffset=(VkDeviceSize)temp_VmlvOye;}();
auto& bufferRowLength_json=json["bufferRowLength"];
[&](){member.bufferRowLength=static_cast<uint32_t>(value_to<int>(bufferRowLength_json));}();
auto& bufferImageHeight_json=json["bufferImageHeight"];
[&](){member.bufferImageHeight=static_cast<uint32_t>(value_to<int>(bufferImageHeight_json));}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.as_object();
            deserialize_struct(temp,member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.as_object();
            deserialize_struct(temp,member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.as_object();
            deserialize_struct(temp,member.imageExtent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkCopyMemoryIndirectCommandNV& member){
        
    
auto& srcAddress_json=json["srcAddress"];
[&](){[&](){srcAddress_json=member.srcAddress;}();}();
auto& dstAddress_json=json["dstAddress"];
[&](){[&](){dstAddress_json=member.dstAddress;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkCopyMemoryIndirectCommandNV& member){
auto& srcAddress_json=json["srcAddress"];
[&](){uint64_t temp_qCbCSnK;[&](){temp_qCbCSnK=static_cast<uint64_t>(value_to<int>(srcAddress_json));}();member.srcAddress=(VkDeviceAddress)temp_qCbCSnK;}();
auto& dstAddress_json=json["dstAddress"];
[&](){uint64_t temp_ownHFoz;[&](){temp_ownHFoz=static_cast<uint64_t>(value_to<int>(dstAddress_json));}();member.dstAddress=(VkDeviceAddress)temp_ownHFoz;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkCopyMemoryToImageIndirectCommandNV& member){
        
    
auto& srcAddress_json=json["srcAddress"];
[&](){[&](){srcAddress_json=member.srcAddress;}();}();
auto& bufferRowLength_json=json["bufferRowLength"];
[&](){bufferRowLength_json=member.bufferRowLength;}();
auto& bufferImageHeight_json=json["bufferImageHeight"];
[&](){bufferImageHeight_json=member.bufferImageHeight;}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.emplace_object();
            return serialize_struct(temp, member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.emplace_object();
            return serialize_struct(temp, member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.emplace_object();
            return serialize_struct(temp, member.imageExtent);
            }();
}
void deserialize_struct(boost::json::object& json, VkCopyMemoryToImageIndirectCommandNV& member){
auto& srcAddress_json=json["srcAddress"];
[&](){uint64_t temp_qCbCSnK;[&](){temp_qCbCSnK=static_cast<uint64_t>(value_to<int>(srcAddress_json));}();member.srcAddress=(VkDeviceAddress)temp_qCbCSnK;}();
auto& bufferRowLength_json=json["bufferRowLength"];
[&](){member.bufferRowLength=static_cast<uint32_t>(value_to<int>(bufferRowLength_json));}();
auto& bufferImageHeight_json=json["bufferImageHeight"];
[&](){member.bufferImageHeight=static_cast<uint32_t>(value_to<int>(bufferImageHeight_json));}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.as_object();
            deserialize_struct(temp,member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.as_object();
            deserialize_struct(temp,member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.as_object();
            deserialize_struct(temp,member.imageExtent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkImageResolve& member){
        
    
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.emplace_object();
            return serialize_struct(temp, member.srcSubresource);
            }();
auto& srcOffset_json=json["srcOffset"];
[&](){
            auto& temp=srcOffset_json.emplace_object();
            return serialize_struct(temp, member.srcOffset);
            }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.emplace_object();
            return serialize_struct(temp, member.dstSubresource);
            }();
auto& dstOffset_json=json["dstOffset"];
[&](){
            auto& temp=dstOffset_json.emplace_object();
            return serialize_struct(temp, member.dstOffset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.emplace_object();
            return serialize_struct(temp, member.extent);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageResolve& member){
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.as_object();
            deserialize_struct(temp,member.srcSubresource);
            }();
auto& srcOffset_json=json["srcOffset"];
[&](){
            auto& temp=srcOffset_json.as_object();
            deserialize_struct(temp,member.srcOffset);
            }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.as_object();
            deserialize_struct(temp,member.dstSubresource);
            }();
auto& dstOffset_json=json["dstOffset"];
[&](){
            auto& temp=dstOffset_json.as_object();
            deserialize_struct(temp,member.dstOffset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.as_object();
            deserialize_struct(temp,member.extent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkShaderModuleCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& codeSize_json=json["codeSize"];
[&](){codeSize_json=member.codeSize;}();
auto& pCode_json=json["pCode"];
[&](){
            if (member.pCode==NULL){
                pCode_json=boost::json::array();
            return; }pCode_json=boost::json::array(member.codeSize / 4);
        auto& arr_mBCUFUl=pCode_json.as_array();
        for(int bOevcKL=0; bOevcKL < member.codeSize / 4; bOevcKL++){
            [&](){arr_mBCUFUl[bOevcKL]=member.pCode[bOevcKL];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkShaderModuleCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_MMIssKC;[&](){temp_MMIssKC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkShaderModuleCreateFlags)temp_MMIssKC;}();}();
auto& codeSize_json=json["codeSize"];
[&](){member.codeSize=static_cast<size_t>(value_to<int>(codeSize_json));}();
auto& pCode_json=json["pCode"];
[&](){ uint32_t* temp_xkxDUDC;;[&](){
            if (pCode_json.as_array().size()==0){
                temp_xkxDUDC=NULL;
            return; }temp_xkxDUDC=(uint32_t*)malloc(member.codeSize / 4*sizeof(uint32_t));
        auto& arr_bHmPqVf=pCode_json.as_array();
        for(int jINECKB=0; jINECKB < member.codeSize / 4; jINECKB++){
            [&](){temp_xkxDUDC[jINECKB]=static_cast<uint32_t>(value_to<int>(arr_bHmPqVf[jINECKB]));}();
        }
        }();member.pCode=temp_xkxDUDC;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorSetLayoutBinding& member){
        
    
auto& binding_json=json["binding"];
[&](){binding_json=member.binding;}();
auto& descriptorType_json=json["descriptorType"];
[&](){[&](){[&](){descriptorType_json=member.descriptorType;}();}();}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){descriptorCount_json=member.descriptorCount;}();
auto& stageFlags_json=json["stageFlags"];
[&](){[&](){[&](){stageFlags_json=member.stageFlags;}();}();}();
auto& pImmutableSamplers_json=json["pImmutableSamplers"];
[&](){
            if (member.pImmutableSamplers==NULL){
                pImmutableSamplers_json=boost::json::array();
            return; }pImmutableSamplers_json=boost::json::array(member.descriptorCount);
        auto& arr_xcuoJXE=pImmutableSamplers_json.as_array();
        for(int jbnNzhV=0; jbnNzhV < member.descriptorCount; jbnNzhV++){
            [&](){serialize_VkSampler(arr_xcuoJXE[jbnNzhV],member.pImmutableSamplers[jbnNzhV]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDescriptorSetLayoutBinding& member){
auto& binding_json=json["binding"];
[&](){member.binding=static_cast<uint32_t>(value_to<int>(binding_json));}();
auto& descriptorType_json=json["descriptorType"];
[&](){[&](){int temp_LETzuZb;[&](){temp_LETzuZb=static_cast<int>(value_to<int>(descriptorType_json));}();member.descriptorType=(VkDescriptorType)temp_LETzuZb;}();}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){member.descriptorCount=static_cast<uint32_t>(value_to<int>(descriptorCount_json));}();
auto& stageFlags_json=json["stageFlags"];
[&](){[&](){int temp_JGpkxAd;[&](){temp_JGpkxAd=static_cast<int>(value_to<int>(stageFlags_json));}();member.stageFlags=(VkShaderStageFlags)temp_JGpkxAd;}();}();
auto& pImmutableSamplers_json=json["pImmutableSamplers"];
[&](){ VkSampler* temp_pgHLJcq;;[&](){
            if (pImmutableSamplers_json.as_array().size()==0){
                temp_pgHLJcq=NULL;
            return; }temp_pgHLJcq=(VkSampler*)malloc(member.descriptorCount*sizeof(VkSampler));
        auto& arr_bUzvmGQ=pImmutableSamplers_json.as_array();
        for(int hNLQkqU=0; hNLQkqU < member.descriptorCount; hNLQkqU++){
            [&](){deserialize_VkSampler(arr_bUzvmGQ[hNLQkqU], temp_pgHLJcq[hNLQkqU]);}();
        }
        }();member.pImmutableSamplers=temp_pgHLJcq;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorSetLayoutCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& bindingCount_json=json["bindingCount"];
[&](){bindingCount_json=member.bindingCount;}();
auto& pBindings_json=json["pBindings"];
[&](){
            if (member.pBindings==NULL){
                pBindings_json=boost::json::array();
            return; }pBindings_json=boost::json::array(member.bindingCount);
        auto& arr_nJbEkUh=pBindings_json.as_array();
        for(int AzgmBbR=0; AzgmBbR < member.bindingCount; AzgmBbR++){
            [&](){
            auto& temp=arr_nJbEkUh[AzgmBbR].emplace_object();
            return serialize_struct(temp, member.pBindings[AzgmBbR]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDescriptorSetLayoutCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_mLzjGTC;[&](){temp_mLzjGTC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDescriptorSetLayoutCreateFlags)temp_mLzjGTC;}();}();
auto& bindingCount_json=json["bindingCount"];
[&](){member.bindingCount=static_cast<uint32_t>(value_to<int>(bindingCount_json));}();
auto& pBindings_json=json["pBindings"];
[&](){ VkDescriptorSetLayoutBinding* temp_TbVSVjT;;[&](){
            if (pBindings_json.as_array().size()==0){
                temp_TbVSVjT=NULL;
            return; }temp_TbVSVjT=(VkDescriptorSetLayoutBinding*)malloc(member.bindingCount*sizeof(VkDescriptorSetLayoutBinding));
        auto& arr_DZNGHez=pBindings_json.as_array();
        for(int MnihnQQ=0; MnihnQQ < member.bindingCount; MnihnQQ++){
            [&](){
            auto& temp=arr_DZNGHez[MnihnQQ].as_object();
            deserialize_struct(temp,temp_TbVSVjT[MnihnQQ]);
            }();
        }
        }();member.pBindings=temp_TbVSVjT;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorPoolSize& member){
        
    
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){descriptorCount_json=member.descriptorCount;}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorPoolSize& member){
auto& type_json=json["type"];
[&](){[&](){int temp_FkFybSO;[&](){temp_FkFybSO=static_cast<int>(value_to<int>(type_json));}();member.type=(VkDescriptorType)temp_FkFybSO;}();}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){member.descriptorCount=static_cast<uint32_t>(value_to<int>(descriptorCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorPoolCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& maxSets_json=json["maxSets"];
[&](){maxSets_json=member.maxSets;}();
auto& poolSizeCount_json=json["poolSizeCount"];
[&](){poolSizeCount_json=member.poolSizeCount;}();
auto& pPoolSizes_json=json["pPoolSizes"];
[&](){
            if (member.pPoolSizes==NULL){
                pPoolSizes_json=boost::json::array();
            return; }pPoolSizes_json=boost::json::array(member.poolSizeCount);
        auto& arr_LuBsymd=pPoolSizes_json.as_array();
        for(int YQeezfi=0; YQeezfi < member.poolSizeCount; YQeezfi++){
            [&](){
            auto& temp=arr_LuBsymd[YQeezfi].emplace_object();
            return serialize_struct(temp, member.pPoolSizes[YQeezfi]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDescriptorPoolCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_rScDlsS;[&](){temp_rScDlsS=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDescriptorPoolCreateFlags)temp_rScDlsS;}();}();
auto& maxSets_json=json["maxSets"];
[&](){member.maxSets=static_cast<uint32_t>(value_to<int>(maxSets_json));}();
auto& poolSizeCount_json=json["poolSizeCount"];
[&](){member.poolSizeCount=static_cast<uint32_t>(value_to<int>(poolSizeCount_json));}();
auto& pPoolSizes_json=json["pPoolSizes"];
[&](){ VkDescriptorPoolSize* temp_KhRUzRC;;[&](){
            if (pPoolSizes_json.as_array().size()==0){
                temp_KhRUzRC=NULL;
            return; }temp_KhRUzRC=(VkDescriptorPoolSize*)malloc(member.poolSizeCount*sizeof(VkDescriptorPoolSize));
        auto& arr_QjtFdfQ=pPoolSizes_json.as_array();
        for(int dRaEfQt=0; dRaEfQt < member.poolSizeCount; dRaEfQt++){
            [&](){
            auto& temp=arr_QjtFdfQ[dRaEfQt].as_object();
            deserialize_struct(temp,temp_KhRUzRC[dRaEfQt]);
            }();
        }
        }();member.pPoolSizes=temp_KhRUzRC;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorSetAllocateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& descriptorPool_json=json["descriptorPool"];
[&](){serialize_VkDescriptorPool(descriptorPool_json,member.descriptorPool);}();
auto& descriptorSetCount_json=json["descriptorSetCount"];
[&](){descriptorSetCount_json=member.descriptorSetCount;}();
auto& pSetLayouts_json=json["pSetLayouts"];
[&](){
            if (member.pSetLayouts==NULL){
                pSetLayouts_json=boost::json::array();
            return; }pSetLayouts_json=boost::json::array(member.descriptorSetCount);
        auto& arr_zVMtIaT=pSetLayouts_json.as_array();
        for(int uklMdkt=0; uklMdkt < member.descriptorSetCount; uklMdkt++){
            [&](){serialize_VkDescriptorSetLayout(arr_zVMtIaT[uklMdkt],member.pSetLayouts[uklMdkt]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDescriptorSetAllocateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& descriptorPool_json=json["descriptorPool"];
[&](){deserialize_VkDescriptorPool(descriptorPool_json, member.descriptorPool);}();
auto& descriptorSetCount_json=json["descriptorSetCount"];
[&](){member.descriptorSetCount=static_cast<uint32_t>(value_to<int>(descriptorSetCount_json));}();
auto& pSetLayouts_json=json["pSetLayouts"];
[&](){ VkDescriptorSetLayout* temp_iRZFemZ;;[&](){
            if (pSetLayouts_json.as_array().size()==0){
                temp_iRZFemZ=NULL;
            return; }temp_iRZFemZ=(VkDescriptorSetLayout*)malloc(member.descriptorSetCount*sizeof(VkDescriptorSetLayout));
        auto& arr_KfikEjZ=pSetLayouts_json.as_array();
        for(int nDMuHRP=0; nDMuHRP < member.descriptorSetCount; nDMuHRP++){
            [&](){deserialize_VkDescriptorSetLayout(arr_KfikEjZ[nDMuHRP], temp_iRZFemZ[nDMuHRP]);}();
        }
        }();member.pSetLayouts=temp_iRZFemZ;}();
}

    void serialize_struct(boost::json::object& json, const VkSpecializationMapEntry& member){
        
    
auto& constantID_json=json["constantID"];
[&](){constantID_json=member.constantID;}();
auto& offset_json=json["offset"];
[&](){offset_json=member.offset;}();
auto& size_json=json["size"];
[&](){size_json=member.size;}();
}
void deserialize_struct(boost::json::object& json, VkSpecializationMapEntry& member){
auto& constantID_json=json["constantID"];
[&](){member.constantID=static_cast<uint32_t>(value_to<int>(constantID_json));}();
auto& offset_json=json["offset"];
[&](){member.offset=static_cast<uint32_t>(value_to<int>(offset_json));}();
auto& size_json=json["size"];
[&](){member.size=static_cast<size_t>(value_to<int>(size_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSpecializationInfo& member){
        
    
auto& mapEntryCount_json=json["mapEntryCount"];
[&](){mapEntryCount_json=member.mapEntryCount;}();
auto& pMapEntries_json=json["pMapEntries"];
[&](){
            if (member.pMapEntries==NULL){
                pMapEntries_json=boost::json::array();
            return; }pMapEntries_json=boost::json::array(member.mapEntryCount);
        auto& arr_yuDvmVn=pMapEntries_json.as_array();
        for(int kycorOP=0; kycorOP < member.mapEntryCount; kycorOP++){
            [&](){
            auto& temp=arr_yuDvmVn[kycorOP].emplace_object();
            return serialize_struct(temp, member.pMapEntries[kycorOP]);
            }();
        }
        }();
auto& dataSize_json=json["dataSize"];
[&](){dataSize_json=member.dataSize;}();
auto& pData_json=json["pData"];
[&](){
            if (member.pData==NULL){
                pData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pData))==NULL){
                pData_json=boost::json::array();
            return; }pData_json=boost::json::array(member.dataSize);
        auto& arr_cukaPTa=pData_json.as_array();
        for(int UqwNSOA=0; UqwNSOA < member.dataSize; UqwNSOA++){
            [&](){arr_cukaPTa[UqwNSOA]=((char*)(member.pData))[UqwNSOA];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkSpecializationInfo& member){
auto& mapEntryCount_json=json["mapEntryCount"];
[&](){member.mapEntryCount=static_cast<uint32_t>(value_to<int>(mapEntryCount_json));}();
auto& pMapEntries_json=json["pMapEntries"];
[&](){ VkSpecializationMapEntry* temp_pFvvwRp;;[&](){
            if (pMapEntries_json.as_array().size()==0){
                temp_pFvvwRp=NULL;
            return; }temp_pFvvwRp=(VkSpecializationMapEntry*)malloc(member.mapEntryCount*sizeof(VkSpecializationMapEntry));
        auto& arr_aRZWyfT=pMapEntries_json.as_array();
        for(int JWoFaOv=0; JWoFaOv < member.mapEntryCount; JWoFaOv++){
            [&](){
            auto& temp=arr_aRZWyfT[JWoFaOv].as_object();
            deserialize_struct(temp,temp_pFvvwRp[JWoFaOv]);
            }();
        }
        }();member.pMapEntries=temp_pFvvwRp;}();
auto& dataSize_json=json["dataSize"];
[&](){member.dataSize=static_cast<size_t>(value_to<int>(dataSize_json));}();
auto& pData_json=json["pData"];
[&](){ void* temp_rZvPbwc;;[&](){
            if (pData_json.as_array().size()==0){
                temp_rZvPbwc=NULL;
            return; }char* temp_qtCaFHh;[&](){
            if (pData_json.as_array().size()==0){
                temp_qtCaFHh=NULL;
            return; }temp_qtCaFHh=(char*)malloc(member.dataSize*sizeof(char));
        auto& arr_XpObFOU=pData_json.as_array();
        for(int tUplioR=0; tUplioR < member.dataSize; tUplioR++){
            [&](){temp_qtCaFHh[tUplioR]=static_cast<char>(value_to<int>(arr_XpObFOU[tUplioR]));}();
        }
        }();temp_rZvPbwc=temp_qtCaFHh;}();member.pData=temp_rZvPbwc;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineShaderStageCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& stage_json=json["stage"];
[&](){[&](){[&](){stage_json=member.stage;}();}();}();
auto& module_json=json["module"];
[&](){serialize_VkShaderModule(module_json,member.module);}();
auto& pName_json=json["pName"];
[&](){
            if (member.pName==NULL){
                pName_json=boost::json::array();
            return; }pName_json=boost::json::array(strlen(member.pName)+1);
        auto& arr_RNtEgHa=pName_json.as_array();
        for(int JRJzPhN=0; JRJzPhN < strlen(member.pName)+1; JRJzPhN++){
            [&](){arr_RNtEgHa[JRJzPhN]=member.pName[JRJzPhN];}();
        }
        }();
auto& pSpecializationInfo_json=json["pSpecializationInfo"];
[&](){
            if (member.pSpecializationInfo==NULL){
                pSpecializationInfo_json=boost::json::array();
            return; }pSpecializationInfo_json=boost::json::array(1);
        auto& arr_AfbichW=pSpecializationInfo_json.as_array();
        for(int lSuLhWh=0; lSuLhWh < 1; lSuLhWh++){
            [&](){
            auto& temp=arr_AfbichW[lSuLhWh].emplace_object();
            return serialize_struct(temp, member.pSpecializationInfo[lSuLhWh]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineShaderStageCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_ydzByks;[&](){temp_ydzByks=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineShaderStageCreateFlags)temp_ydzByks;}();}();
auto& stage_json=json["stage"];
[&](){[&](){int temp_IHUgemq;[&](){temp_IHUgemq=static_cast<int>(value_to<int>(stage_json));}();member.stage=(VkShaderStageFlagBits)temp_IHUgemq;}();}();
auto& module_json=json["module"];
[&](){deserialize_VkShaderModule(module_json, member.module);}();
auto& pName_json=json["pName"];
[&](){ char* temp_AzKgJNk;;[&](){
            if (pName_json.as_array().size()==0){
                temp_AzKgJNk=NULL;
            return; }temp_AzKgJNk=(char*)malloc(pName_json.as_array().size()*sizeof(char));
        auto& arr_SFTpFTT=pName_json.as_array();
        for(int zYvyZlQ=0; zYvyZlQ < pName_json.as_array().size(); zYvyZlQ++){
            [&](){temp_AzKgJNk[zYvyZlQ]=static_cast<char>(value_to<int>(arr_SFTpFTT[zYvyZlQ]));}();
        }
        }();member.pName=temp_AzKgJNk;}();
auto& pSpecializationInfo_json=json["pSpecializationInfo"];
[&](){ VkSpecializationInfo* temp_vphocRa;;[&](){
            if (pSpecializationInfo_json.as_array().size()==0){
                temp_vphocRa=NULL;
            return; }temp_vphocRa=(VkSpecializationInfo*)malloc(1*sizeof(VkSpecializationInfo));
        auto& arr_byhNwxk=pSpecializationInfo_json.as_array();
        for(int zWKlFhs=0; zWKlFhs < 1; zWKlFhs++){
            [&](){
            auto& temp=arr_byhNwxk[zWKlFhs].as_object();
            deserialize_struct(temp,temp_vphocRa[zWKlFhs]);
            }();
        }
        }();member.pSpecializationInfo=temp_vphocRa;}();
}

    void serialize_struct(boost::json::object& json, const VkComputePipelineCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& stage_json=json["stage"];
[&](){
            auto& temp=stage_json.emplace_object();
            return serialize_struct(temp, member.stage);
            }();
auto& layout_json=json["layout"];
[&](){serialize_VkPipelineLayout(layout_json,member.layout);}();
auto& basePipelineHandle_json=json["basePipelineHandle"];
[&](){serialize_VkPipeline(basePipelineHandle_json,member.basePipelineHandle);}();
auto& basePipelineIndex_json=json["basePipelineIndex"];
[&](){basePipelineIndex_json=member.basePipelineIndex;}();
}
void deserialize_struct(boost::json::object& json, VkComputePipelineCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_evbgLuC;[&](){temp_evbgLuC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCreateFlags)temp_evbgLuC;}();}();
auto& stage_json=json["stage"];
[&](){
            auto& temp=stage_json.as_object();
            deserialize_struct(temp,member.stage);
            }();
auto& layout_json=json["layout"];
[&](){deserialize_VkPipelineLayout(layout_json, member.layout);}();
auto& basePipelineHandle_json=json["basePipelineHandle"];
[&](){deserialize_VkPipeline(basePipelineHandle_json, member.basePipelineHandle);}();
auto& basePipelineIndex_json=json["basePipelineIndex"];
[&](){member.basePipelineIndex=static_cast<int32_t>(value_to<int>(basePipelineIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkComputePipelineIndirectBufferInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceAddress_json=json["deviceAddress"];
[&](){[&](){deviceAddress_json=member.deviceAddress;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& pipelineDeviceAddressCaptureReplay_json=json["pipelineDeviceAddressCaptureReplay"];
[&](){[&](){pipelineDeviceAddressCaptureReplay_json=member.pipelineDeviceAddressCaptureReplay;}();}();
}
void deserialize_struct(boost::json::object& json, VkComputePipelineIndirectBufferInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& deviceAddress_json=json["deviceAddress"];
[&](){uint64_t temp_JcebElc;[&](){temp_JcebElc=static_cast<uint64_t>(value_to<int>(deviceAddress_json));}();member.deviceAddress=(VkDeviceAddress)temp_JcebElc;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& pipelineDeviceAddressCaptureReplay_json=json["pipelineDeviceAddressCaptureReplay"];
[&](){uint64_t temp_GdgOMBc;[&](){temp_GdgOMBc=static_cast<uint64_t>(value_to<int>(pipelineDeviceAddressCaptureReplay_json));}();member.pipelineDeviceAddressCaptureReplay=(VkDeviceAddress)temp_GdgOMBc;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineCreateFlags2CreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineCreateFlags2CreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_NRrzoQK;[&](){temp_NRrzoQK=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCreateFlags2KHR)temp_NRrzoQK;}();}();
}

    void serialize_struct(boost::json::object& json, const VkVertexInputBindingDescription& member){
        
    
auto& binding_json=json["binding"];
[&](){binding_json=member.binding;}();
auto& stride_json=json["stride"];
[&](){stride_json=member.stride;}();
auto& inputRate_json=json["inputRate"];
[&](){[&](){[&](){inputRate_json=member.inputRate;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkVertexInputBindingDescription& member){
auto& binding_json=json["binding"];
[&](){member.binding=static_cast<uint32_t>(value_to<int>(binding_json));}();
auto& stride_json=json["stride"];
[&](){member.stride=static_cast<uint32_t>(value_to<int>(stride_json));}();
auto& inputRate_json=json["inputRate"];
[&](){[&](){int temp_fqvaWJZ;[&](){temp_fqvaWJZ=static_cast<int>(value_to<int>(inputRate_json));}();member.inputRate=(VkVertexInputRate)temp_fqvaWJZ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkVertexInputAttributeDescription& member){
        
    
auto& location_json=json["location"];
[&](){location_json=member.location;}();
auto& binding_json=json["binding"];
[&](){binding_json=member.binding;}();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& offset_json=json["offset"];
[&](){offset_json=member.offset;}();
}
void deserialize_struct(boost::json::object& json, VkVertexInputAttributeDescription& member){
auto& location_json=json["location"];
[&](){member.location=static_cast<uint32_t>(value_to<int>(location_json));}();
auto& binding_json=json["binding"];
[&](){member.binding=static_cast<uint32_t>(value_to<int>(binding_json));}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& offset_json=json["offset"];
[&](){member.offset=static_cast<uint32_t>(value_to<int>(offset_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineVertexInputStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& vertexBindingDescriptionCount_json=json["vertexBindingDescriptionCount"];
[&](){vertexBindingDescriptionCount_json=member.vertexBindingDescriptionCount;}();
auto& pVertexBindingDescriptions_json=json["pVertexBindingDescriptions"];
[&](){
            if (member.pVertexBindingDescriptions==NULL){
                pVertexBindingDescriptions_json=boost::json::array();
            return; }pVertexBindingDescriptions_json=boost::json::array(member.vertexBindingDescriptionCount);
        auto& arr_lPaHSpH=pVertexBindingDescriptions_json.as_array();
        for(int YjWVYZF=0; YjWVYZF < member.vertexBindingDescriptionCount; YjWVYZF++){
            [&](){
            auto& temp=arr_lPaHSpH[YjWVYZF].emplace_object();
            return serialize_struct(temp, member.pVertexBindingDescriptions[YjWVYZF]);
            }();
        }
        }();
auto& vertexAttributeDescriptionCount_json=json["vertexAttributeDescriptionCount"];
[&](){vertexAttributeDescriptionCount_json=member.vertexAttributeDescriptionCount;}();
auto& pVertexAttributeDescriptions_json=json["pVertexAttributeDescriptions"];
[&](){
            if (member.pVertexAttributeDescriptions==NULL){
                pVertexAttributeDescriptions_json=boost::json::array();
            return; }pVertexAttributeDescriptions_json=boost::json::array(member.vertexAttributeDescriptionCount);
        auto& arr_vcvXgKV=pVertexAttributeDescriptions_json.as_array();
        for(int bjIoEiI=0; bjIoEiI < member.vertexAttributeDescriptionCount; bjIoEiI++){
            [&](){
            auto& temp=arr_vcvXgKV[bjIoEiI].emplace_object();
            return serialize_struct(temp, member.pVertexAttributeDescriptions[bjIoEiI]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineVertexInputStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_wimNbin;[&](){temp_wimNbin=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineVertexInputStateCreateFlags)temp_wimNbin;}();}();
auto& vertexBindingDescriptionCount_json=json["vertexBindingDescriptionCount"];
[&](){member.vertexBindingDescriptionCount=static_cast<uint32_t>(value_to<int>(vertexBindingDescriptionCount_json));}();
auto& pVertexBindingDescriptions_json=json["pVertexBindingDescriptions"];
[&](){ VkVertexInputBindingDescription* temp_kJYQbtl;;[&](){
            if (pVertexBindingDescriptions_json.as_array().size()==0){
                temp_kJYQbtl=NULL;
            return; }temp_kJYQbtl=(VkVertexInputBindingDescription*)malloc(member.vertexBindingDescriptionCount*sizeof(VkVertexInputBindingDescription));
        auto& arr_SwVSqGy=pVertexBindingDescriptions_json.as_array();
        for(int ufjmVBe=0; ufjmVBe < member.vertexBindingDescriptionCount; ufjmVBe++){
            [&](){
            auto& temp=arr_SwVSqGy[ufjmVBe].as_object();
            deserialize_struct(temp,temp_kJYQbtl[ufjmVBe]);
            }();
        }
        }();member.pVertexBindingDescriptions=temp_kJYQbtl;}();
auto& vertexAttributeDescriptionCount_json=json["vertexAttributeDescriptionCount"];
[&](){member.vertexAttributeDescriptionCount=static_cast<uint32_t>(value_to<int>(vertexAttributeDescriptionCount_json));}();
auto& pVertexAttributeDescriptions_json=json["pVertexAttributeDescriptions"];
[&](){ VkVertexInputAttributeDescription* temp_xzSOtfH;;[&](){
            if (pVertexAttributeDescriptions_json.as_array().size()==0){
                temp_xzSOtfH=NULL;
            return; }temp_xzSOtfH=(VkVertexInputAttributeDescription*)malloc(member.vertexAttributeDescriptionCount*sizeof(VkVertexInputAttributeDescription));
        auto& arr_wYzwnla=pVertexAttributeDescriptions_json.as_array();
        for(int XbgHdbP=0; XbgHdbP < member.vertexAttributeDescriptionCount; XbgHdbP++){
            [&](){
            auto& temp=arr_wYzwnla[XbgHdbP].as_object();
            deserialize_struct(temp,temp_xzSOtfH[XbgHdbP]);
            }();
        }
        }();member.pVertexAttributeDescriptions=temp_xzSOtfH;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineInputAssemblyStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& topology_json=json["topology"];
[&](){[&](){[&](){topology_json=member.topology;}();}();}();
auto& primitiveRestartEnable_json=json["primitiveRestartEnable"];
[&](){[&](){primitiveRestartEnable_json=member.primitiveRestartEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineInputAssemblyStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_PJREQlT;[&](){temp_PJREQlT=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineInputAssemblyStateCreateFlags)temp_PJREQlT;}();}();
auto& topology_json=json["topology"];
[&](){[&](){int temp_OojTbgx;[&](){temp_OojTbgx=static_cast<int>(value_to<int>(topology_json));}();member.topology=(VkPrimitiveTopology)temp_OojTbgx;}();}();
auto& primitiveRestartEnable_json=json["primitiveRestartEnable"];
[&](){uint32_t temp_ZxdOZeb;[&](){temp_ZxdOZeb=static_cast<uint32_t>(value_to<int>(primitiveRestartEnable_json));}();member.primitiveRestartEnable=(VkBool32)temp_ZxdOZeb;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineTessellationStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& patchControlPoints_json=json["patchControlPoints"];
[&](){patchControlPoints_json=member.patchControlPoints;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineTessellationStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_WKrlGtf;[&](){temp_WKrlGtf=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineTessellationStateCreateFlags)temp_WKrlGtf;}();}();
auto& patchControlPoints_json=json["patchControlPoints"];
[&](){member.patchControlPoints=static_cast<uint32_t>(value_to<int>(patchControlPoints_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineViewportStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& viewportCount_json=json["viewportCount"];
[&](){viewportCount_json=member.viewportCount;}();
auto& pViewports_json=json["pViewports"];
[&](){
            if (member.pViewports==NULL){
                pViewports_json=boost::json::array();
            return; }pViewports_json=boost::json::array(member.viewportCount);
        auto& arr_HeuXxgA=pViewports_json.as_array();
        for(int pPPmjfh=0; pPPmjfh < member.viewportCount; pPPmjfh++){
            [&](){
            auto& temp=arr_HeuXxgA[pPPmjfh].emplace_object();
            return serialize_struct(temp, member.pViewports[pPPmjfh]);
            }();
        }
        }();
auto& scissorCount_json=json["scissorCount"];
[&](){scissorCount_json=member.scissorCount;}();
auto& pScissors_json=json["pScissors"];
[&](){
            if (member.pScissors==NULL){
                pScissors_json=boost::json::array();
            return; }pScissors_json=boost::json::array(member.scissorCount);
        auto& arr_jBCJAGW=pScissors_json.as_array();
        for(int pCcccJg=0; pCcccJg < member.scissorCount; pCcccJg++){
            [&](){
            auto& temp=arr_jBCJAGW[pCcccJg].emplace_object();
            return serialize_struct(temp, member.pScissors[pCcccJg]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineViewportStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_HoGRvLK;[&](){temp_HoGRvLK=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineViewportStateCreateFlags)temp_HoGRvLK;}();}();
auto& viewportCount_json=json["viewportCount"];
[&](){member.viewportCount=static_cast<uint32_t>(value_to<int>(viewportCount_json));}();
auto& pViewports_json=json["pViewports"];
[&](){ VkViewport* temp_mgwxeJT;;[&](){
            if (pViewports_json.as_array().size()==0){
                temp_mgwxeJT=NULL;
            return; }temp_mgwxeJT=(VkViewport*)malloc(member.viewportCount*sizeof(VkViewport));
        auto& arr_TzRRtUJ=pViewports_json.as_array();
        for(int WDNKHfs=0; WDNKHfs < member.viewportCount; WDNKHfs++){
            [&](){
            auto& temp=arr_TzRRtUJ[WDNKHfs].as_object();
            deserialize_struct(temp,temp_mgwxeJT[WDNKHfs]);
            }();
        }
        }();member.pViewports=temp_mgwxeJT;}();
auto& scissorCount_json=json["scissorCount"];
[&](){member.scissorCount=static_cast<uint32_t>(value_to<int>(scissorCount_json));}();
auto& pScissors_json=json["pScissors"];
[&](){ VkRect2D* temp_ZKgPoVk;;[&](){
            if (pScissors_json.as_array().size()==0){
                temp_ZKgPoVk=NULL;
            return; }temp_ZKgPoVk=(VkRect2D*)malloc(member.scissorCount*sizeof(VkRect2D));
        auto& arr_UVMSsQZ=pScissors_json.as_array();
        for(int cBQpqVa=0; cBQpqVa < member.scissorCount; cBQpqVa++){
            [&](){
            auto& temp=arr_UVMSsQZ[cBQpqVa].as_object();
            deserialize_struct(temp,temp_ZKgPoVk[cBQpqVa]);
            }();
        }
        }();member.pScissors=temp_ZKgPoVk;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRasterizationStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& depthClampEnable_json=json["depthClampEnable"];
[&](){[&](){depthClampEnable_json=member.depthClampEnable;}();}();
auto& rasterizerDiscardEnable_json=json["rasterizerDiscardEnable"];
[&](){[&](){rasterizerDiscardEnable_json=member.rasterizerDiscardEnable;}();}();
auto& polygonMode_json=json["polygonMode"];
[&](){[&](){[&](){polygonMode_json=member.polygonMode;}();}();}();
auto& cullMode_json=json["cullMode"];
[&](){[&](){[&](){cullMode_json=member.cullMode;}();}();}();
auto& frontFace_json=json["frontFace"];
[&](){[&](){[&](){frontFace_json=member.frontFace;}();}();}();
auto& depthBiasEnable_json=json["depthBiasEnable"];
[&](){[&](){depthBiasEnable_json=member.depthBiasEnable;}();}();
auto& depthBiasConstantFactor_json=json["depthBiasConstantFactor"];
[&](){depthBiasConstantFactor_json=member.depthBiasConstantFactor;}();
auto& depthBiasClamp_json=json["depthBiasClamp"];
[&](){depthBiasClamp_json=member.depthBiasClamp;}();
auto& depthBiasSlopeFactor_json=json["depthBiasSlopeFactor"];
[&](){depthBiasSlopeFactor_json=member.depthBiasSlopeFactor;}();
auto& lineWidth_json=json["lineWidth"];
[&](){lineWidth_json=member.lineWidth;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRasterizationStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_ecpCjJy;[&](){temp_ecpCjJy=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineRasterizationStateCreateFlags)temp_ecpCjJy;}();}();
auto& depthClampEnable_json=json["depthClampEnable"];
[&](){uint32_t temp_QppjnkQ;[&](){temp_QppjnkQ=static_cast<uint32_t>(value_to<int>(depthClampEnable_json));}();member.depthClampEnable=(VkBool32)temp_QppjnkQ;}();
auto& rasterizerDiscardEnable_json=json["rasterizerDiscardEnable"];
[&](){uint32_t temp_aAGPiSN;[&](){temp_aAGPiSN=static_cast<uint32_t>(value_to<int>(rasterizerDiscardEnable_json));}();member.rasterizerDiscardEnable=(VkBool32)temp_aAGPiSN;}();
auto& polygonMode_json=json["polygonMode"];
[&](){[&](){int temp_tpbcdpf;[&](){temp_tpbcdpf=static_cast<int>(value_to<int>(polygonMode_json));}();member.polygonMode=(VkPolygonMode)temp_tpbcdpf;}();}();
auto& cullMode_json=json["cullMode"];
[&](){[&](){int temp_bnCrZDC;[&](){temp_bnCrZDC=static_cast<int>(value_to<int>(cullMode_json));}();member.cullMode=(VkCullModeFlags)temp_bnCrZDC;}();}();
auto& frontFace_json=json["frontFace"];
[&](){[&](){int temp_vUQSmMa;[&](){temp_vUQSmMa=static_cast<int>(value_to<int>(frontFace_json));}();member.frontFace=(VkFrontFace)temp_vUQSmMa;}();}();
auto& depthBiasEnable_json=json["depthBiasEnable"];
[&](){uint32_t temp_vQGdymE;[&](){temp_vQGdymE=static_cast<uint32_t>(value_to<int>(depthBiasEnable_json));}();member.depthBiasEnable=(VkBool32)temp_vQGdymE;}();
auto& depthBiasConstantFactor_json=json["depthBiasConstantFactor"];
[&](){member.depthBiasConstantFactor=static_cast<float>(value_to<int>(depthBiasConstantFactor_json));}();
auto& depthBiasClamp_json=json["depthBiasClamp"];
[&](){member.depthBiasClamp=static_cast<float>(value_to<int>(depthBiasClamp_json));}();
auto& depthBiasSlopeFactor_json=json["depthBiasSlopeFactor"];
[&](){member.depthBiasSlopeFactor=static_cast<float>(value_to<int>(depthBiasSlopeFactor_json));}();
auto& lineWidth_json=json["lineWidth"];
[&](){member.lineWidth=static_cast<float>(value_to<int>(lineWidth_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineMultisampleStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& rasterizationSamples_json=json["rasterizationSamples"];
[&](){[&](){[&](){rasterizationSamples_json=member.rasterizationSamples;}();}();}();
auto& sampleShadingEnable_json=json["sampleShadingEnable"];
[&](){[&](){sampleShadingEnable_json=member.sampleShadingEnable;}();}();
auto& minSampleShading_json=json["minSampleShading"];
[&](){minSampleShading_json=member.minSampleShading;}();
auto& pSampleMask_json=json["pSampleMask"];
[&](){
            if (member.pSampleMask==NULL){
                pSampleMask_json=boost::json::array();
            return; }pSampleMask_json=boost::json::array((member.rasterizationSamples + 31) / 32);
        auto& arr_SWdjBPW=pSampleMask_json.as_array();
        for(int vLiHEkD=0; vLiHEkD < (member.rasterizationSamples + 31) / 32; vLiHEkD++){
            [&](){[&](){arr_SWdjBPW[vLiHEkD]=member.pSampleMask[vLiHEkD];}();}();
        }
        }();
auto& alphaToCoverageEnable_json=json["alphaToCoverageEnable"];
[&](){[&](){alphaToCoverageEnable_json=member.alphaToCoverageEnable;}();}();
auto& alphaToOneEnable_json=json["alphaToOneEnable"];
[&](){[&](){alphaToOneEnable_json=member.alphaToOneEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineMultisampleStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_iKocQxF;[&](){temp_iKocQxF=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineMultisampleStateCreateFlags)temp_iKocQxF;}();}();
auto& rasterizationSamples_json=json["rasterizationSamples"];
[&](){[&](){int temp_cDVWodo;[&](){temp_cDVWodo=static_cast<int>(value_to<int>(rasterizationSamples_json));}();member.rasterizationSamples=(VkSampleCountFlagBits)temp_cDVWodo;}();}();
auto& sampleShadingEnable_json=json["sampleShadingEnable"];
[&](){uint32_t temp_AnvnfqV;[&](){temp_AnvnfqV=static_cast<uint32_t>(value_to<int>(sampleShadingEnable_json));}();member.sampleShadingEnable=(VkBool32)temp_AnvnfqV;}();
auto& minSampleShading_json=json["minSampleShading"];
[&](){member.minSampleShading=static_cast<float>(value_to<int>(minSampleShading_json));}();
auto& pSampleMask_json=json["pSampleMask"];
[&](){ VkSampleMask* temp_arAFShZ;;[&](){
            if (pSampleMask_json.as_array().size()==0){
                temp_arAFShZ=NULL;
            return; }temp_arAFShZ=(VkSampleMask*)malloc((member.rasterizationSamples + 31) / 32*sizeof(VkSampleMask));
        auto& arr_lkRIJjn=pSampleMask_json.as_array();
        for(int ekbfPnr=0; ekbfPnr < (member.rasterizationSamples + 31) / 32; ekbfPnr++){
            [&](){uint32_t temp_lkRIJjn;[&](){temp_lkRIJjn=static_cast<uint32_t>(value_to<int>(arr_lkRIJjn[ekbfPnr]));}();temp_arAFShZ[ekbfPnr]=(VkSampleMask)temp_lkRIJjn;}();
        }
        }();member.pSampleMask=temp_arAFShZ;}();
auto& alphaToCoverageEnable_json=json["alphaToCoverageEnable"];
[&](){uint32_t temp_gjhKogm;[&](){temp_gjhKogm=static_cast<uint32_t>(value_to<int>(alphaToCoverageEnable_json));}();member.alphaToCoverageEnable=(VkBool32)temp_gjhKogm;}();
auto& alphaToOneEnable_json=json["alphaToOneEnable"];
[&](){uint32_t temp_tbncMOZ;[&](){temp_tbncMOZ=static_cast<uint32_t>(value_to<int>(alphaToOneEnable_json));}();member.alphaToOneEnable=(VkBool32)temp_tbncMOZ;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineColorBlendAttachmentState& member){
        
    
auto& blendEnable_json=json["blendEnable"];
[&](){[&](){blendEnable_json=member.blendEnable;}();}();
auto& srcColorBlendFactor_json=json["srcColorBlendFactor"];
[&](){[&](){[&](){srcColorBlendFactor_json=member.srcColorBlendFactor;}();}();}();
auto& dstColorBlendFactor_json=json["dstColorBlendFactor"];
[&](){[&](){[&](){dstColorBlendFactor_json=member.dstColorBlendFactor;}();}();}();
auto& colorBlendOp_json=json["colorBlendOp"];
[&](){[&](){[&](){colorBlendOp_json=member.colorBlendOp;}();}();}();
auto& srcAlphaBlendFactor_json=json["srcAlphaBlendFactor"];
[&](){[&](){[&](){srcAlphaBlendFactor_json=member.srcAlphaBlendFactor;}();}();}();
auto& dstAlphaBlendFactor_json=json["dstAlphaBlendFactor"];
[&](){[&](){[&](){dstAlphaBlendFactor_json=member.dstAlphaBlendFactor;}();}();}();
auto& alphaBlendOp_json=json["alphaBlendOp"];
[&](){[&](){[&](){alphaBlendOp_json=member.alphaBlendOp;}();}();}();
auto& colorWriteMask_json=json["colorWriteMask"];
[&](){[&](){[&](){colorWriteMask_json=member.colorWriteMask;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineColorBlendAttachmentState& member){
auto& blendEnable_json=json["blendEnable"];
[&](){uint32_t temp_uDGwzmf;[&](){temp_uDGwzmf=static_cast<uint32_t>(value_to<int>(blendEnable_json));}();member.blendEnable=(VkBool32)temp_uDGwzmf;}();
auto& srcColorBlendFactor_json=json["srcColorBlendFactor"];
[&](){[&](){int temp_itBZrfJ;[&](){temp_itBZrfJ=static_cast<int>(value_to<int>(srcColorBlendFactor_json));}();member.srcColorBlendFactor=(VkBlendFactor)temp_itBZrfJ;}();}();
auto& dstColorBlendFactor_json=json["dstColorBlendFactor"];
[&](){[&](){int temp_OJUMGlm;[&](){temp_OJUMGlm=static_cast<int>(value_to<int>(dstColorBlendFactor_json));}();member.dstColorBlendFactor=(VkBlendFactor)temp_OJUMGlm;}();}();
auto& colorBlendOp_json=json["colorBlendOp"];
[&](){[&](){int temp_dhbtuka;[&](){temp_dhbtuka=static_cast<int>(value_to<int>(colorBlendOp_json));}();member.colorBlendOp=(VkBlendOp)temp_dhbtuka;}();}();
auto& srcAlphaBlendFactor_json=json["srcAlphaBlendFactor"];
[&](){[&](){int temp_LxHDiTT;[&](){temp_LxHDiTT=static_cast<int>(value_to<int>(srcAlphaBlendFactor_json));}();member.srcAlphaBlendFactor=(VkBlendFactor)temp_LxHDiTT;}();}();
auto& dstAlphaBlendFactor_json=json["dstAlphaBlendFactor"];
[&](){[&](){int temp_VXLWFSC;[&](){temp_VXLWFSC=static_cast<int>(value_to<int>(dstAlphaBlendFactor_json));}();member.dstAlphaBlendFactor=(VkBlendFactor)temp_VXLWFSC;}();}();
auto& alphaBlendOp_json=json["alphaBlendOp"];
[&](){[&](){int temp_obeoNAe;[&](){temp_obeoNAe=static_cast<int>(value_to<int>(alphaBlendOp_json));}();member.alphaBlendOp=(VkBlendOp)temp_obeoNAe;}();}();
auto& colorWriteMask_json=json["colorWriteMask"];
[&](){[&](){int temp_YBugnKU;[&](){temp_YBugnKU=static_cast<int>(value_to<int>(colorWriteMask_json));}();member.colorWriteMask=(VkColorComponentFlags)temp_YBugnKU;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineColorBlendStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& logicOpEnable_json=json["logicOpEnable"];
[&](){[&](){logicOpEnable_json=member.logicOpEnable;}();}();
auto& logicOp_json=json["logicOp"];
[&](){[&](){[&](){logicOp_json=member.logicOp;}();}();}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){attachmentCount_json=member.attachmentCount;}();
auto& pAttachments_json=json["pAttachments"];
[&](){
            if (member.pAttachments==NULL){
                pAttachments_json=boost::json::array();
            return; }pAttachments_json=boost::json::array(member.attachmentCount);
        auto& arr_OXJBqJu=pAttachments_json.as_array();
        for(int oTEAAhc=0; oTEAAhc < member.attachmentCount; oTEAAhc++){
            [&](){
            auto& temp=arr_OXJBqJu[oTEAAhc].emplace_object();
            return serialize_struct(temp, member.pAttachments[oTEAAhc]);
            }();
        }
        }();
auto& blendConstants_json=json["blendConstants"];
[&](){blendConstants_json=boost::json::array(4);
        auto& arr_UnCpRtF=blendConstants_json.as_array();
        for(int axAsZTW=0; axAsZTW < 4; axAsZTW++){
            [&](){arr_UnCpRtF[axAsZTW]=member.blendConstants[axAsZTW];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineColorBlendStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_uberxjP;[&](){temp_uberxjP=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineColorBlendStateCreateFlags)temp_uberxjP;}();}();
auto& logicOpEnable_json=json["logicOpEnable"];
[&](){uint32_t temp_BRlmmkv;[&](){temp_BRlmmkv=static_cast<uint32_t>(value_to<int>(logicOpEnable_json));}();member.logicOpEnable=(VkBool32)temp_BRlmmkv;}();
auto& logicOp_json=json["logicOp"];
[&](){[&](){int temp_HkBAeLb;[&](){temp_HkBAeLb=static_cast<int>(value_to<int>(logicOp_json));}();member.logicOp=(VkLogicOp)temp_HkBAeLb;}();}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){member.attachmentCount=static_cast<uint32_t>(value_to<int>(attachmentCount_json));}();
auto& pAttachments_json=json["pAttachments"];
[&](){ VkPipelineColorBlendAttachmentState* temp_MDLbNHy;;[&](){
            if (pAttachments_json.as_array().size()==0){
                temp_MDLbNHy=NULL;
            return; }temp_MDLbNHy=(VkPipelineColorBlendAttachmentState*)malloc(member.attachmentCount*sizeof(VkPipelineColorBlendAttachmentState));
        auto& arr_EPnzthZ=pAttachments_json.as_array();
        for(int QVhhTLR=0; QVhhTLR < member.attachmentCount; QVhhTLR++){
            [&](){
            auto& temp=arr_EPnzthZ[QVhhTLR].as_object();
            deserialize_struct(temp,temp_MDLbNHy[QVhhTLR]);
            }();
        }
        }();member.pAttachments=temp_MDLbNHy;}();
auto& blendConstants_json=json["blendConstants"];
[&](){
        auto& arr_UnCpRtF=blendConstants_json.as_array();
        for(int axAsZTW=0; axAsZTW < 4; axAsZTW++){
            [&](){member.blendConstants[axAsZTW]=static_cast<float>(value_to<int>(arr_UnCpRtF[axAsZTW]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPipelineDynamicStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& dynamicStateCount_json=json["dynamicStateCount"];
[&](){dynamicStateCount_json=member.dynamicStateCount;}();
auto& pDynamicStates_json=json["pDynamicStates"];
[&](){
            if (member.pDynamicStates==NULL){
                pDynamicStates_json=boost::json::array();
            return; }pDynamicStates_json=boost::json::array(member.dynamicStateCount);
        auto& arr_evgSeON=pDynamicStates_json.as_array();
        for(int PwhzoKV=0; PwhzoKV < member.dynamicStateCount; PwhzoKV++){
            [&](){[&](){[&](){arr_evgSeON[PwhzoKV]=member.pDynamicStates[PwhzoKV];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineDynamicStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_VwrMJNM;[&](){temp_VwrMJNM=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineDynamicStateCreateFlags)temp_VwrMJNM;}();}();
auto& dynamicStateCount_json=json["dynamicStateCount"];
[&](){member.dynamicStateCount=static_cast<uint32_t>(value_to<int>(dynamicStateCount_json));}();
auto& pDynamicStates_json=json["pDynamicStates"];
[&](){ VkDynamicState* temp_BbkCBrv;;[&](){
            if (pDynamicStates_json.as_array().size()==0){
                temp_BbkCBrv=NULL;
            return; }temp_BbkCBrv=(VkDynamicState*)malloc(member.dynamicStateCount*sizeof(VkDynamicState));
        auto& arr_eZCgreQ=pDynamicStates_json.as_array();
        for(int cnjOtMU=0; cnjOtMU < member.dynamicStateCount; cnjOtMU++){
            [&](){[&](){int temp_YEDqGCk;[&](){temp_YEDqGCk=static_cast<int>(value_to<int>(arr_eZCgreQ[cnjOtMU]));}();temp_BbkCBrv[cnjOtMU]=(VkDynamicState)temp_YEDqGCk;}();}();
        }
        }();member.pDynamicStates=temp_BbkCBrv;}();
}

    void serialize_struct(boost::json::object& json, const VkStencilOpState& member){
        
    
auto& failOp_json=json["failOp"];
[&](){[&](){[&](){failOp_json=member.failOp;}();}();}();
auto& passOp_json=json["passOp"];
[&](){[&](){[&](){passOp_json=member.passOp;}();}();}();
auto& depthFailOp_json=json["depthFailOp"];
[&](){[&](){[&](){depthFailOp_json=member.depthFailOp;}();}();}();
auto& compareOp_json=json["compareOp"];
[&](){[&](){[&](){compareOp_json=member.compareOp;}();}();}();
auto& compareMask_json=json["compareMask"];
[&](){compareMask_json=member.compareMask;}();
auto& writeMask_json=json["writeMask"];
[&](){writeMask_json=member.writeMask;}();
auto& reference_json=json["reference"];
[&](){reference_json=member.reference;}();
}
void deserialize_struct(boost::json::object& json, VkStencilOpState& member){
auto& failOp_json=json["failOp"];
[&](){[&](){int temp_pTZMIDh;[&](){temp_pTZMIDh=static_cast<int>(value_to<int>(failOp_json));}();member.failOp=(VkStencilOp)temp_pTZMIDh;}();}();
auto& passOp_json=json["passOp"];
[&](){[&](){int temp_GbOTRQB;[&](){temp_GbOTRQB=static_cast<int>(value_to<int>(passOp_json));}();member.passOp=(VkStencilOp)temp_GbOTRQB;}();}();
auto& depthFailOp_json=json["depthFailOp"];
[&](){[&](){int temp_CTZWwew;[&](){temp_CTZWwew=static_cast<int>(value_to<int>(depthFailOp_json));}();member.depthFailOp=(VkStencilOp)temp_CTZWwew;}();}();
auto& compareOp_json=json["compareOp"];
[&](){[&](){int temp_xnZScEW;[&](){temp_xnZScEW=static_cast<int>(value_to<int>(compareOp_json));}();member.compareOp=(VkCompareOp)temp_xnZScEW;}();}();
auto& compareMask_json=json["compareMask"];
[&](){member.compareMask=static_cast<uint32_t>(value_to<int>(compareMask_json));}();
auto& writeMask_json=json["writeMask"];
[&](){member.writeMask=static_cast<uint32_t>(value_to<int>(writeMask_json));}();
auto& reference_json=json["reference"];
[&](){member.reference=static_cast<uint32_t>(value_to<int>(reference_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineDepthStencilStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& depthTestEnable_json=json["depthTestEnable"];
[&](){[&](){depthTestEnable_json=member.depthTestEnable;}();}();
auto& depthWriteEnable_json=json["depthWriteEnable"];
[&](){[&](){depthWriteEnable_json=member.depthWriteEnable;}();}();
auto& depthCompareOp_json=json["depthCompareOp"];
[&](){[&](){[&](){depthCompareOp_json=member.depthCompareOp;}();}();}();
auto& depthBoundsTestEnable_json=json["depthBoundsTestEnable"];
[&](){[&](){depthBoundsTestEnable_json=member.depthBoundsTestEnable;}();}();
auto& stencilTestEnable_json=json["stencilTestEnable"];
[&](){[&](){stencilTestEnable_json=member.stencilTestEnable;}();}();
auto& front_json=json["front"];
[&](){
            auto& temp=front_json.emplace_object();
            return serialize_struct(temp, member.front);
            }();
auto& back_json=json["back"];
[&](){
            auto& temp=back_json.emplace_object();
            return serialize_struct(temp, member.back);
            }();
auto& minDepthBounds_json=json["minDepthBounds"];
[&](){minDepthBounds_json=member.minDepthBounds;}();
auto& maxDepthBounds_json=json["maxDepthBounds"];
[&](){maxDepthBounds_json=member.maxDepthBounds;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineDepthStencilStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_LWzJUfM;[&](){temp_LWzJUfM=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineDepthStencilStateCreateFlags)temp_LWzJUfM;}();}();
auto& depthTestEnable_json=json["depthTestEnable"];
[&](){uint32_t temp_OdFKLbv;[&](){temp_OdFKLbv=static_cast<uint32_t>(value_to<int>(depthTestEnable_json));}();member.depthTestEnable=(VkBool32)temp_OdFKLbv;}();
auto& depthWriteEnable_json=json["depthWriteEnable"];
[&](){uint32_t temp_dvaUEfe;[&](){temp_dvaUEfe=static_cast<uint32_t>(value_to<int>(depthWriteEnable_json));}();member.depthWriteEnable=(VkBool32)temp_dvaUEfe;}();
auto& depthCompareOp_json=json["depthCompareOp"];
[&](){[&](){int temp_RLxSTVL;[&](){temp_RLxSTVL=static_cast<int>(value_to<int>(depthCompareOp_json));}();member.depthCompareOp=(VkCompareOp)temp_RLxSTVL;}();}();
auto& depthBoundsTestEnable_json=json["depthBoundsTestEnable"];
[&](){uint32_t temp_GkqcxLU;[&](){temp_GkqcxLU=static_cast<uint32_t>(value_to<int>(depthBoundsTestEnable_json));}();member.depthBoundsTestEnable=(VkBool32)temp_GkqcxLU;}();
auto& stencilTestEnable_json=json["stencilTestEnable"];
[&](){uint32_t temp_GnHSLpV;[&](){temp_GnHSLpV=static_cast<uint32_t>(value_to<int>(stencilTestEnable_json));}();member.stencilTestEnable=(VkBool32)temp_GnHSLpV;}();
auto& front_json=json["front"];
[&](){
            auto& temp=front_json.as_object();
            deserialize_struct(temp,member.front);
            }();
auto& back_json=json["back"];
[&](){
            auto& temp=back_json.as_object();
            deserialize_struct(temp,member.back);
            }();
auto& minDepthBounds_json=json["minDepthBounds"];
[&](){member.minDepthBounds=static_cast<float>(value_to<int>(minDepthBounds_json));}();
auto& maxDepthBounds_json=json["maxDepthBounds"];
[&](){member.maxDepthBounds=static_cast<float>(value_to<int>(maxDepthBounds_json));}();
}

    void serialize_struct(boost::json::object& json, const VkGraphicsPipelineCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& stageCount_json=json["stageCount"];
[&](){stageCount_json=member.stageCount;}();
auto& pStages_json=json["pStages"];
[&](){
            if (member.pStages==NULL){
                pStages_json=boost::json::array();
            return; }pStages_json=boost::json::array(member.stageCount);
        auto& arr_wJXHhmh=pStages_json.as_array();
        for(int AsBfcSb=0; AsBfcSb < member.stageCount; AsBfcSb++){
            [&](){
            auto& temp=arr_wJXHhmh[AsBfcSb].emplace_object();
            return serialize_struct(temp, member.pStages[AsBfcSb]);
            }();
        }
        }();
auto& pVertexInputState_json=json["pVertexInputState"];
[&](){
            if (member.pVertexInputState==NULL){
                pVertexInputState_json=boost::json::array();
            return; }pVertexInputState_json=boost::json::array(1);
        auto& arr_HopKlOv=pVertexInputState_json.as_array();
        for(int tqmlCna=0; tqmlCna < 1; tqmlCna++){
            [&](){
            auto& temp=arr_HopKlOv[tqmlCna].emplace_object();
            return serialize_struct(temp, member.pVertexInputState[tqmlCna]);
            }();
        }
        }();
auto& pInputAssemblyState_json=json["pInputAssemblyState"];
[&](){
            if (member.pInputAssemblyState==NULL){
                pInputAssemblyState_json=boost::json::array();
            return; }pInputAssemblyState_json=boost::json::array(1);
        auto& arr_XjVdyCj=pInputAssemblyState_json.as_array();
        for(int kCbcYVf=0; kCbcYVf < 1; kCbcYVf++){
            [&](){
            auto& temp=arr_XjVdyCj[kCbcYVf].emplace_object();
            return serialize_struct(temp, member.pInputAssemblyState[kCbcYVf]);
            }();
        }
        }();
auto& pTessellationState_json=json["pTessellationState"];
[&](){
            if (member.pTessellationState==NULL){
                pTessellationState_json=boost::json::array();
            return; }pTessellationState_json=boost::json::array(1);
        auto& arr_tdhGlVI=pTessellationState_json.as_array();
        for(int IWxBQoq=0; IWxBQoq < 1; IWxBQoq++){
            [&](){
            auto& temp=arr_tdhGlVI[IWxBQoq].emplace_object();
            return serialize_struct(temp, member.pTessellationState[IWxBQoq]);
            }();
        }
        }();
auto& pViewportState_json=json["pViewportState"];
[&](){
            if (member.pViewportState==NULL){
                pViewportState_json=boost::json::array();
            return; }pViewportState_json=boost::json::array(1);
        auto& arr_cLLBOfS=pViewportState_json.as_array();
        for(int ZpMCSfw=0; ZpMCSfw < 1; ZpMCSfw++){
            [&](){
            auto& temp=arr_cLLBOfS[ZpMCSfw].emplace_object();
            return serialize_struct(temp, member.pViewportState[ZpMCSfw]);
            }();
        }
        }();
auto& pRasterizationState_json=json["pRasterizationState"];
[&](){
            if (member.pRasterizationState==NULL){
                pRasterizationState_json=boost::json::array();
            return; }pRasterizationState_json=boost::json::array(1);
        auto& arr_BUWxCGe=pRasterizationState_json.as_array();
        for(int kapFwwJ=0; kapFwwJ < 1; kapFwwJ++){
            [&](){
            auto& temp=arr_BUWxCGe[kapFwwJ].emplace_object();
            return serialize_struct(temp, member.pRasterizationState[kapFwwJ]);
            }();
        }
        }();
auto& pMultisampleState_json=json["pMultisampleState"];
[&](){
            if (member.pMultisampleState==NULL){
                pMultisampleState_json=boost::json::array();
            return; }pMultisampleState_json=boost::json::array(1);
        auto& arr_oxWWlVc=pMultisampleState_json.as_array();
        for(int plsEKGt=0; plsEKGt < 1; plsEKGt++){
            [&](){
            auto& temp=arr_oxWWlVc[plsEKGt].emplace_object();
            return serialize_struct(temp, member.pMultisampleState[plsEKGt]);
            }();
        }
        }();
auto& pDepthStencilState_json=json["pDepthStencilState"];
[&](){
            if (member.pDepthStencilState==NULL){
                pDepthStencilState_json=boost::json::array();
            return; }pDepthStencilState_json=boost::json::array(1);
        auto& arr_CoCyuaF=pDepthStencilState_json.as_array();
        for(int bzaPfwe=0; bzaPfwe < 1; bzaPfwe++){
            [&](){
            auto& temp=arr_CoCyuaF[bzaPfwe].emplace_object();
            return serialize_struct(temp, member.pDepthStencilState[bzaPfwe]);
            }();
        }
        }();
auto& pColorBlendState_json=json["pColorBlendState"];
[&](){
            if (member.pColorBlendState==NULL){
                pColorBlendState_json=boost::json::array();
            return; }pColorBlendState_json=boost::json::array(1);
        auto& arr_fflbfZo=pColorBlendState_json.as_array();
        for(int bapCcQg=0; bapCcQg < 1; bapCcQg++){
            [&](){
            auto& temp=arr_fflbfZo[bapCcQg].emplace_object();
            return serialize_struct(temp, member.pColorBlendState[bapCcQg]);
            }();
        }
        }();
auto& pDynamicState_json=json["pDynamicState"];
[&](){
            if (member.pDynamicState==NULL){
                pDynamicState_json=boost::json::array();
            return; }pDynamicState_json=boost::json::array(1);
        auto& arr_iDMMizu=pDynamicState_json.as_array();
        for(int RNPowsf=0; RNPowsf < 1; RNPowsf++){
            [&](){
            auto& temp=arr_iDMMizu[RNPowsf].emplace_object();
            return serialize_struct(temp, member.pDynamicState[RNPowsf]);
            }();
        }
        }();
auto& layout_json=json["layout"];
[&](){serialize_VkPipelineLayout(layout_json,member.layout);}();
auto& renderPass_json=json["renderPass"];
[&](){serialize_VkRenderPass(renderPass_json,member.renderPass);}();
auto& subpass_json=json["subpass"];
[&](){subpass_json=member.subpass;}();
auto& basePipelineHandle_json=json["basePipelineHandle"];
[&](){serialize_VkPipeline(basePipelineHandle_json,member.basePipelineHandle);}();
auto& basePipelineIndex_json=json["basePipelineIndex"];
[&](){basePipelineIndex_json=member.basePipelineIndex;}();
}
void deserialize_struct(boost::json::object& json, VkGraphicsPipelineCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_evbgLuC;[&](){temp_evbgLuC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCreateFlags)temp_evbgLuC;}();}();
auto& stageCount_json=json["stageCount"];
[&](){member.stageCount=static_cast<uint32_t>(value_to<int>(stageCount_json));}();
auto& pStages_json=json["pStages"];
[&](){ VkPipelineShaderStageCreateInfo* temp_FhIAThL;;[&](){
            if (pStages_json.as_array().size()==0){
                temp_FhIAThL=NULL;
            return; }temp_FhIAThL=(VkPipelineShaderStageCreateInfo*)malloc(member.stageCount*sizeof(VkPipelineShaderStageCreateInfo));
        auto& arr_qUPPcsa=pStages_json.as_array();
        for(int jQYmLXQ=0; jQYmLXQ < member.stageCount; jQYmLXQ++){
            [&](){
            auto& temp=arr_qUPPcsa[jQYmLXQ].as_object();
            deserialize_struct(temp,temp_FhIAThL[jQYmLXQ]);
            }();
        }
        }();member.pStages=temp_FhIAThL;}();
auto& pVertexInputState_json=json["pVertexInputState"];
[&](){ VkPipelineVertexInputStateCreateInfo* temp_EfJMJiL;;[&](){
            if (pVertexInputState_json.as_array().size()==0){
                temp_EfJMJiL=NULL;
            return; }temp_EfJMJiL=(VkPipelineVertexInputStateCreateInfo*)malloc(1*sizeof(VkPipelineVertexInputStateCreateInfo));
        auto& arr_FFMTeFz=pVertexInputState_json.as_array();
        for(int fwmkFXM=0; fwmkFXM < 1; fwmkFXM++){
            [&](){
            auto& temp=arr_FFMTeFz[fwmkFXM].as_object();
            deserialize_struct(temp,temp_EfJMJiL[fwmkFXM]);
            }();
        }
        }();member.pVertexInputState=temp_EfJMJiL;}();
auto& pInputAssemblyState_json=json["pInputAssemblyState"];
[&](){ VkPipelineInputAssemblyStateCreateInfo* temp_QrSGLQw;;[&](){
            if (pInputAssemblyState_json.as_array().size()==0){
                temp_QrSGLQw=NULL;
            return; }temp_QrSGLQw=(VkPipelineInputAssemblyStateCreateInfo*)malloc(1*sizeof(VkPipelineInputAssemblyStateCreateInfo));
        auto& arr_AfLUflm=pInputAssemblyState_json.as_array();
        for(int XxRbfSE=0; XxRbfSE < 1; XxRbfSE++){
            [&](){
            auto& temp=arr_AfLUflm[XxRbfSE].as_object();
            deserialize_struct(temp,temp_QrSGLQw[XxRbfSE]);
            }();
        }
        }();member.pInputAssemblyState=temp_QrSGLQw;}();
auto& pTessellationState_json=json["pTessellationState"];
[&](){ VkPipelineTessellationStateCreateInfo* temp_KHiDBcs;;[&](){
            if (pTessellationState_json.as_array().size()==0){
                temp_KHiDBcs=NULL;
            return; }temp_KHiDBcs=(VkPipelineTessellationStateCreateInfo*)malloc(1*sizeof(VkPipelineTessellationStateCreateInfo));
        auto& arr_PctCEwc=pTessellationState_json.as_array();
        for(int MWEaHRn=0; MWEaHRn < 1; MWEaHRn++){
            [&](){
            auto& temp=arr_PctCEwc[MWEaHRn].as_object();
            deserialize_struct(temp,temp_KHiDBcs[MWEaHRn]);
            }();
        }
        }();member.pTessellationState=temp_KHiDBcs;}();
auto& pViewportState_json=json["pViewportState"];
[&](){ VkPipelineViewportStateCreateInfo* temp_CjrViHM;;[&](){
            if (pViewportState_json.as_array().size()==0){
                temp_CjrViHM=NULL;
            return; }temp_CjrViHM=(VkPipelineViewportStateCreateInfo*)malloc(1*sizeof(VkPipelineViewportStateCreateInfo));
        auto& arr_WTJcGnW=pViewportState_json.as_array();
        for(int ooTyAim=0; ooTyAim < 1; ooTyAim++){
            [&](){
            auto& temp=arr_WTJcGnW[ooTyAim].as_object();
            deserialize_struct(temp,temp_CjrViHM[ooTyAim]);
            }();
        }
        }();member.pViewportState=temp_CjrViHM;}();
auto& pRasterizationState_json=json["pRasterizationState"];
[&](){ VkPipelineRasterizationStateCreateInfo* temp_htRvyws;;[&](){
            if (pRasterizationState_json.as_array().size()==0){
                temp_htRvyws=NULL;
            return; }temp_htRvyws=(VkPipelineRasterizationStateCreateInfo*)malloc(1*sizeof(VkPipelineRasterizationStateCreateInfo));
        auto& arr_vreXJww=pRasterizationState_json.as_array();
        for(int ObMJTui=0; ObMJTui < 1; ObMJTui++){
            [&](){
            auto& temp=arr_vreXJww[ObMJTui].as_object();
            deserialize_struct(temp,temp_htRvyws[ObMJTui]);
            }();
        }
        }();member.pRasterizationState=temp_htRvyws;}();
auto& pMultisampleState_json=json["pMultisampleState"];
[&](){ VkPipelineMultisampleStateCreateInfo* temp_rgLiqai;;[&](){
            if (pMultisampleState_json.as_array().size()==0){
                temp_rgLiqai=NULL;
            return; }temp_rgLiqai=(VkPipelineMultisampleStateCreateInfo*)malloc(1*sizeof(VkPipelineMultisampleStateCreateInfo));
        auto& arr_PBYyUKh=pMultisampleState_json.as_array();
        for(int wJROZSQ=0; wJROZSQ < 1; wJROZSQ++){
            [&](){
            auto& temp=arr_PBYyUKh[wJROZSQ].as_object();
            deserialize_struct(temp,temp_rgLiqai[wJROZSQ]);
            }();
        }
        }();member.pMultisampleState=temp_rgLiqai;}();
auto& pDepthStencilState_json=json["pDepthStencilState"];
[&](){ VkPipelineDepthStencilStateCreateInfo* temp_JEBObfX;;[&](){
            if (pDepthStencilState_json.as_array().size()==0){
                temp_JEBObfX=NULL;
            return; }temp_JEBObfX=(VkPipelineDepthStencilStateCreateInfo*)malloc(1*sizeof(VkPipelineDepthStencilStateCreateInfo));
        auto& arr_qGPHKtH=pDepthStencilState_json.as_array();
        for(int MpBMDks=0; MpBMDks < 1; MpBMDks++){
            [&](){
            auto& temp=arr_qGPHKtH[MpBMDks].as_object();
            deserialize_struct(temp,temp_JEBObfX[MpBMDks]);
            }();
        }
        }();member.pDepthStencilState=temp_JEBObfX;}();
auto& pColorBlendState_json=json["pColorBlendState"];
[&](){ VkPipelineColorBlendStateCreateInfo* temp_GRDbTus;;[&](){
            if (pColorBlendState_json.as_array().size()==0){
                temp_GRDbTus=NULL;
            return; }temp_GRDbTus=(VkPipelineColorBlendStateCreateInfo*)malloc(1*sizeof(VkPipelineColorBlendStateCreateInfo));
        auto& arr_UmBBwAd=pColorBlendState_json.as_array();
        for(int ivchlnp=0; ivchlnp < 1; ivchlnp++){
            [&](){
            auto& temp=arr_UmBBwAd[ivchlnp].as_object();
            deserialize_struct(temp,temp_GRDbTus[ivchlnp]);
            }();
        }
        }();member.pColorBlendState=temp_GRDbTus;}();
auto& pDynamicState_json=json["pDynamicState"];
[&](){ VkPipelineDynamicStateCreateInfo* temp_xiTcGaw;;[&](){
            if (pDynamicState_json.as_array().size()==0){
                temp_xiTcGaw=NULL;
            return; }temp_xiTcGaw=(VkPipelineDynamicStateCreateInfo*)malloc(1*sizeof(VkPipelineDynamicStateCreateInfo));
        auto& arr_qGMmZys=pDynamicState_json.as_array();
        for(int kbWOyWu=0; kbWOyWu < 1; kbWOyWu++){
            [&](){
            auto& temp=arr_qGMmZys[kbWOyWu].as_object();
            deserialize_struct(temp,temp_xiTcGaw[kbWOyWu]);
            }();
        }
        }();member.pDynamicState=temp_xiTcGaw;}();
auto& layout_json=json["layout"];
[&](){deserialize_VkPipelineLayout(layout_json, member.layout);}();
auto& renderPass_json=json["renderPass"];
[&](){deserialize_VkRenderPass(renderPass_json, member.renderPass);}();
auto& subpass_json=json["subpass"];
[&](){member.subpass=static_cast<uint32_t>(value_to<int>(subpass_json));}();
auto& basePipelineHandle_json=json["basePipelineHandle"];
[&](){deserialize_VkPipeline(basePipelineHandle_json, member.basePipelineHandle);}();
auto& basePipelineIndex_json=json["basePipelineIndex"];
[&](){member.basePipelineIndex=static_cast<int32_t>(value_to<int>(basePipelineIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineCacheCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& initialDataSize_json=json["initialDataSize"];
[&](){initialDataSize_json=member.initialDataSize;}();
auto& pInitialData_json=json["pInitialData"];
[&](){
            if (member.pInitialData==NULL){
                pInitialData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pInitialData))==NULL){
                pInitialData_json=boost::json::array();
            return; }pInitialData_json=boost::json::array(member.initialDataSize);
        auto& arr_cScJjND=pInitialData_json.as_array();
        for(int iGwyJEq=0; iGwyJEq < member.initialDataSize; iGwyJEq++){
            [&](){arr_cScJjND[iGwyJEq]=((char*)(member.pInitialData))[iGwyJEq];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineCacheCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_RwjtJyT;[&](){temp_RwjtJyT=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCacheCreateFlags)temp_RwjtJyT;}();}();
auto& initialDataSize_json=json["initialDataSize"];
[&](){member.initialDataSize=static_cast<size_t>(value_to<int>(initialDataSize_json));}();
auto& pInitialData_json=json["pInitialData"];
[&](){ void* temp_sCprdNy;;[&](){
            if (pInitialData_json.as_array().size()==0){
                temp_sCprdNy=NULL;
            return; }char* temp_jJhMRIG;[&](){
            if (pInitialData_json.as_array().size()==0){
                temp_jJhMRIG=NULL;
            return; }temp_jJhMRIG=(char*)malloc(member.initialDataSize*sizeof(char));
        auto& arr_COCjXDl=pInitialData_json.as_array();
        for(int zledvTk=0; zledvTk < member.initialDataSize; zledvTk++){
            [&](){temp_jJhMRIG[zledvTk]=static_cast<char>(value_to<int>(arr_COCjXDl[zledvTk]));}();
        }
        }();temp_sCprdNy=temp_jJhMRIG;}();member.pInitialData=temp_sCprdNy;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineCacheHeaderVersionOne& member){
        
    
auto& headerSize_json=json["headerSize"];
[&](){headerSize_json=member.headerSize;}();
auto& headerVersion_json=json["headerVersion"];
[&](){[&](){[&](){headerVersion_json=member.headerVersion;}();}();}();
auto& vendorID_json=json["vendorID"];
[&](){vendorID_json=member.vendorID;}();
auto& deviceID_json=json["deviceID"];
[&](){deviceID_json=member.deviceID;}();
auto& pipelineCacheUUID_json=json["pipelineCacheUUID"];
[&](){pipelineCacheUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_nLZmyOs=pipelineCacheUUID_json.as_array();
        for(int tnNOYvF=0; tnNOYvF < VK_UUID_SIZE; tnNOYvF++){
            [&](){arr_nLZmyOs[tnNOYvF]=member.pipelineCacheUUID[tnNOYvF];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineCacheHeaderVersionOne& member){
auto& headerSize_json=json["headerSize"];
[&](){member.headerSize=static_cast<uint32_t>(value_to<int>(headerSize_json));}();
auto& headerVersion_json=json["headerVersion"];
[&](){[&](){int temp_NuabcEw;[&](){temp_NuabcEw=static_cast<int>(value_to<int>(headerVersion_json));}();member.headerVersion=(VkPipelineCacheHeaderVersion)temp_NuabcEw;}();}();
auto& vendorID_json=json["vendorID"];
[&](){member.vendorID=static_cast<uint32_t>(value_to<int>(vendorID_json));}();
auto& deviceID_json=json["deviceID"];
[&](){member.deviceID=static_cast<uint32_t>(value_to<int>(deviceID_json));}();
auto& pipelineCacheUUID_json=json["pipelineCacheUUID"];
[&](){
        auto& arr_nLZmyOs=pipelineCacheUUID_json.as_array();
        for(int tnNOYvF=0; tnNOYvF < VK_UUID_SIZE; tnNOYvF++){
            [&](){member.pipelineCacheUUID[tnNOYvF]=static_cast<uint8_t>(value_to<int>(arr_nLZmyOs[tnNOYvF]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPushConstantRange& member){
        
    
auto& stageFlags_json=json["stageFlags"];
[&](){[&](){[&](){stageFlags_json=member.stageFlags;}();}();}();
auto& offset_json=json["offset"];
[&](){offset_json=member.offset;}();
auto& size_json=json["size"];
[&](){size_json=member.size;}();
}
void deserialize_struct(boost::json::object& json, VkPushConstantRange& member){
auto& stageFlags_json=json["stageFlags"];
[&](){[&](){int temp_JGpkxAd;[&](){temp_JGpkxAd=static_cast<int>(value_to<int>(stageFlags_json));}();member.stageFlags=(VkShaderStageFlags)temp_JGpkxAd;}();}();
auto& offset_json=json["offset"];
[&](){member.offset=static_cast<uint32_t>(value_to<int>(offset_json));}();
auto& size_json=json["size"];
[&](){member.size=static_cast<uint32_t>(value_to<int>(size_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineLayoutCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& setLayoutCount_json=json["setLayoutCount"];
[&](){setLayoutCount_json=member.setLayoutCount;}();
auto& pSetLayouts_json=json["pSetLayouts"];
[&](){
            if (member.pSetLayouts==NULL){
                pSetLayouts_json=boost::json::array();
            return; }pSetLayouts_json=boost::json::array(member.setLayoutCount);
        auto& arr_zVMtIaT=pSetLayouts_json.as_array();
        for(int uklMdkt=0; uklMdkt < member.setLayoutCount; uklMdkt++){
            [&](){serialize_VkDescriptorSetLayout(arr_zVMtIaT[uklMdkt],member.pSetLayouts[uklMdkt]);}();
        }
        }();
auto& pushConstantRangeCount_json=json["pushConstantRangeCount"];
[&](){pushConstantRangeCount_json=member.pushConstantRangeCount;}();
auto& pPushConstantRanges_json=json["pPushConstantRanges"];
[&](){
            if (member.pPushConstantRanges==NULL){
                pPushConstantRanges_json=boost::json::array();
            return; }pPushConstantRanges_json=boost::json::array(member.pushConstantRangeCount);
        auto& arr_doTQoKZ=pPushConstantRanges_json.as_array();
        for(int IhaFWFv=0; IhaFWFv < member.pushConstantRangeCount; IhaFWFv++){
            [&](){
            auto& temp=arr_doTQoKZ[IhaFWFv].emplace_object();
            return serialize_struct(temp, member.pPushConstantRanges[IhaFWFv]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineLayoutCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_uOmDseJ;[&](){temp_uOmDseJ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineLayoutCreateFlags)temp_uOmDseJ;}();}();
auto& setLayoutCount_json=json["setLayoutCount"];
[&](){member.setLayoutCount=static_cast<uint32_t>(value_to<int>(setLayoutCount_json));}();
auto& pSetLayouts_json=json["pSetLayouts"];
[&](){ VkDescriptorSetLayout* temp_bpLPvjG;;[&](){
            if (pSetLayouts_json.as_array().size()==0){
                temp_bpLPvjG=NULL;
            return; }temp_bpLPvjG=(VkDescriptorSetLayout*)malloc(member.setLayoutCount*sizeof(VkDescriptorSetLayout));
        auto& arr_KfikEjZ=pSetLayouts_json.as_array();
        for(int nDMuHRP=0; nDMuHRP < member.setLayoutCount; nDMuHRP++){
            [&](){deserialize_VkDescriptorSetLayout(arr_KfikEjZ[nDMuHRP], temp_bpLPvjG[nDMuHRP]);}();
        }
        }();member.pSetLayouts=temp_bpLPvjG;}();
auto& pushConstantRangeCount_json=json["pushConstantRangeCount"];
[&](){member.pushConstantRangeCount=static_cast<uint32_t>(value_to<int>(pushConstantRangeCount_json));}();
auto& pPushConstantRanges_json=json["pPushConstantRanges"];
[&](){ VkPushConstantRange* temp_VHwwNeL;;[&](){
            if (pPushConstantRanges_json.as_array().size()==0){
                temp_VHwwNeL=NULL;
            return; }temp_VHwwNeL=(VkPushConstantRange*)malloc(member.pushConstantRangeCount*sizeof(VkPushConstantRange));
        auto& arr_ezithAb=pPushConstantRanges_json.as_array();
        for(int RRqDZWS=0; RRqDZWS < member.pushConstantRangeCount; RRqDZWS++){
            [&](){
            auto& temp=arr_ezithAb[RRqDZWS].as_object();
            deserialize_struct(temp,temp_VHwwNeL[RRqDZWS]);
            }();
        }
        }();member.pPushConstantRanges=temp_VHwwNeL;}();
}

    void serialize_struct(boost::json::object& json, const VkSamplerCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& magFilter_json=json["magFilter"];
[&](){[&](){[&](){magFilter_json=member.magFilter;}();}();}();
auto& minFilter_json=json["minFilter"];
[&](){[&](){[&](){minFilter_json=member.minFilter;}();}();}();
auto& mipmapMode_json=json["mipmapMode"];
[&](){[&](){[&](){mipmapMode_json=member.mipmapMode;}();}();}();
auto& addressModeU_json=json["addressModeU"];
[&](){[&](){[&](){addressModeU_json=member.addressModeU;}();}();}();
auto& addressModeV_json=json["addressModeV"];
[&](){[&](){[&](){addressModeV_json=member.addressModeV;}();}();}();
auto& addressModeW_json=json["addressModeW"];
[&](){[&](){[&](){addressModeW_json=member.addressModeW;}();}();}();
auto& mipLodBias_json=json["mipLodBias"];
[&](){mipLodBias_json=member.mipLodBias;}();
auto& anisotropyEnable_json=json["anisotropyEnable"];
[&](){[&](){anisotropyEnable_json=member.anisotropyEnable;}();}();
auto& maxAnisotropy_json=json["maxAnisotropy"];
[&](){maxAnisotropy_json=member.maxAnisotropy;}();
auto& compareEnable_json=json["compareEnable"];
[&](){[&](){compareEnable_json=member.compareEnable;}();}();
auto& compareOp_json=json["compareOp"];
[&](){[&](){[&](){compareOp_json=member.compareOp;}();}();}();
auto& minLod_json=json["minLod"];
[&](){minLod_json=member.minLod;}();
auto& maxLod_json=json["maxLod"];
[&](){maxLod_json=member.maxLod;}();
auto& borderColor_json=json["borderColor"];
[&](){[&](){[&](){borderColor_json=member.borderColor;}();}();}();
auto& unnormalizedCoordinates_json=json["unnormalizedCoordinates"];
[&](){[&](){unnormalizedCoordinates_json=member.unnormalizedCoordinates;}();}();
}
void deserialize_struct(boost::json::object& json, VkSamplerCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_CxZpBwD;[&](){temp_CxZpBwD=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSamplerCreateFlags)temp_CxZpBwD;}();}();
auto& magFilter_json=json["magFilter"];
[&](){[&](){int temp_nbUrGit;[&](){temp_nbUrGit=static_cast<int>(value_to<int>(magFilter_json));}();member.magFilter=(VkFilter)temp_nbUrGit;}();}();
auto& minFilter_json=json["minFilter"];
[&](){[&](){int temp_vDtCftv;[&](){temp_vDtCftv=static_cast<int>(value_to<int>(minFilter_json));}();member.minFilter=(VkFilter)temp_vDtCftv;}();}();
auto& mipmapMode_json=json["mipmapMode"];
[&](){[&](){int temp_nydbTxo;[&](){temp_nydbTxo=static_cast<int>(value_to<int>(mipmapMode_json));}();member.mipmapMode=(VkSamplerMipmapMode)temp_nydbTxo;}();}();
auto& addressModeU_json=json["addressModeU"];
[&](){[&](){int temp_WzwUpxY;[&](){temp_WzwUpxY=static_cast<int>(value_to<int>(addressModeU_json));}();member.addressModeU=(VkSamplerAddressMode)temp_WzwUpxY;}();}();
auto& addressModeV_json=json["addressModeV"];
[&](){[&](){int temp_UNAdlov;[&](){temp_UNAdlov=static_cast<int>(value_to<int>(addressModeV_json));}();member.addressModeV=(VkSamplerAddressMode)temp_UNAdlov;}();}();
auto& addressModeW_json=json["addressModeW"];
[&](){[&](){int temp_ZLGMpWf;[&](){temp_ZLGMpWf=static_cast<int>(value_to<int>(addressModeW_json));}();member.addressModeW=(VkSamplerAddressMode)temp_ZLGMpWf;}();}();
auto& mipLodBias_json=json["mipLodBias"];
[&](){member.mipLodBias=static_cast<float>(value_to<int>(mipLodBias_json));}();
auto& anisotropyEnable_json=json["anisotropyEnable"];
[&](){uint32_t temp_OQzpuIP;[&](){temp_OQzpuIP=static_cast<uint32_t>(value_to<int>(anisotropyEnable_json));}();member.anisotropyEnable=(VkBool32)temp_OQzpuIP;}();
auto& maxAnisotropy_json=json["maxAnisotropy"];
[&](){member.maxAnisotropy=static_cast<float>(value_to<int>(maxAnisotropy_json));}();
auto& compareEnable_json=json["compareEnable"];
[&](){uint32_t temp_telXFSk;[&](){temp_telXFSk=static_cast<uint32_t>(value_to<int>(compareEnable_json));}();member.compareEnable=(VkBool32)temp_telXFSk;}();
auto& compareOp_json=json["compareOp"];
[&](){[&](){int temp_xnZScEW;[&](){temp_xnZScEW=static_cast<int>(value_to<int>(compareOp_json));}();member.compareOp=(VkCompareOp)temp_xnZScEW;}();}();
auto& minLod_json=json["minLod"];
[&](){member.minLod=static_cast<float>(value_to<int>(minLod_json));}();
auto& maxLod_json=json["maxLod"];
[&](){member.maxLod=static_cast<float>(value_to<int>(maxLod_json));}();
auto& borderColor_json=json["borderColor"];
[&](){[&](){int temp_lbYcmml;[&](){temp_lbYcmml=static_cast<int>(value_to<int>(borderColor_json));}();member.borderColor=(VkBorderColor)temp_lbYcmml;}();}();
auto& unnormalizedCoordinates_json=json["unnormalizedCoordinates"];
[&](){uint32_t temp_dsJhPch;[&](){temp_dsJhPch=static_cast<uint32_t>(value_to<int>(unnormalizedCoordinates_json));}();member.unnormalizedCoordinates=(VkBool32)temp_dsJhPch;}();
}

    void serialize_struct(boost::json::object& json, const VkCommandPoolCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){queueFamilyIndex_json=member.queueFamilyIndex;}();
}
void deserialize_struct(boost::json::object& json, VkCommandPoolCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_GfUnotK;[&](){temp_GfUnotK=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkCommandPoolCreateFlags)temp_GfUnotK;}();}();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){member.queueFamilyIndex=static_cast<uint32_t>(value_to<int>(queueFamilyIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkCommandBufferAllocateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& commandPool_json=json["commandPool"];
[&](){serialize_VkCommandPool(commandPool_json,member.commandPool);}();
auto& level_json=json["level"];
[&](){[&](){[&](){level_json=member.level;}();}();}();
auto& commandBufferCount_json=json["commandBufferCount"];
[&](){commandBufferCount_json=member.commandBufferCount;}();
}
void deserialize_struct(boost::json::object& json, VkCommandBufferAllocateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& commandPool_json=json["commandPool"];
[&](){deserialize_VkCommandPool(commandPool_json, member.commandPool);}();
auto& level_json=json["level"];
[&](){[&](){int temp_aVOzlIb;[&](){temp_aVOzlIb=static_cast<int>(value_to<int>(level_json));}();member.level=(VkCommandBufferLevel)temp_aVOzlIb;}();}();
auto& commandBufferCount_json=json["commandBufferCount"];
[&](){member.commandBufferCount=static_cast<uint32_t>(value_to<int>(commandBufferCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkCommandBufferInheritanceInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& renderPass_json=json["renderPass"];
[&](){serialize_VkRenderPass(renderPass_json,member.renderPass);}();
auto& subpass_json=json["subpass"];
[&](){subpass_json=member.subpass;}();
auto& framebuffer_json=json["framebuffer"];
[&](){serialize_VkFramebuffer(framebuffer_json,member.framebuffer);}();
auto& occlusionQueryEnable_json=json["occlusionQueryEnable"];
[&](){[&](){occlusionQueryEnable_json=member.occlusionQueryEnable;}();}();
auto& queryFlags_json=json["queryFlags"];
[&](){[&](){[&](){queryFlags_json=member.queryFlags;}();}();}();
auto& pipelineStatistics_json=json["pipelineStatistics"];
[&](){[&](){[&](){pipelineStatistics_json=member.pipelineStatistics;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCommandBufferInheritanceInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& renderPass_json=json["renderPass"];
[&](){deserialize_VkRenderPass(renderPass_json, member.renderPass);}();
auto& subpass_json=json["subpass"];
[&](){member.subpass=static_cast<uint32_t>(value_to<int>(subpass_json));}();
auto& framebuffer_json=json["framebuffer"];
[&](){deserialize_VkFramebuffer(framebuffer_json, member.framebuffer);}();
auto& occlusionQueryEnable_json=json["occlusionQueryEnable"];
[&](){uint32_t temp_QhbkIIC;[&](){temp_QhbkIIC=static_cast<uint32_t>(value_to<int>(occlusionQueryEnable_json));}();member.occlusionQueryEnable=(VkBool32)temp_QhbkIIC;}();
auto& queryFlags_json=json["queryFlags"];
[&](){[&](){int temp_wmCpnVR;[&](){temp_wmCpnVR=static_cast<int>(value_to<int>(queryFlags_json));}();member.queryFlags=(VkQueryControlFlags)temp_wmCpnVR;}();}();
auto& pipelineStatistics_json=json["pipelineStatistics"];
[&](){[&](){int temp_OdKoqRB;[&](){temp_OdKoqRB=static_cast<int>(value_to<int>(pipelineStatistics_json));}();member.pipelineStatistics=(VkQueryPipelineStatisticFlags)temp_OdKoqRB;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCommandBufferBeginInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pInheritanceInfo_json=json["pInheritanceInfo"];
[&](){
            if (member.pInheritanceInfo==NULL){
                pInheritanceInfo_json=boost::json::array();
            return; }pInheritanceInfo_json=boost::json::array(1);
        auto& arr_PAjnrNx=pInheritanceInfo_json.as_array();
        for(int bGTbYrK=0; bGTbYrK < 1; bGTbYrK++){
            [&](){
            auto& temp=arr_PAjnrNx[bGTbYrK].emplace_object();
            return serialize_struct(temp, member.pInheritanceInfo[bGTbYrK]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCommandBufferBeginInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_LtBykeZ;[&](){temp_LtBykeZ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkCommandBufferUsageFlags)temp_LtBykeZ;}();}();
auto& pInheritanceInfo_json=json["pInheritanceInfo"];
[&](){ VkCommandBufferInheritanceInfo* temp_vIPUbSt;;[&](){
            if (pInheritanceInfo_json.as_array().size()==0){
                temp_vIPUbSt=NULL;
            return; }temp_vIPUbSt=(VkCommandBufferInheritanceInfo*)malloc(1*sizeof(VkCommandBufferInheritanceInfo));
        auto& arr_oaaLljo=pInheritanceInfo_json.as_array();
        for(int vFXUxqt=0; vFXUxqt < 1; vFXUxqt++){
            [&](){
            auto& temp=arr_oaaLljo[vFXUxqt].as_object();
            deserialize_struct(temp,temp_vIPUbSt[vFXUxqt]);
            }();
        }
        }();member.pInheritanceInfo=temp_vIPUbSt;}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassBeginInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& renderPass_json=json["renderPass"];
[&](){serialize_VkRenderPass(renderPass_json,member.renderPass);}();
auto& framebuffer_json=json["framebuffer"];
[&](){serialize_VkFramebuffer(framebuffer_json,member.framebuffer);}();
auto& renderArea_json=json["renderArea"];
[&](){
            auto& temp=renderArea_json.emplace_object();
            return serialize_struct(temp, member.renderArea);
            }();
auto& clearValueCount_json=json["clearValueCount"];
[&](){clearValueCount_json=member.clearValueCount;}();
auto& pClearValues_json=json["pClearValues"];
[&](){
            if (member.pClearValues==NULL){
                pClearValues_json=boost::json::array();
            return; }pClearValues_json=boost::json::array(member.clearValueCount);
        auto& arr_EjHFbnM=pClearValues_json.as_array();
        for(int rfbiVln=0; rfbiVln < member.clearValueCount; rfbiVln++){
            [&](){
            auto& temp=arr_EjHFbnM[rfbiVln].emplace_object();
            return serialize_struct(temp, member.pClearValues[rfbiVln]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassBeginInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& renderPass_json=json["renderPass"];
[&](){deserialize_VkRenderPass(renderPass_json, member.renderPass);}();
auto& framebuffer_json=json["framebuffer"];
[&](){deserialize_VkFramebuffer(framebuffer_json, member.framebuffer);}();
auto& renderArea_json=json["renderArea"];
[&](){
            auto& temp=renderArea_json.as_object();
            deserialize_struct(temp,member.renderArea);
            }();
auto& clearValueCount_json=json["clearValueCount"];
[&](){member.clearValueCount=static_cast<uint32_t>(value_to<int>(clearValueCount_json));}();
auto& pClearValues_json=json["pClearValues"];
[&](){ VkClearValue* temp_WmLQpNF;;[&](){
            if (pClearValues_json.as_array().size()==0){
                temp_WmLQpNF=NULL;
            return; }temp_WmLQpNF=(VkClearValue*)malloc(member.clearValueCount*sizeof(VkClearValue));
        auto& arr_EEtzpqV=pClearValues_json.as_array();
        for(int UyuyRAd=0; UyuyRAd < member.clearValueCount; UyuyRAd++){
            [&](){
            auto& temp=arr_EEtzpqV[UyuyRAd].as_object();
            deserialize_struct(temp,temp_WmLQpNF[UyuyRAd]);
            }();
        }
        }();member.pClearValues=temp_WmLQpNF;}();
}

    void serialize_struct(boost::json::object& json, const VkClearColorValue& member){
        
    
auto& float32_json=json["float32"];
[&](){float32_json=boost::json::array(4);
        auto& arr_omPSdwq=float32_json.as_array();
        for(int RHZEIfX=0; RHZEIfX < 4; RHZEIfX++){
            [&](){arr_omPSdwq[RHZEIfX]=member.float32[RHZEIfX];}();
        }
        }();
auto& int32_json=json["int32"];
[&](){int32_json=boost::json::array(4);
        auto& arr_XYZztdl=int32_json.as_array();
        for(int numzepE=0; numzepE < 4; numzepE++){
            [&](){arr_XYZztdl[numzepE]=member.int32[numzepE];}();
        }
        }();
auto& uint32_json=json["uint32"];
[&](){uint32_json=boost::json::array(4);
        auto& arr_piDmlAI=uint32_json.as_array();
        for(int uljKkhi=0; uljKkhi < 4; uljKkhi++){
            [&](){arr_piDmlAI[uljKkhi]=member.uint32[uljKkhi];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkClearColorValue& member){
auto& float32_json=json["float32"];
[&](){
        auto& arr_omPSdwq=float32_json.as_array();
        for(int RHZEIfX=0; RHZEIfX < 4; RHZEIfX++){
            [&](){member.float32[RHZEIfX]=static_cast<float>(value_to<int>(arr_omPSdwq[RHZEIfX]));}();
        }
        }();
auto& int32_json=json["int32"];
[&](){
        auto& arr_XYZztdl=int32_json.as_array();
        for(int numzepE=0; numzepE < 4; numzepE++){
            [&](){member.int32[numzepE]=static_cast<int32_t>(value_to<int>(arr_XYZztdl[numzepE]));}();
        }
        }();
auto& uint32_json=json["uint32"];
[&](){
        auto& arr_piDmlAI=uint32_json.as_array();
        for(int uljKkhi=0; uljKkhi < 4; uljKkhi++){
            [&](){member.uint32[uljKkhi]=static_cast<uint32_t>(value_to<int>(arr_piDmlAI[uljKkhi]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkClearDepthStencilValue& member){
        
    
auto& depth_json=json["depth"];
[&](){depth_json=member.depth;}();
auto& stencil_json=json["stencil"];
[&](){stencil_json=member.stencil;}();
}
void deserialize_struct(boost::json::object& json, VkClearDepthStencilValue& member){
auto& depth_json=json["depth"];
[&](){member.depth=static_cast<float>(value_to<int>(depth_json));}();
auto& stencil_json=json["stencil"];
[&](){member.stencil=static_cast<uint32_t>(value_to<int>(stencil_json));}();
}

    void serialize_struct(boost::json::object& json, const VkClearValue& member){
        
    
auto& color_json=json["color"];
[&](){
            auto& temp=color_json.emplace_object();
            return serialize_struct(temp, member.color);
            }();
auto& depthStencil_json=json["depthStencil"];
[&](){
            auto& temp=depthStencil_json.emplace_object();
            return serialize_struct(temp, member.depthStencil);
            }();
}
void deserialize_struct(boost::json::object& json, VkClearValue& member){
auto& color_json=json["color"];
[&](){
            auto& temp=color_json.as_object();
            deserialize_struct(temp,member.color);
            }();
auto& depthStencil_json=json["depthStencil"];
[&](){
            auto& temp=depthStencil_json.as_object();
            deserialize_struct(temp,member.depthStencil);
            }();
}

    void serialize_struct(boost::json::object& json, const VkClearAttachment& member){
        
    
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){[&](){aspectMask_json=member.aspectMask;}();}();}();
auto& colorAttachment_json=json["colorAttachment"];
[&](){colorAttachment_json=member.colorAttachment;}();
auto& clearValue_json=json["clearValue"];
[&](){
            auto& temp=clearValue_json.emplace_object();
            return serialize_struct(temp, member.clearValue);
            }();
}
void deserialize_struct(boost::json::object& json, VkClearAttachment& member){
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){int temp_srmSgxC;[&](){temp_srmSgxC=static_cast<int>(value_to<int>(aspectMask_json));}();member.aspectMask=(VkImageAspectFlags)temp_srmSgxC;}();}();
auto& colorAttachment_json=json["colorAttachment"];
[&](){member.colorAttachment=static_cast<uint32_t>(value_to<int>(colorAttachment_json));}();
auto& clearValue_json=json["clearValue"];
[&](){
            auto& temp=clearValue_json.as_object();
            deserialize_struct(temp,member.clearValue);
            }();
}

    void serialize_struct(boost::json::object& json, const VkAttachmentDescription& member){
        
    
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& samples_json=json["samples"];
[&](){[&](){[&](){samples_json=member.samples;}();}();}();
auto& loadOp_json=json["loadOp"];
[&](){[&](){[&](){loadOp_json=member.loadOp;}();}();}();
auto& storeOp_json=json["storeOp"];
[&](){[&](){[&](){storeOp_json=member.storeOp;}();}();}();
auto& stencilLoadOp_json=json["stencilLoadOp"];
[&](){[&](){[&](){stencilLoadOp_json=member.stencilLoadOp;}();}();}();
auto& stencilStoreOp_json=json["stencilStoreOp"];
[&](){[&](){[&](){stencilStoreOp_json=member.stencilStoreOp;}();}();}();
auto& initialLayout_json=json["initialLayout"];
[&](){[&](){[&](){initialLayout_json=member.initialLayout;}();}();}();
auto& finalLayout_json=json["finalLayout"];
[&](){[&](){[&](){finalLayout_json=member.finalLayout;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkAttachmentDescription& member){
auto& flags_json=json["flags"];
[&](){[&](){int temp_ghpfkho;[&](){temp_ghpfkho=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkAttachmentDescriptionFlags)temp_ghpfkho;}();}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& samples_json=json["samples"];
[&](){[&](){int temp_HAQfesR;[&](){temp_HAQfesR=static_cast<int>(value_to<int>(samples_json));}();member.samples=(VkSampleCountFlagBits)temp_HAQfesR;}();}();
auto& loadOp_json=json["loadOp"];
[&](){[&](){int temp_FWnxBHJ;[&](){temp_FWnxBHJ=static_cast<int>(value_to<int>(loadOp_json));}();member.loadOp=(VkAttachmentLoadOp)temp_FWnxBHJ;}();}();
auto& storeOp_json=json["storeOp"];
[&](){[&](){int temp_fIASqxv;[&](){temp_fIASqxv=static_cast<int>(value_to<int>(storeOp_json));}();member.storeOp=(VkAttachmentStoreOp)temp_fIASqxv;}();}();
auto& stencilLoadOp_json=json["stencilLoadOp"];
[&](){[&](){int temp_jznxgLa;[&](){temp_jznxgLa=static_cast<int>(value_to<int>(stencilLoadOp_json));}();member.stencilLoadOp=(VkAttachmentLoadOp)temp_jznxgLa;}();}();
auto& stencilStoreOp_json=json["stencilStoreOp"];
[&](){[&](){int temp_aqhHNNp;[&](){temp_aqhHNNp=static_cast<int>(value_to<int>(stencilStoreOp_json));}();member.stencilStoreOp=(VkAttachmentStoreOp)temp_aqhHNNp;}();}();
auto& initialLayout_json=json["initialLayout"];
[&](){[&](){int temp_TsZaHzS;[&](){temp_TsZaHzS=static_cast<int>(value_to<int>(initialLayout_json));}();member.initialLayout=(VkImageLayout)temp_TsZaHzS;}();}();
auto& finalLayout_json=json["finalLayout"];
[&](){[&](){int temp_ZJMaJVD;[&](){temp_ZJMaJVD=static_cast<int>(value_to<int>(finalLayout_json));}();member.finalLayout=(VkImageLayout)temp_ZJMaJVD;}();}();
}

    void serialize_struct(boost::json::object& json, const VkAttachmentReference& member){
        
    
auto& attachment_json=json["attachment"];
[&](){attachment_json=member.attachment;}();
auto& layout_json=json["layout"];
[&](){[&](){[&](){layout_json=member.layout;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkAttachmentReference& member){
auto& attachment_json=json["attachment"];
[&](){member.attachment=static_cast<uint32_t>(value_to<int>(attachment_json));}();
auto& layout_json=json["layout"];
[&](){[&](){int temp_TkPJJWY;[&](){temp_TkPJJWY=static_cast<int>(value_to<int>(layout_json));}();member.layout=(VkImageLayout)temp_TkPJJWY;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSubpassDescription& member){
        
    
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){[&](){pipelineBindPoint_json=member.pipelineBindPoint;}();}();}();
auto& inputAttachmentCount_json=json["inputAttachmentCount"];
[&](){inputAttachmentCount_json=member.inputAttachmentCount;}();
auto& pInputAttachments_json=json["pInputAttachments"];
[&](){
            if (member.pInputAttachments==NULL){
                pInputAttachments_json=boost::json::array();
            return; }pInputAttachments_json=boost::json::array(member.inputAttachmentCount);
        auto& arr_KLGwzOx=pInputAttachments_json.as_array();
        for(int fcmsdlH=0; fcmsdlH < member.inputAttachmentCount; fcmsdlH++){
            [&](){
            auto& temp=arr_KLGwzOx[fcmsdlH].emplace_object();
            return serialize_struct(temp, member.pInputAttachments[fcmsdlH]);
            }();
        }
        }();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){colorAttachmentCount_json=member.colorAttachmentCount;}();
auto& pColorAttachments_json=json["pColorAttachments"];
[&](){
            if (member.pColorAttachments==NULL){
                pColorAttachments_json=boost::json::array();
            return; }pColorAttachments_json=boost::json::array(member.colorAttachmentCount);
        auto& arr_PChCviG=pColorAttachments_json.as_array();
        for(int NEsWaUO=0; NEsWaUO < member.colorAttachmentCount; NEsWaUO++){
            [&](){
            auto& temp=arr_PChCviG[NEsWaUO].emplace_object();
            return serialize_struct(temp, member.pColorAttachments[NEsWaUO]);
            }();
        }
        }();
auto& pResolveAttachments_json=json["pResolveAttachments"];
[&](){
            if (member.pResolveAttachments==NULL){
                pResolveAttachments_json=boost::json::array();
            return; }pResolveAttachments_json=boost::json::array(member.colorAttachmentCount);
        auto& arr_YtbBtCp=pResolveAttachments_json.as_array();
        for(int HXoIIAZ=0; HXoIIAZ < member.colorAttachmentCount; HXoIIAZ++){
            [&](){
            auto& temp=arr_YtbBtCp[HXoIIAZ].emplace_object();
            return serialize_struct(temp, member.pResolveAttachments[HXoIIAZ]);
            }();
        }
        }();
auto& pDepthStencilAttachment_json=json["pDepthStencilAttachment"];
[&](){
            if (member.pDepthStencilAttachment==NULL){
                pDepthStencilAttachment_json=boost::json::array();
            return; }pDepthStencilAttachment_json=boost::json::array(1);
        auto& arr_irkynNl=pDepthStencilAttachment_json.as_array();
        for(int CQzmEZj=0; CQzmEZj < 1; CQzmEZj++){
            [&](){
            auto& temp=arr_irkynNl[CQzmEZj].emplace_object();
            return serialize_struct(temp, member.pDepthStencilAttachment[CQzmEZj]);
            }();
        }
        }();
auto& preserveAttachmentCount_json=json["preserveAttachmentCount"];
[&](){preserveAttachmentCount_json=member.preserveAttachmentCount;}();
auto& pPreserveAttachments_json=json["pPreserveAttachments"];
[&](){
            if (member.pPreserveAttachments==NULL){
                pPreserveAttachments_json=boost::json::array();
            return; }pPreserveAttachments_json=boost::json::array(member.preserveAttachmentCount);
        auto& arr_JglfHnP=pPreserveAttachments_json.as_array();
        for(int GdjjjYx=0; GdjjjYx < member.preserveAttachmentCount; GdjjjYx++){
            [&](){arr_JglfHnP[GdjjjYx]=member.pPreserveAttachments[GdjjjYx];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSubpassDescription& member){
auto& flags_json=json["flags"];
[&](){[&](){int temp_QvdTojH;[&](){temp_QvdTojH=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSubpassDescriptionFlags)temp_QvdTojH;}();}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){int temp_WiAtSfj;[&](){temp_WiAtSfj=static_cast<int>(value_to<int>(pipelineBindPoint_json));}();member.pipelineBindPoint=(VkPipelineBindPoint)temp_WiAtSfj;}();}();
auto& inputAttachmentCount_json=json["inputAttachmentCount"];
[&](){member.inputAttachmentCount=static_cast<uint32_t>(value_to<int>(inputAttachmentCount_json));}();
auto& pInputAttachments_json=json["pInputAttachments"];
[&](){ VkAttachmentReference* temp_UdteYxB;;[&](){
            if (pInputAttachments_json.as_array().size()==0){
                temp_UdteYxB=NULL;
            return; }temp_UdteYxB=(VkAttachmentReference*)malloc(member.inputAttachmentCount*sizeof(VkAttachmentReference));
        auto& arr_wyjJdTe=pInputAttachments_json.as_array();
        for(int HZAoYcR=0; HZAoYcR < member.inputAttachmentCount; HZAoYcR++){
            [&](){
            auto& temp=arr_wyjJdTe[HZAoYcR].as_object();
            deserialize_struct(temp,temp_UdteYxB[HZAoYcR]);
            }();
        }
        }();member.pInputAttachments=temp_UdteYxB;}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){member.colorAttachmentCount=static_cast<uint32_t>(value_to<int>(colorAttachmentCount_json));}();
auto& pColorAttachments_json=json["pColorAttachments"];
[&](){ VkAttachmentReference* temp_gGwFBaG;;[&](){
            if (pColorAttachments_json.as_array().size()==0){
                temp_gGwFBaG=NULL;
            return; }temp_gGwFBaG=(VkAttachmentReference*)malloc(member.colorAttachmentCount*sizeof(VkAttachmentReference));
        auto& arr_uSMkpTS=pColorAttachments_json.as_array();
        for(int CHWEiZy=0; CHWEiZy < member.colorAttachmentCount; CHWEiZy++){
            [&](){
            auto& temp=arr_uSMkpTS[CHWEiZy].as_object();
            deserialize_struct(temp,temp_gGwFBaG[CHWEiZy]);
            }();
        }
        }();member.pColorAttachments=temp_gGwFBaG;}();
auto& pResolveAttachments_json=json["pResolveAttachments"];
[&](){ VkAttachmentReference* temp_rCdSAub;;[&](){
            if (pResolveAttachments_json.as_array().size()==0){
                temp_rCdSAub=NULL;
            return; }temp_rCdSAub=(VkAttachmentReference*)malloc(member.colorAttachmentCount*sizeof(VkAttachmentReference));
        auto& arr_MBUCyac=pResolveAttachments_json.as_array();
        for(int wgtHfTl=0; wgtHfTl < member.colorAttachmentCount; wgtHfTl++){
            [&](){
            auto& temp=arr_MBUCyac[wgtHfTl].as_object();
            deserialize_struct(temp,temp_rCdSAub[wgtHfTl]);
            }();
        }
        }();member.pResolveAttachments=temp_rCdSAub;}();
auto& pDepthStencilAttachment_json=json["pDepthStencilAttachment"];
[&](){ VkAttachmentReference* temp_qxwbCyQ;;[&](){
            if (pDepthStencilAttachment_json.as_array().size()==0){
                temp_qxwbCyQ=NULL;
            return; }temp_qxwbCyQ=(VkAttachmentReference*)malloc(1*sizeof(VkAttachmentReference));
        auto& arr_xDxdUJV=pDepthStencilAttachment_json.as_array();
        for(int KQovUsn=0; KQovUsn < 1; KQovUsn++){
            [&](){
            auto& temp=arr_xDxdUJV[KQovUsn].as_object();
            deserialize_struct(temp,temp_qxwbCyQ[KQovUsn]);
            }();
        }
        }();member.pDepthStencilAttachment=temp_qxwbCyQ;}();
auto& preserveAttachmentCount_json=json["preserveAttachmentCount"];
[&](){member.preserveAttachmentCount=static_cast<uint32_t>(value_to<int>(preserveAttachmentCount_json));}();
auto& pPreserveAttachments_json=json["pPreserveAttachments"];
[&](){ uint32_t* temp_jnYWItN;;[&](){
            if (pPreserveAttachments_json.as_array().size()==0){
                temp_jnYWItN=NULL;
            return; }temp_jnYWItN=(uint32_t*)malloc(member.preserveAttachmentCount*sizeof(uint32_t));
        auto& arr_sEqrXMO=pPreserveAttachments_json.as_array();
        for(int AzzybZu=0; AzzybZu < member.preserveAttachmentCount; AzzybZu++){
            [&](){temp_jnYWItN[AzzybZu]=static_cast<uint32_t>(value_to<int>(arr_sEqrXMO[AzzybZu]));}();
        }
        }();member.pPreserveAttachments=temp_jnYWItN;}();
}

    void serialize_struct(boost::json::object& json, const VkSubpassDependency& member){
        
    
auto& srcSubpass_json=json["srcSubpass"];
[&](){srcSubpass_json=member.srcSubpass;}();
auto& dstSubpass_json=json["dstSubpass"];
[&](){dstSubpass_json=member.dstSubpass;}();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){[&](){srcStageMask_json=member.srcStageMask;}();}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){[&](){dstStageMask_json=member.dstStageMask;}();}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){[&](){srcAccessMask_json=member.srcAccessMask;}();}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){[&](){dstAccessMask_json=member.dstAccessMask;}();}();}();
auto& dependencyFlags_json=json["dependencyFlags"];
[&](){[&](){[&](){dependencyFlags_json=member.dependencyFlags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSubpassDependency& member){
auto& srcSubpass_json=json["srcSubpass"];
[&](){member.srcSubpass=static_cast<uint32_t>(value_to<int>(srcSubpass_json));}();
auto& dstSubpass_json=json["dstSubpass"];
[&](){member.dstSubpass=static_cast<uint32_t>(value_to<int>(dstSubpass_json));}();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){int temp_OagNenu;[&](){temp_OagNenu=static_cast<int>(value_to<int>(srcStageMask_json));}();member.srcStageMask=(VkPipelineStageFlags)temp_OagNenu;}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){int temp_uQeYZtj;[&](){temp_uQeYZtj=static_cast<int>(value_to<int>(dstStageMask_json));}();member.dstStageMask=(VkPipelineStageFlags)temp_uQeYZtj;}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){int temp_YMhhQIt;[&](){temp_YMhhQIt=static_cast<int>(value_to<int>(srcAccessMask_json));}();member.srcAccessMask=(VkAccessFlags)temp_YMhhQIt;}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){int temp_cyeCcOP;[&](){temp_cyeCcOP=static_cast<int>(value_to<int>(dstAccessMask_json));}();member.dstAccessMask=(VkAccessFlags)temp_cyeCcOP;}();}();
auto& dependencyFlags_json=json["dependencyFlags"];
[&](){[&](){int temp_BaltLwx;[&](){temp_BaltLwx=static_cast<int>(value_to<int>(dependencyFlags_json));}();member.dependencyFlags=(VkDependencyFlags)temp_BaltLwx;}();}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){attachmentCount_json=member.attachmentCount;}();
auto& pAttachments_json=json["pAttachments"];
[&](){
            if (member.pAttachments==NULL){
                pAttachments_json=boost::json::array();
            return; }pAttachments_json=boost::json::array(member.attachmentCount);
        auto& arr_eNXksbn=pAttachments_json.as_array();
        for(int EAnEZOy=0; EAnEZOy < member.attachmentCount; EAnEZOy++){
            [&](){
            auto& temp=arr_eNXksbn[EAnEZOy].emplace_object();
            return serialize_struct(temp, member.pAttachments[EAnEZOy]);
            }();
        }
        }();
auto& subpassCount_json=json["subpassCount"];
[&](){subpassCount_json=member.subpassCount;}();
auto& pSubpasses_json=json["pSubpasses"];
[&](){
            if (member.pSubpasses==NULL){
                pSubpasses_json=boost::json::array();
            return; }pSubpasses_json=boost::json::array(member.subpassCount);
        auto& arr_TnSUMFM=pSubpasses_json.as_array();
        for(int fNtyFzh=0; fNtyFzh < member.subpassCount; fNtyFzh++){
            [&](){
            auto& temp=arr_TnSUMFM[fNtyFzh].emplace_object();
            return serialize_struct(temp, member.pSubpasses[fNtyFzh]);
            }();
        }
        }();
auto& dependencyCount_json=json["dependencyCount"];
[&](){dependencyCount_json=member.dependencyCount;}();
auto& pDependencies_json=json["pDependencies"];
[&](){
            if (member.pDependencies==NULL){
                pDependencies_json=boost::json::array();
            return; }pDependencies_json=boost::json::array(member.dependencyCount);
        auto& arr_IXOqlEN=pDependencies_json.as_array();
        for(int ivzxefA=0; ivzxefA < member.dependencyCount; ivzxefA++){
            [&](){
            auto& temp=arr_IXOqlEN[ivzxefA].emplace_object();
            return serialize_struct(temp, member.pDependencies[ivzxefA]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_lmsxAlv;[&](){temp_lmsxAlv=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkRenderPassCreateFlags)temp_lmsxAlv;}();}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){member.attachmentCount=static_cast<uint32_t>(value_to<int>(attachmentCount_json));}();
auto& pAttachments_json=json["pAttachments"];
[&](){ VkAttachmentDescription* temp_ExSqFdt;;[&](){
            if (pAttachments_json.as_array().size()==0){
                temp_ExSqFdt=NULL;
            return; }temp_ExSqFdt=(VkAttachmentDescription*)malloc(member.attachmentCount*sizeof(VkAttachmentDescription));
        auto& arr_BDoVCqp=pAttachments_json.as_array();
        for(int cfilbBF=0; cfilbBF < member.attachmentCount; cfilbBF++){
            [&](){
            auto& temp=arr_BDoVCqp[cfilbBF].as_object();
            deserialize_struct(temp,temp_ExSqFdt[cfilbBF]);
            }();
        }
        }();member.pAttachments=temp_ExSqFdt;}();
auto& subpassCount_json=json["subpassCount"];
[&](){member.subpassCount=static_cast<uint32_t>(value_to<int>(subpassCount_json));}();
auto& pSubpasses_json=json["pSubpasses"];
[&](){ VkSubpassDescription* temp_JhMDnGk;;[&](){
            if (pSubpasses_json.as_array().size()==0){
                temp_JhMDnGk=NULL;
            return; }temp_JhMDnGk=(VkSubpassDescription*)malloc(member.subpassCount*sizeof(VkSubpassDescription));
        auto& arr_QBMevFV=pSubpasses_json.as_array();
        for(int xtJDQLK=0; xtJDQLK < member.subpassCount; xtJDQLK++){
            [&](){
            auto& temp=arr_QBMevFV[xtJDQLK].as_object();
            deserialize_struct(temp,temp_JhMDnGk[xtJDQLK]);
            }();
        }
        }();member.pSubpasses=temp_JhMDnGk;}();
auto& dependencyCount_json=json["dependencyCount"];
[&](){member.dependencyCount=static_cast<uint32_t>(value_to<int>(dependencyCount_json));}();
auto& pDependencies_json=json["pDependencies"];
[&](){ VkSubpassDependency* temp_LgkiCAd;;[&](){
            if (pDependencies_json.as_array().size()==0){
                temp_LgkiCAd=NULL;
            return; }temp_LgkiCAd=(VkSubpassDependency*)malloc(member.dependencyCount*sizeof(VkSubpassDependency));
        auto& arr_tvMOoia=pDependencies_json.as_array();
        for(int hsbIyfq=0; hsbIyfq < member.dependencyCount; hsbIyfq++){
            [&](){
            auto& temp=arr_tvMOoia[hsbIyfq].as_object();
            deserialize_struct(temp,temp_LgkiCAd[hsbIyfq]);
            }();
        }
        }();member.pDependencies=temp_LgkiCAd;}();
}

    void serialize_struct(boost::json::object& json, const VkEventCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkEventCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_dyBnBUR;[&](){temp_dyBnBUR=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkEventCreateFlags)temp_dyBnBUR;}();}();
}

    void serialize_struct(boost::json::object& json, const VkFenceCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkFenceCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_RZKDhbw;[&](){temp_RZKDhbw=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkFenceCreateFlags)temp_RZKDhbw;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFeatures& member){
        
    
auto& robustBufferAccess_json=json["robustBufferAccess"];
[&](){[&](){robustBufferAccess_json=member.robustBufferAccess;}();}();
auto& fullDrawIndexUint32_json=json["fullDrawIndexUint32"];
[&](){[&](){fullDrawIndexUint32_json=member.fullDrawIndexUint32;}();}();
auto& imageCubeArray_json=json["imageCubeArray"];
[&](){[&](){imageCubeArray_json=member.imageCubeArray;}();}();
auto& independentBlend_json=json["independentBlend"];
[&](){[&](){independentBlend_json=member.independentBlend;}();}();
auto& geometryShader_json=json["geometryShader"];
[&](){[&](){geometryShader_json=member.geometryShader;}();}();
auto& tessellationShader_json=json["tessellationShader"];
[&](){[&](){tessellationShader_json=member.tessellationShader;}();}();
auto& sampleRateShading_json=json["sampleRateShading"];
[&](){[&](){sampleRateShading_json=member.sampleRateShading;}();}();
auto& dualSrcBlend_json=json["dualSrcBlend"];
[&](){[&](){dualSrcBlend_json=member.dualSrcBlend;}();}();
auto& logicOp_json=json["logicOp"];
[&](){[&](){logicOp_json=member.logicOp;}();}();
auto& multiDrawIndirect_json=json["multiDrawIndirect"];
[&](){[&](){multiDrawIndirect_json=member.multiDrawIndirect;}();}();
auto& drawIndirectFirstInstance_json=json["drawIndirectFirstInstance"];
[&](){[&](){drawIndirectFirstInstance_json=member.drawIndirectFirstInstance;}();}();
auto& depthClamp_json=json["depthClamp"];
[&](){[&](){depthClamp_json=member.depthClamp;}();}();
auto& depthBiasClamp_json=json["depthBiasClamp"];
[&](){[&](){depthBiasClamp_json=member.depthBiasClamp;}();}();
auto& fillModeNonSolid_json=json["fillModeNonSolid"];
[&](){[&](){fillModeNonSolid_json=member.fillModeNonSolid;}();}();
auto& depthBounds_json=json["depthBounds"];
[&](){[&](){depthBounds_json=member.depthBounds;}();}();
auto& wideLines_json=json["wideLines"];
[&](){[&](){wideLines_json=member.wideLines;}();}();
auto& largePoints_json=json["largePoints"];
[&](){[&](){largePoints_json=member.largePoints;}();}();
auto& alphaToOne_json=json["alphaToOne"];
[&](){[&](){alphaToOne_json=member.alphaToOne;}();}();
auto& multiViewport_json=json["multiViewport"];
[&](){[&](){multiViewport_json=member.multiViewport;}();}();
auto& samplerAnisotropy_json=json["samplerAnisotropy"];
[&](){[&](){samplerAnisotropy_json=member.samplerAnisotropy;}();}();
auto& textureCompressionETC2_json=json["textureCompressionETC2"];
[&](){[&](){textureCompressionETC2_json=member.textureCompressionETC2;}();}();
auto& textureCompressionASTC_LDR_json=json["textureCompressionASTC_LDR"];
[&](){[&](){textureCompressionASTC_LDR_json=member.textureCompressionASTC_LDR;}();}();
auto& textureCompressionBC_json=json["textureCompressionBC"];
[&](){[&](){textureCompressionBC_json=member.textureCompressionBC;}();}();
auto& occlusionQueryPrecise_json=json["occlusionQueryPrecise"];
[&](){[&](){occlusionQueryPrecise_json=member.occlusionQueryPrecise;}();}();
auto& pipelineStatisticsQuery_json=json["pipelineStatisticsQuery"];
[&](){[&](){pipelineStatisticsQuery_json=member.pipelineStatisticsQuery;}();}();
auto& vertexPipelineStoresAndAtomics_json=json["vertexPipelineStoresAndAtomics"];
[&](){[&](){vertexPipelineStoresAndAtomics_json=member.vertexPipelineStoresAndAtomics;}();}();
auto& fragmentStoresAndAtomics_json=json["fragmentStoresAndAtomics"];
[&](){[&](){fragmentStoresAndAtomics_json=member.fragmentStoresAndAtomics;}();}();
auto& shaderTessellationAndGeometryPointSize_json=json["shaderTessellationAndGeometryPointSize"];
[&](){[&](){shaderTessellationAndGeometryPointSize_json=member.shaderTessellationAndGeometryPointSize;}();}();
auto& shaderImageGatherExtended_json=json["shaderImageGatherExtended"];
[&](){[&](){shaderImageGatherExtended_json=member.shaderImageGatherExtended;}();}();
auto& shaderStorageImageExtendedFormats_json=json["shaderStorageImageExtendedFormats"];
[&](){[&](){shaderStorageImageExtendedFormats_json=member.shaderStorageImageExtendedFormats;}();}();
auto& shaderStorageImageMultisample_json=json["shaderStorageImageMultisample"];
[&](){[&](){shaderStorageImageMultisample_json=member.shaderStorageImageMultisample;}();}();
auto& shaderStorageImageReadWithoutFormat_json=json["shaderStorageImageReadWithoutFormat"];
[&](){[&](){shaderStorageImageReadWithoutFormat_json=member.shaderStorageImageReadWithoutFormat;}();}();
auto& shaderStorageImageWriteWithoutFormat_json=json["shaderStorageImageWriteWithoutFormat"];
[&](){[&](){shaderStorageImageWriteWithoutFormat_json=member.shaderStorageImageWriteWithoutFormat;}();}();
auto& shaderUniformBufferArrayDynamicIndexing_json=json["shaderUniformBufferArrayDynamicIndexing"];
[&](){[&](){shaderUniformBufferArrayDynamicIndexing_json=member.shaderUniformBufferArrayDynamicIndexing;}();}();
auto& shaderSampledImageArrayDynamicIndexing_json=json["shaderSampledImageArrayDynamicIndexing"];
[&](){[&](){shaderSampledImageArrayDynamicIndexing_json=member.shaderSampledImageArrayDynamicIndexing;}();}();
auto& shaderStorageBufferArrayDynamicIndexing_json=json["shaderStorageBufferArrayDynamicIndexing"];
[&](){[&](){shaderStorageBufferArrayDynamicIndexing_json=member.shaderStorageBufferArrayDynamicIndexing;}();}();
auto& shaderStorageImageArrayDynamicIndexing_json=json["shaderStorageImageArrayDynamicIndexing"];
[&](){[&](){shaderStorageImageArrayDynamicIndexing_json=member.shaderStorageImageArrayDynamicIndexing;}();}();
auto& shaderClipDistance_json=json["shaderClipDistance"];
[&](){[&](){shaderClipDistance_json=member.shaderClipDistance;}();}();
auto& shaderCullDistance_json=json["shaderCullDistance"];
[&](){[&](){shaderCullDistance_json=member.shaderCullDistance;}();}();
auto& shaderFloat64_json=json["shaderFloat64"];
[&](){[&](){shaderFloat64_json=member.shaderFloat64;}();}();
auto& shaderInt64_json=json["shaderInt64"];
[&](){[&](){shaderInt64_json=member.shaderInt64;}();}();
auto& shaderInt16_json=json["shaderInt16"];
[&](){[&](){shaderInt16_json=member.shaderInt16;}();}();
auto& shaderResourceResidency_json=json["shaderResourceResidency"];
[&](){[&](){shaderResourceResidency_json=member.shaderResourceResidency;}();}();
auto& shaderResourceMinLod_json=json["shaderResourceMinLod"];
[&](){[&](){shaderResourceMinLod_json=member.shaderResourceMinLod;}();}();
auto& sparseBinding_json=json["sparseBinding"];
[&](){[&](){sparseBinding_json=member.sparseBinding;}();}();
auto& sparseResidencyBuffer_json=json["sparseResidencyBuffer"];
[&](){[&](){sparseResidencyBuffer_json=member.sparseResidencyBuffer;}();}();
auto& sparseResidencyImage2D_json=json["sparseResidencyImage2D"];
[&](){[&](){sparseResidencyImage2D_json=member.sparseResidencyImage2D;}();}();
auto& sparseResidencyImage3D_json=json["sparseResidencyImage3D"];
[&](){[&](){sparseResidencyImage3D_json=member.sparseResidencyImage3D;}();}();
auto& sparseResidency2Samples_json=json["sparseResidency2Samples"];
[&](){[&](){sparseResidency2Samples_json=member.sparseResidency2Samples;}();}();
auto& sparseResidency4Samples_json=json["sparseResidency4Samples"];
[&](){[&](){sparseResidency4Samples_json=member.sparseResidency4Samples;}();}();
auto& sparseResidency8Samples_json=json["sparseResidency8Samples"];
[&](){[&](){sparseResidency8Samples_json=member.sparseResidency8Samples;}();}();
auto& sparseResidency16Samples_json=json["sparseResidency16Samples"];
[&](){[&](){sparseResidency16Samples_json=member.sparseResidency16Samples;}();}();
auto& sparseResidencyAliased_json=json["sparseResidencyAliased"];
[&](){[&](){sparseResidencyAliased_json=member.sparseResidencyAliased;}();}();
auto& variableMultisampleRate_json=json["variableMultisampleRate"];
[&](){[&](){variableMultisampleRate_json=member.variableMultisampleRate;}();}();
auto& inheritedQueries_json=json["inheritedQueries"];
[&](){[&](){inheritedQueries_json=member.inheritedQueries;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFeatures& member){
auto& robustBufferAccess_json=json["robustBufferAccess"];
[&](){uint32_t temp_fLdSFWM;[&](){temp_fLdSFWM=static_cast<uint32_t>(value_to<int>(robustBufferAccess_json));}();member.robustBufferAccess=(VkBool32)temp_fLdSFWM;}();
auto& fullDrawIndexUint32_json=json["fullDrawIndexUint32"];
[&](){uint32_t temp_iJjXjol;[&](){temp_iJjXjol=static_cast<uint32_t>(value_to<int>(fullDrawIndexUint32_json));}();member.fullDrawIndexUint32=(VkBool32)temp_iJjXjol;}();
auto& imageCubeArray_json=json["imageCubeArray"];
[&](){uint32_t temp_BwOmdLx;[&](){temp_BwOmdLx=static_cast<uint32_t>(value_to<int>(imageCubeArray_json));}();member.imageCubeArray=(VkBool32)temp_BwOmdLx;}();
auto& independentBlend_json=json["independentBlend"];
[&](){uint32_t temp_OQNLUGg;[&](){temp_OQNLUGg=static_cast<uint32_t>(value_to<int>(independentBlend_json));}();member.independentBlend=(VkBool32)temp_OQNLUGg;}();
auto& geometryShader_json=json["geometryShader"];
[&](){uint32_t temp_STFNKBV;[&](){temp_STFNKBV=static_cast<uint32_t>(value_to<int>(geometryShader_json));}();member.geometryShader=(VkBool32)temp_STFNKBV;}();
auto& tessellationShader_json=json["tessellationShader"];
[&](){uint32_t temp_ZpbooAU;[&](){temp_ZpbooAU=static_cast<uint32_t>(value_to<int>(tessellationShader_json));}();member.tessellationShader=(VkBool32)temp_ZpbooAU;}();
auto& sampleRateShading_json=json["sampleRateShading"];
[&](){uint32_t temp_NPbUYaY;[&](){temp_NPbUYaY=static_cast<uint32_t>(value_to<int>(sampleRateShading_json));}();member.sampleRateShading=(VkBool32)temp_NPbUYaY;}();
auto& dualSrcBlend_json=json["dualSrcBlend"];
[&](){uint32_t temp_lRyxCZb;[&](){temp_lRyxCZb=static_cast<uint32_t>(value_to<int>(dualSrcBlend_json));}();member.dualSrcBlend=(VkBool32)temp_lRyxCZb;}();
auto& logicOp_json=json["logicOp"];
[&](){uint32_t temp_TGcfGla;[&](){temp_TGcfGla=static_cast<uint32_t>(value_to<int>(logicOp_json));}();member.logicOp=(VkBool32)temp_TGcfGla;}();
auto& multiDrawIndirect_json=json["multiDrawIndirect"];
[&](){uint32_t temp_sGIFbXV;[&](){temp_sGIFbXV=static_cast<uint32_t>(value_to<int>(multiDrawIndirect_json));}();member.multiDrawIndirect=(VkBool32)temp_sGIFbXV;}();
auto& drawIndirectFirstInstance_json=json["drawIndirectFirstInstance"];
[&](){uint32_t temp_mLzRmwn;[&](){temp_mLzRmwn=static_cast<uint32_t>(value_to<int>(drawIndirectFirstInstance_json));}();member.drawIndirectFirstInstance=(VkBool32)temp_mLzRmwn;}();
auto& depthClamp_json=json["depthClamp"];
[&](){uint32_t temp_YkKZdtX;[&](){temp_YkKZdtX=static_cast<uint32_t>(value_to<int>(depthClamp_json));}();member.depthClamp=(VkBool32)temp_YkKZdtX;}();
auto& depthBiasClamp_json=json["depthBiasClamp"];
[&](){uint32_t temp_ssDkGEk;[&](){temp_ssDkGEk=static_cast<uint32_t>(value_to<int>(depthBiasClamp_json));}();member.depthBiasClamp=(VkBool32)temp_ssDkGEk;}();
auto& fillModeNonSolid_json=json["fillModeNonSolid"];
[&](){uint32_t temp_nxdgmmQ;[&](){temp_nxdgmmQ=static_cast<uint32_t>(value_to<int>(fillModeNonSolid_json));}();member.fillModeNonSolid=(VkBool32)temp_nxdgmmQ;}();
auto& depthBounds_json=json["depthBounds"];
[&](){uint32_t temp_doUOWKJ;[&](){temp_doUOWKJ=static_cast<uint32_t>(value_to<int>(depthBounds_json));}();member.depthBounds=(VkBool32)temp_doUOWKJ;}();
auto& wideLines_json=json["wideLines"];
[&](){uint32_t temp_fgaYIPz;[&](){temp_fgaYIPz=static_cast<uint32_t>(value_to<int>(wideLines_json));}();member.wideLines=(VkBool32)temp_fgaYIPz;}();
auto& largePoints_json=json["largePoints"];
[&](){uint32_t temp_GaNdZDQ;[&](){temp_GaNdZDQ=static_cast<uint32_t>(value_to<int>(largePoints_json));}();member.largePoints=(VkBool32)temp_GaNdZDQ;}();
auto& alphaToOne_json=json["alphaToOne"];
[&](){uint32_t temp_HtGGPEd;[&](){temp_HtGGPEd=static_cast<uint32_t>(value_to<int>(alphaToOne_json));}();member.alphaToOne=(VkBool32)temp_HtGGPEd;}();
auto& multiViewport_json=json["multiViewport"];
[&](){uint32_t temp_JjTQWuS;[&](){temp_JjTQWuS=static_cast<uint32_t>(value_to<int>(multiViewport_json));}();member.multiViewport=(VkBool32)temp_JjTQWuS;}();
auto& samplerAnisotropy_json=json["samplerAnisotropy"];
[&](){uint32_t temp_axcwTex;[&](){temp_axcwTex=static_cast<uint32_t>(value_to<int>(samplerAnisotropy_json));}();member.samplerAnisotropy=(VkBool32)temp_axcwTex;}();
auto& textureCompressionETC2_json=json["textureCompressionETC2"];
[&](){uint32_t temp_noPjpvN;[&](){temp_noPjpvN=static_cast<uint32_t>(value_to<int>(textureCompressionETC2_json));}();member.textureCompressionETC2=(VkBool32)temp_noPjpvN;}();
auto& textureCompressionASTC_LDR_json=json["textureCompressionASTC_LDR"];
[&](){uint32_t temp_RCtswDr;[&](){temp_RCtswDr=static_cast<uint32_t>(value_to<int>(textureCompressionASTC_LDR_json));}();member.textureCompressionASTC_LDR=(VkBool32)temp_RCtswDr;}();
auto& textureCompressionBC_json=json["textureCompressionBC"];
[&](){uint32_t temp_tRjsfsU;[&](){temp_tRjsfsU=static_cast<uint32_t>(value_to<int>(textureCompressionBC_json));}();member.textureCompressionBC=(VkBool32)temp_tRjsfsU;}();
auto& occlusionQueryPrecise_json=json["occlusionQueryPrecise"];
[&](){uint32_t temp_hQzxhvO;[&](){temp_hQzxhvO=static_cast<uint32_t>(value_to<int>(occlusionQueryPrecise_json));}();member.occlusionQueryPrecise=(VkBool32)temp_hQzxhvO;}();
auto& pipelineStatisticsQuery_json=json["pipelineStatisticsQuery"];
[&](){uint32_t temp_jyXDlyo;[&](){temp_jyXDlyo=static_cast<uint32_t>(value_to<int>(pipelineStatisticsQuery_json));}();member.pipelineStatisticsQuery=(VkBool32)temp_jyXDlyo;}();
auto& vertexPipelineStoresAndAtomics_json=json["vertexPipelineStoresAndAtomics"];
[&](){uint32_t temp_qWwQxYE;[&](){temp_qWwQxYE=static_cast<uint32_t>(value_to<int>(vertexPipelineStoresAndAtomics_json));}();member.vertexPipelineStoresAndAtomics=(VkBool32)temp_qWwQxYE;}();
auto& fragmentStoresAndAtomics_json=json["fragmentStoresAndAtomics"];
[&](){uint32_t temp_bQgHZdK;[&](){temp_bQgHZdK=static_cast<uint32_t>(value_to<int>(fragmentStoresAndAtomics_json));}();member.fragmentStoresAndAtomics=(VkBool32)temp_bQgHZdK;}();
auto& shaderTessellationAndGeometryPointSize_json=json["shaderTessellationAndGeometryPointSize"];
[&](){uint32_t temp_xnfGOWc;[&](){temp_xnfGOWc=static_cast<uint32_t>(value_to<int>(shaderTessellationAndGeometryPointSize_json));}();member.shaderTessellationAndGeometryPointSize=(VkBool32)temp_xnfGOWc;}();
auto& shaderImageGatherExtended_json=json["shaderImageGatherExtended"];
[&](){uint32_t temp_uNgLiQG;[&](){temp_uNgLiQG=static_cast<uint32_t>(value_to<int>(shaderImageGatherExtended_json));}();member.shaderImageGatherExtended=(VkBool32)temp_uNgLiQG;}();
auto& shaderStorageImageExtendedFormats_json=json["shaderStorageImageExtendedFormats"];
[&](){uint32_t temp_OkLLBtp;[&](){temp_OkLLBtp=static_cast<uint32_t>(value_to<int>(shaderStorageImageExtendedFormats_json));}();member.shaderStorageImageExtendedFormats=(VkBool32)temp_OkLLBtp;}();
auto& shaderStorageImageMultisample_json=json["shaderStorageImageMultisample"];
[&](){uint32_t temp_QiYrtuk;[&](){temp_QiYrtuk=static_cast<uint32_t>(value_to<int>(shaderStorageImageMultisample_json));}();member.shaderStorageImageMultisample=(VkBool32)temp_QiYrtuk;}();
auto& shaderStorageImageReadWithoutFormat_json=json["shaderStorageImageReadWithoutFormat"];
[&](){uint32_t temp_GYoXxzb;[&](){temp_GYoXxzb=static_cast<uint32_t>(value_to<int>(shaderStorageImageReadWithoutFormat_json));}();member.shaderStorageImageReadWithoutFormat=(VkBool32)temp_GYoXxzb;}();
auto& shaderStorageImageWriteWithoutFormat_json=json["shaderStorageImageWriteWithoutFormat"];
[&](){uint32_t temp_dIDNXDl;[&](){temp_dIDNXDl=static_cast<uint32_t>(value_to<int>(shaderStorageImageWriteWithoutFormat_json));}();member.shaderStorageImageWriteWithoutFormat=(VkBool32)temp_dIDNXDl;}();
auto& shaderUniformBufferArrayDynamicIndexing_json=json["shaderUniformBufferArrayDynamicIndexing"];
[&](){uint32_t temp_VLbqEsf;[&](){temp_VLbqEsf=static_cast<uint32_t>(value_to<int>(shaderUniformBufferArrayDynamicIndexing_json));}();member.shaderUniformBufferArrayDynamicIndexing=(VkBool32)temp_VLbqEsf;}();
auto& shaderSampledImageArrayDynamicIndexing_json=json["shaderSampledImageArrayDynamicIndexing"];
[&](){uint32_t temp_PLmKqxa;[&](){temp_PLmKqxa=static_cast<uint32_t>(value_to<int>(shaderSampledImageArrayDynamicIndexing_json));}();member.shaderSampledImageArrayDynamicIndexing=(VkBool32)temp_PLmKqxa;}();
auto& shaderStorageBufferArrayDynamicIndexing_json=json["shaderStorageBufferArrayDynamicIndexing"];
[&](){uint32_t temp_LtpaqNF;[&](){temp_LtpaqNF=static_cast<uint32_t>(value_to<int>(shaderStorageBufferArrayDynamicIndexing_json));}();member.shaderStorageBufferArrayDynamicIndexing=(VkBool32)temp_LtpaqNF;}();
auto& shaderStorageImageArrayDynamicIndexing_json=json["shaderStorageImageArrayDynamicIndexing"];
[&](){uint32_t temp_gsTllkI;[&](){temp_gsTllkI=static_cast<uint32_t>(value_to<int>(shaderStorageImageArrayDynamicIndexing_json));}();member.shaderStorageImageArrayDynamicIndexing=(VkBool32)temp_gsTllkI;}();
auto& shaderClipDistance_json=json["shaderClipDistance"];
[&](){uint32_t temp_VOXfSAs;[&](){temp_VOXfSAs=static_cast<uint32_t>(value_to<int>(shaderClipDistance_json));}();member.shaderClipDistance=(VkBool32)temp_VOXfSAs;}();
auto& shaderCullDistance_json=json["shaderCullDistance"];
[&](){uint32_t temp_bZnlWOn;[&](){temp_bZnlWOn=static_cast<uint32_t>(value_to<int>(shaderCullDistance_json));}();member.shaderCullDistance=(VkBool32)temp_bZnlWOn;}();
auto& shaderFloat64_json=json["shaderFloat64"];
[&](){uint32_t temp_KIuPvXT;[&](){temp_KIuPvXT=static_cast<uint32_t>(value_to<int>(shaderFloat64_json));}();member.shaderFloat64=(VkBool32)temp_KIuPvXT;}();
auto& shaderInt64_json=json["shaderInt64"];
[&](){uint32_t temp_vCFJNvt;[&](){temp_vCFJNvt=static_cast<uint32_t>(value_to<int>(shaderInt64_json));}();member.shaderInt64=(VkBool32)temp_vCFJNvt;}();
auto& shaderInt16_json=json["shaderInt16"];
[&](){uint32_t temp_VokzWfW;[&](){temp_VokzWfW=static_cast<uint32_t>(value_to<int>(shaderInt16_json));}();member.shaderInt16=(VkBool32)temp_VokzWfW;}();
auto& shaderResourceResidency_json=json["shaderResourceResidency"];
[&](){uint32_t temp_edfnULK;[&](){temp_edfnULK=static_cast<uint32_t>(value_to<int>(shaderResourceResidency_json));}();member.shaderResourceResidency=(VkBool32)temp_edfnULK;}();
auto& shaderResourceMinLod_json=json["shaderResourceMinLod"];
[&](){uint32_t temp_PfiTPai;[&](){temp_PfiTPai=static_cast<uint32_t>(value_to<int>(shaderResourceMinLod_json));}();member.shaderResourceMinLod=(VkBool32)temp_PfiTPai;}();
auto& sparseBinding_json=json["sparseBinding"];
[&](){uint32_t temp_pOsETpb;[&](){temp_pOsETpb=static_cast<uint32_t>(value_to<int>(sparseBinding_json));}();member.sparseBinding=(VkBool32)temp_pOsETpb;}();
auto& sparseResidencyBuffer_json=json["sparseResidencyBuffer"];
[&](){uint32_t temp_emnApyJ;[&](){temp_emnApyJ=static_cast<uint32_t>(value_to<int>(sparseResidencyBuffer_json));}();member.sparseResidencyBuffer=(VkBool32)temp_emnApyJ;}();
auto& sparseResidencyImage2D_json=json["sparseResidencyImage2D"];
[&](){uint32_t temp_PxuEUlN;[&](){temp_PxuEUlN=static_cast<uint32_t>(value_to<int>(sparseResidencyImage2D_json));}();member.sparseResidencyImage2D=(VkBool32)temp_PxuEUlN;}();
auto& sparseResidencyImage3D_json=json["sparseResidencyImage3D"];
[&](){uint32_t temp_WIhnMpj;[&](){temp_WIhnMpj=static_cast<uint32_t>(value_to<int>(sparseResidencyImage3D_json));}();member.sparseResidencyImage3D=(VkBool32)temp_WIhnMpj;}();
auto& sparseResidency2Samples_json=json["sparseResidency2Samples"];
[&](){uint32_t temp_MCEPHvW;[&](){temp_MCEPHvW=static_cast<uint32_t>(value_to<int>(sparseResidency2Samples_json));}();member.sparseResidency2Samples=(VkBool32)temp_MCEPHvW;}();
auto& sparseResidency4Samples_json=json["sparseResidency4Samples"];
[&](){uint32_t temp_fnnQMMQ;[&](){temp_fnnQMMQ=static_cast<uint32_t>(value_to<int>(sparseResidency4Samples_json));}();member.sparseResidency4Samples=(VkBool32)temp_fnnQMMQ;}();
auto& sparseResidency8Samples_json=json["sparseResidency8Samples"];
[&](){uint32_t temp_nytFTUJ;[&](){temp_nytFTUJ=static_cast<uint32_t>(value_to<int>(sparseResidency8Samples_json));}();member.sparseResidency8Samples=(VkBool32)temp_nytFTUJ;}();
auto& sparseResidency16Samples_json=json["sparseResidency16Samples"];
[&](){uint32_t temp_NqorkFU;[&](){temp_NqorkFU=static_cast<uint32_t>(value_to<int>(sparseResidency16Samples_json));}();member.sparseResidency16Samples=(VkBool32)temp_NqorkFU;}();
auto& sparseResidencyAliased_json=json["sparseResidencyAliased"];
[&](){uint32_t temp_oJAKsoG;[&](){temp_oJAKsoG=static_cast<uint32_t>(value_to<int>(sparseResidencyAliased_json));}();member.sparseResidencyAliased=(VkBool32)temp_oJAKsoG;}();
auto& variableMultisampleRate_json=json["variableMultisampleRate"];
[&](){uint32_t temp_RwqCyiV;[&](){temp_RwqCyiV=static_cast<uint32_t>(value_to<int>(variableMultisampleRate_json));}();member.variableMultisampleRate=(VkBool32)temp_RwqCyiV;}();
auto& inheritedQueries_json=json["inheritedQueries"];
[&](){uint32_t temp_yUqVFXQ;[&](){temp_yUqVFXQ=static_cast<uint32_t>(value_to<int>(inheritedQueries_json));}();member.inheritedQueries=(VkBool32)temp_yUqVFXQ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSparseProperties& member){
        
    
auto& residencyStandard2DBlockShape_json=json["residencyStandard2DBlockShape"];
[&](){[&](){residencyStandard2DBlockShape_json=member.residencyStandard2DBlockShape;}();}();
auto& residencyStandard2DMultisampleBlockShape_json=json["residencyStandard2DMultisampleBlockShape"];
[&](){[&](){residencyStandard2DMultisampleBlockShape_json=member.residencyStandard2DMultisampleBlockShape;}();}();
auto& residencyStandard3DBlockShape_json=json["residencyStandard3DBlockShape"];
[&](){[&](){residencyStandard3DBlockShape_json=member.residencyStandard3DBlockShape;}();}();
auto& residencyAlignedMipSize_json=json["residencyAlignedMipSize"];
[&](){[&](){residencyAlignedMipSize_json=member.residencyAlignedMipSize;}();}();
auto& residencyNonResidentStrict_json=json["residencyNonResidentStrict"];
[&](){[&](){residencyNonResidentStrict_json=member.residencyNonResidentStrict;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSparseProperties& member){
auto& residencyStandard2DBlockShape_json=json["residencyStandard2DBlockShape"];
[&](){uint32_t temp_vjgfNeM;[&](){temp_vjgfNeM=static_cast<uint32_t>(value_to<int>(residencyStandard2DBlockShape_json));}();member.residencyStandard2DBlockShape=(VkBool32)temp_vjgfNeM;}();
auto& residencyStandard2DMultisampleBlockShape_json=json["residencyStandard2DMultisampleBlockShape"];
[&](){uint32_t temp_qJFdLPW;[&](){temp_qJFdLPW=static_cast<uint32_t>(value_to<int>(residencyStandard2DMultisampleBlockShape_json));}();member.residencyStandard2DMultisampleBlockShape=(VkBool32)temp_qJFdLPW;}();
auto& residencyStandard3DBlockShape_json=json["residencyStandard3DBlockShape"];
[&](){uint32_t temp_vxSvYCB;[&](){temp_vxSvYCB=static_cast<uint32_t>(value_to<int>(residencyStandard3DBlockShape_json));}();member.residencyStandard3DBlockShape=(VkBool32)temp_vxSvYCB;}();
auto& residencyAlignedMipSize_json=json["residencyAlignedMipSize"];
[&](){uint32_t temp_WAnHGse;[&](){temp_WAnHGse=static_cast<uint32_t>(value_to<int>(residencyAlignedMipSize_json));}();member.residencyAlignedMipSize=(VkBool32)temp_WAnHGse;}();
auto& residencyNonResidentStrict_json=json["residencyNonResidentStrict"];
[&](){uint32_t temp_GvUyCtI;[&](){temp_GvUyCtI=static_cast<uint32_t>(value_to<int>(residencyNonResidentStrict_json));}();member.residencyNonResidentStrict=(VkBool32)temp_GvUyCtI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceLimits& member){
        
    
auto& maxImageDimension1D_json=json["maxImageDimension1D"];
[&](){maxImageDimension1D_json=member.maxImageDimension1D;}();
auto& maxImageDimension2D_json=json["maxImageDimension2D"];
[&](){maxImageDimension2D_json=member.maxImageDimension2D;}();
auto& maxImageDimension3D_json=json["maxImageDimension3D"];
[&](){maxImageDimension3D_json=member.maxImageDimension3D;}();
auto& maxImageDimensionCube_json=json["maxImageDimensionCube"];
[&](){maxImageDimensionCube_json=member.maxImageDimensionCube;}();
auto& maxImageArrayLayers_json=json["maxImageArrayLayers"];
[&](){maxImageArrayLayers_json=member.maxImageArrayLayers;}();
auto& maxTexelBufferElements_json=json["maxTexelBufferElements"];
[&](){maxTexelBufferElements_json=member.maxTexelBufferElements;}();
auto& maxUniformBufferRange_json=json["maxUniformBufferRange"];
[&](){maxUniformBufferRange_json=member.maxUniformBufferRange;}();
auto& maxStorageBufferRange_json=json["maxStorageBufferRange"];
[&](){maxStorageBufferRange_json=member.maxStorageBufferRange;}();
auto& maxPushConstantsSize_json=json["maxPushConstantsSize"];
[&](){maxPushConstantsSize_json=member.maxPushConstantsSize;}();
auto& maxMemoryAllocationCount_json=json["maxMemoryAllocationCount"];
[&](){maxMemoryAllocationCount_json=member.maxMemoryAllocationCount;}();
auto& maxSamplerAllocationCount_json=json["maxSamplerAllocationCount"];
[&](){maxSamplerAllocationCount_json=member.maxSamplerAllocationCount;}();
auto& bufferImageGranularity_json=json["bufferImageGranularity"];
[&](){[&](){bufferImageGranularity_json=member.bufferImageGranularity;}();}();
auto& sparseAddressSpaceSize_json=json["sparseAddressSpaceSize"];
[&](){[&](){sparseAddressSpaceSize_json=member.sparseAddressSpaceSize;}();}();
auto& maxBoundDescriptorSets_json=json["maxBoundDescriptorSets"];
[&](){maxBoundDescriptorSets_json=member.maxBoundDescriptorSets;}();
auto& maxPerStageDescriptorSamplers_json=json["maxPerStageDescriptorSamplers"];
[&](){maxPerStageDescriptorSamplers_json=member.maxPerStageDescriptorSamplers;}();
auto& maxPerStageDescriptorUniformBuffers_json=json["maxPerStageDescriptorUniformBuffers"];
[&](){maxPerStageDescriptorUniformBuffers_json=member.maxPerStageDescriptorUniformBuffers;}();
auto& maxPerStageDescriptorStorageBuffers_json=json["maxPerStageDescriptorStorageBuffers"];
[&](){maxPerStageDescriptorStorageBuffers_json=member.maxPerStageDescriptorStorageBuffers;}();
auto& maxPerStageDescriptorSampledImages_json=json["maxPerStageDescriptorSampledImages"];
[&](){maxPerStageDescriptorSampledImages_json=member.maxPerStageDescriptorSampledImages;}();
auto& maxPerStageDescriptorStorageImages_json=json["maxPerStageDescriptorStorageImages"];
[&](){maxPerStageDescriptorStorageImages_json=member.maxPerStageDescriptorStorageImages;}();
auto& maxPerStageDescriptorInputAttachments_json=json["maxPerStageDescriptorInputAttachments"];
[&](){maxPerStageDescriptorInputAttachments_json=member.maxPerStageDescriptorInputAttachments;}();
auto& maxPerStageResources_json=json["maxPerStageResources"];
[&](){maxPerStageResources_json=member.maxPerStageResources;}();
auto& maxDescriptorSetSamplers_json=json["maxDescriptorSetSamplers"];
[&](){maxDescriptorSetSamplers_json=member.maxDescriptorSetSamplers;}();
auto& maxDescriptorSetUniformBuffers_json=json["maxDescriptorSetUniformBuffers"];
[&](){maxDescriptorSetUniformBuffers_json=member.maxDescriptorSetUniformBuffers;}();
auto& maxDescriptorSetUniformBuffersDynamic_json=json["maxDescriptorSetUniformBuffersDynamic"];
[&](){maxDescriptorSetUniformBuffersDynamic_json=member.maxDescriptorSetUniformBuffersDynamic;}();
auto& maxDescriptorSetStorageBuffers_json=json["maxDescriptorSetStorageBuffers"];
[&](){maxDescriptorSetStorageBuffers_json=member.maxDescriptorSetStorageBuffers;}();
auto& maxDescriptorSetStorageBuffersDynamic_json=json["maxDescriptorSetStorageBuffersDynamic"];
[&](){maxDescriptorSetStorageBuffersDynamic_json=member.maxDescriptorSetStorageBuffersDynamic;}();
auto& maxDescriptorSetSampledImages_json=json["maxDescriptorSetSampledImages"];
[&](){maxDescriptorSetSampledImages_json=member.maxDescriptorSetSampledImages;}();
auto& maxDescriptorSetStorageImages_json=json["maxDescriptorSetStorageImages"];
[&](){maxDescriptorSetStorageImages_json=member.maxDescriptorSetStorageImages;}();
auto& maxDescriptorSetInputAttachments_json=json["maxDescriptorSetInputAttachments"];
[&](){maxDescriptorSetInputAttachments_json=member.maxDescriptorSetInputAttachments;}();
auto& maxVertexInputAttributes_json=json["maxVertexInputAttributes"];
[&](){maxVertexInputAttributes_json=member.maxVertexInputAttributes;}();
auto& maxVertexInputBindings_json=json["maxVertexInputBindings"];
[&](){maxVertexInputBindings_json=member.maxVertexInputBindings;}();
auto& maxVertexInputAttributeOffset_json=json["maxVertexInputAttributeOffset"];
[&](){maxVertexInputAttributeOffset_json=member.maxVertexInputAttributeOffset;}();
auto& maxVertexInputBindingStride_json=json["maxVertexInputBindingStride"];
[&](){maxVertexInputBindingStride_json=member.maxVertexInputBindingStride;}();
auto& maxVertexOutputComponents_json=json["maxVertexOutputComponents"];
[&](){maxVertexOutputComponents_json=member.maxVertexOutputComponents;}();
auto& maxTessellationGenerationLevel_json=json["maxTessellationGenerationLevel"];
[&](){maxTessellationGenerationLevel_json=member.maxTessellationGenerationLevel;}();
auto& maxTessellationPatchSize_json=json["maxTessellationPatchSize"];
[&](){maxTessellationPatchSize_json=member.maxTessellationPatchSize;}();
auto& maxTessellationControlPerVertexInputComponents_json=json["maxTessellationControlPerVertexInputComponents"];
[&](){maxTessellationControlPerVertexInputComponents_json=member.maxTessellationControlPerVertexInputComponents;}();
auto& maxTessellationControlPerVertexOutputComponents_json=json["maxTessellationControlPerVertexOutputComponents"];
[&](){maxTessellationControlPerVertexOutputComponents_json=member.maxTessellationControlPerVertexOutputComponents;}();
auto& maxTessellationControlPerPatchOutputComponents_json=json["maxTessellationControlPerPatchOutputComponents"];
[&](){maxTessellationControlPerPatchOutputComponents_json=member.maxTessellationControlPerPatchOutputComponents;}();
auto& maxTessellationControlTotalOutputComponents_json=json["maxTessellationControlTotalOutputComponents"];
[&](){maxTessellationControlTotalOutputComponents_json=member.maxTessellationControlTotalOutputComponents;}();
auto& maxTessellationEvaluationInputComponents_json=json["maxTessellationEvaluationInputComponents"];
[&](){maxTessellationEvaluationInputComponents_json=member.maxTessellationEvaluationInputComponents;}();
auto& maxTessellationEvaluationOutputComponents_json=json["maxTessellationEvaluationOutputComponents"];
[&](){maxTessellationEvaluationOutputComponents_json=member.maxTessellationEvaluationOutputComponents;}();
auto& maxGeometryShaderInvocations_json=json["maxGeometryShaderInvocations"];
[&](){maxGeometryShaderInvocations_json=member.maxGeometryShaderInvocations;}();
auto& maxGeometryInputComponents_json=json["maxGeometryInputComponents"];
[&](){maxGeometryInputComponents_json=member.maxGeometryInputComponents;}();
auto& maxGeometryOutputComponents_json=json["maxGeometryOutputComponents"];
[&](){maxGeometryOutputComponents_json=member.maxGeometryOutputComponents;}();
auto& maxGeometryOutputVertices_json=json["maxGeometryOutputVertices"];
[&](){maxGeometryOutputVertices_json=member.maxGeometryOutputVertices;}();
auto& maxGeometryTotalOutputComponents_json=json["maxGeometryTotalOutputComponents"];
[&](){maxGeometryTotalOutputComponents_json=member.maxGeometryTotalOutputComponents;}();
auto& maxFragmentInputComponents_json=json["maxFragmentInputComponents"];
[&](){maxFragmentInputComponents_json=member.maxFragmentInputComponents;}();
auto& maxFragmentOutputAttachments_json=json["maxFragmentOutputAttachments"];
[&](){maxFragmentOutputAttachments_json=member.maxFragmentOutputAttachments;}();
auto& maxFragmentDualSrcAttachments_json=json["maxFragmentDualSrcAttachments"];
[&](){maxFragmentDualSrcAttachments_json=member.maxFragmentDualSrcAttachments;}();
auto& maxFragmentCombinedOutputResources_json=json["maxFragmentCombinedOutputResources"];
[&](){maxFragmentCombinedOutputResources_json=member.maxFragmentCombinedOutputResources;}();
auto& maxComputeSharedMemorySize_json=json["maxComputeSharedMemorySize"];
[&](){maxComputeSharedMemorySize_json=member.maxComputeSharedMemorySize;}();
auto& maxComputeWorkGroupCount_json=json["maxComputeWorkGroupCount"];
[&](){maxComputeWorkGroupCount_json=boost::json::array(3);
        auto& arr_WDsIjGv=maxComputeWorkGroupCount_json.as_array();
        for(int kHbpeVx=0; kHbpeVx < 3; kHbpeVx++){
            [&](){arr_WDsIjGv[kHbpeVx]=member.maxComputeWorkGroupCount[kHbpeVx];}();
        }
        }();
auto& maxComputeWorkGroupInvocations_json=json["maxComputeWorkGroupInvocations"];
[&](){maxComputeWorkGroupInvocations_json=member.maxComputeWorkGroupInvocations;}();
auto& maxComputeWorkGroupSize_json=json["maxComputeWorkGroupSize"];
[&](){maxComputeWorkGroupSize_json=boost::json::array(3);
        auto& arr_mrDFXSz=maxComputeWorkGroupSize_json.as_array();
        for(int crVwwSK=0; crVwwSK < 3; crVwwSK++){
            [&](){arr_mrDFXSz[crVwwSK]=member.maxComputeWorkGroupSize[crVwwSK];}();
        }
        }();
auto& subPixelPrecisionBits_json=json["subPixelPrecisionBits"];
[&](){subPixelPrecisionBits_json=member.subPixelPrecisionBits;}();
auto& subTexelPrecisionBits_json=json["subTexelPrecisionBits"];
[&](){subTexelPrecisionBits_json=member.subTexelPrecisionBits;}();
auto& mipmapPrecisionBits_json=json["mipmapPrecisionBits"];
[&](){mipmapPrecisionBits_json=member.mipmapPrecisionBits;}();
auto& maxDrawIndexedIndexValue_json=json["maxDrawIndexedIndexValue"];
[&](){maxDrawIndexedIndexValue_json=member.maxDrawIndexedIndexValue;}();
auto& maxDrawIndirectCount_json=json["maxDrawIndirectCount"];
[&](){maxDrawIndirectCount_json=member.maxDrawIndirectCount;}();
auto& maxSamplerLodBias_json=json["maxSamplerLodBias"];
[&](){maxSamplerLodBias_json=member.maxSamplerLodBias;}();
auto& maxSamplerAnisotropy_json=json["maxSamplerAnisotropy"];
[&](){maxSamplerAnisotropy_json=member.maxSamplerAnisotropy;}();
auto& maxViewports_json=json["maxViewports"];
[&](){maxViewports_json=member.maxViewports;}();
auto& maxViewportDimensions_json=json["maxViewportDimensions"];
[&](){maxViewportDimensions_json=boost::json::array(2);
        auto& arr_tYpCjJd=maxViewportDimensions_json.as_array();
        for(int ycCCCsN=0; ycCCCsN < 2; ycCCCsN++){
            [&](){arr_tYpCjJd[ycCCCsN]=member.maxViewportDimensions[ycCCCsN];}();
        }
        }();
auto& viewportBoundsRange_json=json["viewportBoundsRange"];
[&](){viewportBoundsRange_json=boost::json::array(2);
        auto& arr_damAIRy=viewportBoundsRange_json.as_array();
        for(int PARUdVU=0; PARUdVU < 2; PARUdVU++){
            [&](){arr_damAIRy[PARUdVU]=member.viewportBoundsRange[PARUdVU];}();
        }
        }();
auto& viewportSubPixelBits_json=json["viewportSubPixelBits"];
[&](){viewportSubPixelBits_json=member.viewportSubPixelBits;}();
auto& minMemoryMapAlignment_json=json["minMemoryMapAlignment"];
[&](){minMemoryMapAlignment_json=member.minMemoryMapAlignment;}();
auto& minTexelBufferOffsetAlignment_json=json["minTexelBufferOffsetAlignment"];
[&](){[&](){minTexelBufferOffsetAlignment_json=member.minTexelBufferOffsetAlignment;}();}();
auto& minUniformBufferOffsetAlignment_json=json["minUniformBufferOffsetAlignment"];
[&](){[&](){minUniformBufferOffsetAlignment_json=member.minUniformBufferOffsetAlignment;}();}();
auto& minStorageBufferOffsetAlignment_json=json["minStorageBufferOffsetAlignment"];
[&](){[&](){minStorageBufferOffsetAlignment_json=member.minStorageBufferOffsetAlignment;}();}();
auto& minTexelOffset_json=json["minTexelOffset"];
[&](){minTexelOffset_json=member.minTexelOffset;}();
auto& maxTexelOffset_json=json["maxTexelOffset"];
[&](){maxTexelOffset_json=member.maxTexelOffset;}();
auto& minTexelGatherOffset_json=json["minTexelGatherOffset"];
[&](){minTexelGatherOffset_json=member.minTexelGatherOffset;}();
auto& maxTexelGatherOffset_json=json["maxTexelGatherOffset"];
[&](){maxTexelGatherOffset_json=member.maxTexelGatherOffset;}();
auto& minInterpolationOffset_json=json["minInterpolationOffset"];
[&](){minInterpolationOffset_json=member.minInterpolationOffset;}();
auto& maxInterpolationOffset_json=json["maxInterpolationOffset"];
[&](){maxInterpolationOffset_json=member.maxInterpolationOffset;}();
auto& subPixelInterpolationOffsetBits_json=json["subPixelInterpolationOffsetBits"];
[&](){subPixelInterpolationOffsetBits_json=member.subPixelInterpolationOffsetBits;}();
auto& maxFramebufferWidth_json=json["maxFramebufferWidth"];
[&](){maxFramebufferWidth_json=member.maxFramebufferWidth;}();
auto& maxFramebufferHeight_json=json["maxFramebufferHeight"];
[&](){maxFramebufferHeight_json=member.maxFramebufferHeight;}();
auto& maxFramebufferLayers_json=json["maxFramebufferLayers"];
[&](){maxFramebufferLayers_json=member.maxFramebufferLayers;}();
auto& framebufferColorSampleCounts_json=json["framebufferColorSampleCounts"];
[&](){[&](){[&](){framebufferColorSampleCounts_json=member.framebufferColorSampleCounts;}();}();}();
auto& framebufferDepthSampleCounts_json=json["framebufferDepthSampleCounts"];
[&](){[&](){[&](){framebufferDepthSampleCounts_json=member.framebufferDepthSampleCounts;}();}();}();
auto& framebufferStencilSampleCounts_json=json["framebufferStencilSampleCounts"];
[&](){[&](){[&](){framebufferStencilSampleCounts_json=member.framebufferStencilSampleCounts;}();}();}();
auto& framebufferNoAttachmentsSampleCounts_json=json["framebufferNoAttachmentsSampleCounts"];
[&](){[&](){[&](){framebufferNoAttachmentsSampleCounts_json=member.framebufferNoAttachmentsSampleCounts;}();}();}();
auto& maxColorAttachments_json=json["maxColorAttachments"];
[&](){maxColorAttachments_json=member.maxColorAttachments;}();
auto& sampledImageColorSampleCounts_json=json["sampledImageColorSampleCounts"];
[&](){[&](){[&](){sampledImageColorSampleCounts_json=member.sampledImageColorSampleCounts;}();}();}();
auto& sampledImageIntegerSampleCounts_json=json["sampledImageIntegerSampleCounts"];
[&](){[&](){[&](){sampledImageIntegerSampleCounts_json=member.sampledImageIntegerSampleCounts;}();}();}();
auto& sampledImageDepthSampleCounts_json=json["sampledImageDepthSampleCounts"];
[&](){[&](){[&](){sampledImageDepthSampleCounts_json=member.sampledImageDepthSampleCounts;}();}();}();
auto& sampledImageStencilSampleCounts_json=json["sampledImageStencilSampleCounts"];
[&](){[&](){[&](){sampledImageStencilSampleCounts_json=member.sampledImageStencilSampleCounts;}();}();}();
auto& storageImageSampleCounts_json=json["storageImageSampleCounts"];
[&](){[&](){[&](){storageImageSampleCounts_json=member.storageImageSampleCounts;}();}();}();
auto& maxSampleMaskWords_json=json["maxSampleMaskWords"];
[&](){maxSampleMaskWords_json=member.maxSampleMaskWords;}();
auto& timestampComputeAndGraphics_json=json["timestampComputeAndGraphics"];
[&](){[&](){timestampComputeAndGraphics_json=member.timestampComputeAndGraphics;}();}();
auto& timestampPeriod_json=json["timestampPeriod"];
[&](){timestampPeriod_json=member.timestampPeriod;}();
auto& maxClipDistances_json=json["maxClipDistances"];
[&](){maxClipDistances_json=member.maxClipDistances;}();
auto& maxCullDistances_json=json["maxCullDistances"];
[&](){maxCullDistances_json=member.maxCullDistances;}();
auto& maxCombinedClipAndCullDistances_json=json["maxCombinedClipAndCullDistances"];
[&](){maxCombinedClipAndCullDistances_json=member.maxCombinedClipAndCullDistances;}();
auto& discreteQueuePriorities_json=json["discreteQueuePriorities"];
[&](){discreteQueuePriorities_json=member.discreteQueuePriorities;}();
auto& pointSizeRange_json=json["pointSizeRange"];
[&](){pointSizeRange_json=boost::json::array(2);
        auto& arr_JnsAwfl=pointSizeRange_json.as_array();
        for(int DtetcFR=0; DtetcFR < 2; DtetcFR++){
            [&](){arr_JnsAwfl[DtetcFR]=member.pointSizeRange[DtetcFR];}();
        }
        }();
auto& lineWidthRange_json=json["lineWidthRange"];
[&](){lineWidthRange_json=boost::json::array(2);
        auto& arr_KERqHIq=lineWidthRange_json.as_array();
        for(int mAcInEU=0; mAcInEU < 2; mAcInEU++){
            [&](){arr_KERqHIq[mAcInEU]=member.lineWidthRange[mAcInEU];}();
        }
        }();
auto& pointSizeGranularity_json=json["pointSizeGranularity"];
[&](){pointSizeGranularity_json=member.pointSizeGranularity;}();
auto& lineWidthGranularity_json=json["lineWidthGranularity"];
[&](){lineWidthGranularity_json=member.lineWidthGranularity;}();
auto& strictLines_json=json["strictLines"];
[&](){[&](){strictLines_json=member.strictLines;}();}();
auto& standardSampleLocations_json=json["standardSampleLocations"];
[&](){[&](){standardSampleLocations_json=member.standardSampleLocations;}();}();
auto& optimalBufferCopyOffsetAlignment_json=json["optimalBufferCopyOffsetAlignment"];
[&](){[&](){optimalBufferCopyOffsetAlignment_json=member.optimalBufferCopyOffsetAlignment;}();}();
auto& optimalBufferCopyRowPitchAlignment_json=json["optimalBufferCopyRowPitchAlignment"];
[&](){[&](){optimalBufferCopyRowPitchAlignment_json=member.optimalBufferCopyRowPitchAlignment;}();}();
auto& nonCoherentAtomSize_json=json["nonCoherentAtomSize"];
[&](){[&](){nonCoherentAtomSize_json=member.nonCoherentAtomSize;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceLimits& member){
auto& maxImageDimension1D_json=json["maxImageDimension1D"];
[&](){member.maxImageDimension1D=static_cast<uint32_t>(value_to<int>(maxImageDimension1D_json));}();
auto& maxImageDimension2D_json=json["maxImageDimension2D"];
[&](){member.maxImageDimension2D=static_cast<uint32_t>(value_to<int>(maxImageDimension2D_json));}();
auto& maxImageDimension3D_json=json["maxImageDimension3D"];
[&](){member.maxImageDimension3D=static_cast<uint32_t>(value_to<int>(maxImageDimension3D_json));}();
auto& maxImageDimensionCube_json=json["maxImageDimensionCube"];
[&](){member.maxImageDimensionCube=static_cast<uint32_t>(value_to<int>(maxImageDimensionCube_json));}();
auto& maxImageArrayLayers_json=json["maxImageArrayLayers"];
[&](){member.maxImageArrayLayers=static_cast<uint32_t>(value_to<int>(maxImageArrayLayers_json));}();
auto& maxTexelBufferElements_json=json["maxTexelBufferElements"];
[&](){member.maxTexelBufferElements=static_cast<uint32_t>(value_to<int>(maxTexelBufferElements_json));}();
auto& maxUniformBufferRange_json=json["maxUniformBufferRange"];
[&](){member.maxUniformBufferRange=static_cast<uint32_t>(value_to<int>(maxUniformBufferRange_json));}();
auto& maxStorageBufferRange_json=json["maxStorageBufferRange"];
[&](){member.maxStorageBufferRange=static_cast<uint32_t>(value_to<int>(maxStorageBufferRange_json));}();
auto& maxPushConstantsSize_json=json["maxPushConstantsSize"];
[&](){member.maxPushConstantsSize=static_cast<uint32_t>(value_to<int>(maxPushConstantsSize_json));}();
auto& maxMemoryAllocationCount_json=json["maxMemoryAllocationCount"];
[&](){member.maxMemoryAllocationCount=static_cast<uint32_t>(value_to<int>(maxMemoryAllocationCount_json));}();
auto& maxSamplerAllocationCount_json=json["maxSamplerAllocationCount"];
[&](){member.maxSamplerAllocationCount=static_cast<uint32_t>(value_to<int>(maxSamplerAllocationCount_json));}();
auto& bufferImageGranularity_json=json["bufferImageGranularity"];
[&](){uint64_t temp_ymFJvEz;[&](){temp_ymFJvEz=static_cast<uint64_t>(value_to<int>(bufferImageGranularity_json));}();member.bufferImageGranularity=(VkDeviceSize)temp_ymFJvEz;}();
auto& sparseAddressSpaceSize_json=json["sparseAddressSpaceSize"];
[&](){uint64_t temp_hFnsrAR;[&](){temp_hFnsrAR=static_cast<uint64_t>(value_to<int>(sparseAddressSpaceSize_json));}();member.sparseAddressSpaceSize=(VkDeviceSize)temp_hFnsrAR;}();
auto& maxBoundDescriptorSets_json=json["maxBoundDescriptorSets"];
[&](){member.maxBoundDescriptorSets=static_cast<uint32_t>(value_to<int>(maxBoundDescriptorSets_json));}();
auto& maxPerStageDescriptorSamplers_json=json["maxPerStageDescriptorSamplers"];
[&](){member.maxPerStageDescriptorSamplers=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorSamplers_json));}();
auto& maxPerStageDescriptorUniformBuffers_json=json["maxPerStageDescriptorUniformBuffers"];
[&](){member.maxPerStageDescriptorUniformBuffers=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUniformBuffers_json));}();
auto& maxPerStageDescriptorStorageBuffers_json=json["maxPerStageDescriptorStorageBuffers"];
[&](){member.maxPerStageDescriptorStorageBuffers=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorStorageBuffers_json));}();
auto& maxPerStageDescriptorSampledImages_json=json["maxPerStageDescriptorSampledImages"];
[&](){member.maxPerStageDescriptorSampledImages=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorSampledImages_json));}();
auto& maxPerStageDescriptorStorageImages_json=json["maxPerStageDescriptorStorageImages"];
[&](){member.maxPerStageDescriptorStorageImages=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorStorageImages_json));}();
auto& maxPerStageDescriptorInputAttachments_json=json["maxPerStageDescriptorInputAttachments"];
[&](){member.maxPerStageDescriptorInputAttachments=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorInputAttachments_json));}();
auto& maxPerStageResources_json=json["maxPerStageResources"];
[&](){member.maxPerStageResources=static_cast<uint32_t>(value_to<int>(maxPerStageResources_json));}();
auto& maxDescriptorSetSamplers_json=json["maxDescriptorSetSamplers"];
[&](){member.maxDescriptorSetSamplers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetSamplers_json));}();
auto& maxDescriptorSetUniformBuffers_json=json["maxDescriptorSetUniformBuffers"];
[&](){member.maxDescriptorSetUniformBuffers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUniformBuffers_json));}();
auto& maxDescriptorSetUniformBuffersDynamic_json=json["maxDescriptorSetUniformBuffersDynamic"];
[&](){member.maxDescriptorSetUniformBuffersDynamic=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUniformBuffersDynamic_json));}();
auto& maxDescriptorSetStorageBuffers_json=json["maxDescriptorSetStorageBuffers"];
[&](){member.maxDescriptorSetStorageBuffers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetStorageBuffers_json));}();
auto& maxDescriptorSetStorageBuffersDynamic_json=json["maxDescriptorSetStorageBuffersDynamic"];
[&](){member.maxDescriptorSetStorageBuffersDynamic=static_cast<uint32_t>(value_to<int>(maxDescriptorSetStorageBuffersDynamic_json));}();
auto& maxDescriptorSetSampledImages_json=json["maxDescriptorSetSampledImages"];
[&](){member.maxDescriptorSetSampledImages=static_cast<uint32_t>(value_to<int>(maxDescriptorSetSampledImages_json));}();
auto& maxDescriptorSetStorageImages_json=json["maxDescriptorSetStorageImages"];
[&](){member.maxDescriptorSetStorageImages=static_cast<uint32_t>(value_to<int>(maxDescriptorSetStorageImages_json));}();
auto& maxDescriptorSetInputAttachments_json=json["maxDescriptorSetInputAttachments"];
[&](){member.maxDescriptorSetInputAttachments=static_cast<uint32_t>(value_to<int>(maxDescriptorSetInputAttachments_json));}();
auto& maxVertexInputAttributes_json=json["maxVertexInputAttributes"];
[&](){member.maxVertexInputAttributes=static_cast<uint32_t>(value_to<int>(maxVertexInputAttributes_json));}();
auto& maxVertexInputBindings_json=json["maxVertexInputBindings"];
[&](){member.maxVertexInputBindings=static_cast<uint32_t>(value_to<int>(maxVertexInputBindings_json));}();
auto& maxVertexInputAttributeOffset_json=json["maxVertexInputAttributeOffset"];
[&](){member.maxVertexInputAttributeOffset=static_cast<uint32_t>(value_to<int>(maxVertexInputAttributeOffset_json));}();
auto& maxVertexInputBindingStride_json=json["maxVertexInputBindingStride"];
[&](){member.maxVertexInputBindingStride=static_cast<uint32_t>(value_to<int>(maxVertexInputBindingStride_json));}();
auto& maxVertexOutputComponents_json=json["maxVertexOutputComponents"];
[&](){member.maxVertexOutputComponents=static_cast<uint32_t>(value_to<int>(maxVertexOutputComponents_json));}();
auto& maxTessellationGenerationLevel_json=json["maxTessellationGenerationLevel"];
[&](){member.maxTessellationGenerationLevel=static_cast<uint32_t>(value_to<int>(maxTessellationGenerationLevel_json));}();
auto& maxTessellationPatchSize_json=json["maxTessellationPatchSize"];
[&](){member.maxTessellationPatchSize=static_cast<uint32_t>(value_to<int>(maxTessellationPatchSize_json));}();
auto& maxTessellationControlPerVertexInputComponents_json=json["maxTessellationControlPerVertexInputComponents"];
[&](){member.maxTessellationControlPerVertexInputComponents=static_cast<uint32_t>(value_to<int>(maxTessellationControlPerVertexInputComponents_json));}();
auto& maxTessellationControlPerVertexOutputComponents_json=json["maxTessellationControlPerVertexOutputComponents"];
[&](){member.maxTessellationControlPerVertexOutputComponents=static_cast<uint32_t>(value_to<int>(maxTessellationControlPerVertexOutputComponents_json));}();
auto& maxTessellationControlPerPatchOutputComponents_json=json["maxTessellationControlPerPatchOutputComponents"];
[&](){member.maxTessellationControlPerPatchOutputComponents=static_cast<uint32_t>(value_to<int>(maxTessellationControlPerPatchOutputComponents_json));}();
auto& maxTessellationControlTotalOutputComponents_json=json["maxTessellationControlTotalOutputComponents"];
[&](){member.maxTessellationControlTotalOutputComponents=static_cast<uint32_t>(value_to<int>(maxTessellationControlTotalOutputComponents_json));}();
auto& maxTessellationEvaluationInputComponents_json=json["maxTessellationEvaluationInputComponents"];
[&](){member.maxTessellationEvaluationInputComponents=static_cast<uint32_t>(value_to<int>(maxTessellationEvaluationInputComponents_json));}();
auto& maxTessellationEvaluationOutputComponents_json=json["maxTessellationEvaluationOutputComponents"];
[&](){member.maxTessellationEvaluationOutputComponents=static_cast<uint32_t>(value_to<int>(maxTessellationEvaluationOutputComponents_json));}();
auto& maxGeometryShaderInvocations_json=json["maxGeometryShaderInvocations"];
[&](){member.maxGeometryShaderInvocations=static_cast<uint32_t>(value_to<int>(maxGeometryShaderInvocations_json));}();
auto& maxGeometryInputComponents_json=json["maxGeometryInputComponents"];
[&](){member.maxGeometryInputComponents=static_cast<uint32_t>(value_to<int>(maxGeometryInputComponents_json));}();
auto& maxGeometryOutputComponents_json=json["maxGeometryOutputComponents"];
[&](){member.maxGeometryOutputComponents=static_cast<uint32_t>(value_to<int>(maxGeometryOutputComponents_json));}();
auto& maxGeometryOutputVertices_json=json["maxGeometryOutputVertices"];
[&](){member.maxGeometryOutputVertices=static_cast<uint32_t>(value_to<int>(maxGeometryOutputVertices_json));}();
auto& maxGeometryTotalOutputComponents_json=json["maxGeometryTotalOutputComponents"];
[&](){member.maxGeometryTotalOutputComponents=static_cast<uint32_t>(value_to<int>(maxGeometryTotalOutputComponents_json));}();
auto& maxFragmentInputComponents_json=json["maxFragmentInputComponents"];
[&](){member.maxFragmentInputComponents=static_cast<uint32_t>(value_to<int>(maxFragmentInputComponents_json));}();
auto& maxFragmentOutputAttachments_json=json["maxFragmentOutputAttachments"];
[&](){member.maxFragmentOutputAttachments=static_cast<uint32_t>(value_to<int>(maxFragmentOutputAttachments_json));}();
auto& maxFragmentDualSrcAttachments_json=json["maxFragmentDualSrcAttachments"];
[&](){member.maxFragmentDualSrcAttachments=static_cast<uint32_t>(value_to<int>(maxFragmentDualSrcAttachments_json));}();
auto& maxFragmentCombinedOutputResources_json=json["maxFragmentCombinedOutputResources"];
[&](){member.maxFragmentCombinedOutputResources=static_cast<uint32_t>(value_to<int>(maxFragmentCombinedOutputResources_json));}();
auto& maxComputeSharedMemorySize_json=json["maxComputeSharedMemorySize"];
[&](){member.maxComputeSharedMemorySize=static_cast<uint32_t>(value_to<int>(maxComputeSharedMemorySize_json));}();
auto& maxComputeWorkGroupCount_json=json["maxComputeWorkGroupCount"];
[&](){
        auto& arr_WDsIjGv=maxComputeWorkGroupCount_json.as_array();
        for(int kHbpeVx=0; kHbpeVx < 3; kHbpeVx++){
            [&](){member.maxComputeWorkGroupCount[kHbpeVx]=static_cast<uint32_t>(value_to<int>(arr_WDsIjGv[kHbpeVx]));}();
        }
        }();
auto& maxComputeWorkGroupInvocations_json=json["maxComputeWorkGroupInvocations"];
[&](){member.maxComputeWorkGroupInvocations=static_cast<uint32_t>(value_to<int>(maxComputeWorkGroupInvocations_json));}();
auto& maxComputeWorkGroupSize_json=json["maxComputeWorkGroupSize"];
[&](){
        auto& arr_mrDFXSz=maxComputeWorkGroupSize_json.as_array();
        for(int crVwwSK=0; crVwwSK < 3; crVwwSK++){
            [&](){member.maxComputeWorkGroupSize[crVwwSK]=static_cast<uint32_t>(value_to<int>(arr_mrDFXSz[crVwwSK]));}();
        }
        }();
auto& subPixelPrecisionBits_json=json["subPixelPrecisionBits"];
[&](){member.subPixelPrecisionBits=static_cast<uint32_t>(value_to<int>(subPixelPrecisionBits_json));}();
auto& subTexelPrecisionBits_json=json["subTexelPrecisionBits"];
[&](){member.subTexelPrecisionBits=static_cast<uint32_t>(value_to<int>(subTexelPrecisionBits_json));}();
auto& mipmapPrecisionBits_json=json["mipmapPrecisionBits"];
[&](){member.mipmapPrecisionBits=static_cast<uint32_t>(value_to<int>(mipmapPrecisionBits_json));}();
auto& maxDrawIndexedIndexValue_json=json["maxDrawIndexedIndexValue"];
[&](){member.maxDrawIndexedIndexValue=static_cast<uint32_t>(value_to<int>(maxDrawIndexedIndexValue_json));}();
auto& maxDrawIndirectCount_json=json["maxDrawIndirectCount"];
[&](){member.maxDrawIndirectCount=static_cast<uint32_t>(value_to<int>(maxDrawIndirectCount_json));}();
auto& maxSamplerLodBias_json=json["maxSamplerLodBias"];
[&](){member.maxSamplerLodBias=static_cast<float>(value_to<int>(maxSamplerLodBias_json));}();
auto& maxSamplerAnisotropy_json=json["maxSamplerAnisotropy"];
[&](){member.maxSamplerAnisotropy=static_cast<float>(value_to<int>(maxSamplerAnisotropy_json));}();
auto& maxViewports_json=json["maxViewports"];
[&](){member.maxViewports=static_cast<uint32_t>(value_to<int>(maxViewports_json));}();
auto& maxViewportDimensions_json=json["maxViewportDimensions"];
[&](){
        auto& arr_tYpCjJd=maxViewportDimensions_json.as_array();
        for(int ycCCCsN=0; ycCCCsN < 2; ycCCCsN++){
            [&](){member.maxViewportDimensions[ycCCCsN]=static_cast<uint32_t>(value_to<int>(arr_tYpCjJd[ycCCCsN]));}();
        }
        }();
auto& viewportBoundsRange_json=json["viewportBoundsRange"];
[&](){
        auto& arr_damAIRy=viewportBoundsRange_json.as_array();
        for(int PARUdVU=0; PARUdVU < 2; PARUdVU++){
            [&](){member.viewportBoundsRange[PARUdVU]=static_cast<float>(value_to<int>(arr_damAIRy[PARUdVU]));}();
        }
        }();
auto& viewportSubPixelBits_json=json["viewportSubPixelBits"];
[&](){member.viewportSubPixelBits=static_cast<uint32_t>(value_to<int>(viewportSubPixelBits_json));}();
auto& minMemoryMapAlignment_json=json["minMemoryMapAlignment"];
[&](){member.minMemoryMapAlignment=static_cast<size_t>(value_to<int>(minMemoryMapAlignment_json));}();
auto& minTexelBufferOffsetAlignment_json=json["minTexelBufferOffsetAlignment"];
[&](){uint64_t temp_rsKRqkr;[&](){temp_rsKRqkr=static_cast<uint64_t>(value_to<int>(minTexelBufferOffsetAlignment_json));}();member.minTexelBufferOffsetAlignment=(VkDeviceSize)temp_rsKRqkr;}();
auto& minUniformBufferOffsetAlignment_json=json["minUniformBufferOffsetAlignment"];
[&](){uint64_t temp_qbXCoqm;[&](){temp_qbXCoqm=static_cast<uint64_t>(value_to<int>(minUniformBufferOffsetAlignment_json));}();member.minUniformBufferOffsetAlignment=(VkDeviceSize)temp_qbXCoqm;}();
auto& minStorageBufferOffsetAlignment_json=json["minStorageBufferOffsetAlignment"];
[&](){uint64_t temp_RyiETvD;[&](){temp_RyiETvD=static_cast<uint64_t>(value_to<int>(minStorageBufferOffsetAlignment_json));}();member.minStorageBufferOffsetAlignment=(VkDeviceSize)temp_RyiETvD;}();
auto& minTexelOffset_json=json["minTexelOffset"];
[&](){member.minTexelOffset=static_cast<int32_t>(value_to<int>(minTexelOffset_json));}();
auto& maxTexelOffset_json=json["maxTexelOffset"];
[&](){member.maxTexelOffset=static_cast<uint32_t>(value_to<int>(maxTexelOffset_json));}();
auto& minTexelGatherOffset_json=json["minTexelGatherOffset"];
[&](){member.minTexelGatherOffset=static_cast<int32_t>(value_to<int>(minTexelGatherOffset_json));}();
auto& maxTexelGatherOffset_json=json["maxTexelGatherOffset"];
[&](){member.maxTexelGatherOffset=static_cast<uint32_t>(value_to<int>(maxTexelGatherOffset_json));}();
auto& minInterpolationOffset_json=json["minInterpolationOffset"];
[&](){member.minInterpolationOffset=static_cast<float>(value_to<int>(minInterpolationOffset_json));}();
auto& maxInterpolationOffset_json=json["maxInterpolationOffset"];
[&](){member.maxInterpolationOffset=static_cast<float>(value_to<int>(maxInterpolationOffset_json));}();
auto& subPixelInterpolationOffsetBits_json=json["subPixelInterpolationOffsetBits"];
[&](){member.subPixelInterpolationOffsetBits=static_cast<uint32_t>(value_to<int>(subPixelInterpolationOffsetBits_json));}();
auto& maxFramebufferWidth_json=json["maxFramebufferWidth"];
[&](){member.maxFramebufferWidth=static_cast<uint32_t>(value_to<int>(maxFramebufferWidth_json));}();
auto& maxFramebufferHeight_json=json["maxFramebufferHeight"];
[&](){member.maxFramebufferHeight=static_cast<uint32_t>(value_to<int>(maxFramebufferHeight_json));}();
auto& maxFramebufferLayers_json=json["maxFramebufferLayers"];
[&](){member.maxFramebufferLayers=static_cast<uint32_t>(value_to<int>(maxFramebufferLayers_json));}();
auto& framebufferColorSampleCounts_json=json["framebufferColorSampleCounts"];
[&](){[&](){int temp_iAlmxTz;[&](){temp_iAlmxTz=static_cast<int>(value_to<int>(framebufferColorSampleCounts_json));}();member.framebufferColorSampleCounts=(VkSampleCountFlags)temp_iAlmxTz;}();}();
auto& framebufferDepthSampleCounts_json=json["framebufferDepthSampleCounts"];
[&](){[&](){int temp_EaExpbe;[&](){temp_EaExpbe=static_cast<int>(value_to<int>(framebufferDepthSampleCounts_json));}();member.framebufferDepthSampleCounts=(VkSampleCountFlags)temp_EaExpbe;}();}();
auto& framebufferStencilSampleCounts_json=json["framebufferStencilSampleCounts"];
[&](){[&](){int temp_oWvynug;[&](){temp_oWvynug=static_cast<int>(value_to<int>(framebufferStencilSampleCounts_json));}();member.framebufferStencilSampleCounts=(VkSampleCountFlags)temp_oWvynug;}();}();
auto& framebufferNoAttachmentsSampleCounts_json=json["framebufferNoAttachmentsSampleCounts"];
[&](){[&](){int temp_XAZAoAC;[&](){temp_XAZAoAC=static_cast<int>(value_to<int>(framebufferNoAttachmentsSampleCounts_json));}();member.framebufferNoAttachmentsSampleCounts=(VkSampleCountFlags)temp_XAZAoAC;}();}();
auto& maxColorAttachments_json=json["maxColorAttachments"];
[&](){member.maxColorAttachments=static_cast<uint32_t>(value_to<int>(maxColorAttachments_json));}();
auto& sampledImageColorSampleCounts_json=json["sampledImageColorSampleCounts"];
[&](){[&](){int temp_SkurIcW;[&](){temp_SkurIcW=static_cast<int>(value_to<int>(sampledImageColorSampleCounts_json));}();member.sampledImageColorSampleCounts=(VkSampleCountFlags)temp_SkurIcW;}();}();
auto& sampledImageIntegerSampleCounts_json=json["sampledImageIntegerSampleCounts"];
[&](){[&](){int temp_JpOjibX;[&](){temp_JpOjibX=static_cast<int>(value_to<int>(sampledImageIntegerSampleCounts_json));}();member.sampledImageIntegerSampleCounts=(VkSampleCountFlags)temp_JpOjibX;}();}();
auto& sampledImageDepthSampleCounts_json=json["sampledImageDepthSampleCounts"];
[&](){[&](){int temp_pErmFLk;[&](){temp_pErmFLk=static_cast<int>(value_to<int>(sampledImageDepthSampleCounts_json));}();member.sampledImageDepthSampleCounts=(VkSampleCountFlags)temp_pErmFLk;}();}();
auto& sampledImageStencilSampleCounts_json=json["sampledImageStencilSampleCounts"];
[&](){[&](){int temp_gLaPSUo;[&](){temp_gLaPSUo=static_cast<int>(value_to<int>(sampledImageStencilSampleCounts_json));}();member.sampledImageStencilSampleCounts=(VkSampleCountFlags)temp_gLaPSUo;}();}();
auto& storageImageSampleCounts_json=json["storageImageSampleCounts"];
[&](){[&](){int temp_rsbfdVm;[&](){temp_rsbfdVm=static_cast<int>(value_to<int>(storageImageSampleCounts_json));}();member.storageImageSampleCounts=(VkSampleCountFlags)temp_rsbfdVm;}();}();
auto& maxSampleMaskWords_json=json["maxSampleMaskWords"];
[&](){member.maxSampleMaskWords=static_cast<uint32_t>(value_to<int>(maxSampleMaskWords_json));}();
auto& timestampComputeAndGraphics_json=json["timestampComputeAndGraphics"];
[&](){uint32_t temp_FHEbwRG;[&](){temp_FHEbwRG=static_cast<uint32_t>(value_to<int>(timestampComputeAndGraphics_json));}();member.timestampComputeAndGraphics=(VkBool32)temp_FHEbwRG;}();
auto& timestampPeriod_json=json["timestampPeriod"];
[&](){member.timestampPeriod=static_cast<float>(value_to<int>(timestampPeriod_json));}();
auto& maxClipDistances_json=json["maxClipDistances"];
[&](){member.maxClipDistances=static_cast<uint32_t>(value_to<int>(maxClipDistances_json));}();
auto& maxCullDistances_json=json["maxCullDistances"];
[&](){member.maxCullDistances=static_cast<uint32_t>(value_to<int>(maxCullDistances_json));}();
auto& maxCombinedClipAndCullDistances_json=json["maxCombinedClipAndCullDistances"];
[&](){member.maxCombinedClipAndCullDistances=static_cast<uint32_t>(value_to<int>(maxCombinedClipAndCullDistances_json));}();
auto& discreteQueuePriorities_json=json["discreteQueuePriorities"];
[&](){member.discreteQueuePriorities=static_cast<uint32_t>(value_to<int>(discreteQueuePriorities_json));}();
auto& pointSizeRange_json=json["pointSizeRange"];
[&](){
        auto& arr_JnsAwfl=pointSizeRange_json.as_array();
        for(int DtetcFR=0; DtetcFR < 2; DtetcFR++){
            [&](){member.pointSizeRange[DtetcFR]=static_cast<float>(value_to<int>(arr_JnsAwfl[DtetcFR]));}();
        }
        }();
auto& lineWidthRange_json=json["lineWidthRange"];
[&](){
        auto& arr_KERqHIq=lineWidthRange_json.as_array();
        for(int mAcInEU=0; mAcInEU < 2; mAcInEU++){
            [&](){member.lineWidthRange[mAcInEU]=static_cast<float>(value_to<int>(arr_KERqHIq[mAcInEU]));}();
        }
        }();
auto& pointSizeGranularity_json=json["pointSizeGranularity"];
[&](){member.pointSizeGranularity=static_cast<float>(value_to<int>(pointSizeGranularity_json));}();
auto& lineWidthGranularity_json=json["lineWidthGranularity"];
[&](){member.lineWidthGranularity=static_cast<float>(value_to<int>(lineWidthGranularity_json));}();
auto& strictLines_json=json["strictLines"];
[&](){uint32_t temp_OqkwsHC;[&](){temp_OqkwsHC=static_cast<uint32_t>(value_to<int>(strictLines_json));}();member.strictLines=(VkBool32)temp_OqkwsHC;}();
auto& standardSampleLocations_json=json["standardSampleLocations"];
[&](){uint32_t temp_bpgCmMT;[&](){temp_bpgCmMT=static_cast<uint32_t>(value_to<int>(standardSampleLocations_json));}();member.standardSampleLocations=(VkBool32)temp_bpgCmMT;}();
auto& optimalBufferCopyOffsetAlignment_json=json["optimalBufferCopyOffsetAlignment"];
[&](){uint64_t temp_pnoXbrX;[&](){temp_pnoXbrX=static_cast<uint64_t>(value_to<int>(optimalBufferCopyOffsetAlignment_json));}();member.optimalBufferCopyOffsetAlignment=(VkDeviceSize)temp_pnoXbrX;}();
auto& optimalBufferCopyRowPitchAlignment_json=json["optimalBufferCopyRowPitchAlignment"];
[&](){uint64_t temp_kCytabu;[&](){temp_kCytabu=static_cast<uint64_t>(value_to<int>(optimalBufferCopyRowPitchAlignment_json));}();member.optimalBufferCopyRowPitchAlignment=(VkDeviceSize)temp_kCytabu;}();
auto& nonCoherentAtomSize_json=json["nonCoherentAtomSize"];
[&](){uint64_t temp_RfywxFu;[&](){temp_RfywxFu=static_cast<uint64_t>(value_to<int>(nonCoherentAtomSize_json));}();member.nonCoherentAtomSize=(VkDeviceSize)temp_RfywxFu;}();
}

    void serialize_struct(boost::json::object& json, const VkSemaphoreCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSemaphoreCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_spnnJrh;[&](){temp_spnnJrh=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSemaphoreCreateFlags)temp_spnnJrh;}();}();
}

    void serialize_struct(boost::json::object& json, const VkQueryPoolCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& queryType_json=json["queryType"];
[&](){[&](){[&](){queryType_json=member.queryType;}();}();}();
auto& queryCount_json=json["queryCount"];
[&](){queryCount_json=member.queryCount;}();
auto& pipelineStatistics_json=json["pipelineStatistics"];
[&](){[&](){[&](){pipelineStatistics_json=member.pipelineStatistics;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkQueryPoolCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_YoSKNrB;[&](){temp_YoSKNrB=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkQueryPoolCreateFlags)temp_YoSKNrB;}();}();
auto& queryType_json=json["queryType"];
[&](){[&](){int temp_JVWbjRq;[&](){temp_JVWbjRq=static_cast<int>(value_to<int>(queryType_json));}();member.queryType=(VkQueryType)temp_JVWbjRq;}();}();
auto& queryCount_json=json["queryCount"];
[&](){member.queryCount=static_cast<uint32_t>(value_to<int>(queryCount_json));}();
auto& pipelineStatistics_json=json["pipelineStatistics"];
[&](){[&](){int temp_OdKoqRB;[&](){temp_OdKoqRB=static_cast<int>(value_to<int>(pipelineStatistics_json));}();member.pipelineStatistics=(VkQueryPipelineStatisticFlags)temp_OdKoqRB;}();}();
}

    void serialize_struct(boost::json::object& json, const VkFramebufferCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& renderPass_json=json["renderPass"];
[&](){serialize_VkRenderPass(renderPass_json,member.renderPass);}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){attachmentCount_json=member.attachmentCount;}();
auto& pAttachments_json=json["pAttachments"];
[&](){
            if (member.pAttachments==NULL){
                pAttachments_json=boost::json::array();
            return; }pAttachments_json=boost::json::array(member.attachmentCount);
        auto& arr_XUnbodX=pAttachments_json.as_array();
        for(int FOVxLSQ=0; FOVxLSQ < member.attachmentCount; FOVxLSQ++){
            [&](){serialize_VkImageView(arr_XUnbodX[FOVxLSQ],member.pAttachments[FOVxLSQ]);}();
        }
        }();
auto& width_json=json["width"];
[&](){width_json=member.width;}();
auto& height_json=json["height"];
[&](){height_json=member.height;}();
auto& layers_json=json["layers"];
[&](){layers_json=member.layers;}();
}
void deserialize_struct(boost::json::object& json, VkFramebufferCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_iTJFEOR;[&](){temp_iTJFEOR=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkFramebufferCreateFlags)temp_iTJFEOR;}();}();
auto& renderPass_json=json["renderPass"];
[&](){deserialize_VkRenderPass(renderPass_json, member.renderPass);}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){member.attachmentCount=static_cast<uint32_t>(value_to<int>(attachmentCount_json));}();
auto& pAttachments_json=json["pAttachments"];
[&](){ VkImageView* temp_veJtHuE;;[&](){
            if (pAttachments_json.as_array().size()==0){
                temp_veJtHuE=NULL;
            return; }temp_veJtHuE=(VkImageView*)malloc(member.attachmentCount*sizeof(VkImageView));
        auto& arr_vOukWcp=pAttachments_json.as_array();
        for(int SjNLYTr=0; SjNLYTr < member.attachmentCount; SjNLYTr++){
            [&](){deserialize_VkImageView(arr_vOukWcp[SjNLYTr], temp_veJtHuE[SjNLYTr]);}();
        }
        }();member.pAttachments=temp_veJtHuE;}();
auto& width_json=json["width"];
[&](){member.width=static_cast<uint32_t>(value_to<int>(width_json));}();
auto& height_json=json["height"];
[&](){member.height=static_cast<uint32_t>(value_to<int>(height_json));}();
auto& layers_json=json["layers"];
[&](){member.layers=static_cast<uint32_t>(value_to<int>(layers_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDrawIndirectCommand& member){
        
    
auto& vertexCount_json=json["vertexCount"];
[&](){vertexCount_json=member.vertexCount;}();
auto& instanceCount_json=json["instanceCount"];
[&](){instanceCount_json=member.instanceCount;}();
auto& firstVertex_json=json["firstVertex"];
[&](){firstVertex_json=member.firstVertex;}();
auto& firstInstance_json=json["firstInstance"];
[&](){firstInstance_json=member.firstInstance;}();
}
void deserialize_struct(boost::json::object& json, VkDrawIndirectCommand& member){
auto& vertexCount_json=json["vertexCount"];
[&](){member.vertexCount=static_cast<uint32_t>(value_to<int>(vertexCount_json));}();
auto& instanceCount_json=json["instanceCount"];
[&](){member.instanceCount=static_cast<uint32_t>(value_to<int>(instanceCount_json));}();
auto& firstVertex_json=json["firstVertex"];
[&](){member.firstVertex=static_cast<uint32_t>(value_to<int>(firstVertex_json));}();
auto& firstInstance_json=json["firstInstance"];
[&](){member.firstInstance=static_cast<uint32_t>(value_to<int>(firstInstance_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDrawIndexedIndirectCommand& member){
        
    
auto& indexCount_json=json["indexCount"];
[&](){indexCount_json=member.indexCount;}();
auto& instanceCount_json=json["instanceCount"];
[&](){instanceCount_json=member.instanceCount;}();
auto& firstIndex_json=json["firstIndex"];
[&](){firstIndex_json=member.firstIndex;}();
auto& vertexOffset_json=json["vertexOffset"];
[&](){vertexOffset_json=member.vertexOffset;}();
auto& firstInstance_json=json["firstInstance"];
[&](){firstInstance_json=member.firstInstance;}();
}
void deserialize_struct(boost::json::object& json, VkDrawIndexedIndirectCommand& member){
auto& indexCount_json=json["indexCount"];
[&](){member.indexCount=static_cast<uint32_t>(value_to<int>(indexCount_json));}();
auto& instanceCount_json=json["instanceCount"];
[&](){member.instanceCount=static_cast<uint32_t>(value_to<int>(instanceCount_json));}();
auto& firstIndex_json=json["firstIndex"];
[&](){member.firstIndex=static_cast<uint32_t>(value_to<int>(firstIndex_json));}();
auto& vertexOffset_json=json["vertexOffset"];
[&](){member.vertexOffset=static_cast<int32_t>(value_to<int>(vertexOffset_json));}();
auto& firstInstance_json=json["firstInstance"];
[&](){member.firstInstance=static_cast<uint32_t>(value_to<int>(firstInstance_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDispatchIndirectCommand& member){
        
    
auto& x_json=json["x"];
[&](){x_json=member.x;}();
auto& y_json=json["y"];
[&](){y_json=member.y;}();
auto& z_json=json["z"];
[&](){z_json=member.z;}();
}
void deserialize_struct(boost::json::object& json, VkDispatchIndirectCommand& member){
auto& x_json=json["x"];
[&](){member.x=static_cast<uint32_t>(value_to<int>(x_json));}();
auto& y_json=json["y"];
[&](){member.y=static_cast<uint32_t>(value_to<int>(y_json));}();
auto& z_json=json["z"];
[&](){member.z=static_cast<uint32_t>(value_to<int>(z_json));}();
}

    void serialize_struct(boost::json::object& json, const VkMultiDrawInfoEXT& member){
        
    
auto& firstVertex_json=json["firstVertex"];
[&](){firstVertex_json=member.firstVertex;}();
auto& vertexCount_json=json["vertexCount"];
[&](){vertexCount_json=member.vertexCount;}();
}
void deserialize_struct(boost::json::object& json, VkMultiDrawInfoEXT& member){
auto& firstVertex_json=json["firstVertex"];
[&](){member.firstVertex=static_cast<uint32_t>(value_to<int>(firstVertex_json));}();
auto& vertexCount_json=json["vertexCount"];
[&](){member.vertexCount=static_cast<uint32_t>(value_to<int>(vertexCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkMultiDrawIndexedInfoEXT& member){
        
    
auto& firstIndex_json=json["firstIndex"];
[&](){firstIndex_json=member.firstIndex;}();
auto& indexCount_json=json["indexCount"];
[&](){indexCount_json=member.indexCount;}();
auto& vertexOffset_json=json["vertexOffset"];
[&](){vertexOffset_json=member.vertexOffset;}();
}
void deserialize_struct(boost::json::object& json, VkMultiDrawIndexedInfoEXT& member){
auto& firstIndex_json=json["firstIndex"];
[&](){member.firstIndex=static_cast<uint32_t>(value_to<int>(firstIndex_json));}();
auto& indexCount_json=json["indexCount"];
[&](){member.indexCount=static_cast<uint32_t>(value_to<int>(indexCount_json));}();
auto& vertexOffset_json=json["vertexOffset"];
[&](){member.vertexOffset=static_cast<int32_t>(value_to<int>(vertexOffset_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSubmitInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& waitSemaphoreCount_json=json["waitSemaphoreCount"];
[&](){waitSemaphoreCount_json=member.waitSemaphoreCount;}();
auto& pWaitSemaphores_json=json["pWaitSemaphores"];
[&](){
            if (member.pWaitSemaphores==NULL){
                pWaitSemaphores_json=boost::json::array();
            return; }pWaitSemaphores_json=boost::json::array(member.waitSemaphoreCount);
        auto& arr_AxVizBE=pWaitSemaphores_json.as_array();
        for(int XBpvDer=0; XBpvDer < member.waitSemaphoreCount; XBpvDer++){
            [&](){serialize_VkSemaphore(arr_AxVizBE[XBpvDer],member.pWaitSemaphores[XBpvDer]);}();
        }
        }();
auto& pWaitDstStageMask_json=json["pWaitDstStageMask"];
[&](){
            if (member.pWaitDstStageMask==NULL){
                pWaitDstStageMask_json=boost::json::array();
            return; }pWaitDstStageMask_json=boost::json::array(member.waitSemaphoreCount);
        auto& arr_oQyrzEm=pWaitDstStageMask_json.as_array();
        for(int fKVRNjr=0; fKVRNjr < member.waitSemaphoreCount; fKVRNjr++){
            [&](){[&](){[&](){arr_oQyrzEm[fKVRNjr]=member.pWaitDstStageMask[fKVRNjr];}();}();}();
        }
        }();
auto& commandBufferCount_json=json["commandBufferCount"];
[&](){commandBufferCount_json=member.commandBufferCount;}();
auto& pCommandBuffers_json=json["pCommandBuffers"];
[&](){
            if (member.pCommandBuffers==NULL){
                pCommandBuffers_json=boost::json::array();
            return; }pCommandBuffers_json=boost::json::array(member.commandBufferCount);
        auto& arr_gceABMa=pCommandBuffers_json.as_array();
        for(int EViCAMU=0; EViCAMU < member.commandBufferCount; EViCAMU++){
            [&](){serialize_VkCommandBuffer(arr_gceABMa[EViCAMU],member.pCommandBuffers[EViCAMU]);}();
        }
        }();
auto& signalSemaphoreCount_json=json["signalSemaphoreCount"];
[&](){signalSemaphoreCount_json=member.signalSemaphoreCount;}();
auto& pSignalSemaphores_json=json["pSignalSemaphores"];
[&](){
            if (member.pSignalSemaphores==NULL){
                pSignalSemaphores_json=boost::json::array();
            return; }pSignalSemaphores_json=boost::json::array(member.signalSemaphoreCount);
        auto& arr_wTKZAbP=pSignalSemaphores_json.as_array();
        for(int zRpxMAc=0; zRpxMAc < member.signalSemaphoreCount; zRpxMAc++){
            [&](){serialize_VkSemaphore(arr_wTKZAbP[zRpxMAc],member.pSignalSemaphores[zRpxMAc]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSubmitInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& waitSemaphoreCount_json=json["waitSemaphoreCount"];
[&](){member.waitSemaphoreCount=static_cast<uint32_t>(value_to<int>(waitSemaphoreCount_json));}();
auto& pWaitSemaphores_json=json["pWaitSemaphores"];
[&](){ VkSemaphore* temp_ZOgWazs;;[&](){
            if (pWaitSemaphores_json.as_array().size()==0){
                temp_ZOgWazs=NULL;
            return; }temp_ZOgWazs=(VkSemaphore*)malloc(member.waitSemaphoreCount*sizeof(VkSemaphore));
        auto& arr_EtUHlJM=pWaitSemaphores_json.as_array();
        for(int JgknMrE=0; JgknMrE < member.waitSemaphoreCount; JgknMrE++){
            [&](){deserialize_VkSemaphore(arr_EtUHlJM[JgknMrE], temp_ZOgWazs[JgknMrE]);}();
        }
        }();member.pWaitSemaphores=temp_ZOgWazs;}();
auto& pWaitDstStageMask_json=json["pWaitDstStageMask"];
[&](){ VkPipelineStageFlags* temp_jnBGIGc;;[&](){
            if (pWaitDstStageMask_json.as_array().size()==0){
                temp_jnBGIGc=NULL;
            return; }temp_jnBGIGc=(VkPipelineStageFlags*)malloc(member.waitSemaphoreCount*sizeof(VkPipelineStageFlags));
        auto& arr_cyyyTJY=pWaitDstStageMask_json.as_array();
        for(int YghvlOM=0; YghvlOM < member.waitSemaphoreCount; YghvlOM++){
            [&](){[&](){int temp_BxVComZ;[&](){temp_BxVComZ=static_cast<int>(value_to<int>(arr_cyyyTJY[YghvlOM]));}();temp_jnBGIGc[YghvlOM]=(VkPipelineStageFlags)temp_BxVComZ;}();}();
        }
        }();member.pWaitDstStageMask=temp_jnBGIGc;}();
auto& commandBufferCount_json=json["commandBufferCount"];
[&](){member.commandBufferCount=static_cast<uint32_t>(value_to<int>(commandBufferCount_json));}();
auto& pCommandBuffers_json=json["pCommandBuffers"];
[&](){ VkCommandBuffer* temp_vAjqehs;;[&](){
            if (pCommandBuffers_json.as_array().size()==0){
                temp_vAjqehs=NULL;
            return; }temp_vAjqehs=(VkCommandBuffer*)malloc(member.commandBufferCount*sizeof(VkCommandBuffer));
        auto& arr_laSMaAh=pCommandBuffers_json.as_array();
        for(int IbzHXLC=0; IbzHXLC < member.commandBufferCount; IbzHXLC++){
            [&](){deserialize_VkCommandBuffer(arr_laSMaAh[IbzHXLC], temp_vAjqehs[IbzHXLC]);}();
        }
        }();member.pCommandBuffers=temp_vAjqehs;}();
auto& signalSemaphoreCount_json=json["signalSemaphoreCount"];
[&](){member.signalSemaphoreCount=static_cast<uint32_t>(value_to<int>(signalSemaphoreCount_json));}();
auto& pSignalSemaphores_json=json["pSignalSemaphores"];
[&](){ VkSemaphore* temp_mrerffy;;[&](){
            if (pSignalSemaphores_json.as_array().size()==0){
                temp_mrerffy=NULL;
            return; }temp_mrerffy=(VkSemaphore*)malloc(member.signalSemaphoreCount*sizeof(VkSemaphore));
        auto& arr_UVSUapF=pSignalSemaphores_json.as_array();
        for(int ZmOmQdZ=0; ZmOmQdZ < member.signalSemaphoreCount; ZmOmQdZ++){
            [&](){deserialize_VkSemaphore(arr_UVSUapF[ZmOmQdZ], temp_mrerffy[ZmOmQdZ]);}();
        }
        }();member.pSignalSemaphores=temp_mrerffy;}();
}

    void serialize_struct(boost::json::object& json, const VkDisplayPropertiesKHR& member){
        
    
auto& display_json=json["display"];
[&](){serialize_VkDisplayKHR(display_json,member.display);}();
auto& displayName_json=json["displayName"];
[&](){
            if (member.displayName==NULL){
                displayName_json=boost::json::array();
            return; }displayName_json=boost::json::array(strlen(member.displayName)+1);
        auto& arr_GUVDjBh=displayName_json.as_array();
        for(int BsvzZKW=0; BsvzZKW < strlen(member.displayName)+1; BsvzZKW++){
            [&](){arr_GUVDjBh[BsvzZKW]=member.displayName[BsvzZKW];}();
        }
        }();
auto& physicalDimensions_json=json["physicalDimensions"];
[&](){
            auto& temp=physicalDimensions_json.emplace_object();
            return serialize_struct(temp, member.physicalDimensions);
            }();
auto& physicalResolution_json=json["physicalResolution"];
[&](){
            auto& temp=physicalResolution_json.emplace_object();
            return serialize_struct(temp, member.physicalResolution);
            }();
auto& supportedTransforms_json=json["supportedTransforms"];
[&](){[&](){[&](){supportedTransforms_json=member.supportedTransforms;}();}();}();
auto& planeReorderPossible_json=json["planeReorderPossible"];
[&](){[&](){planeReorderPossible_json=member.planeReorderPossible;}();}();
auto& persistentContent_json=json["persistentContent"];
[&](){[&](){persistentContent_json=member.persistentContent;}();}();
}
void deserialize_struct(boost::json::object& json, VkDisplayPropertiesKHR& member){
auto& display_json=json["display"];
[&](){deserialize_VkDisplayKHR(display_json, member.display);}();
auto& displayName_json=json["displayName"];
[&](){ char* temp_hfObfFy;;[&](){
            if (displayName_json.as_array().size()==0){
                temp_hfObfFy=NULL;
            return; }temp_hfObfFy=(char*)malloc(displayName_json.as_array().size()*sizeof(char));
        auto& arr_ILEyfSP=displayName_json.as_array();
        for(int PQyabRP=0; PQyabRP < displayName_json.as_array().size(); PQyabRP++){
            [&](){temp_hfObfFy[PQyabRP]=static_cast<char>(value_to<int>(arr_ILEyfSP[PQyabRP]));}();
        }
        }();member.displayName=temp_hfObfFy;}();
auto& physicalDimensions_json=json["physicalDimensions"];
[&](){
            auto& temp=physicalDimensions_json.as_object();
            deserialize_struct(temp,member.physicalDimensions);
            }();
auto& physicalResolution_json=json["physicalResolution"];
[&](){
            auto& temp=physicalResolution_json.as_object();
            deserialize_struct(temp,member.physicalResolution);
            }();
auto& supportedTransforms_json=json["supportedTransforms"];
[&](){[&](){int temp_lOAidao;[&](){temp_lOAidao=static_cast<int>(value_to<int>(supportedTransforms_json));}();member.supportedTransforms=(VkSurfaceTransformFlagsKHR)temp_lOAidao;}();}();
auto& planeReorderPossible_json=json["planeReorderPossible"];
[&](){uint32_t temp_sdvxgmn;[&](){temp_sdvxgmn=static_cast<uint32_t>(value_to<int>(planeReorderPossible_json));}();member.planeReorderPossible=(VkBool32)temp_sdvxgmn;}();
auto& persistentContent_json=json["persistentContent"];
[&](){uint32_t temp_WsmEDIr;[&](){temp_WsmEDIr=static_cast<uint32_t>(value_to<int>(persistentContent_json));}();member.persistentContent=(VkBool32)temp_WsmEDIr;}();
}

    void serialize_struct(boost::json::object& json, const VkDisplayPlanePropertiesKHR& member){
        
    
auto& currentDisplay_json=json["currentDisplay"];
[&](){serialize_VkDisplayKHR(currentDisplay_json,member.currentDisplay);}();
auto& currentStackIndex_json=json["currentStackIndex"];
[&](){currentStackIndex_json=member.currentStackIndex;}();
}
void deserialize_struct(boost::json::object& json, VkDisplayPlanePropertiesKHR& member){
auto& currentDisplay_json=json["currentDisplay"];
[&](){deserialize_VkDisplayKHR(currentDisplay_json, member.currentDisplay);}();
auto& currentStackIndex_json=json["currentStackIndex"];
[&](){member.currentStackIndex=static_cast<uint32_t>(value_to<int>(currentStackIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDisplayModeParametersKHR& member){
        
    
auto& visibleRegion_json=json["visibleRegion"];
[&](){
            auto& temp=visibleRegion_json.emplace_object();
            return serialize_struct(temp, member.visibleRegion);
            }();
auto& refreshRate_json=json["refreshRate"];
[&](){refreshRate_json=member.refreshRate;}();
}
void deserialize_struct(boost::json::object& json, VkDisplayModeParametersKHR& member){
auto& visibleRegion_json=json["visibleRegion"];
[&](){
            auto& temp=visibleRegion_json.as_object();
            deserialize_struct(temp,member.visibleRegion);
            }();
auto& refreshRate_json=json["refreshRate"];
[&](){member.refreshRate=static_cast<uint32_t>(value_to<int>(refreshRate_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDisplayModePropertiesKHR& member){
        
    
auto& displayMode_json=json["displayMode"];
[&](){serialize_VkDisplayModeKHR(displayMode_json,member.displayMode);}();
auto& parameters_json=json["parameters"];
[&](){
            auto& temp=parameters_json.emplace_object();
            return serialize_struct(temp, member.parameters);
            }();
}
void deserialize_struct(boost::json::object& json, VkDisplayModePropertiesKHR& member){
auto& displayMode_json=json["displayMode"];
[&](){deserialize_VkDisplayModeKHR(displayMode_json, member.displayMode);}();
auto& parameters_json=json["parameters"];
[&](){
            auto& temp=parameters_json.as_object();
            deserialize_struct(temp,member.parameters);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDisplayModeCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& parameters_json=json["parameters"];
[&](){
            auto& temp=parameters_json.emplace_object();
            return serialize_struct(temp, member.parameters);
            }();
}
void deserialize_struct(boost::json::object& json, VkDisplayModeCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_wrCwAUu;[&](){temp_wrCwAUu=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDisplayModeCreateFlagsKHR)temp_wrCwAUu;}();}();
auto& parameters_json=json["parameters"];
[&](){
            auto& temp=parameters_json.as_object();
            deserialize_struct(temp,member.parameters);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDisplayPlaneCapabilitiesKHR& member){
        
    
auto& supportedAlpha_json=json["supportedAlpha"];
[&](){[&](){[&](){supportedAlpha_json=member.supportedAlpha;}();}();}();
auto& minSrcPosition_json=json["minSrcPosition"];
[&](){
            auto& temp=minSrcPosition_json.emplace_object();
            return serialize_struct(temp, member.minSrcPosition);
            }();
auto& maxSrcPosition_json=json["maxSrcPosition"];
[&](){
            auto& temp=maxSrcPosition_json.emplace_object();
            return serialize_struct(temp, member.maxSrcPosition);
            }();
auto& minSrcExtent_json=json["minSrcExtent"];
[&](){
            auto& temp=minSrcExtent_json.emplace_object();
            return serialize_struct(temp, member.minSrcExtent);
            }();
auto& maxSrcExtent_json=json["maxSrcExtent"];
[&](){
            auto& temp=maxSrcExtent_json.emplace_object();
            return serialize_struct(temp, member.maxSrcExtent);
            }();
auto& minDstPosition_json=json["minDstPosition"];
[&](){
            auto& temp=minDstPosition_json.emplace_object();
            return serialize_struct(temp, member.minDstPosition);
            }();
auto& maxDstPosition_json=json["maxDstPosition"];
[&](){
            auto& temp=maxDstPosition_json.emplace_object();
            return serialize_struct(temp, member.maxDstPosition);
            }();
auto& minDstExtent_json=json["minDstExtent"];
[&](){
            auto& temp=minDstExtent_json.emplace_object();
            return serialize_struct(temp, member.minDstExtent);
            }();
auto& maxDstExtent_json=json["maxDstExtent"];
[&](){
            auto& temp=maxDstExtent_json.emplace_object();
            return serialize_struct(temp, member.maxDstExtent);
            }();
}
void deserialize_struct(boost::json::object& json, VkDisplayPlaneCapabilitiesKHR& member){
auto& supportedAlpha_json=json["supportedAlpha"];
[&](){[&](){int temp_dHEiCkV;[&](){temp_dHEiCkV=static_cast<int>(value_to<int>(supportedAlpha_json));}();member.supportedAlpha=(VkDisplayPlaneAlphaFlagsKHR)temp_dHEiCkV;}();}();
auto& minSrcPosition_json=json["minSrcPosition"];
[&](){
            auto& temp=minSrcPosition_json.as_object();
            deserialize_struct(temp,member.minSrcPosition);
            }();
auto& maxSrcPosition_json=json["maxSrcPosition"];
[&](){
            auto& temp=maxSrcPosition_json.as_object();
            deserialize_struct(temp,member.maxSrcPosition);
            }();
auto& minSrcExtent_json=json["minSrcExtent"];
[&](){
            auto& temp=minSrcExtent_json.as_object();
            deserialize_struct(temp,member.minSrcExtent);
            }();
auto& maxSrcExtent_json=json["maxSrcExtent"];
[&](){
            auto& temp=maxSrcExtent_json.as_object();
            deserialize_struct(temp,member.maxSrcExtent);
            }();
auto& minDstPosition_json=json["minDstPosition"];
[&](){
            auto& temp=minDstPosition_json.as_object();
            deserialize_struct(temp,member.minDstPosition);
            }();
auto& maxDstPosition_json=json["maxDstPosition"];
[&](){
            auto& temp=maxDstPosition_json.as_object();
            deserialize_struct(temp,member.maxDstPosition);
            }();
auto& minDstExtent_json=json["minDstExtent"];
[&](){
            auto& temp=minDstExtent_json.as_object();
            deserialize_struct(temp,member.minDstExtent);
            }();
auto& maxDstExtent_json=json["maxDstExtent"];
[&](){
            auto& temp=maxDstExtent_json.as_object();
            deserialize_struct(temp,member.maxDstExtent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDisplaySurfaceCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& displayMode_json=json["displayMode"];
[&](){serialize_VkDisplayModeKHR(displayMode_json,member.displayMode);}();
auto& planeIndex_json=json["planeIndex"];
[&](){planeIndex_json=member.planeIndex;}();
auto& planeStackIndex_json=json["planeStackIndex"];
[&](){planeStackIndex_json=member.planeStackIndex;}();
auto& transform_json=json["transform"];
[&](){[&](){[&](){transform_json=member.transform;}();}();}();
auto& globalAlpha_json=json["globalAlpha"];
[&](){globalAlpha_json=member.globalAlpha;}();
auto& alphaMode_json=json["alphaMode"];
[&](){[&](){[&](){alphaMode_json=member.alphaMode;}();}();}();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.emplace_object();
            return serialize_struct(temp, member.imageExtent);
            }();
}
void deserialize_struct(boost::json::object& json, VkDisplaySurfaceCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_KrORNUx;[&](){temp_KrORNUx=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDisplaySurfaceCreateFlagsKHR)temp_KrORNUx;}();}();
auto& displayMode_json=json["displayMode"];
[&](){deserialize_VkDisplayModeKHR(displayMode_json, member.displayMode);}();
auto& planeIndex_json=json["planeIndex"];
[&](){member.planeIndex=static_cast<uint32_t>(value_to<int>(planeIndex_json));}();
auto& planeStackIndex_json=json["planeStackIndex"];
[&](){member.planeStackIndex=static_cast<uint32_t>(value_to<int>(planeStackIndex_json));}();
auto& transform_json=json["transform"];
[&](){[&](){int temp_docqSjH;[&](){temp_docqSjH=static_cast<int>(value_to<int>(transform_json));}();member.transform=(VkSurfaceTransformFlagBitsKHR)temp_docqSjH;}();}();
auto& globalAlpha_json=json["globalAlpha"];
[&](){member.globalAlpha=static_cast<float>(value_to<int>(globalAlpha_json));}();
auto& alphaMode_json=json["alphaMode"];
[&](){[&](){int temp_JIjldeI;[&](){temp_JIjldeI=static_cast<int>(value_to<int>(alphaMode_json));}();member.alphaMode=(VkDisplayPlaneAlphaFlagBitsKHR)temp_JIjldeI;}();}();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.as_object();
            deserialize_struct(temp,member.imageExtent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDisplayPresentInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcRect_json=json["srcRect"];
[&](){
            auto& temp=srcRect_json.emplace_object();
            return serialize_struct(temp, member.srcRect);
            }();
auto& dstRect_json=json["dstRect"];
[&](){
            auto& temp=dstRect_json.emplace_object();
            return serialize_struct(temp, member.dstRect);
            }();
auto& persistent_json=json["persistent"];
[&](){[&](){persistent_json=member.persistent;}();}();
}
void deserialize_struct(boost::json::object& json, VkDisplayPresentInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcRect_json=json["srcRect"];
[&](){
            auto& temp=srcRect_json.as_object();
            deserialize_struct(temp,member.srcRect);
            }();
auto& dstRect_json=json["dstRect"];
[&](){
            auto& temp=dstRect_json.as_object();
            deserialize_struct(temp,member.dstRect);
            }();
auto& persistent_json=json["persistent"];
[&](){uint32_t temp_NEBQDWU;[&](){temp_NEBQDWU=static_cast<uint32_t>(value_to<int>(persistent_json));}();member.persistent=(VkBool32)temp_NEBQDWU;}();
}

    void serialize_struct(boost::json::object& json, const VkSurfaceCapabilitiesKHR& member){
        
    
auto& minImageCount_json=json["minImageCount"];
[&](){minImageCount_json=member.minImageCount;}();
auto& maxImageCount_json=json["maxImageCount"];
[&](){maxImageCount_json=member.maxImageCount;}();
auto& currentExtent_json=json["currentExtent"];
[&](){
            auto& temp=currentExtent_json.emplace_object();
            return serialize_struct(temp, member.currentExtent);
            }();
auto& minImageExtent_json=json["minImageExtent"];
[&](){
            auto& temp=minImageExtent_json.emplace_object();
            return serialize_struct(temp, member.minImageExtent);
            }();
auto& maxImageExtent_json=json["maxImageExtent"];
[&](){
            auto& temp=maxImageExtent_json.emplace_object();
            return serialize_struct(temp, member.maxImageExtent);
            }();
auto& maxImageArrayLayers_json=json["maxImageArrayLayers"];
[&](){maxImageArrayLayers_json=member.maxImageArrayLayers;}();
auto& supportedTransforms_json=json["supportedTransforms"];
[&](){[&](){[&](){supportedTransforms_json=member.supportedTransforms;}();}();}();
auto& currentTransform_json=json["currentTransform"];
[&](){[&](){[&](){currentTransform_json=member.currentTransform;}();}();}();
auto& supportedCompositeAlpha_json=json["supportedCompositeAlpha"];
[&](){[&](){[&](){supportedCompositeAlpha_json=member.supportedCompositeAlpha;}();}();}();
auto& supportedUsageFlags_json=json["supportedUsageFlags"];
[&](){[&](){[&](){supportedUsageFlags_json=member.supportedUsageFlags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSurfaceCapabilitiesKHR& member){
auto& minImageCount_json=json["minImageCount"];
[&](){member.minImageCount=static_cast<uint32_t>(value_to<int>(minImageCount_json));}();
auto& maxImageCount_json=json["maxImageCount"];
[&](){member.maxImageCount=static_cast<uint32_t>(value_to<int>(maxImageCount_json));}();
auto& currentExtent_json=json["currentExtent"];
[&](){
            auto& temp=currentExtent_json.as_object();
            deserialize_struct(temp,member.currentExtent);
            }();
auto& minImageExtent_json=json["minImageExtent"];
[&](){
            auto& temp=minImageExtent_json.as_object();
            deserialize_struct(temp,member.minImageExtent);
            }();
auto& maxImageExtent_json=json["maxImageExtent"];
[&](){
            auto& temp=maxImageExtent_json.as_object();
            deserialize_struct(temp,member.maxImageExtent);
            }();
auto& maxImageArrayLayers_json=json["maxImageArrayLayers"];
[&](){member.maxImageArrayLayers=static_cast<uint32_t>(value_to<int>(maxImageArrayLayers_json));}();
auto& supportedTransforms_json=json["supportedTransforms"];
[&](){[&](){int temp_lOAidao;[&](){temp_lOAidao=static_cast<int>(value_to<int>(supportedTransforms_json));}();member.supportedTransforms=(VkSurfaceTransformFlagsKHR)temp_lOAidao;}();}();
auto& currentTransform_json=json["currentTransform"];
[&](){[&](){int temp_qlBkHeK;[&](){temp_qlBkHeK=static_cast<int>(value_to<int>(currentTransform_json));}();member.currentTransform=(VkSurfaceTransformFlagBitsKHR)temp_qlBkHeK;}();}();
auto& supportedCompositeAlpha_json=json["supportedCompositeAlpha"];
[&](){[&](){int temp_kYiNncV;[&](){temp_kYiNncV=static_cast<int>(value_to<int>(supportedCompositeAlpha_json));}();member.supportedCompositeAlpha=(VkCompositeAlphaFlagsKHR)temp_kYiNncV;}();}();
auto& supportedUsageFlags_json=json["supportedUsageFlags"];
[&](){[&](){int temp_FWyNJlL;[&](){temp_FWyNJlL=static_cast<int>(value_to<int>(supportedUsageFlags_json));}();member.supportedUsageFlags=(VkImageUsageFlags)temp_FWyNJlL;}();}();
}

    void serialize_struct(boost::json::object& json, const VkXlibSurfaceCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& dpy_json=json["dpy"];
[&](){
            if (member.dpy==NULL){
                dpy_json=boost::json::array();
            return; }dpy_json=(uintptr_t)member.dpy;}();
auto& window_json=json["window"];
[&](){window_json=(uintptr_t)member.window;}();
}
void deserialize_struct(boost::json::object& json, VkXlibSurfaceCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_GYQhMnC;[&](){temp_GYQhMnC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkXlibSurfaceCreateFlagsKHR)temp_GYQhMnC;}();}();
auto& dpy_json=json["dpy"];
[&](){
            if (dpy_json.as_array().size()==0){
                member.dpy=NULL;
            return; }member.dpy=(Display* )(value_to<uintptr_t>(dpy_json));}();
auto& window_json=json["window"];
[&](){member.window=(Window )(value_to<uintptr_t>(window_json));}();
}

    void serialize_struct(boost::json::object& json, const VkXcbSurfaceCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& connection_json=json["connection"];
[&](){
            if (member.connection==NULL){
                connection_json=boost::json::array();
            return; }connection_json=(uintptr_t)member.connection;}();
auto& window_json=json["window"];
[&](){window_json=(uintptr_t)member.window;}();
}
void deserialize_struct(boost::json::object& json, VkXcbSurfaceCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_JiXRIbI;[&](){temp_JiXRIbI=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkXcbSurfaceCreateFlagsKHR)temp_JiXRIbI;}();}();
auto& connection_json=json["connection"];
[&](){
            if (connection_json.as_array().size()==0){
                member.connection=NULL;
            return; }member.connection=(xcb_connection_t* )(value_to<uintptr_t>(connection_json));}();
auto& window_json=json["window"];
[&](){member.window=(xcb_window_t )(value_to<uintptr_t>(window_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSurfaceFormatKHR& member){
        
    
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& colorSpace_json=json["colorSpace"];
[&](){[&](){[&](){colorSpace_json=member.colorSpace;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSurfaceFormatKHR& member){
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& colorSpace_json=json["colorSpace"];
[&](){[&](){int temp_ROaWBIG;[&](){temp_ROaWBIG=static_cast<int>(value_to<int>(colorSpace_json));}();member.colorSpace=(VkColorSpaceKHR)temp_ROaWBIG;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSwapchainCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& surface_json=json["surface"];
[&](){serialize_VkSurfaceKHR(surface_json,member.surface);}();
auto& minImageCount_json=json["minImageCount"];
[&](){minImageCount_json=member.minImageCount;}();
auto& imageFormat_json=json["imageFormat"];
[&](){[&](){[&](){imageFormat_json=member.imageFormat;}();}();}();
auto& imageColorSpace_json=json["imageColorSpace"];
[&](){[&](){[&](){imageColorSpace_json=member.imageColorSpace;}();}();}();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.emplace_object();
            return serialize_struct(temp, member.imageExtent);
            }();
auto& imageArrayLayers_json=json["imageArrayLayers"];
[&](){imageArrayLayers_json=member.imageArrayLayers;}();
auto& imageUsage_json=json["imageUsage"];
[&](){[&](){[&](){imageUsage_json=member.imageUsage;}();}();}();
auto& imageSharingMode_json=json["imageSharingMode"];
[&](){[&](){[&](){imageSharingMode_json=member.imageSharingMode;}();}();}();
auto& queueFamilyIndexCount_json=json["queueFamilyIndexCount"];
[&](){queueFamilyIndexCount_json=member.queueFamilyIndexCount;}();
auto& pQueueFamilyIndices_json=json["pQueueFamilyIndices"];
[&](){
            if (member.pQueueFamilyIndices==NULL){
                pQueueFamilyIndices_json=boost::json::array();
            return; }pQueueFamilyIndices_json=boost::json::array(member.queueFamilyIndexCount);
        auto& arr_miZGtyX=pQueueFamilyIndices_json.as_array();
        for(int VJZTqbB=0; VJZTqbB < member.queueFamilyIndexCount; VJZTqbB++){
            [&](){arr_miZGtyX[VJZTqbB]=member.pQueueFamilyIndices[VJZTqbB];}();
        }
        }();
auto& preTransform_json=json["preTransform"];
[&](){[&](){[&](){preTransform_json=member.preTransform;}();}();}();
auto& compositeAlpha_json=json["compositeAlpha"];
[&](){[&](){[&](){compositeAlpha_json=member.compositeAlpha;}();}();}();
auto& presentMode_json=json["presentMode"];
[&](){[&](){[&](){presentMode_json=member.presentMode;}();}();}();
auto& clipped_json=json["clipped"];
[&](){[&](){clipped_json=member.clipped;}();}();
auto& oldSwapchain_json=json["oldSwapchain"];
[&](){serialize_VkSwapchainKHR(oldSwapchain_json,member.oldSwapchain);}();
}
void deserialize_struct(boost::json::object& json, VkSwapchainCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_VLDeCRD;[&](){temp_VLDeCRD=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSwapchainCreateFlagsKHR)temp_VLDeCRD;}();}();
auto& surface_json=json["surface"];
[&](){deserialize_VkSurfaceKHR(surface_json, member.surface);}();
auto& minImageCount_json=json["minImageCount"];
[&](){member.minImageCount=static_cast<uint32_t>(value_to<int>(minImageCount_json));}();
auto& imageFormat_json=json["imageFormat"];
[&](){[&](){int temp_BOhPhdB;[&](){temp_BOhPhdB=static_cast<int>(value_to<int>(imageFormat_json));}();member.imageFormat=(VkFormat)temp_BOhPhdB;}();}();
auto& imageColorSpace_json=json["imageColorSpace"];
[&](){[&](){int temp_BROIXdp;[&](){temp_BROIXdp=static_cast<int>(value_to<int>(imageColorSpace_json));}();member.imageColorSpace=(VkColorSpaceKHR)temp_BROIXdp;}();}();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.as_object();
            deserialize_struct(temp,member.imageExtent);
            }();
auto& imageArrayLayers_json=json["imageArrayLayers"];
[&](){member.imageArrayLayers=static_cast<uint32_t>(value_to<int>(imageArrayLayers_json));}();
auto& imageUsage_json=json["imageUsage"];
[&](){[&](){int temp_UnfmVYD;[&](){temp_UnfmVYD=static_cast<int>(value_to<int>(imageUsage_json));}();member.imageUsage=(VkImageUsageFlags)temp_UnfmVYD;}();}();
auto& imageSharingMode_json=json["imageSharingMode"];
[&](){[&](){int temp_mPbHxmW;[&](){temp_mPbHxmW=static_cast<int>(value_to<int>(imageSharingMode_json));}();member.imageSharingMode=(VkSharingMode)temp_mPbHxmW;}();}();
auto& queueFamilyIndexCount_json=json["queueFamilyIndexCount"];
[&](){member.queueFamilyIndexCount=static_cast<uint32_t>(value_to<int>(queueFamilyIndexCount_json));}();
auto& pQueueFamilyIndices_json=json["pQueueFamilyIndices"];
[&](){ uint32_t* temp_RQIKvOJ;;[&](){
            if (pQueueFamilyIndices_json.as_array().size()==0){
                temp_RQIKvOJ=NULL;
            return; }temp_RQIKvOJ=(uint32_t*)malloc(member.queueFamilyIndexCount*sizeof(uint32_t));
        auto& arr_PLMLiyU=pQueueFamilyIndices_json.as_array();
        for(int CXBfdQH=0; CXBfdQH < member.queueFamilyIndexCount; CXBfdQH++){
            [&](){temp_RQIKvOJ[CXBfdQH]=static_cast<uint32_t>(value_to<int>(arr_PLMLiyU[CXBfdQH]));}();
        }
        }();member.pQueueFamilyIndices=temp_RQIKvOJ;}();
auto& preTransform_json=json["preTransform"];
[&](){[&](){int temp_NoybulF;[&](){temp_NoybulF=static_cast<int>(value_to<int>(preTransform_json));}();member.preTransform=(VkSurfaceTransformFlagBitsKHR)temp_NoybulF;}();}();
auto& compositeAlpha_json=json["compositeAlpha"];
[&](){[&](){int temp_MnYeotv;[&](){temp_MnYeotv=static_cast<int>(value_to<int>(compositeAlpha_json));}();member.compositeAlpha=(VkCompositeAlphaFlagBitsKHR)temp_MnYeotv;}();}();
auto& presentMode_json=json["presentMode"];
[&](){[&](){int temp_iaJAWxo;[&](){temp_iaJAWxo=static_cast<int>(value_to<int>(presentMode_json));}();member.presentMode=(VkPresentModeKHR)temp_iaJAWxo;}();}();
auto& clipped_json=json["clipped"];
[&](){uint32_t temp_KopwZcA;[&](){temp_KopwZcA=static_cast<uint32_t>(value_to<int>(clipped_json));}();member.clipped=(VkBool32)temp_KopwZcA;}();
auto& oldSwapchain_json=json["oldSwapchain"];
[&](){deserialize_VkSwapchainKHR(oldSwapchain_json, member.oldSwapchain);}();
}

    void serialize_struct(boost::json::object& json, const VkPresentInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& waitSemaphoreCount_json=json["waitSemaphoreCount"];
[&](){waitSemaphoreCount_json=member.waitSemaphoreCount;}();
auto& pWaitSemaphores_json=json["pWaitSemaphores"];
[&](){
            if (member.pWaitSemaphores==NULL){
                pWaitSemaphores_json=boost::json::array();
            return; }pWaitSemaphores_json=boost::json::array(member.waitSemaphoreCount);
        auto& arr_AxVizBE=pWaitSemaphores_json.as_array();
        for(int XBpvDer=0; XBpvDer < member.waitSemaphoreCount; XBpvDer++){
            [&](){serialize_VkSemaphore(arr_AxVizBE[XBpvDer],member.pWaitSemaphores[XBpvDer]);}();
        }
        }();
auto& swapchainCount_json=json["swapchainCount"];
[&](){swapchainCount_json=member.swapchainCount;}();
auto& pSwapchains_json=json["pSwapchains"];
[&](){
            if (member.pSwapchains==NULL){
                pSwapchains_json=boost::json::array();
            return; }pSwapchains_json=boost::json::array(member.swapchainCount);
        auto& arr_rmsPqbh=pSwapchains_json.as_array();
        for(int BUaLlYr=0; BUaLlYr < member.swapchainCount; BUaLlYr++){
            [&](){serialize_VkSwapchainKHR(arr_rmsPqbh[BUaLlYr],member.pSwapchains[BUaLlYr]);}();
        }
        }();
auto& pImageIndices_json=json["pImageIndices"];
[&](){
            if (member.pImageIndices==NULL){
                pImageIndices_json=boost::json::array();
            return; }pImageIndices_json=boost::json::array(member.swapchainCount);
        auto& arr_fmPZCwp=pImageIndices_json.as_array();
        for(int lfPeqDF=0; lfPeqDF < member.swapchainCount; lfPeqDF++){
            [&](){arr_fmPZCwp[lfPeqDF]=member.pImageIndices[lfPeqDF];}();
        }
        }();
auto& pResults_json=json["pResults"];
[&](){
            if (member.pResults==NULL){
                pResults_json=boost::json::array();
            return; }pResults_json=boost::json::array(member.swapchainCount);
        auto& arr_CaahsAP=pResults_json.as_array();
        for(int nYCZlMn=0; nYCZlMn < member.swapchainCount; nYCZlMn++){
            [&](){[&](){[&](){arr_CaahsAP[nYCZlMn]=member.pResults[nYCZlMn];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPresentInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& waitSemaphoreCount_json=json["waitSemaphoreCount"];
[&](){member.waitSemaphoreCount=static_cast<uint32_t>(value_to<int>(waitSemaphoreCount_json));}();
auto& pWaitSemaphores_json=json["pWaitSemaphores"];
[&](){ VkSemaphore* temp_ZOgWazs;;[&](){
            if (pWaitSemaphores_json.as_array().size()==0){
                temp_ZOgWazs=NULL;
            return; }temp_ZOgWazs=(VkSemaphore*)malloc(member.waitSemaphoreCount*sizeof(VkSemaphore));
        auto& arr_EtUHlJM=pWaitSemaphores_json.as_array();
        for(int JgknMrE=0; JgknMrE < member.waitSemaphoreCount; JgknMrE++){
            [&](){deserialize_VkSemaphore(arr_EtUHlJM[JgknMrE], temp_ZOgWazs[JgknMrE]);}();
        }
        }();member.pWaitSemaphores=temp_ZOgWazs;}();
auto& swapchainCount_json=json["swapchainCount"];
[&](){member.swapchainCount=static_cast<uint32_t>(value_to<int>(swapchainCount_json));}();
auto& pSwapchains_json=json["pSwapchains"];
[&](){ VkSwapchainKHR* temp_gqRHNDC;;[&](){
            if (pSwapchains_json.as_array().size()==0){
                temp_gqRHNDC=NULL;
            return; }temp_gqRHNDC=(VkSwapchainKHR*)malloc(member.swapchainCount*sizeof(VkSwapchainKHR));
        auto& arr_AKebdOe=pSwapchains_json.as_array();
        for(int wNljORb=0; wNljORb < member.swapchainCount; wNljORb++){
            [&](){deserialize_VkSwapchainKHR(arr_AKebdOe[wNljORb], temp_gqRHNDC[wNljORb]);}();
        }
        }();member.pSwapchains=temp_gqRHNDC;}();
auto& pImageIndices_json=json["pImageIndices"];
[&](){ uint32_t* temp_RwCNvtD;;[&](){
            if (pImageIndices_json.as_array().size()==0){
                temp_RwCNvtD=NULL;
            return; }temp_RwCNvtD=(uint32_t*)malloc(member.swapchainCount*sizeof(uint32_t));
        auto& arr_wIgefjv=pImageIndices_json.as_array();
        for(int MuunZXi=0; MuunZXi < member.swapchainCount; MuunZXi++){
            [&](){temp_RwCNvtD[MuunZXi]=static_cast<uint32_t>(value_to<int>(arr_wIgefjv[MuunZXi]));}();
        }
        }();member.pImageIndices=temp_RwCNvtD;}();
auto& pResults_json=json["pResults"];
[&](){
            if (pResults_json.as_array().size()==0){
                member.pResults=NULL;
            return; }member.pResults=(VkResult*)malloc(member.swapchainCount*sizeof(VkResult));
        auto& arr_CaahsAP=pResults_json.as_array();
        for(int nYCZlMn=0; nYCZlMn < member.swapchainCount; nYCZlMn++){
            [&](){[&](){int temp_dsNlDmr;[&](){temp_dsNlDmr=static_cast<int>(value_to<int>(arr_CaahsAP[nYCZlMn]));}();member.pResults[nYCZlMn]=(VkResult)temp_dsNlDmr;}();}();
        }
        }();
}

        void serialize_pUserData(boost::json::object& json, const VkDebugReportCallbackCreateInfoEXT& member){
        auto& pUserData_json=json["pUserData"];
        
[&](){
            if (member.pUserData==NULL){
                pUserData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pUserData))==NULL){
                pUserData_json=boost::json::array();
            return; }pUserData_json=boost::json::array(strlen(((char*)(member.pUserData)))+1);
        auto& arr_svgqjpy=pUserData_json.as_array();
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData)))+1; lQswvtW++){
            [&](){arr_svgqjpy[lQswvtW]=((char*)(member.pUserData))[lQswvtW];}();
        }
        }();}();
json["PFN_vkDebugReportCallbackEXT"]=(uintptr_t)(member.pfnCallback);
}

        void deserialize_pUserData(boost::json::object& json, VkDebugReportCallbackCreateInfoEXT& member){
            #ifdef CLIENT
               void* pUserData;
               [&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData=temp_YghEUhF;}();
            #else 
                auto pUserData=new pUserData_struct();
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData->pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData->pUserData=temp_YghEUhF;}();
pUserData->PFN_vkDebugReportCallbackEXT=(value_to<uintptr_t>(json["PFN_vkDebugReportCallbackEXT"]));

        #endif
        member.pUserData=pUserData;
        }
        

    void serialize_struct(boost::json::object& json, const VkDebugReportCallbackCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pfnCallback_json=json["pfnCallback"];
[&](){
            auto& temp=pfnCallback_json.emplace_object();
            return serialize_PFN_vkDebugReportCallbackEXT(temp, member.pfnCallback);
            }();
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.emplace_object();
            serialize_pUserData(pUserData_json_1, member);
            
}
void deserialize_struct(boost::json::object& json, VkDebugReportCallbackCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_wweSklr;[&](){temp_wweSklr=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDebugReportFlagsEXT)temp_wweSklr;}();}();
auto& pfnCallback_json=json["pfnCallback"];
[&](){
            auto& temp=pfnCallback_json.as_object();
            deserialize_PFN_vkDebugReportCallbackEXT(temp,member.pfnCallback);
            }();
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.as_object();
            deserialize_pUserData(pUserData_json_1, member);
            
}

    void serialize_struct(boost::json::object& json, const VkValidationFlagsEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& disabledValidationCheckCount_json=json["disabledValidationCheckCount"];
[&](){disabledValidationCheckCount_json=member.disabledValidationCheckCount;}();
auto& pDisabledValidationChecks_json=json["pDisabledValidationChecks"];
[&](){
            if (member.pDisabledValidationChecks==NULL){
                pDisabledValidationChecks_json=boost::json::array();
            return; }pDisabledValidationChecks_json=boost::json::array(member.disabledValidationCheckCount);
        auto& arr_gHxKdJg=pDisabledValidationChecks_json.as_array();
        for(int bduqxYp=0; bduqxYp < member.disabledValidationCheckCount; bduqxYp++){
            [&](){[&](){[&](){arr_gHxKdJg[bduqxYp]=member.pDisabledValidationChecks[bduqxYp];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkValidationFlagsEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& disabledValidationCheckCount_json=json["disabledValidationCheckCount"];
[&](){member.disabledValidationCheckCount=static_cast<uint32_t>(value_to<int>(disabledValidationCheckCount_json));}();
auto& pDisabledValidationChecks_json=json["pDisabledValidationChecks"];
[&](){ VkValidationCheckEXT* temp_ABbHUXw;;[&](){
            if (pDisabledValidationChecks_json.as_array().size()==0){
                temp_ABbHUXw=NULL;
            return; }temp_ABbHUXw=(VkValidationCheckEXT*)malloc(member.disabledValidationCheckCount*sizeof(VkValidationCheckEXT));
        auto& arr_DMMcepp=pDisabledValidationChecks_json.as_array();
        for(int VzteYsQ=0; VzteYsQ < member.disabledValidationCheckCount; VzteYsQ++){
            [&](){[&](){int temp_Bplkwft;[&](){temp_Bplkwft=static_cast<int>(value_to<int>(arr_DMMcepp[VzteYsQ]));}();temp_ABbHUXw[VzteYsQ]=(VkValidationCheckEXT)temp_Bplkwft;}();}();
        }
        }();member.pDisabledValidationChecks=temp_ABbHUXw;}();
}

    void serialize_struct(boost::json::object& json, const VkValidationFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& enabledValidationFeatureCount_json=json["enabledValidationFeatureCount"];
[&](){enabledValidationFeatureCount_json=member.enabledValidationFeatureCount;}();
auto& pEnabledValidationFeatures_json=json["pEnabledValidationFeatures"];
[&](){
            if (member.pEnabledValidationFeatures==NULL){
                pEnabledValidationFeatures_json=boost::json::array();
            return; }pEnabledValidationFeatures_json=boost::json::array(member.enabledValidationFeatureCount);
        auto& arr_yicbfVL=pEnabledValidationFeatures_json.as_array();
        for(int CXiLeqh=0; CXiLeqh < member.enabledValidationFeatureCount; CXiLeqh++){
            [&](){[&](){[&](){arr_yicbfVL[CXiLeqh]=member.pEnabledValidationFeatures[CXiLeqh];}();}();}();
        }
        }();
auto& disabledValidationFeatureCount_json=json["disabledValidationFeatureCount"];
[&](){disabledValidationFeatureCount_json=member.disabledValidationFeatureCount;}();
auto& pDisabledValidationFeatures_json=json["pDisabledValidationFeatures"];
[&](){
            if (member.pDisabledValidationFeatures==NULL){
                pDisabledValidationFeatures_json=boost::json::array();
            return; }pDisabledValidationFeatures_json=boost::json::array(member.disabledValidationFeatureCount);
        auto& arr_MvjaOlv=pDisabledValidationFeatures_json.as_array();
        for(int JQPktzh=0; JQPktzh < member.disabledValidationFeatureCount; JQPktzh++){
            [&](){[&](){[&](){arr_MvjaOlv[JQPktzh]=member.pDisabledValidationFeatures[JQPktzh];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkValidationFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& enabledValidationFeatureCount_json=json["enabledValidationFeatureCount"];
[&](){member.enabledValidationFeatureCount=static_cast<uint32_t>(value_to<int>(enabledValidationFeatureCount_json));}();
auto& pEnabledValidationFeatures_json=json["pEnabledValidationFeatures"];
[&](){ VkValidationFeatureEnableEXT* temp_eHCzPMS;;[&](){
            if (pEnabledValidationFeatures_json.as_array().size()==0){
                temp_eHCzPMS=NULL;
            return; }temp_eHCzPMS=(VkValidationFeatureEnableEXT*)malloc(member.enabledValidationFeatureCount*sizeof(VkValidationFeatureEnableEXT));
        auto& arr_SWlNWeF=pEnabledValidationFeatures_json.as_array();
        for(int FrGTKnl=0; FrGTKnl < member.enabledValidationFeatureCount; FrGTKnl++){
            [&](){[&](){int temp_wFWqTxu;[&](){temp_wFWqTxu=static_cast<int>(value_to<int>(arr_SWlNWeF[FrGTKnl]));}();temp_eHCzPMS[FrGTKnl]=(VkValidationFeatureEnableEXT)temp_wFWqTxu;}();}();
        }
        }();member.pEnabledValidationFeatures=temp_eHCzPMS;}();
auto& disabledValidationFeatureCount_json=json["disabledValidationFeatureCount"];
[&](){member.disabledValidationFeatureCount=static_cast<uint32_t>(value_to<int>(disabledValidationFeatureCount_json));}();
auto& pDisabledValidationFeatures_json=json["pDisabledValidationFeatures"];
[&](){ VkValidationFeatureDisableEXT* temp_ecqJARs;;[&](){
            if (pDisabledValidationFeatures_json.as_array().size()==0){
                temp_ecqJARs=NULL;
            return; }temp_ecqJARs=(VkValidationFeatureDisableEXT*)malloc(member.disabledValidationFeatureCount*sizeof(VkValidationFeatureDisableEXT));
        auto& arr_vZkCQLJ=pDisabledValidationFeatures_json.as_array();
        for(int QrVhslB=0; QrVhslB < member.disabledValidationFeatureCount; QrVhslB++){
            [&](){[&](){int temp_bDHOhkh;[&](){temp_bDHOhkh=static_cast<int>(value_to<int>(arr_vZkCQLJ[QrVhslB]));}();temp_ecqJARs[QrVhslB]=(VkValidationFeatureDisableEXT)temp_bDHOhkh;}();}();
        }
        }();member.pDisabledValidationFeatures=temp_ecqJARs;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRasterizationStateRasterizationOrderAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rasterizationOrder_json=json["rasterizationOrder"];
[&](){[&](){[&](){rasterizationOrder_json=member.rasterizationOrder;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRasterizationStateRasterizationOrderAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& rasterizationOrder_json=json["rasterizationOrder"];
[&](){[&](){int temp_JVQipKQ;[&](){temp_JVQipKQ=static_cast<int>(value_to<int>(rasterizationOrder_json));}();member.rasterizationOrder=(VkRasterizationOrderAMD)temp_JVQipKQ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDebugMarkerObjectNameInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& objectType_json=json["objectType"];
[&](){[&](){[&](){objectType_json=member.objectType;}();}();}();
auto& object_json=json["object"];
[&](){object_json=member.object;}();
auto& pObjectName_json=json["pObjectName"];
[&](){
            if (member.pObjectName==NULL){
                pObjectName_json=boost::json::array();
            return; }pObjectName_json=boost::json::array(strlen(member.pObjectName)+1);
        auto& arr_iVlKnsS=pObjectName_json.as_array();
        for(int ScjeCfd=0; ScjeCfd < strlen(member.pObjectName)+1; ScjeCfd++){
            [&](){arr_iVlKnsS[ScjeCfd]=member.pObjectName[ScjeCfd];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDebugMarkerObjectNameInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& objectType_json=json["objectType"];
[&](){[&](){int temp_txqySLu;[&](){temp_txqySLu=static_cast<int>(value_to<int>(objectType_json));}();member.objectType=(VkDebugReportObjectTypeEXT)temp_txqySLu;}();}();
auto& object_json=json["object"];
[&](){member.object=static_cast<uint64_t>(value_to<int>(object_json));}();
auto& pObjectName_json=json["pObjectName"];
[&](){ char* temp_QsnbdsB;;[&](){
            if (pObjectName_json.as_array().size()==0){
                temp_QsnbdsB=NULL;
            return; }temp_QsnbdsB=(char*)malloc(pObjectName_json.as_array().size()*sizeof(char));
        auto& arr_aGdfwIy=pObjectName_json.as_array();
        for(int VmCdhEn=0; VmCdhEn < pObjectName_json.as_array().size(); VmCdhEn++){
            [&](){temp_QsnbdsB[VmCdhEn]=static_cast<char>(value_to<int>(arr_aGdfwIy[VmCdhEn]));}();
        }
        }();member.pObjectName=temp_QsnbdsB;}();
}

    void serialize_struct(boost::json::object& json, const VkDebugMarkerObjectTagInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& objectType_json=json["objectType"];
[&](){[&](){[&](){objectType_json=member.objectType;}();}();}();
auto& object_json=json["object"];
[&](){object_json=member.object;}();
auto& tagName_json=json["tagName"];
[&](){tagName_json=member.tagName;}();
auto& tagSize_json=json["tagSize"];
[&](){tagSize_json=member.tagSize;}();
auto& pTag_json=json["pTag"];
[&](){
            if (member.pTag==NULL){
                pTag_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pTag))==NULL){
                pTag_json=boost::json::array();
            return; }pTag_json=boost::json::array(member.tagSize);
        auto& arr_FJzNXuD=pTag_json.as_array();
        for(int LCdjkoW=0; LCdjkoW < member.tagSize; LCdjkoW++){
            [&](){arr_FJzNXuD[LCdjkoW]=((char*)(member.pTag))[LCdjkoW];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkDebugMarkerObjectTagInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& objectType_json=json["objectType"];
[&](){[&](){int temp_txqySLu;[&](){temp_txqySLu=static_cast<int>(value_to<int>(objectType_json));}();member.objectType=(VkDebugReportObjectTypeEXT)temp_txqySLu;}();}();
auto& object_json=json["object"];
[&](){member.object=static_cast<uint64_t>(value_to<int>(object_json));}();
auto& tagName_json=json["tagName"];
[&](){member.tagName=static_cast<uint64_t>(value_to<int>(tagName_json));}();
auto& tagSize_json=json["tagSize"];
[&](){member.tagSize=static_cast<size_t>(value_to<int>(tagSize_json));}();
auto& pTag_json=json["pTag"];
[&](){ void* temp_lyAiwyk;;[&](){
            if (pTag_json.as_array().size()==0){
                temp_lyAiwyk=NULL;
            return; }char* temp_pWZkwTB;[&](){
            if (pTag_json.as_array().size()==0){
                temp_pWZkwTB=NULL;
            return; }temp_pWZkwTB=(char*)malloc(member.tagSize*sizeof(char));
        auto& arr_ewjwcVs=pTag_json.as_array();
        for(int uOzVzVX=0; uOzVzVX < member.tagSize; uOzVzVX++){
            [&](){temp_pWZkwTB[uOzVzVX]=static_cast<char>(value_to<int>(arr_ewjwcVs[uOzVzVX]));}();
        }
        }();temp_lyAiwyk=temp_pWZkwTB;}();member.pTag=temp_lyAiwyk;}();
}

    void serialize_struct(boost::json::object& json, const VkDebugMarkerMarkerInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pMarkerName_json=json["pMarkerName"];
[&](){
            if (member.pMarkerName==NULL){
                pMarkerName_json=boost::json::array();
            return; }pMarkerName_json=boost::json::array(strlen(member.pMarkerName)+1);
        auto& arr_pcGlkUX=pMarkerName_json.as_array();
        for(int LXIerUb=0; LXIerUb < strlen(member.pMarkerName)+1; LXIerUb++){
            [&](){arr_pcGlkUX[LXIerUb]=member.pMarkerName[LXIerUb];}();
        }
        }();
auto& color_json=json["color"];
[&](){color_json=boost::json::array(4);
        auto& arr_gJbxAWU=color_json.as_array();
        for(int oOlCIuz=0; oOlCIuz < 4; oOlCIuz++){
            [&](){arr_gJbxAWU[oOlCIuz]=member.color[oOlCIuz];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDebugMarkerMarkerInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pMarkerName_json=json["pMarkerName"];
[&](){ char* temp_fzugyvW;;[&](){
            if (pMarkerName_json.as_array().size()==0){
                temp_fzugyvW=NULL;
            return; }temp_fzugyvW=(char*)malloc(pMarkerName_json.as_array().size()*sizeof(char));
        auto& arr_EuPrESw=pMarkerName_json.as_array();
        for(int pBXQsbj=0; pBXQsbj < pMarkerName_json.as_array().size(); pBXQsbj++){
            [&](){temp_fzugyvW[pBXQsbj]=static_cast<char>(value_to<int>(arr_EuPrESw[pBXQsbj]));}();
        }
        }();member.pMarkerName=temp_fzugyvW;}();
auto& color_json=json["color"];
[&](){
        auto& arr_gJbxAWU=color_json.as_array();
        for(int oOlCIuz=0; oOlCIuz < 4; oOlCIuz++){
            [&](){member.color[oOlCIuz]=static_cast<float>(value_to<int>(arr_gJbxAWU[oOlCIuz]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkDedicatedAllocationImageCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dedicatedAllocation_json=json["dedicatedAllocation"];
[&](){[&](){dedicatedAllocation_json=member.dedicatedAllocation;}();}();
}
void deserialize_struct(boost::json::object& json, VkDedicatedAllocationImageCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& dedicatedAllocation_json=json["dedicatedAllocation"];
[&](){uint32_t temp_qjowhSf;[&](){temp_qjowhSf=static_cast<uint32_t>(value_to<int>(dedicatedAllocation_json));}();member.dedicatedAllocation=(VkBool32)temp_qjowhSf;}();
}

    void serialize_struct(boost::json::object& json, const VkDedicatedAllocationBufferCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dedicatedAllocation_json=json["dedicatedAllocation"];
[&](){[&](){dedicatedAllocation_json=member.dedicatedAllocation;}();}();
}
void deserialize_struct(boost::json::object& json, VkDedicatedAllocationBufferCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& dedicatedAllocation_json=json["dedicatedAllocation"];
[&](){uint32_t temp_qjowhSf;[&](){temp_qjowhSf=static_cast<uint32_t>(value_to<int>(dedicatedAllocation_json));}();member.dedicatedAllocation=(VkBool32)temp_qjowhSf;}();
}

    void serialize_struct(boost::json::object& json, const VkDedicatedAllocationMemoryAllocateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
}
void deserialize_struct(boost::json::object& json, VkDedicatedAllocationMemoryAllocateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
}

    void serialize_struct(boost::json::object& json, const VkExternalImageFormatPropertiesNV& member){
        
    
auto& imageFormatProperties_json=json["imageFormatProperties"];
[&](){
            auto& temp=imageFormatProperties_json.emplace_object();
            return serialize_struct(temp, member.imageFormatProperties);
            }();
auto& externalMemoryFeatures_json=json["externalMemoryFeatures"];
[&](){[&](){[&](){externalMemoryFeatures_json=member.externalMemoryFeatures;}();}();}();
auto& exportFromImportedHandleTypes_json=json["exportFromImportedHandleTypes"];
[&](){[&](){[&](){exportFromImportedHandleTypes_json=member.exportFromImportedHandleTypes;}();}();}();
auto& compatibleHandleTypes_json=json["compatibleHandleTypes"];
[&](){[&](){[&](){compatibleHandleTypes_json=member.compatibleHandleTypes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExternalImageFormatPropertiesNV& member){
auto& imageFormatProperties_json=json["imageFormatProperties"];
[&](){
            auto& temp=imageFormatProperties_json.as_object();
            deserialize_struct(temp,member.imageFormatProperties);
            }();
auto& externalMemoryFeatures_json=json["externalMemoryFeatures"];
[&](){[&](){int temp_LRdzzJT;[&](){temp_LRdzzJT=static_cast<int>(value_to<int>(externalMemoryFeatures_json));}();member.externalMemoryFeatures=(VkExternalMemoryFeatureFlagsNV)temp_LRdzzJT;}();}();
auto& exportFromImportedHandleTypes_json=json["exportFromImportedHandleTypes"];
[&](){[&](){int temp_ZcePxbI;[&](){temp_ZcePxbI=static_cast<int>(value_to<int>(exportFromImportedHandleTypes_json));}();member.exportFromImportedHandleTypes=(VkExternalMemoryHandleTypeFlagsNV)temp_ZcePxbI;}();}();
auto& compatibleHandleTypes_json=json["compatibleHandleTypes"];
[&](){[&](){int temp_PrAvEia;[&](){temp_PrAvEia=static_cast<int>(value_to<int>(compatibleHandleTypes_json));}();member.compatibleHandleTypes=(VkExternalMemoryHandleTypeFlagsNV)temp_PrAvEia;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExternalMemoryImageCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){[&](){handleTypes_json=member.handleTypes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExternalMemoryImageCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){int temp_aBrtWoV;[&](){temp_aBrtWoV=static_cast<int>(value_to<int>(handleTypes_json));}();member.handleTypes=(VkExternalMemoryHandleTypeFlagsNV)temp_aBrtWoV;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExportMemoryAllocateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){[&](){handleTypes_json=member.handleTypes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExportMemoryAllocateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){int temp_aBrtWoV;[&](){temp_aBrtWoV=static_cast<int>(value_to<int>(handleTypes_json));}();member.handleTypes=(VkExternalMemoryHandleTypeFlagsNV)temp_aBrtWoV;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceGeneratedCommands_json=json["deviceGeneratedCommands"];
[&](){[&](){deviceGeneratedCommands_json=member.deviceGeneratedCommands;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& deviceGeneratedCommands_json=json["deviceGeneratedCommands"];
[&](){uint32_t temp_fFgNZuP;[&](){temp_fFgNZuP=static_cast<uint32_t>(value_to<int>(deviceGeneratedCommands_json));}();member.deviceGeneratedCommands=(VkBool32)temp_fFgNZuP;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceGeneratedCompute_json=json["deviceGeneratedCompute"];
[&](){[&](){deviceGeneratedCompute_json=member.deviceGeneratedCompute;}();}();
auto& deviceGeneratedComputePipelines_json=json["deviceGeneratedComputePipelines"];
[&](){[&](){deviceGeneratedComputePipelines_json=member.deviceGeneratedComputePipelines;}();}();
auto& deviceGeneratedComputeCaptureReplay_json=json["deviceGeneratedComputeCaptureReplay"];
[&](){[&](){deviceGeneratedComputeCaptureReplay_json=member.deviceGeneratedComputeCaptureReplay;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& deviceGeneratedCompute_json=json["deviceGeneratedCompute"];
[&](){uint32_t temp_DqkaSOu;[&](){temp_DqkaSOu=static_cast<uint32_t>(value_to<int>(deviceGeneratedCompute_json));}();member.deviceGeneratedCompute=(VkBool32)temp_DqkaSOu;}();
auto& deviceGeneratedComputePipelines_json=json["deviceGeneratedComputePipelines"];
[&](){uint32_t temp_uLFutiG;[&](){temp_uLFutiG=static_cast<uint32_t>(value_to<int>(deviceGeneratedComputePipelines_json));}();member.deviceGeneratedComputePipelines=(VkBool32)temp_uLFutiG;}();
auto& deviceGeneratedComputeCaptureReplay_json=json["deviceGeneratedComputeCaptureReplay"];
[&](){uint32_t temp_efqYTSx;[&](){temp_efqYTSx=static_cast<uint32_t>(value_to<int>(deviceGeneratedComputeCaptureReplay_json));}();member.deviceGeneratedComputeCaptureReplay=(VkBool32)temp_efqYTSx;}();
}

    void serialize_struct(boost::json::object& json, const VkDevicePrivateDataCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& privateDataSlotRequestCount_json=json["privateDataSlotRequestCount"];
[&](){privateDataSlotRequestCount_json=member.privateDataSlotRequestCount;}();
}
void deserialize_struct(boost::json::object& json, VkDevicePrivateDataCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& privateDataSlotRequestCount_json=json["privateDataSlotRequestCount"];
[&](){member.privateDataSlotRequestCount=static_cast<uint32_t>(value_to<int>(privateDataSlotRequestCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPrivateDataSlotCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPrivateDataSlotCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_DjpFHFI;[&](){temp_DjpFHFI=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPrivateDataSlotCreateFlags)temp_DjpFHFI;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePrivateDataFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& privateData_json=json["privateData"];
[&](){[&](){privateData_json=member.privateData;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePrivateDataFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& privateData_json=json["privateData"];
[&](){uint32_t temp_dlWhRic;[&](){temp_dlWhRic=static_cast<uint32_t>(value_to<int>(privateData_json));}();member.privateData=(VkBool32)temp_dlWhRic;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxGraphicsShaderGroupCount_json=json["maxGraphicsShaderGroupCount"];
[&](){maxGraphicsShaderGroupCount_json=member.maxGraphicsShaderGroupCount;}();
auto& maxIndirectSequenceCount_json=json["maxIndirectSequenceCount"];
[&](){maxIndirectSequenceCount_json=member.maxIndirectSequenceCount;}();
auto& maxIndirectCommandsTokenCount_json=json["maxIndirectCommandsTokenCount"];
[&](){maxIndirectCommandsTokenCount_json=member.maxIndirectCommandsTokenCount;}();
auto& maxIndirectCommandsStreamCount_json=json["maxIndirectCommandsStreamCount"];
[&](){maxIndirectCommandsStreamCount_json=member.maxIndirectCommandsStreamCount;}();
auto& maxIndirectCommandsTokenOffset_json=json["maxIndirectCommandsTokenOffset"];
[&](){maxIndirectCommandsTokenOffset_json=member.maxIndirectCommandsTokenOffset;}();
auto& maxIndirectCommandsStreamStride_json=json["maxIndirectCommandsStreamStride"];
[&](){maxIndirectCommandsStreamStride_json=member.maxIndirectCommandsStreamStride;}();
auto& minSequencesCountBufferOffsetAlignment_json=json["minSequencesCountBufferOffsetAlignment"];
[&](){minSequencesCountBufferOffsetAlignment_json=member.minSequencesCountBufferOffsetAlignment;}();
auto& minSequencesIndexBufferOffsetAlignment_json=json["minSequencesIndexBufferOffsetAlignment"];
[&](){minSequencesIndexBufferOffsetAlignment_json=member.minSequencesIndexBufferOffsetAlignment;}();
auto& minIndirectCommandsBufferOffsetAlignment_json=json["minIndirectCommandsBufferOffsetAlignment"];
[&](){minIndirectCommandsBufferOffsetAlignment_json=member.minIndirectCommandsBufferOffsetAlignment;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxGraphicsShaderGroupCount_json=json["maxGraphicsShaderGroupCount"];
[&](){member.maxGraphicsShaderGroupCount=static_cast<uint32_t>(value_to<int>(maxGraphicsShaderGroupCount_json));}();
auto& maxIndirectSequenceCount_json=json["maxIndirectSequenceCount"];
[&](){member.maxIndirectSequenceCount=static_cast<uint32_t>(value_to<int>(maxIndirectSequenceCount_json));}();
auto& maxIndirectCommandsTokenCount_json=json["maxIndirectCommandsTokenCount"];
[&](){member.maxIndirectCommandsTokenCount=static_cast<uint32_t>(value_to<int>(maxIndirectCommandsTokenCount_json));}();
auto& maxIndirectCommandsStreamCount_json=json["maxIndirectCommandsStreamCount"];
[&](){member.maxIndirectCommandsStreamCount=static_cast<uint32_t>(value_to<int>(maxIndirectCommandsStreamCount_json));}();
auto& maxIndirectCommandsTokenOffset_json=json["maxIndirectCommandsTokenOffset"];
[&](){member.maxIndirectCommandsTokenOffset=static_cast<uint32_t>(value_to<int>(maxIndirectCommandsTokenOffset_json));}();
auto& maxIndirectCommandsStreamStride_json=json["maxIndirectCommandsStreamStride"];
[&](){member.maxIndirectCommandsStreamStride=static_cast<uint32_t>(value_to<int>(maxIndirectCommandsStreamStride_json));}();
auto& minSequencesCountBufferOffsetAlignment_json=json["minSequencesCountBufferOffsetAlignment"];
[&](){member.minSequencesCountBufferOffsetAlignment=static_cast<uint32_t>(value_to<int>(minSequencesCountBufferOffsetAlignment_json));}();
auto& minSequencesIndexBufferOffsetAlignment_json=json["minSequencesIndexBufferOffsetAlignment"];
[&](){member.minSequencesIndexBufferOffsetAlignment=static_cast<uint32_t>(value_to<int>(minSequencesIndexBufferOffsetAlignment_json));}();
auto& minIndirectCommandsBufferOffsetAlignment_json=json["minIndirectCommandsBufferOffsetAlignment"];
[&](){member.minIndirectCommandsBufferOffsetAlignment=static_cast<uint32_t>(value_to<int>(minIndirectCommandsBufferOffsetAlignment_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMultiDrawPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxMultiDrawCount_json=json["maxMultiDrawCount"];
[&](){maxMultiDrawCount_json=member.maxMultiDrawCount;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMultiDrawPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxMultiDrawCount_json=json["maxMultiDrawCount"];
[&](){member.maxMultiDrawCount=static_cast<uint32_t>(value_to<int>(maxMultiDrawCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkGraphicsShaderGroupCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stageCount_json=json["stageCount"];
[&](){stageCount_json=member.stageCount;}();
auto& pStages_json=json["pStages"];
[&](){
            if (member.pStages==NULL){
                pStages_json=boost::json::array();
            return; }pStages_json=boost::json::array(member.stageCount);
        auto& arr_wJXHhmh=pStages_json.as_array();
        for(int AsBfcSb=0; AsBfcSb < member.stageCount; AsBfcSb++){
            [&](){
            auto& temp=arr_wJXHhmh[AsBfcSb].emplace_object();
            return serialize_struct(temp, member.pStages[AsBfcSb]);
            }();
        }
        }();
auto& pVertexInputState_json=json["pVertexInputState"];
[&](){
            if (member.pVertexInputState==NULL){
                pVertexInputState_json=boost::json::array();
            return; }pVertexInputState_json=boost::json::array(1);
        auto& arr_HopKlOv=pVertexInputState_json.as_array();
        for(int tqmlCna=0; tqmlCna < 1; tqmlCna++){
            [&](){
            auto& temp=arr_HopKlOv[tqmlCna].emplace_object();
            return serialize_struct(temp, member.pVertexInputState[tqmlCna]);
            }();
        }
        }();
auto& pTessellationState_json=json["pTessellationState"];
[&](){
            if (member.pTessellationState==NULL){
                pTessellationState_json=boost::json::array();
            return; }pTessellationState_json=boost::json::array(1);
        auto& arr_tdhGlVI=pTessellationState_json.as_array();
        for(int IWxBQoq=0; IWxBQoq < 1; IWxBQoq++){
            [&](){
            auto& temp=arr_tdhGlVI[IWxBQoq].emplace_object();
            return serialize_struct(temp, member.pTessellationState[IWxBQoq]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkGraphicsShaderGroupCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& stageCount_json=json["stageCount"];
[&](){member.stageCount=static_cast<uint32_t>(value_to<int>(stageCount_json));}();
auto& pStages_json=json["pStages"];
[&](){ VkPipelineShaderStageCreateInfo* temp_FhIAThL;;[&](){
            if (pStages_json.as_array().size()==0){
                temp_FhIAThL=NULL;
            return; }temp_FhIAThL=(VkPipelineShaderStageCreateInfo*)malloc(member.stageCount*sizeof(VkPipelineShaderStageCreateInfo));
        auto& arr_qUPPcsa=pStages_json.as_array();
        for(int jQYmLXQ=0; jQYmLXQ < member.stageCount; jQYmLXQ++){
            [&](){
            auto& temp=arr_qUPPcsa[jQYmLXQ].as_object();
            deserialize_struct(temp,temp_FhIAThL[jQYmLXQ]);
            }();
        }
        }();member.pStages=temp_FhIAThL;}();
auto& pVertexInputState_json=json["pVertexInputState"];
[&](){ VkPipelineVertexInputStateCreateInfo* temp_EfJMJiL;;[&](){
            if (pVertexInputState_json.as_array().size()==0){
                temp_EfJMJiL=NULL;
            return; }temp_EfJMJiL=(VkPipelineVertexInputStateCreateInfo*)malloc(1*sizeof(VkPipelineVertexInputStateCreateInfo));
        auto& arr_FFMTeFz=pVertexInputState_json.as_array();
        for(int fwmkFXM=0; fwmkFXM < 1; fwmkFXM++){
            [&](){
            auto& temp=arr_FFMTeFz[fwmkFXM].as_object();
            deserialize_struct(temp,temp_EfJMJiL[fwmkFXM]);
            }();
        }
        }();member.pVertexInputState=temp_EfJMJiL;}();
auto& pTessellationState_json=json["pTessellationState"];
[&](){ VkPipelineTessellationStateCreateInfo* temp_KHiDBcs;;[&](){
            if (pTessellationState_json.as_array().size()==0){
                temp_KHiDBcs=NULL;
            return; }temp_KHiDBcs=(VkPipelineTessellationStateCreateInfo*)malloc(1*sizeof(VkPipelineTessellationStateCreateInfo));
        auto& arr_PctCEwc=pTessellationState_json.as_array();
        for(int MWEaHRn=0; MWEaHRn < 1; MWEaHRn++){
            [&](){
            auto& temp=arr_PctCEwc[MWEaHRn].as_object();
            deserialize_struct(temp,temp_KHiDBcs[MWEaHRn]);
            }();
        }
        }();member.pTessellationState=temp_KHiDBcs;}();
}

    void serialize_struct(boost::json::object& json, const VkGraphicsPipelineShaderGroupsCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& groupCount_json=json["groupCount"];
[&](){groupCount_json=member.groupCount;}();
auto& pGroups_json=json["pGroups"];
[&](){
            if (member.pGroups==NULL){
                pGroups_json=boost::json::array();
            return; }pGroups_json=boost::json::array(member.groupCount);
        auto& arr_xbmYEqu=pGroups_json.as_array();
        for(int DKdqHYk=0; DKdqHYk < member.groupCount; DKdqHYk++){
            [&](){
            auto& temp=arr_xbmYEqu[DKdqHYk].emplace_object();
            return serialize_struct(temp, member.pGroups[DKdqHYk]);
            }();
        }
        }();
auto& pipelineCount_json=json["pipelineCount"];
[&](){pipelineCount_json=member.pipelineCount;}();
auto& pPipelines_json=json["pPipelines"];
[&](){
            if (member.pPipelines==NULL){
                pPipelines_json=boost::json::array();
            return; }pPipelines_json=boost::json::array(member.pipelineCount);
        auto& arr_ykCmxiL=pPipelines_json.as_array();
        for(int HgcTYHx=0; HgcTYHx < member.pipelineCount; HgcTYHx++){
            [&](){serialize_VkPipeline(arr_ykCmxiL[HgcTYHx],member.pPipelines[HgcTYHx]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkGraphicsPipelineShaderGroupsCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& groupCount_json=json["groupCount"];
[&](){member.groupCount=static_cast<uint32_t>(value_to<int>(groupCount_json));}();
auto& pGroups_json=json["pGroups"];
[&](){ VkGraphicsShaderGroupCreateInfoNV* temp_TsORzMq;;[&](){
            if (pGroups_json.as_array().size()==0){
                temp_TsORzMq=NULL;
            return; }temp_TsORzMq=(VkGraphicsShaderGroupCreateInfoNV*)malloc(member.groupCount*sizeof(VkGraphicsShaderGroupCreateInfoNV));
        auto& arr_IDMxUlB=pGroups_json.as_array();
        for(int nNISfdu=0; nNISfdu < member.groupCount; nNISfdu++){
            [&](){
            auto& temp=arr_IDMxUlB[nNISfdu].as_object();
            deserialize_struct(temp,temp_TsORzMq[nNISfdu]);
            }();
        }
        }();member.pGroups=temp_TsORzMq;}();
auto& pipelineCount_json=json["pipelineCount"];
[&](){member.pipelineCount=static_cast<uint32_t>(value_to<int>(pipelineCount_json));}();
auto& pPipelines_json=json["pPipelines"];
[&](){ VkPipeline* temp_EUjhUCI;;[&](){
            if (pPipelines_json.as_array().size()==0){
                temp_EUjhUCI=NULL;
            return; }temp_EUjhUCI=(VkPipeline*)malloc(member.pipelineCount*sizeof(VkPipeline));
        auto& arr_NeLDYdZ=pPipelines_json.as_array();
        for(int vgTPlih=0; vgTPlih < member.pipelineCount; vgTPlih++){
            [&](){deserialize_VkPipeline(arr_NeLDYdZ[vgTPlih], temp_EUjhUCI[vgTPlih]);}();
        }
        }();member.pPipelines=temp_EUjhUCI;}();
}

    void serialize_struct(boost::json::object& json, const VkBindShaderGroupIndirectCommandNV& member){
        
    
auto& groupIndex_json=json["groupIndex"];
[&](){groupIndex_json=member.groupIndex;}();
}
void deserialize_struct(boost::json::object& json, VkBindShaderGroupIndirectCommandNV& member){
auto& groupIndex_json=json["groupIndex"];
[&](){member.groupIndex=static_cast<uint32_t>(value_to<int>(groupIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkBindIndexBufferIndirectCommandNV& member){
        
    
auto& bufferAddress_json=json["bufferAddress"];
[&](){[&](){bufferAddress_json=member.bufferAddress;}();}();
auto& size_json=json["size"];
[&](){size_json=member.size;}();
auto& indexType_json=json["indexType"];
[&](){[&](){[&](){indexType_json=member.indexType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkBindIndexBufferIndirectCommandNV& member){
auto& bufferAddress_json=json["bufferAddress"];
[&](){uint64_t temp_EihJeMj;[&](){temp_EihJeMj=static_cast<uint64_t>(value_to<int>(bufferAddress_json));}();member.bufferAddress=(VkDeviceAddress)temp_EihJeMj;}();
auto& size_json=json["size"];
[&](){member.size=static_cast<uint32_t>(value_to<int>(size_json));}();
auto& indexType_json=json["indexType"];
[&](){[&](){int temp_sCUtzFY;[&](){temp_sCUtzFY=static_cast<int>(value_to<int>(indexType_json));}();member.indexType=(VkIndexType)temp_sCUtzFY;}();}();
}

    void serialize_struct(boost::json::object& json, const VkBindVertexBufferIndirectCommandNV& member){
        
    
auto& bufferAddress_json=json["bufferAddress"];
[&](){[&](){bufferAddress_json=member.bufferAddress;}();}();
auto& size_json=json["size"];
[&](){size_json=member.size;}();
auto& stride_json=json["stride"];
[&](){stride_json=member.stride;}();
}
void deserialize_struct(boost::json::object& json, VkBindVertexBufferIndirectCommandNV& member){
auto& bufferAddress_json=json["bufferAddress"];
[&](){uint64_t temp_EihJeMj;[&](){temp_EihJeMj=static_cast<uint64_t>(value_to<int>(bufferAddress_json));}();member.bufferAddress=(VkDeviceAddress)temp_EihJeMj;}();
auto& size_json=json["size"];
[&](){member.size=static_cast<uint32_t>(value_to<int>(size_json));}();
auto& stride_json=json["stride"];
[&](){member.stride=static_cast<uint32_t>(value_to<int>(stride_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSetStateFlagsIndirectCommandNV& member){
        
    
auto& data_json=json["data"];
[&](){data_json=member.data;}();
}
void deserialize_struct(boost::json::object& json, VkSetStateFlagsIndirectCommandNV& member){
auto& data_json=json["data"];
[&](){member.data=static_cast<uint32_t>(value_to<int>(data_json));}();
}

    void serialize_struct(boost::json::object& json, const VkIndirectCommandsStreamNV& member){
        
    
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
}
void deserialize_struct(boost::json::object& json, VkIndirectCommandsStreamNV& member){
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
}

    void serialize_struct(boost::json::object& json, const VkIndirectCommandsLayoutTokenNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& tokenType_json=json["tokenType"];
[&](){[&](){[&](){tokenType_json=member.tokenType;}();}();}();
auto& stream_json=json["stream"];
[&](){stream_json=member.stream;}();
auto& offset_json=json["offset"];
[&](){offset_json=member.offset;}();
auto& vertexBindingUnit_json=json["vertexBindingUnit"];
[&](){vertexBindingUnit_json=member.vertexBindingUnit;}();
auto& vertexDynamicStride_json=json["vertexDynamicStride"];
[&](){[&](){vertexDynamicStride_json=member.vertexDynamicStride;}();}();
auto& pushconstantPipelineLayout_json=json["pushconstantPipelineLayout"];
[&](){serialize_VkPipelineLayout(pushconstantPipelineLayout_json,member.pushconstantPipelineLayout);}();
auto& pushconstantShaderStageFlags_json=json["pushconstantShaderStageFlags"];
[&](){[&](){[&](){pushconstantShaderStageFlags_json=member.pushconstantShaderStageFlags;}();}();}();
auto& pushconstantOffset_json=json["pushconstantOffset"];
[&](){pushconstantOffset_json=member.pushconstantOffset;}();
auto& pushconstantSize_json=json["pushconstantSize"];
[&](){pushconstantSize_json=member.pushconstantSize;}();
auto& indirectStateFlags_json=json["indirectStateFlags"];
[&](){[&](){[&](){indirectStateFlags_json=member.indirectStateFlags;}();}();}();
auto& indexTypeCount_json=json["indexTypeCount"];
[&](){indexTypeCount_json=member.indexTypeCount;}();
auto& pIndexTypes_json=json["pIndexTypes"];
[&](){
            if (member.pIndexTypes==NULL){
                pIndexTypes_json=boost::json::array();
            return; }pIndexTypes_json=boost::json::array(member.indexTypeCount);
        auto& arr_UgjmpPY=pIndexTypes_json.as_array();
        for(int ZAMvbKq=0; ZAMvbKq < member.indexTypeCount; ZAMvbKq++){
            [&](){[&](){[&](){arr_UgjmpPY[ZAMvbKq]=member.pIndexTypes[ZAMvbKq];}();}();}();
        }
        }();
auto& pIndexTypeValues_json=json["pIndexTypeValues"];
[&](){
            if (member.pIndexTypeValues==NULL){
                pIndexTypeValues_json=boost::json::array();
            return; }pIndexTypeValues_json=boost::json::array(member.indexTypeCount);
        auto& arr_RSRnOkD=pIndexTypeValues_json.as_array();
        for(int EEhOagC=0; EEhOagC < member.indexTypeCount; EEhOagC++){
            [&](){arr_RSRnOkD[EEhOagC]=member.pIndexTypeValues[EEhOagC];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkIndirectCommandsLayoutTokenNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& tokenType_json=json["tokenType"];
[&](){[&](){int temp_cVbGiDI;[&](){temp_cVbGiDI=static_cast<int>(value_to<int>(tokenType_json));}();member.tokenType=(VkIndirectCommandsTokenTypeNV)temp_cVbGiDI;}();}();
auto& stream_json=json["stream"];
[&](){member.stream=static_cast<uint32_t>(value_to<int>(stream_json));}();
auto& offset_json=json["offset"];
[&](){member.offset=static_cast<uint32_t>(value_to<int>(offset_json));}();
auto& vertexBindingUnit_json=json["vertexBindingUnit"];
[&](){member.vertexBindingUnit=static_cast<uint32_t>(value_to<int>(vertexBindingUnit_json));}();
auto& vertexDynamicStride_json=json["vertexDynamicStride"];
[&](){uint32_t temp_eUuFrGg;[&](){temp_eUuFrGg=static_cast<uint32_t>(value_to<int>(vertexDynamicStride_json));}();member.vertexDynamicStride=(VkBool32)temp_eUuFrGg;}();
auto& pushconstantPipelineLayout_json=json["pushconstantPipelineLayout"];
[&](){deserialize_VkPipelineLayout(pushconstantPipelineLayout_json, member.pushconstantPipelineLayout);}();
auto& pushconstantShaderStageFlags_json=json["pushconstantShaderStageFlags"];
[&](){[&](){int temp_nvKpnex;[&](){temp_nvKpnex=static_cast<int>(value_to<int>(pushconstantShaderStageFlags_json));}();member.pushconstantShaderStageFlags=(VkShaderStageFlags)temp_nvKpnex;}();}();
auto& pushconstantOffset_json=json["pushconstantOffset"];
[&](){member.pushconstantOffset=static_cast<uint32_t>(value_to<int>(pushconstantOffset_json));}();
auto& pushconstantSize_json=json["pushconstantSize"];
[&](){member.pushconstantSize=static_cast<uint32_t>(value_to<int>(pushconstantSize_json));}();
auto& indirectStateFlags_json=json["indirectStateFlags"];
[&](){[&](){int temp_qYSvcOd;[&](){temp_qYSvcOd=static_cast<int>(value_to<int>(indirectStateFlags_json));}();member.indirectStateFlags=(VkIndirectStateFlagsNV)temp_qYSvcOd;}();}();
auto& indexTypeCount_json=json["indexTypeCount"];
[&](){member.indexTypeCount=static_cast<uint32_t>(value_to<int>(indexTypeCount_json));}();
auto& pIndexTypes_json=json["pIndexTypes"];
[&](){ VkIndexType* temp_WoSkJUK;;[&](){
            if (pIndexTypes_json.as_array().size()==0){
                temp_WoSkJUK=NULL;
            return; }temp_WoSkJUK=(VkIndexType*)malloc(member.indexTypeCount*sizeof(VkIndexType));
        auto& arr_FIUjLUK=pIndexTypes_json.as_array();
        for(int lFsAZog=0; lFsAZog < member.indexTypeCount; lFsAZog++){
            [&](){[&](){int temp_hNlpdCP;[&](){temp_hNlpdCP=static_cast<int>(value_to<int>(arr_FIUjLUK[lFsAZog]));}();temp_WoSkJUK[lFsAZog]=(VkIndexType)temp_hNlpdCP;}();}();
        }
        }();member.pIndexTypes=temp_WoSkJUK;}();
auto& pIndexTypeValues_json=json["pIndexTypeValues"];
[&](){ uint32_t* temp_Ssecxdx;;[&](){
            if (pIndexTypeValues_json.as_array().size()==0){
                temp_Ssecxdx=NULL;
            return; }temp_Ssecxdx=(uint32_t*)malloc(member.indexTypeCount*sizeof(uint32_t));
        auto& arr_cHgkfzc=pIndexTypeValues_json.as_array();
        for(int otuDcDc=0; otuDcDc < member.indexTypeCount; otuDcDc++){
            [&](){temp_Ssecxdx[otuDcDc]=static_cast<uint32_t>(value_to<int>(arr_cHgkfzc[otuDcDc]));}();
        }
        }();member.pIndexTypeValues=temp_Ssecxdx;}();
}

    void serialize_struct(boost::json::object& json, const VkIndirectCommandsLayoutCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){[&](){pipelineBindPoint_json=member.pipelineBindPoint;}();}();}();
auto& tokenCount_json=json["tokenCount"];
[&](){tokenCount_json=member.tokenCount;}();
auto& pTokens_json=json["pTokens"];
[&](){
            if (member.pTokens==NULL){
                pTokens_json=boost::json::array();
            return; }pTokens_json=boost::json::array(member.tokenCount);
        auto& arr_fUkYdRn=pTokens_json.as_array();
        for(int PBaXRHm=0; PBaXRHm < member.tokenCount; PBaXRHm++){
            [&](){
            auto& temp=arr_fUkYdRn[PBaXRHm].emplace_object();
            return serialize_struct(temp, member.pTokens[PBaXRHm]);
            }();
        }
        }();
auto& streamCount_json=json["streamCount"];
[&](){streamCount_json=member.streamCount;}();
auto& pStreamStrides_json=json["pStreamStrides"];
[&](){
            if (member.pStreamStrides==NULL){
                pStreamStrides_json=boost::json::array();
            return; }pStreamStrides_json=boost::json::array(member.streamCount);
        auto& arr_MlWxCCh=pStreamStrides_json.as_array();
        for(int ESgdJDg=0; ESgdJDg < member.streamCount; ESgdJDg++){
            [&](){arr_MlWxCCh[ESgdJDg]=member.pStreamStrides[ESgdJDg];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkIndirectCommandsLayoutCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_zrrzLzk;[&](){temp_zrrzLzk=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkIndirectCommandsLayoutUsageFlagsNV)temp_zrrzLzk;}();}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){int temp_WiAtSfj;[&](){temp_WiAtSfj=static_cast<int>(value_to<int>(pipelineBindPoint_json));}();member.pipelineBindPoint=(VkPipelineBindPoint)temp_WiAtSfj;}();}();
auto& tokenCount_json=json["tokenCount"];
[&](){member.tokenCount=static_cast<uint32_t>(value_to<int>(tokenCount_json));}();
auto& pTokens_json=json["pTokens"];
[&](){ VkIndirectCommandsLayoutTokenNV* temp_KMqCQlK;;[&](){
            if (pTokens_json.as_array().size()==0){
                temp_KMqCQlK=NULL;
            return; }temp_KMqCQlK=(VkIndirectCommandsLayoutTokenNV*)malloc(member.tokenCount*sizeof(VkIndirectCommandsLayoutTokenNV));
        auto& arr_UzuRJfE=pTokens_json.as_array();
        for(int TsTMYTb=0; TsTMYTb < member.tokenCount; TsTMYTb++){
            [&](){
            auto& temp=arr_UzuRJfE[TsTMYTb].as_object();
            deserialize_struct(temp,temp_KMqCQlK[TsTMYTb]);
            }();
        }
        }();member.pTokens=temp_KMqCQlK;}();
auto& streamCount_json=json["streamCount"];
[&](){member.streamCount=static_cast<uint32_t>(value_to<int>(streamCount_json));}();
auto& pStreamStrides_json=json["pStreamStrides"];
[&](){ uint32_t* temp_efwEfCV;;[&](){
            if (pStreamStrides_json.as_array().size()==0){
                temp_efwEfCV=NULL;
            return; }temp_efwEfCV=(uint32_t*)malloc(member.streamCount*sizeof(uint32_t));
        auto& arr_JPKtcSq=pStreamStrides_json.as_array();
        for(int QEyNHkD=0; QEyNHkD < member.streamCount; QEyNHkD++){
            [&](){temp_efwEfCV[QEyNHkD]=static_cast<uint32_t>(value_to<int>(arr_JPKtcSq[QEyNHkD]));}();
        }
        }();member.pStreamStrides=temp_efwEfCV;}();
}

    void serialize_struct(boost::json::object& json, const VkGeneratedCommandsInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){[&](){pipelineBindPoint_json=member.pipelineBindPoint;}();}();}();
auto& pipeline_json=json["pipeline"];
[&](){serialize_VkPipeline(pipeline_json,member.pipeline);}();
auto& indirectCommandsLayout_json=json["indirectCommandsLayout"];
[&](){serialize_VkIndirectCommandsLayoutNV(indirectCommandsLayout_json,member.indirectCommandsLayout);}();
auto& streamCount_json=json["streamCount"];
[&](){streamCount_json=member.streamCount;}();
auto& pStreams_json=json["pStreams"];
[&](){
            if (member.pStreams==NULL){
                pStreams_json=boost::json::array();
            return; }pStreams_json=boost::json::array(member.streamCount);
        auto& arr_hAgHXtW=pStreams_json.as_array();
        for(int DPlUWAU=0; DPlUWAU < member.streamCount; DPlUWAU++){
            [&](){
            auto& temp=arr_hAgHXtW[DPlUWAU].emplace_object();
            return serialize_struct(temp, member.pStreams[DPlUWAU]);
            }();
        }
        }();
auto& sequencesCount_json=json["sequencesCount"];
[&](){sequencesCount_json=member.sequencesCount;}();
auto& preprocessBuffer_json=json["preprocessBuffer"];
[&](){serialize_VkBuffer(preprocessBuffer_json,member.preprocessBuffer);}();
auto& preprocessOffset_json=json["preprocessOffset"];
[&](){[&](){preprocessOffset_json=member.preprocessOffset;}();}();
auto& preprocessSize_json=json["preprocessSize"];
[&](){[&](){preprocessSize_json=member.preprocessSize;}();}();
auto& sequencesCountBuffer_json=json["sequencesCountBuffer"];
[&](){serialize_VkBuffer(sequencesCountBuffer_json,member.sequencesCountBuffer);}();
auto& sequencesCountOffset_json=json["sequencesCountOffset"];
[&](){[&](){sequencesCountOffset_json=member.sequencesCountOffset;}();}();
auto& sequencesIndexBuffer_json=json["sequencesIndexBuffer"];
[&](){serialize_VkBuffer(sequencesIndexBuffer_json,member.sequencesIndexBuffer);}();
auto& sequencesIndexOffset_json=json["sequencesIndexOffset"];
[&](){[&](){sequencesIndexOffset_json=member.sequencesIndexOffset;}();}();
}
void deserialize_struct(boost::json::object& json, VkGeneratedCommandsInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){int temp_WiAtSfj;[&](){temp_WiAtSfj=static_cast<int>(value_to<int>(pipelineBindPoint_json));}();member.pipelineBindPoint=(VkPipelineBindPoint)temp_WiAtSfj;}();}();
auto& pipeline_json=json["pipeline"];
[&](){deserialize_VkPipeline(pipeline_json, member.pipeline);}();
auto& indirectCommandsLayout_json=json["indirectCommandsLayout"];
[&](){deserialize_VkIndirectCommandsLayoutNV(indirectCommandsLayout_json, member.indirectCommandsLayout);}();
auto& streamCount_json=json["streamCount"];
[&](){member.streamCount=static_cast<uint32_t>(value_to<int>(streamCount_json));}();
auto& pStreams_json=json["pStreams"];
[&](){ VkIndirectCommandsStreamNV* temp_gJBjCVL;;[&](){
            if (pStreams_json.as_array().size()==0){
                temp_gJBjCVL=NULL;
            return; }temp_gJBjCVL=(VkIndirectCommandsStreamNV*)malloc(member.streamCount*sizeof(VkIndirectCommandsStreamNV));
        auto& arr_JHaLytg=pStreams_json.as_array();
        for(int DpIeEej=0; DpIeEej < member.streamCount; DpIeEej++){
            [&](){
            auto& temp=arr_JHaLytg[DpIeEej].as_object();
            deserialize_struct(temp,temp_gJBjCVL[DpIeEej]);
            }();
        }
        }();member.pStreams=temp_gJBjCVL;}();
auto& sequencesCount_json=json["sequencesCount"];
[&](){member.sequencesCount=static_cast<uint32_t>(value_to<int>(sequencesCount_json));}();
auto& preprocessBuffer_json=json["preprocessBuffer"];
[&](){deserialize_VkBuffer(preprocessBuffer_json, member.preprocessBuffer);}();
auto& preprocessOffset_json=json["preprocessOffset"];
[&](){uint64_t temp_uxEazuL;[&](){temp_uxEazuL=static_cast<uint64_t>(value_to<int>(preprocessOffset_json));}();member.preprocessOffset=(VkDeviceSize)temp_uxEazuL;}();
auto& preprocessSize_json=json["preprocessSize"];
[&](){uint64_t temp_AYrIiHV;[&](){temp_AYrIiHV=static_cast<uint64_t>(value_to<int>(preprocessSize_json));}();member.preprocessSize=(VkDeviceSize)temp_AYrIiHV;}();
auto& sequencesCountBuffer_json=json["sequencesCountBuffer"];
[&](){deserialize_VkBuffer(sequencesCountBuffer_json, member.sequencesCountBuffer);}();
auto& sequencesCountOffset_json=json["sequencesCountOffset"];
[&](){uint64_t temp_xzHnKzv;[&](){temp_xzHnKzv=static_cast<uint64_t>(value_to<int>(sequencesCountOffset_json));}();member.sequencesCountOffset=(VkDeviceSize)temp_xzHnKzv;}();
auto& sequencesIndexBuffer_json=json["sequencesIndexBuffer"];
[&](){deserialize_VkBuffer(sequencesIndexBuffer_json, member.sequencesIndexBuffer);}();
auto& sequencesIndexOffset_json=json["sequencesIndexOffset"];
[&](){uint64_t temp_aezlUSc;[&](){temp_aezlUSc=static_cast<uint64_t>(value_to<int>(sequencesIndexOffset_json));}();member.sequencesIndexOffset=(VkDeviceSize)temp_aezlUSc;}();
}

    void serialize_struct(boost::json::object& json, const VkGeneratedCommandsMemoryRequirementsInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){[&](){pipelineBindPoint_json=member.pipelineBindPoint;}();}();}();
auto& pipeline_json=json["pipeline"];
[&](){serialize_VkPipeline(pipeline_json,member.pipeline);}();
auto& indirectCommandsLayout_json=json["indirectCommandsLayout"];
[&](){serialize_VkIndirectCommandsLayoutNV(indirectCommandsLayout_json,member.indirectCommandsLayout);}();
auto& maxSequencesCount_json=json["maxSequencesCount"];
[&](){maxSequencesCount_json=member.maxSequencesCount;}();
}
void deserialize_struct(boost::json::object& json, VkGeneratedCommandsMemoryRequirementsInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){int temp_WiAtSfj;[&](){temp_WiAtSfj=static_cast<int>(value_to<int>(pipelineBindPoint_json));}();member.pipelineBindPoint=(VkPipelineBindPoint)temp_WiAtSfj;}();}();
auto& pipeline_json=json["pipeline"];
[&](){deserialize_VkPipeline(pipeline_json, member.pipeline);}();
auto& indirectCommandsLayout_json=json["indirectCommandsLayout"];
[&](){deserialize_VkIndirectCommandsLayoutNV(indirectCommandsLayout_json, member.indirectCommandsLayout);}();
auto& maxSequencesCount_json=json["maxSequencesCount"];
[&](){member.maxSequencesCount=static_cast<uint32_t>(value_to<int>(maxSequencesCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineIndirectDeviceAddressInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){[&](){pipelineBindPoint_json=member.pipelineBindPoint;}();}();}();
auto& pipeline_json=json["pipeline"];
[&](){serialize_VkPipeline(pipeline_json,member.pipeline);}();
}
void deserialize_struct(boost::json::object& json, VkPipelineIndirectDeviceAddressInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){int temp_WiAtSfj;[&](){temp_WiAtSfj=static_cast<int>(value_to<int>(pipelineBindPoint_json));}();member.pipelineBindPoint=(VkPipelineBindPoint)temp_WiAtSfj;}();}();
auto& pipeline_json=json["pipeline"];
[&](){deserialize_VkPipeline(pipeline_json, member.pipeline);}();
}

    void serialize_struct(boost::json::object& json, const VkBindPipelineIndirectCommandNV& member){
        
    
auto& pipelineAddress_json=json["pipelineAddress"];
[&](){[&](){pipelineAddress_json=member.pipelineAddress;}();}();
}
void deserialize_struct(boost::json::object& json, VkBindPipelineIndirectCommandNV& member){
auto& pipelineAddress_json=json["pipelineAddress"];
[&](){uint64_t temp_txmacXw;[&](){temp_txmacXw=static_cast<uint64_t>(value_to<int>(pipelineAddress_json));}();member.pipelineAddress=(VkDeviceAddress)temp_txmacXw;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFeatures2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& features_json=json["features"];
[&](){
            auto& temp=features_json.emplace_object();
            return serialize_struct(temp, member.features);
            }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFeatures2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& features_json=json["features"];
[&](){
            auto& temp=features_json.as_object();
            deserialize_struct(temp,member.features);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceProperties2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& properties_json=json["properties"];
[&](){
            auto& temp=properties_json.emplace_object();
            return serialize_struct(temp, member.properties);
            }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceProperties2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& properties_json=json["properties"];
[&](){
            auto& temp=properties_json.as_object();
            deserialize_struct(temp,member.properties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkFormatProperties2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& formatProperties_json=json["formatProperties"];
[&](){
            auto& temp=formatProperties_json.emplace_object();
            return serialize_struct(temp, member.formatProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkFormatProperties2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& formatProperties_json=json["formatProperties"];
[&](){
            auto& temp=formatProperties_json.as_object();
            deserialize_struct(temp,member.formatProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkImageFormatProperties2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageFormatProperties_json=json["imageFormatProperties"];
[&](){
            auto& temp=imageFormatProperties_json.emplace_object();
            return serialize_struct(temp, member.imageFormatProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageFormatProperties2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& imageFormatProperties_json=json["imageFormatProperties"];
[&](){
            auto& temp=imageFormatProperties_json.as_object();
            deserialize_struct(temp,member.imageFormatProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageFormatInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& tiling_json=json["tiling"];
[&](){[&](){[&](){tiling_json=member.tiling;}();}();}();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageFormatInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& type_json=json["type"];
[&](){[&](){int temp_gZGFluL;[&](){temp_gZGFluL=static_cast<int>(value_to<int>(type_json));}();member.type=(VkImageType)temp_gZGFluL;}();}();
auto& tiling_json=json["tiling"];
[&](){[&](){int temp_ldSxudR;[&](){temp_ldSxudR=static_cast<int>(value_to<int>(tiling_json));}();member.tiling=(VkImageTiling)temp_ldSxudR;}();}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_FIcOdeK;[&](){temp_FIcOdeK=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkImageUsageFlags)temp_FIcOdeK;}();}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_gikCMkV;[&](){temp_gikCMkV=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkImageCreateFlags)temp_gikCMkV;}();}();
}

    void serialize_struct(boost::json::object& json, const VkQueueFamilyProperties2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& queueFamilyProperties_json=json["queueFamilyProperties"];
[&](){
            auto& temp=queueFamilyProperties_json.emplace_object();
            return serialize_struct(temp, member.queueFamilyProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkQueueFamilyProperties2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& queueFamilyProperties_json=json["queueFamilyProperties"];
[&](){
            auto& temp=queueFamilyProperties_json.as_object();
            deserialize_struct(temp,member.queueFamilyProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMemoryProperties2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memoryProperties_json=json["memoryProperties"];
[&](){
            auto& temp=memoryProperties_json.emplace_object();
            return serialize_struct(temp, member.memoryProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMemoryProperties2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& memoryProperties_json=json["memoryProperties"];
[&](){
            auto& temp=memoryProperties_json.as_object();
            deserialize_struct(temp,member.memoryProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSparseImageFormatProperties2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& properties_json=json["properties"];
[&](){
            auto& temp=properties_json.emplace_object();
            return serialize_struct(temp, member.properties);
            }();
}
void deserialize_struct(boost::json::object& json, VkSparseImageFormatProperties2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& properties_json=json["properties"];
[&](){
            auto& temp=properties_json.as_object();
            deserialize_struct(temp,member.properties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSparseImageFormatInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& samples_json=json["samples"];
[&](){[&](){[&](){samples_json=member.samples;}();}();}();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
auto& tiling_json=json["tiling"];
[&](){[&](){[&](){tiling_json=member.tiling;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSparseImageFormatInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& type_json=json["type"];
[&](){[&](){int temp_gZGFluL;[&](){temp_gZGFluL=static_cast<int>(value_to<int>(type_json));}();member.type=(VkImageType)temp_gZGFluL;}();}();
auto& samples_json=json["samples"];
[&](){[&](){int temp_HAQfesR;[&](){temp_HAQfesR=static_cast<int>(value_to<int>(samples_json));}();member.samples=(VkSampleCountFlagBits)temp_HAQfesR;}();}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_FIcOdeK;[&](){temp_FIcOdeK=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkImageUsageFlags)temp_FIcOdeK;}();}();
auto& tiling_json=json["tiling"];
[&](){[&](){int temp_ldSxudR;[&](){temp_ldSxudR=static_cast<int>(value_to<int>(tiling_json));}();member.tiling=(VkImageTiling)temp_ldSxudR;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePushDescriptorPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxPushDescriptors_json=json["maxPushDescriptors"];
[&](){maxPushDescriptors_json=member.maxPushDescriptors;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePushDescriptorPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxPushDescriptors_json=json["maxPushDescriptors"];
[&](){member.maxPushDescriptors=static_cast<uint32_t>(value_to<int>(maxPushDescriptors_json));}();
}

    void serialize_struct(boost::json::object& json, const VkConformanceVersion& member){
        
    
auto& major_json=json["major"];
[&](){major_json=member.major;}();
auto& minor_json=json["minor"];
[&](){minor_json=member.minor;}();
auto& subminor_json=json["subminor"];
[&](){subminor_json=member.subminor;}();
auto& patch_json=json["patch"];
[&](){patch_json=member.patch;}();
}
void deserialize_struct(boost::json::object& json, VkConformanceVersion& member){
auto& major_json=json["major"];
[&](){member.major=static_cast<uint8_t>(value_to<int>(major_json));}();
auto& minor_json=json["minor"];
[&](){member.minor=static_cast<uint8_t>(value_to<int>(minor_json));}();
auto& subminor_json=json["subminor"];
[&](){member.subminor=static_cast<uint8_t>(value_to<int>(subminor_json));}();
auto& patch_json=json["patch"];
[&](){member.patch=static_cast<uint8_t>(value_to<int>(patch_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDriverProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& driverID_json=json["driverID"];
[&](){[&](){[&](){driverID_json=member.driverID;}();}();}();
auto& driverName_json=json["driverName"];
[&](){driverName_json=boost::json::array(VK_MAX_DRIVER_NAME_SIZE);
        auto& arr_SyXYXNX=driverName_json.as_array();
        for(int vSFArQc=0; vSFArQc < VK_MAX_DRIVER_NAME_SIZE; vSFArQc++){
            [&](){arr_SyXYXNX[vSFArQc]=member.driverName[vSFArQc];}();
        }
        }();
auto& driverInfo_json=json["driverInfo"];
[&](){driverInfo_json=boost::json::array(VK_MAX_DRIVER_INFO_SIZE);
        auto& arr_TFnmGhH=driverInfo_json.as_array();
        for(int ZmulTHh=0; ZmulTHh < VK_MAX_DRIVER_INFO_SIZE; ZmulTHh++){
            [&](){arr_TFnmGhH[ZmulTHh]=member.driverInfo[ZmulTHh];}();
        }
        }();
auto& conformanceVersion_json=json["conformanceVersion"];
[&](){
            auto& temp=conformanceVersion_json.emplace_object();
            return serialize_struct(temp, member.conformanceVersion);
            }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDriverProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& driverID_json=json["driverID"];
[&](){[&](){int temp_vHrPzGx;[&](){temp_vHrPzGx=static_cast<int>(value_to<int>(driverID_json));}();member.driverID=(VkDriverId)temp_vHrPzGx;}();}();
auto& driverName_json=json["driverName"];
[&](){
        auto& arr_SyXYXNX=driverName_json.as_array();
        for(int vSFArQc=0; vSFArQc < VK_MAX_DRIVER_NAME_SIZE; vSFArQc++){
            [&](){member.driverName[vSFArQc]=static_cast<char>(value_to<int>(arr_SyXYXNX[vSFArQc]));}();
        }
        }();
auto& driverInfo_json=json["driverInfo"];
[&](){
        auto& arr_TFnmGhH=driverInfo_json.as_array();
        for(int ZmulTHh=0; ZmulTHh < VK_MAX_DRIVER_INFO_SIZE; ZmulTHh++){
            [&](){member.driverInfo[ZmulTHh]=static_cast<char>(value_to<int>(arr_TFnmGhH[ZmulTHh]));}();
        }
        }();
auto& conformanceVersion_json=json["conformanceVersion"];
[&](){
            auto& temp=conformanceVersion_json.as_object();
            deserialize_struct(temp,member.conformanceVersion);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPresentRegionsKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchainCount_json=json["swapchainCount"];
[&](){swapchainCount_json=member.swapchainCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.swapchainCount);
        auto& arr_odKhLjV=pRegions_json.as_array();
        for(int FrDcLRd=0; FrDcLRd < member.swapchainCount; FrDcLRd++){
            [&](){
            auto& temp=arr_odKhLjV[FrDcLRd].emplace_object();
            return serialize_struct(temp, member.pRegions[FrDcLRd]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPresentRegionsKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchainCount_json=json["swapchainCount"];
[&](){member.swapchainCount=static_cast<uint32_t>(value_to<int>(swapchainCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkPresentRegionKHR* temp_ikTufyO;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_ikTufyO=NULL;
            return; }temp_ikTufyO=(VkPresentRegionKHR*)malloc(member.swapchainCount*sizeof(VkPresentRegionKHR));
        auto& arr_gTGOjBS=pRegions_json.as_array();
        for(int DIywFKZ=0; DIywFKZ < member.swapchainCount; DIywFKZ++){
            [&](){
            auto& temp=arr_gTGOjBS[DIywFKZ].as_object();
            deserialize_struct(temp,temp_ikTufyO[DIywFKZ]);
            }();
        }
        }();member.pRegions=temp_ikTufyO;}();
}

    void serialize_struct(boost::json::object& json, const VkPresentRegionKHR& member){
        
    
auto& rectangleCount_json=json["rectangleCount"];
[&](){rectangleCount_json=member.rectangleCount;}();
auto& pRectangles_json=json["pRectangles"];
[&](){
            if (member.pRectangles==NULL){
                pRectangles_json=boost::json::array();
            return; }pRectangles_json=boost::json::array(member.rectangleCount);
        auto& arr_mTDiSim=pRectangles_json.as_array();
        for(int vGVwhpO=0; vGVwhpO < member.rectangleCount; vGVwhpO++){
            [&](){
            auto& temp=arr_mTDiSim[vGVwhpO].emplace_object();
            return serialize_struct(temp, member.pRectangles[vGVwhpO]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPresentRegionKHR& member){
auto& rectangleCount_json=json["rectangleCount"];
[&](){member.rectangleCount=static_cast<uint32_t>(value_to<int>(rectangleCount_json));}();
auto& pRectangles_json=json["pRectangles"];
[&](){ VkRectLayerKHR* temp_frEJVgm;;[&](){
            if (pRectangles_json.as_array().size()==0){
                temp_frEJVgm=NULL;
            return; }temp_frEJVgm=(VkRectLayerKHR*)malloc(member.rectangleCount*sizeof(VkRectLayerKHR));
        auto& arr_OKfTPag=pRectangles_json.as_array();
        for(int lthuVqR=0; lthuVqR < member.rectangleCount; lthuVqR++){
            [&](){
            auto& temp=arr_OKfTPag[lthuVqR].as_object();
            deserialize_struct(temp,temp_frEJVgm[lthuVqR]);
            }();
        }
        }();member.pRectangles=temp_frEJVgm;}();
}

    void serialize_struct(boost::json::object& json, const VkRectLayerKHR& member){
        
    
auto& offset_json=json["offset"];
[&](){
            auto& temp=offset_json.emplace_object();
            return serialize_struct(temp, member.offset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.emplace_object();
            return serialize_struct(temp, member.extent);
            }();
auto& layer_json=json["layer"];
[&](){layer_json=member.layer;}();
}
void deserialize_struct(boost::json::object& json, VkRectLayerKHR& member){
auto& offset_json=json["offset"];
[&](){
            auto& temp=offset_json.as_object();
            deserialize_struct(temp,member.offset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.as_object();
            deserialize_struct(temp,member.extent);
            }();
auto& layer_json=json["layer"];
[&](){member.layer=static_cast<uint32_t>(value_to<int>(layer_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVariablePointersFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& variablePointersStorageBuffer_json=json["variablePointersStorageBuffer"];
[&](){[&](){variablePointersStorageBuffer_json=member.variablePointersStorageBuffer;}();}();
auto& variablePointers_json=json["variablePointers"];
[&](){[&](){variablePointers_json=member.variablePointers;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVariablePointersFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& variablePointersStorageBuffer_json=json["variablePointersStorageBuffer"];
[&](){uint32_t temp_ZTlpmfq;[&](){temp_ZTlpmfq=static_cast<uint32_t>(value_to<int>(variablePointersStorageBuffer_json));}();member.variablePointersStorageBuffer=(VkBool32)temp_ZTlpmfq;}();
auto& variablePointers_json=json["variablePointers"];
[&](){uint32_t temp_DgiVyJz;[&](){temp_DgiVyJz=static_cast<uint32_t>(value_to<int>(variablePointers_json));}();member.variablePointers=(VkBool32)temp_DgiVyJz;}();
}

    void serialize_struct(boost::json::object& json, const VkExternalMemoryProperties& member){
        
    
auto& externalMemoryFeatures_json=json["externalMemoryFeatures"];
[&](){[&](){[&](){externalMemoryFeatures_json=member.externalMemoryFeatures;}();}();}();
auto& exportFromImportedHandleTypes_json=json["exportFromImportedHandleTypes"];
[&](){[&](){[&](){exportFromImportedHandleTypes_json=member.exportFromImportedHandleTypes;}();}();}();
auto& compatibleHandleTypes_json=json["compatibleHandleTypes"];
[&](){[&](){[&](){compatibleHandleTypes_json=member.compatibleHandleTypes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExternalMemoryProperties& member){
auto& externalMemoryFeatures_json=json["externalMemoryFeatures"];
[&](){[&](){int temp_JUYTjNH;[&](){temp_JUYTjNH=static_cast<int>(value_to<int>(externalMemoryFeatures_json));}();member.externalMemoryFeatures=(VkExternalMemoryFeatureFlags)temp_JUYTjNH;}();}();
auto& exportFromImportedHandleTypes_json=json["exportFromImportedHandleTypes"];
[&](){[&](){int temp_CUfIgYF;[&](){temp_CUfIgYF=static_cast<int>(value_to<int>(exportFromImportedHandleTypes_json));}();member.exportFromImportedHandleTypes=(VkExternalMemoryHandleTypeFlags)temp_CUfIgYF;}();}();
auto& compatibleHandleTypes_json=json["compatibleHandleTypes"];
[&](){[&](){int temp_pnAMLUp;[&](){temp_pnAMLUp=static_cast<int>(value_to<int>(compatibleHandleTypes_json));}();member.compatibleHandleTypes=(VkExternalMemoryHandleTypeFlags)temp_pnAMLUp;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExternalImageFormatInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExternalImageFormatInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_eyKBrDS;[&](){temp_eyKBrDS=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalMemoryHandleTypeFlagBits)temp_eyKBrDS;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExternalImageFormatProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& externalMemoryProperties_json=json["externalMemoryProperties"];
[&](){
            auto& temp=externalMemoryProperties_json.emplace_object();
            return serialize_struct(temp, member.externalMemoryProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkExternalImageFormatProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& externalMemoryProperties_json=json["externalMemoryProperties"];
[&](){
            auto& temp=externalMemoryProperties_json.as_object();
            deserialize_struct(temp,member.externalMemoryProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExternalBufferInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExternalBufferInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_NttNRTT;[&](){temp_NttNRTT=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkBufferCreateFlags)temp_NttNRTT;}();}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_xMTCOae;[&](){temp_xMTCOae=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkBufferUsageFlags)temp_xMTCOae;}();}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_eyKBrDS;[&](){temp_eyKBrDS=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalMemoryHandleTypeFlagBits)temp_eyKBrDS;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExternalBufferProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& externalMemoryProperties_json=json["externalMemoryProperties"];
[&](){
            auto& temp=externalMemoryProperties_json.emplace_object();
            return serialize_struct(temp, member.externalMemoryProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkExternalBufferProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& externalMemoryProperties_json=json["externalMemoryProperties"];
[&](){
            auto& temp=externalMemoryProperties_json.as_object();
            deserialize_struct(temp,member.externalMemoryProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceIDProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceUUID_json=json["deviceUUID"];
[&](){deviceUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_FuHCgMt=deviceUUID_json.as_array();
        for(int ysVOqaa=0; ysVOqaa < VK_UUID_SIZE; ysVOqaa++){
            [&](){arr_FuHCgMt[ysVOqaa]=member.deviceUUID[ysVOqaa];}();
        }
        }();
auto& driverUUID_json=json["driverUUID"];
[&](){driverUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_YRnTzib=driverUUID_json.as_array();
        for(int mkRKwTt=0; mkRKwTt < VK_UUID_SIZE; mkRKwTt++){
            [&](){arr_YRnTzib[mkRKwTt]=member.driverUUID[mkRKwTt];}();
        }
        }();
auto& deviceLUID_json=json["deviceLUID"];
[&](){deviceLUID_json=boost::json::array(VK_LUID_SIZE);
        auto& arr_ZPJcGyp=deviceLUID_json.as_array();
        for(int LcxBcjU=0; LcxBcjU < VK_LUID_SIZE; LcxBcjU++){
            [&](){arr_ZPJcGyp[LcxBcjU]=member.deviceLUID[LcxBcjU];}();
        }
        }();
auto& deviceNodeMask_json=json["deviceNodeMask"];
[&](){deviceNodeMask_json=member.deviceNodeMask;}();
auto& deviceLUIDValid_json=json["deviceLUIDValid"];
[&](){[&](){deviceLUIDValid_json=member.deviceLUIDValid;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceIDProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& deviceUUID_json=json["deviceUUID"];
[&](){
        auto& arr_FuHCgMt=deviceUUID_json.as_array();
        for(int ysVOqaa=0; ysVOqaa < VK_UUID_SIZE; ysVOqaa++){
            [&](){member.deviceUUID[ysVOqaa]=static_cast<uint8_t>(value_to<int>(arr_FuHCgMt[ysVOqaa]));}();
        }
        }();
auto& driverUUID_json=json["driverUUID"];
[&](){
        auto& arr_YRnTzib=driverUUID_json.as_array();
        for(int mkRKwTt=0; mkRKwTt < VK_UUID_SIZE; mkRKwTt++){
            [&](){member.driverUUID[mkRKwTt]=static_cast<uint8_t>(value_to<int>(arr_YRnTzib[mkRKwTt]));}();
        }
        }();
auto& deviceLUID_json=json["deviceLUID"];
[&](){
        auto& arr_ZPJcGyp=deviceLUID_json.as_array();
        for(int LcxBcjU=0; LcxBcjU < VK_LUID_SIZE; LcxBcjU++){
            [&](){member.deviceLUID[LcxBcjU]=static_cast<uint8_t>(value_to<int>(arr_ZPJcGyp[LcxBcjU]));}();
        }
        }();
auto& deviceNodeMask_json=json["deviceNodeMask"];
[&](){member.deviceNodeMask=static_cast<uint32_t>(value_to<int>(deviceNodeMask_json));}();
auto& deviceLUIDValid_json=json["deviceLUIDValid"];
[&](){uint32_t temp_ZWIQNBq;[&](){temp_ZWIQNBq=static_cast<uint32_t>(value_to<int>(deviceLUIDValid_json));}();member.deviceLUIDValid=(VkBool32)temp_ZWIQNBq;}();
}

    void serialize_struct(boost::json::object& json, const VkExternalMemoryImageCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){[&](){handleTypes_json=member.handleTypes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExternalMemoryImageCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){int temp_xJmxCsM;[&](){temp_xJmxCsM=static_cast<int>(value_to<int>(handleTypes_json));}();member.handleTypes=(VkExternalMemoryHandleTypeFlags)temp_xJmxCsM;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExternalMemoryBufferCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){[&](){handleTypes_json=member.handleTypes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExternalMemoryBufferCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){int temp_xJmxCsM;[&](){temp_xJmxCsM=static_cast<int>(value_to<int>(handleTypes_json));}();member.handleTypes=(VkExternalMemoryHandleTypeFlags)temp_xJmxCsM;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExportMemoryAllocateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){[&](){handleTypes_json=member.handleTypes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExportMemoryAllocateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){int temp_xJmxCsM;[&](){temp_xJmxCsM=static_cast<int>(value_to<int>(handleTypes_json));}();member.handleTypes=(VkExternalMemoryHandleTypeFlags)temp_xJmxCsM;}();}();
}

    void serialize_struct(boost::json::object& json, const VkImportMemoryFdInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
auto& fd_json=json["fd"];
[&](){fd_json=member.fd;}();
}
void deserialize_struct(boost::json::object& json, VkImportMemoryFdInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_eyKBrDS;[&](){temp_eyKBrDS=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalMemoryHandleTypeFlagBits)temp_eyKBrDS;}();}();
auto& fd_json=json["fd"];
[&](){member.fd=static_cast<int>(value_to<int>(fd_json));}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryFdPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memoryTypeBits_json=json["memoryTypeBits"];
[&](){memoryTypeBits_json=member.memoryTypeBits;}();
}
void deserialize_struct(boost::json::object& json, VkMemoryFdPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& memoryTypeBits_json=json["memoryTypeBits"];
[&](){member.memoryTypeBits=static_cast<uint32_t>(value_to<int>(memoryTypeBits_json));}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryGetFdInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkMemoryGetFdInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_eyKBrDS;[&](){temp_eyKBrDS=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalMemoryHandleTypeFlagBits)temp_eyKBrDS;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExternalSemaphoreInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExternalSemaphoreInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_MnMNLvU;[&](){temp_MnMNLvU=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalSemaphoreHandleTypeFlagBits)temp_MnMNLvU;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExternalSemaphoreProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& exportFromImportedHandleTypes_json=json["exportFromImportedHandleTypes"];
[&](){[&](){[&](){exportFromImportedHandleTypes_json=member.exportFromImportedHandleTypes;}();}();}();
auto& compatibleHandleTypes_json=json["compatibleHandleTypes"];
[&](){[&](){[&](){compatibleHandleTypes_json=member.compatibleHandleTypes;}();}();}();
auto& externalSemaphoreFeatures_json=json["externalSemaphoreFeatures"];
[&](){[&](){[&](){externalSemaphoreFeatures_json=member.externalSemaphoreFeatures;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExternalSemaphoreProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& exportFromImportedHandleTypes_json=json["exportFromImportedHandleTypes"];
[&](){[&](){int temp_xsxVOQu;[&](){temp_xsxVOQu=static_cast<int>(value_to<int>(exportFromImportedHandleTypes_json));}();member.exportFromImportedHandleTypes=(VkExternalSemaphoreHandleTypeFlags)temp_xsxVOQu;}();}();
auto& compatibleHandleTypes_json=json["compatibleHandleTypes"];
[&](){[&](){int temp_EmLcyuI;[&](){temp_EmLcyuI=static_cast<int>(value_to<int>(compatibleHandleTypes_json));}();member.compatibleHandleTypes=(VkExternalSemaphoreHandleTypeFlags)temp_EmLcyuI;}();}();
auto& externalSemaphoreFeatures_json=json["externalSemaphoreFeatures"];
[&](){[&](){int temp_bTLvhka;[&](){temp_bTLvhka=static_cast<int>(value_to<int>(externalSemaphoreFeatures_json));}();member.externalSemaphoreFeatures=(VkExternalSemaphoreFeatureFlags)temp_bTLvhka;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExportSemaphoreCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){[&](){handleTypes_json=member.handleTypes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExportSemaphoreCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){int temp_UxgEfDq;[&](){temp_UxgEfDq=static_cast<int>(value_to<int>(handleTypes_json));}();member.handleTypes=(VkExternalSemaphoreHandleTypeFlags)temp_UxgEfDq;}();}();
}

    void serialize_struct(boost::json::object& json, const VkImportSemaphoreFdInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& semaphore_json=json["semaphore"];
[&](){serialize_VkSemaphore(semaphore_json,member.semaphore);}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
auto& fd_json=json["fd"];
[&](){fd_json=member.fd;}();
}
void deserialize_struct(boost::json::object& json, VkImportSemaphoreFdInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& semaphore_json=json["semaphore"];
[&](){deserialize_VkSemaphore(semaphore_json, member.semaphore);}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_ezvKDqt;[&](){temp_ezvKDqt=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSemaphoreImportFlags)temp_ezvKDqt;}();}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_MnMNLvU;[&](){temp_MnMNLvU=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalSemaphoreHandleTypeFlagBits)temp_MnMNLvU;}();}();
auto& fd_json=json["fd"];
[&](){member.fd=static_cast<int>(value_to<int>(fd_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSemaphoreGetFdInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& semaphore_json=json["semaphore"];
[&](){serialize_VkSemaphore(semaphore_json,member.semaphore);}();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSemaphoreGetFdInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& semaphore_json=json["semaphore"];
[&](){deserialize_VkSemaphore(semaphore_json, member.semaphore);}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_MnMNLvU;[&](){temp_MnMNLvU=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalSemaphoreHandleTypeFlagBits)temp_MnMNLvU;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExternalFenceInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExternalFenceInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_kPIOJpb;[&](){temp_kPIOJpb=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalFenceHandleTypeFlagBits)temp_kPIOJpb;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExternalFenceProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& exportFromImportedHandleTypes_json=json["exportFromImportedHandleTypes"];
[&](){[&](){[&](){exportFromImportedHandleTypes_json=member.exportFromImportedHandleTypes;}();}();}();
auto& compatibleHandleTypes_json=json["compatibleHandleTypes"];
[&](){[&](){[&](){compatibleHandleTypes_json=member.compatibleHandleTypes;}();}();}();
auto& externalFenceFeatures_json=json["externalFenceFeatures"];
[&](){[&](){[&](){externalFenceFeatures_json=member.externalFenceFeatures;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExternalFenceProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& exportFromImportedHandleTypes_json=json["exportFromImportedHandleTypes"];
[&](){[&](){int temp_FkCZeaD;[&](){temp_FkCZeaD=static_cast<int>(value_to<int>(exportFromImportedHandleTypes_json));}();member.exportFromImportedHandleTypes=(VkExternalFenceHandleTypeFlags)temp_FkCZeaD;}();}();
auto& compatibleHandleTypes_json=json["compatibleHandleTypes"];
[&](){[&](){int temp_kLrkdtd;[&](){temp_kLrkdtd=static_cast<int>(value_to<int>(compatibleHandleTypes_json));}();member.compatibleHandleTypes=(VkExternalFenceHandleTypeFlags)temp_kLrkdtd;}();}();
auto& externalFenceFeatures_json=json["externalFenceFeatures"];
[&](){[&](){int temp_QtjpflL;[&](){temp_QtjpflL=static_cast<int>(value_to<int>(externalFenceFeatures_json));}();member.externalFenceFeatures=(VkExternalFenceFeatureFlags)temp_QtjpflL;}();}();
}

    void serialize_struct(boost::json::object& json, const VkExportFenceCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){[&](){handleTypes_json=member.handleTypes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkExportFenceCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleTypes_json=json["handleTypes"];
[&](){[&](){int temp_aVtCzze;[&](){temp_aVtCzze=static_cast<int>(value_to<int>(handleTypes_json));}();member.handleTypes=(VkExternalFenceHandleTypeFlags)temp_aVtCzze;}();}();
}

    void serialize_struct(boost::json::object& json, const VkImportFenceFdInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fence_json=json["fence"];
[&](){serialize_VkFence(fence_json,member.fence);}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
auto& fd_json=json["fd"];
[&](){fd_json=member.fd;}();
}
void deserialize_struct(boost::json::object& json, VkImportFenceFdInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& fence_json=json["fence"];
[&](){deserialize_VkFence(fence_json, member.fence);}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_AgzZwTI;[&](){temp_AgzZwTI=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkFenceImportFlags)temp_AgzZwTI;}();}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_kPIOJpb;[&](){temp_kPIOJpb=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalFenceHandleTypeFlagBits)temp_kPIOJpb;}();}();
auto& fd_json=json["fd"];
[&](){member.fd=static_cast<int>(value_to<int>(fd_json));}();
}

    void serialize_struct(boost::json::object& json, const VkFenceGetFdInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fence_json=json["fence"];
[&](){serialize_VkFence(fence_json,member.fence);}();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkFenceGetFdInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& fence_json=json["fence"];
[&](){deserialize_VkFence(fence_json, member.fence);}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_kPIOJpb;[&](){temp_kPIOJpb=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalFenceHandleTypeFlagBits)temp_kPIOJpb;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMultiviewFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& multiview_json=json["multiview"];
[&](){[&](){multiview_json=member.multiview;}();}();
auto& multiviewGeometryShader_json=json["multiviewGeometryShader"];
[&](){[&](){multiviewGeometryShader_json=member.multiviewGeometryShader;}();}();
auto& multiviewTessellationShader_json=json["multiviewTessellationShader"];
[&](){[&](){multiviewTessellationShader_json=member.multiviewTessellationShader;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMultiviewFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& multiview_json=json["multiview"];
[&](){uint32_t temp_EEzipVg;[&](){temp_EEzipVg=static_cast<uint32_t>(value_to<int>(multiview_json));}();member.multiview=(VkBool32)temp_EEzipVg;}();
auto& multiviewGeometryShader_json=json["multiviewGeometryShader"];
[&](){uint32_t temp_ZgXANng;[&](){temp_ZgXANng=static_cast<uint32_t>(value_to<int>(multiviewGeometryShader_json));}();member.multiviewGeometryShader=(VkBool32)temp_ZgXANng;}();
auto& multiviewTessellationShader_json=json["multiviewTessellationShader"];
[&](){uint32_t temp_kJVppEY;[&](){temp_kJVppEY=static_cast<uint32_t>(value_to<int>(multiviewTessellationShader_json));}();member.multiviewTessellationShader=(VkBool32)temp_kJVppEY;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMultiviewProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxMultiviewViewCount_json=json["maxMultiviewViewCount"];
[&](){maxMultiviewViewCount_json=member.maxMultiviewViewCount;}();
auto& maxMultiviewInstanceIndex_json=json["maxMultiviewInstanceIndex"];
[&](){maxMultiviewInstanceIndex_json=member.maxMultiviewInstanceIndex;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMultiviewProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxMultiviewViewCount_json=json["maxMultiviewViewCount"];
[&](){member.maxMultiviewViewCount=static_cast<uint32_t>(value_to<int>(maxMultiviewViewCount_json));}();
auto& maxMultiviewInstanceIndex_json=json["maxMultiviewInstanceIndex"];
[&](){member.maxMultiviewInstanceIndex=static_cast<uint32_t>(value_to<int>(maxMultiviewInstanceIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassMultiviewCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& subpassCount_json=json["subpassCount"];
[&](){subpassCount_json=member.subpassCount;}();
auto& pViewMasks_json=json["pViewMasks"];
[&](){
            if (member.pViewMasks==NULL){
                pViewMasks_json=boost::json::array();
            return; }pViewMasks_json=boost::json::array(member.subpassCount);
        auto& arr_kvxvbTW=pViewMasks_json.as_array();
        for(int QCxnKEd=0; QCxnKEd < member.subpassCount; QCxnKEd++){
            [&](){arr_kvxvbTW[QCxnKEd]=member.pViewMasks[QCxnKEd];}();
        }
        }();
auto& dependencyCount_json=json["dependencyCount"];
[&](){dependencyCount_json=member.dependencyCount;}();
auto& pViewOffsets_json=json["pViewOffsets"];
[&](){
            if (member.pViewOffsets==NULL){
                pViewOffsets_json=boost::json::array();
            return; }pViewOffsets_json=boost::json::array(member.dependencyCount);
        auto& arr_dfjKMWh=pViewOffsets_json.as_array();
        for(int toBzgRl=0; toBzgRl < member.dependencyCount; toBzgRl++){
            [&](){arr_dfjKMWh[toBzgRl]=member.pViewOffsets[toBzgRl];}();
        }
        }();
auto& correlationMaskCount_json=json["correlationMaskCount"];
[&](){correlationMaskCount_json=member.correlationMaskCount;}();
auto& pCorrelationMasks_json=json["pCorrelationMasks"];
[&](){
            if (member.pCorrelationMasks==NULL){
                pCorrelationMasks_json=boost::json::array();
            return; }pCorrelationMasks_json=boost::json::array(member.correlationMaskCount);
        auto& arr_JMONgUj=pCorrelationMasks_json.as_array();
        for(int lhTmhiZ=0; lhTmhiZ < member.correlationMaskCount; lhTmhiZ++){
            [&](){arr_JMONgUj[lhTmhiZ]=member.pCorrelationMasks[lhTmhiZ];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassMultiviewCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& subpassCount_json=json["subpassCount"];
[&](){member.subpassCount=static_cast<uint32_t>(value_to<int>(subpassCount_json));}();
auto& pViewMasks_json=json["pViewMasks"];
[&](){ uint32_t* temp_GGiWqJk;;[&](){
            if (pViewMasks_json.as_array().size()==0){
                temp_GGiWqJk=NULL;
            return; }temp_GGiWqJk=(uint32_t*)malloc(member.subpassCount*sizeof(uint32_t));
        auto& arr_sxEoloJ=pViewMasks_json.as_array();
        for(int iEEGzuv=0; iEEGzuv < member.subpassCount; iEEGzuv++){
            [&](){temp_GGiWqJk[iEEGzuv]=static_cast<uint32_t>(value_to<int>(arr_sxEoloJ[iEEGzuv]));}();
        }
        }();member.pViewMasks=temp_GGiWqJk;}();
auto& dependencyCount_json=json["dependencyCount"];
[&](){member.dependencyCount=static_cast<uint32_t>(value_to<int>(dependencyCount_json));}();
auto& pViewOffsets_json=json["pViewOffsets"];
[&](){ int32_t* temp_vtCOeFw;;[&](){
            if (pViewOffsets_json.as_array().size()==0){
                temp_vtCOeFw=NULL;
            return; }temp_vtCOeFw=(int32_t*)malloc(member.dependencyCount*sizeof(int32_t));
        auto& arr_ytlDKTW=pViewOffsets_json.as_array();
        for(int moKbiWL=0; moKbiWL < member.dependencyCount; moKbiWL++){
            [&](){temp_vtCOeFw[moKbiWL]=static_cast<int32_t>(value_to<int>(arr_ytlDKTW[moKbiWL]));}();
        }
        }();member.pViewOffsets=temp_vtCOeFw;}();
auto& correlationMaskCount_json=json["correlationMaskCount"];
[&](){member.correlationMaskCount=static_cast<uint32_t>(value_to<int>(correlationMaskCount_json));}();
auto& pCorrelationMasks_json=json["pCorrelationMasks"];
[&](){ uint32_t* temp_pgounVg;;[&](){
            if (pCorrelationMasks_json.as_array().size()==0){
                temp_pgounVg=NULL;
            return; }temp_pgounVg=(uint32_t*)malloc(member.correlationMaskCount*sizeof(uint32_t));
        auto& arr_zrofKya=pCorrelationMasks_json.as_array();
        for(int xLWevVA=0; xLWevVA < member.correlationMaskCount; xLWevVA++){
            [&](){temp_pgounVg[xLWevVA]=static_cast<uint32_t>(value_to<int>(arr_zrofKya[xLWevVA]));}();
        }
        }();member.pCorrelationMasks=temp_pgounVg;}();
}

    void serialize_struct(boost::json::object& json, const VkSurfaceCapabilities2EXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& minImageCount_json=json["minImageCount"];
[&](){minImageCount_json=member.minImageCount;}();
auto& maxImageCount_json=json["maxImageCount"];
[&](){maxImageCount_json=member.maxImageCount;}();
auto& currentExtent_json=json["currentExtent"];
[&](){
            auto& temp=currentExtent_json.emplace_object();
            return serialize_struct(temp, member.currentExtent);
            }();
auto& minImageExtent_json=json["minImageExtent"];
[&](){
            auto& temp=minImageExtent_json.emplace_object();
            return serialize_struct(temp, member.minImageExtent);
            }();
auto& maxImageExtent_json=json["maxImageExtent"];
[&](){
            auto& temp=maxImageExtent_json.emplace_object();
            return serialize_struct(temp, member.maxImageExtent);
            }();
auto& maxImageArrayLayers_json=json["maxImageArrayLayers"];
[&](){maxImageArrayLayers_json=member.maxImageArrayLayers;}();
auto& supportedTransforms_json=json["supportedTransforms"];
[&](){[&](){[&](){supportedTransforms_json=member.supportedTransforms;}();}();}();
auto& currentTransform_json=json["currentTransform"];
[&](){[&](){[&](){currentTransform_json=member.currentTransform;}();}();}();
auto& supportedCompositeAlpha_json=json["supportedCompositeAlpha"];
[&](){[&](){[&](){supportedCompositeAlpha_json=member.supportedCompositeAlpha;}();}();}();
auto& supportedUsageFlags_json=json["supportedUsageFlags"];
[&](){[&](){[&](){supportedUsageFlags_json=member.supportedUsageFlags;}();}();}();
auto& supportedSurfaceCounters_json=json["supportedSurfaceCounters"];
[&](){[&](){[&](){supportedSurfaceCounters_json=member.supportedSurfaceCounters;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSurfaceCapabilities2EXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& minImageCount_json=json["minImageCount"];
[&](){member.minImageCount=static_cast<uint32_t>(value_to<int>(minImageCount_json));}();
auto& maxImageCount_json=json["maxImageCount"];
[&](){member.maxImageCount=static_cast<uint32_t>(value_to<int>(maxImageCount_json));}();
auto& currentExtent_json=json["currentExtent"];
[&](){
            auto& temp=currentExtent_json.as_object();
            deserialize_struct(temp,member.currentExtent);
            }();
auto& minImageExtent_json=json["minImageExtent"];
[&](){
            auto& temp=minImageExtent_json.as_object();
            deserialize_struct(temp,member.minImageExtent);
            }();
auto& maxImageExtent_json=json["maxImageExtent"];
[&](){
            auto& temp=maxImageExtent_json.as_object();
            deserialize_struct(temp,member.maxImageExtent);
            }();
auto& maxImageArrayLayers_json=json["maxImageArrayLayers"];
[&](){member.maxImageArrayLayers=static_cast<uint32_t>(value_to<int>(maxImageArrayLayers_json));}();
auto& supportedTransforms_json=json["supportedTransforms"];
[&](){[&](){int temp_lOAidao;[&](){temp_lOAidao=static_cast<int>(value_to<int>(supportedTransforms_json));}();member.supportedTransforms=(VkSurfaceTransformFlagsKHR)temp_lOAidao;}();}();
auto& currentTransform_json=json["currentTransform"];
[&](){[&](){int temp_qlBkHeK;[&](){temp_qlBkHeK=static_cast<int>(value_to<int>(currentTransform_json));}();member.currentTransform=(VkSurfaceTransformFlagBitsKHR)temp_qlBkHeK;}();}();
auto& supportedCompositeAlpha_json=json["supportedCompositeAlpha"];
[&](){[&](){int temp_kYiNncV;[&](){temp_kYiNncV=static_cast<int>(value_to<int>(supportedCompositeAlpha_json));}();member.supportedCompositeAlpha=(VkCompositeAlphaFlagsKHR)temp_kYiNncV;}();}();
auto& supportedUsageFlags_json=json["supportedUsageFlags"];
[&](){[&](){int temp_FWyNJlL;[&](){temp_FWyNJlL=static_cast<int>(value_to<int>(supportedUsageFlags_json));}();member.supportedUsageFlags=(VkImageUsageFlags)temp_FWyNJlL;}();}();
auto& supportedSurfaceCounters_json=json["supportedSurfaceCounters"];
[&](){[&](){int temp_ePqdEuZ;[&](){temp_ePqdEuZ=static_cast<int>(value_to<int>(supportedSurfaceCounters_json));}();member.supportedSurfaceCounters=(VkSurfaceCounterFlagsEXT)temp_ePqdEuZ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDisplayPowerInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& powerState_json=json["powerState"];
[&](){[&](){[&](){powerState_json=member.powerState;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDisplayPowerInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& powerState_json=json["powerState"];
[&](){[&](){int temp_IOnmAci;[&](){temp_IOnmAci=static_cast<int>(value_to<int>(powerState_json));}();member.powerState=(VkDisplayPowerStateEXT)temp_IOnmAci;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceEventInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceEvent_json=json["deviceEvent"];
[&](){[&](){[&](){deviceEvent_json=member.deviceEvent;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceEventInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& deviceEvent_json=json["deviceEvent"];
[&](){[&](){int temp_uNtrmEh;[&](){temp_uNtrmEh=static_cast<int>(value_to<int>(deviceEvent_json));}();member.deviceEvent=(VkDeviceEventTypeEXT)temp_uNtrmEh;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDisplayEventInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& displayEvent_json=json["displayEvent"];
[&](){[&](){[&](){displayEvent_json=member.displayEvent;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDisplayEventInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& displayEvent_json=json["displayEvent"];
[&](){[&](){int temp_veOEPjB;[&](){temp_veOEPjB=static_cast<int>(value_to<int>(displayEvent_json));}();member.displayEvent=(VkDisplayEventTypeEXT)temp_veOEPjB;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSwapchainCounterCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& surfaceCounters_json=json["surfaceCounters"];
[&](){[&](){[&](){surfaceCounters_json=member.surfaceCounters;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSwapchainCounterCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& surfaceCounters_json=json["surfaceCounters"];
[&](){[&](){int temp_eXnlLkY;[&](){temp_eXnlLkY=static_cast<int>(value_to<int>(surfaceCounters_json));}();member.surfaceCounters=(VkSurfaceCounterFlagsEXT)temp_eXnlLkY;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceGroupProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& physicalDeviceCount_json=json["physicalDeviceCount"];
[&](){physicalDeviceCount_json=member.physicalDeviceCount;}();
auto& physicalDevices_json=json["physicalDevices"];
[&](){physicalDevices_json=boost::json::array(VK_MAX_DEVICE_GROUP_SIZE);
        auto& arr_XgwsVdm=physicalDevices_json.as_array();
        for(int irLzMAt=0; irLzMAt < VK_MAX_DEVICE_GROUP_SIZE; irLzMAt++){
            [&](){serialize_VkPhysicalDevice(arr_XgwsVdm[irLzMAt],member.physicalDevices[irLzMAt]);}();
        }
        }();
auto& subsetAllocation_json=json["subsetAllocation"];
[&](){[&](){subsetAllocation_json=member.subsetAllocation;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceGroupProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& physicalDeviceCount_json=json["physicalDeviceCount"];
[&](){member.physicalDeviceCount=static_cast<uint32_t>(value_to<int>(physicalDeviceCount_json));}();
auto& physicalDevices_json=json["physicalDevices"];
[&](){
        auto& arr_XgwsVdm=physicalDevices_json.as_array();
        for(int irLzMAt=0; irLzMAt < VK_MAX_DEVICE_GROUP_SIZE; irLzMAt++){
            [&](){deserialize_VkPhysicalDevice(arr_XgwsVdm[irLzMAt], member.physicalDevices[irLzMAt]);}();
        }
        }();
auto& subsetAllocation_json=json["subsetAllocation"];
[&](){uint32_t temp_YlGjcjs;[&](){temp_YlGjcjs=static_cast<uint32_t>(value_to<int>(subsetAllocation_json));}();member.subsetAllocation=(VkBool32)temp_YlGjcjs;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryAllocateFlagsInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& deviceMask_json=json["deviceMask"];
[&](){deviceMask_json=member.deviceMask;}();
}
void deserialize_struct(boost::json::object& json, VkMemoryAllocateFlagsInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_XOTRTrC;[&](){temp_XOTRTrC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkMemoryAllocateFlags)temp_XOTRTrC;}();}();
auto& deviceMask_json=json["deviceMask"];
[&](){member.deviceMask=static_cast<uint32_t>(value_to<int>(deviceMask_json));}();
}

    void serialize_struct(boost::json::object& json, const VkBindBufferMemoryInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){[&](){memoryOffset_json=member.memoryOffset;}();}();
}
void deserialize_struct(boost::json::object& json, VkBindBufferMemoryInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){uint64_t temp_VWSGqtD;[&](){temp_VWSGqtD=static_cast<uint64_t>(value_to<int>(memoryOffset_json));}();member.memoryOffset=(VkDeviceSize)temp_VWSGqtD;}();
}

    void serialize_struct(boost::json::object& json, const VkBindBufferMemoryDeviceGroupInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceIndexCount_json=json["deviceIndexCount"];
[&](){deviceIndexCount_json=member.deviceIndexCount;}();
auto& pDeviceIndices_json=json["pDeviceIndices"];
[&](){
            if (member.pDeviceIndices==NULL){
                pDeviceIndices_json=boost::json::array();
            return; }pDeviceIndices_json=boost::json::array(member.deviceIndexCount);
        auto& arr_ljPbTMN=pDeviceIndices_json.as_array();
        for(int MmIaHqo=0; MmIaHqo < member.deviceIndexCount; MmIaHqo++){
            [&](){arr_ljPbTMN[MmIaHqo]=member.pDeviceIndices[MmIaHqo];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkBindBufferMemoryDeviceGroupInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& deviceIndexCount_json=json["deviceIndexCount"];
[&](){member.deviceIndexCount=static_cast<uint32_t>(value_to<int>(deviceIndexCount_json));}();
auto& pDeviceIndices_json=json["pDeviceIndices"];
[&](){ uint32_t* temp_RfExfNJ;;[&](){
            if (pDeviceIndices_json.as_array().size()==0){
                temp_RfExfNJ=NULL;
            return; }temp_RfExfNJ=(uint32_t*)malloc(member.deviceIndexCount*sizeof(uint32_t));
        auto& arr_QDynsLg=pDeviceIndices_json.as_array();
        for(int YTdkCPI=0; YTdkCPI < member.deviceIndexCount; YTdkCPI++){
            [&](){temp_RfExfNJ[YTdkCPI]=static_cast<uint32_t>(value_to<int>(arr_QDynsLg[YTdkCPI]));}();
        }
        }();member.pDeviceIndices=temp_RfExfNJ;}();
}

    void serialize_struct(boost::json::object& json, const VkBindImageMemoryInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){[&](){memoryOffset_json=member.memoryOffset;}();}();
}
void deserialize_struct(boost::json::object& json, VkBindImageMemoryInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){uint64_t temp_VWSGqtD;[&](){temp_VWSGqtD=static_cast<uint64_t>(value_to<int>(memoryOffset_json));}();member.memoryOffset=(VkDeviceSize)temp_VWSGqtD;}();
}

    void serialize_struct(boost::json::object& json, const VkBindImageMemoryDeviceGroupInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceIndexCount_json=json["deviceIndexCount"];
[&](){deviceIndexCount_json=member.deviceIndexCount;}();
auto& pDeviceIndices_json=json["pDeviceIndices"];
[&](){
            if (member.pDeviceIndices==NULL){
                pDeviceIndices_json=boost::json::array();
            return; }pDeviceIndices_json=boost::json::array(member.deviceIndexCount);
        auto& arr_ljPbTMN=pDeviceIndices_json.as_array();
        for(int MmIaHqo=0; MmIaHqo < member.deviceIndexCount; MmIaHqo++){
            [&](){arr_ljPbTMN[MmIaHqo]=member.pDeviceIndices[MmIaHqo];}();
        }
        }();
auto& splitInstanceBindRegionCount_json=json["splitInstanceBindRegionCount"];
[&](){splitInstanceBindRegionCount_json=member.splitInstanceBindRegionCount;}();
auto& pSplitInstanceBindRegions_json=json["pSplitInstanceBindRegions"];
[&](){
            if (member.pSplitInstanceBindRegions==NULL){
                pSplitInstanceBindRegions_json=boost::json::array();
            return; }pSplitInstanceBindRegions_json=boost::json::array(member.splitInstanceBindRegionCount);
        auto& arr_FsMIswf=pSplitInstanceBindRegions_json.as_array();
        for(int iUbVYoM=0; iUbVYoM < member.splitInstanceBindRegionCount; iUbVYoM++){
            [&](){
            auto& temp=arr_FsMIswf[iUbVYoM].emplace_object();
            return serialize_struct(temp, member.pSplitInstanceBindRegions[iUbVYoM]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkBindImageMemoryDeviceGroupInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& deviceIndexCount_json=json["deviceIndexCount"];
[&](){member.deviceIndexCount=static_cast<uint32_t>(value_to<int>(deviceIndexCount_json));}();
auto& pDeviceIndices_json=json["pDeviceIndices"];
[&](){ uint32_t* temp_RfExfNJ;;[&](){
            if (pDeviceIndices_json.as_array().size()==0){
                temp_RfExfNJ=NULL;
            return; }temp_RfExfNJ=(uint32_t*)malloc(member.deviceIndexCount*sizeof(uint32_t));
        auto& arr_QDynsLg=pDeviceIndices_json.as_array();
        for(int YTdkCPI=0; YTdkCPI < member.deviceIndexCount; YTdkCPI++){
            [&](){temp_RfExfNJ[YTdkCPI]=static_cast<uint32_t>(value_to<int>(arr_QDynsLg[YTdkCPI]));}();
        }
        }();member.pDeviceIndices=temp_RfExfNJ;}();
auto& splitInstanceBindRegionCount_json=json["splitInstanceBindRegionCount"];
[&](){member.splitInstanceBindRegionCount=static_cast<uint32_t>(value_to<int>(splitInstanceBindRegionCount_json));}();
auto& pSplitInstanceBindRegions_json=json["pSplitInstanceBindRegions"];
[&](){ VkRect2D* temp_wgRMBSZ;;[&](){
            if (pSplitInstanceBindRegions_json.as_array().size()==0){
                temp_wgRMBSZ=NULL;
            return; }temp_wgRMBSZ=(VkRect2D*)malloc(member.splitInstanceBindRegionCount*sizeof(VkRect2D));
        auto& arr_sUsGTOY=pSplitInstanceBindRegions_json.as_array();
        for(int GwHzLXU=0; GwHzLXU < member.splitInstanceBindRegionCount; GwHzLXU++){
            [&](){
            auto& temp=arr_sUsGTOY[GwHzLXU].as_object();
            deserialize_struct(temp,temp_wgRMBSZ[GwHzLXU]);
            }();
        }
        }();member.pSplitInstanceBindRegions=temp_wgRMBSZ;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceGroupRenderPassBeginInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceMask_json=json["deviceMask"];
[&](){deviceMask_json=member.deviceMask;}();
auto& deviceRenderAreaCount_json=json["deviceRenderAreaCount"];
[&](){deviceRenderAreaCount_json=member.deviceRenderAreaCount;}();
auto& pDeviceRenderAreas_json=json["pDeviceRenderAreas"];
[&](){
            if (member.pDeviceRenderAreas==NULL){
                pDeviceRenderAreas_json=boost::json::array();
            return; }pDeviceRenderAreas_json=boost::json::array(member.deviceRenderAreaCount);
        auto& arr_FLwGcSx=pDeviceRenderAreas_json.as_array();
        for(int EOKQvdK=0; EOKQvdK < member.deviceRenderAreaCount; EOKQvdK++){
            [&](){
            auto& temp=arr_FLwGcSx[EOKQvdK].emplace_object();
            return serialize_struct(temp, member.pDeviceRenderAreas[EOKQvdK]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDeviceGroupRenderPassBeginInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& deviceMask_json=json["deviceMask"];
[&](){member.deviceMask=static_cast<uint32_t>(value_to<int>(deviceMask_json));}();
auto& deviceRenderAreaCount_json=json["deviceRenderAreaCount"];
[&](){member.deviceRenderAreaCount=static_cast<uint32_t>(value_to<int>(deviceRenderAreaCount_json));}();
auto& pDeviceRenderAreas_json=json["pDeviceRenderAreas"];
[&](){ VkRect2D* temp_wIlvcNB;;[&](){
            if (pDeviceRenderAreas_json.as_array().size()==0){
                temp_wIlvcNB=NULL;
            return; }temp_wIlvcNB=(VkRect2D*)malloc(member.deviceRenderAreaCount*sizeof(VkRect2D));
        auto& arr_cMmdsTY=pDeviceRenderAreas_json.as_array();
        for(int mrmrewt=0; mrmrewt < member.deviceRenderAreaCount; mrmrewt++){
            [&](){
            auto& temp=arr_cMmdsTY[mrmrewt].as_object();
            deserialize_struct(temp,temp_wIlvcNB[mrmrewt]);
            }();
        }
        }();member.pDeviceRenderAreas=temp_wIlvcNB;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceGroupCommandBufferBeginInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceMask_json=json["deviceMask"];
[&](){deviceMask_json=member.deviceMask;}();
}
void deserialize_struct(boost::json::object& json, VkDeviceGroupCommandBufferBeginInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& deviceMask_json=json["deviceMask"];
[&](){member.deviceMask=static_cast<uint32_t>(value_to<int>(deviceMask_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceGroupSubmitInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& waitSemaphoreCount_json=json["waitSemaphoreCount"];
[&](){waitSemaphoreCount_json=member.waitSemaphoreCount;}();
auto& pWaitSemaphoreDeviceIndices_json=json["pWaitSemaphoreDeviceIndices"];
[&](){
            if (member.pWaitSemaphoreDeviceIndices==NULL){
                pWaitSemaphoreDeviceIndices_json=boost::json::array();
            return; }pWaitSemaphoreDeviceIndices_json=boost::json::array(member.waitSemaphoreCount);
        auto& arr_iAzsMfo=pWaitSemaphoreDeviceIndices_json.as_array();
        for(int vMaGqQO=0; vMaGqQO < member.waitSemaphoreCount; vMaGqQO++){
            [&](){arr_iAzsMfo[vMaGqQO]=member.pWaitSemaphoreDeviceIndices[vMaGqQO];}();
        }
        }();
auto& commandBufferCount_json=json["commandBufferCount"];
[&](){commandBufferCount_json=member.commandBufferCount;}();
auto& pCommandBufferDeviceMasks_json=json["pCommandBufferDeviceMasks"];
[&](){
            if (member.pCommandBufferDeviceMasks==NULL){
                pCommandBufferDeviceMasks_json=boost::json::array();
            return; }pCommandBufferDeviceMasks_json=boost::json::array(member.commandBufferCount);
        auto& arr_DUTiEGO=pCommandBufferDeviceMasks_json.as_array();
        for(int jqFUlKM=0; jqFUlKM < member.commandBufferCount; jqFUlKM++){
            [&](){arr_DUTiEGO[jqFUlKM]=member.pCommandBufferDeviceMasks[jqFUlKM];}();
        }
        }();
auto& signalSemaphoreCount_json=json["signalSemaphoreCount"];
[&](){signalSemaphoreCount_json=member.signalSemaphoreCount;}();
auto& pSignalSemaphoreDeviceIndices_json=json["pSignalSemaphoreDeviceIndices"];
[&](){
            if (member.pSignalSemaphoreDeviceIndices==NULL){
                pSignalSemaphoreDeviceIndices_json=boost::json::array();
            return; }pSignalSemaphoreDeviceIndices_json=boost::json::array(member.signalSemaphoreCount);
        auto& arr_ILMUvlb=pSignalSemaphoreDeviceIndices_json.as_array();
        for(int KGcJCbp=0; KGcJCbp < member.signalSemaphoreCount; KGcJCbp++){
            [&](){arr_ILMUvlb[KGcJCbp]=member.pSignalSemaphoreDeviceIndices[KGcJCbp];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDeviceGroupSubmitInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& waitSemaphoreCount_json=json["waitSemaphoreCount"];
[&](){member.waitSemaphoreCount=static_cast<uint32_t>(value_to<int>(waitSemaphoreCount_json));}();
auto& pWaitSemaphoreDeviceIndices_json=json["pWaitSemaphoreDeviceIndices"];
[&](){ uint32_t* temp_aWXXFwt;;[&](){
            if (pWaitSemaphoreDeviceIndices_json.as_array().size()==0){
                temp_aWXXFwt=NULL;
            return; }temp_aWXXFwt=(uint32_t*)malloc(member.waitSemaphoreCount*sizeof(uint32_t));
        auto& arr_aPELlBO=pWaitSemaphoreDeviceIndices_json.as_array();
        for(int cWsFNmn=0; cWsFNmn < member.waitSemaphoreCount; cWsFNmn++){
            [&](){temp_aWXXFwt[cWsFNmn]=static_cast<uint32_t>(value_to<int>(arr_aPELlBO[cWsFNmn]));}();
        }
        }();member.pWaitSemaphoreDeviceIndices=temp_aWXXFwt;}();
auto& commandBufferCount_json=json["commandBufferCount"];
[&](){member.commandBufferCount=static_cast<uint32_t>(value_to<int>(commandBufferCount_json));}();
auto& pCommandBufferDeviceMasks_json=json["pCommandBufferDeviceMasks"];
[&](){ uint32_t* temp_RWLcEPp;;[&](){
            if (pCommandBufferDeviceMasks_json.as_array().size()==0){
                temp_RWLcEPp=NULL;
            return; }temp_RWLcEPp=(uint32_t*)malloc(member.commandBufferCount*sizeof(uint32_t));
        auto& arr_ublNTmX=pCommandBufferDeviceMasks_json.as_array();
        for(int WydNvmR=0; WydNvmR < member.commandBufferCount; WydNvmR++){
            [&](){temp_RWLcEPp[WydNvmR]=static_cast<uint32_t>(value_to<int>(arr_ublNTmX[WydNvmR]));}();
        }
        }();member.pCommandBufferDeviceMasks=temp_RWLcEPp;}();
auto& signalSemaphoreCount_json=json["signalSemaphoreCount"];
[&](){member.signalSemaphoreCount=static_cast<uint32_t>(value_to<int>(signalSemaphoreCount_json));}();
auto& pSignalSemaphoreDeviceIndices_json=json["pSignalSemaphoreDeviceIndices"];
[&](){ uint32_t* temp_AWqAuWW;;[&](){
            if (pSignalSemaphoreDeviceIndices_json.as_array().size()==0){
                temp_AWqAuWW=NULL;
            return; }temp_AWqAuWW=(uint32_t*)malloc(member.signalSemaphoreCount*sizeof(uint32_t));
        auto& arr_FctaLev=pSignalSemaphoreDeviceIndices_json.as_array();
        for(int vBTkmAq=0; vBTkmAq < member.signalSemaphoreCount; vBTkmAq++){
            [&](){temp_AWqAuWW[vBTkmAq]=static_cast<uint32_t>(value_to<int>(arr_FctaLev[vBTkmAq]));}();
        }
        }();member.pSignalSemaphoreDeviceIndices=temp_AWqAuWW;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceGroupBindSparseInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& resourceDeviceIndex_json=json["resourceDeviceIndex"];
[&](){resourceDeviceIndex_json=member.resourceDeviceIndex;}();
auto& memoryDeviceIndex_json=json["memoryDeviceIndex"];
[&](){memoryDeviceIndex_json=member.memoryDeviceIndex;}();
}
void deserialize_struct(boost::json::object& json, VkDeviceGroupBindSparseInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& resourceDeviceIndex_json=json["resourceDeviceIndex"];
[&](){member.resourceDeviceIndex=static_cast<uint32_t>(value_to<int>(resourceDeviceIndex_json));}();
auto& memoryDeviceIndex_json=json["memoryDeviceIndex"];
[&](){member.memoryDeviceIndex=static_cast<uint32_t>(value_to<int>(memoryDeviceIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceGroupPresentCapabilitiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& presentMask_json=json["presentMask"];
[&](){presentMask_json=boost::json::array(VK_MAX_DEVICE_GROUP_SIZE);
        auto& arr_tEmzMzn=presentMask_json.as_array();
        for(int DNQcEdD=0; DNQcEdD < VK_MAX_DEVICE_GROUP_SIZE; DNQcEdD++){
            [&](){arr_tEmzMzn[DNQcEdD]=member.presentMask[DNQcEdD];}();
        }
        }();
auto& modes_json=json["modes"];
[&](){[&](){[&](){modes_json=member.modes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceGroupPresentCapabilitiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& presentMask_json=json["presentMask"];
[&](){
        auto& arr_tEmzMzn=presentMask_json.as_array();
        for(int DNQcEdD=0; DNQcEdD < VK_MAX_DEVICE_GROUP_SIZE; DNQcEdD++){
            [&](){member.presentMask[DNQcEdD]=static_cast<uint32_t>(value_to<int>(arr_tEmzMzn[DNQcEdD]));}();
        }
        }();
auto& modes_json=json["modes"];
[&](){[&](){int temp_uiGUyqC;[&](){temp_uiGUyqC=static_cast<int>(value_to<int>(modes_json));}();member.modes=(VkDeviceGroupPresentModeFlagsKHR)temp_uiGUyqC;}();}();
}

    void serialize_struct(boost::json::object& json, const VkImageSwapchainCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchain_json=json["swapchain"];
[&](){serialize_VkSwapchainKHR(swapchain_json,member.swapchain);}();
}
void deserialize_struct(boost::json::object& json, VkImageSwapchainCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchain_json=json["swapchain"];
[&](){deserialize_VkSwapchainKHR(swapchain_json, member.swapchain);}();
}

    void serialize_struct(boost::json::object& json, const VkBindImageMemorySwapchainInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchain_json=json["swapchain"];
[&](){serialize_VkSwapchainKHR(swapchain_json,member.swapchain);}();
auto& imageIndex_json=json["imageIndex"];
[&](){imageIndex_json=member.imageIndex;}();
}
void deserialize_struct(boost::json::object& json, VkBindImageMemorySwapchainInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchain_json=json["swapchain"];
[&](){deserialize_VkSwapchainKHR(swapchain_json, member.swapchain);}();
auto& imageIndex_json=json["imageIndex"];
[&](){member.imageIndex=static_cast<uint32_t>(value_to<int>(imageIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkAcquireNextImageInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchain_json=json["swapchain"];
[&](){serialize_VkSwapchainKHR(swapchain_json,member.swapchain);}();
auto& timeout_json=json["timeout"];
[&](){timeout_json=member.timeout;}();
auto& semaphore_json=json["semaphore"];
[&](){serialize_VkSemaphore(semaphore_json,member.semaphore);}();
auto& fence_json=json["fence"];
[&](){serialize_VkFence(fence_json,member.fence);}();
auto& deviceMask_json=json["deviceMask"];
[&](){deviceMask_json=member.deviceMask;}();
}
void deserialize_struct(boost::json::object& json, VkAcquireNextImageInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchain_json=json["swapchain"];
[&](){deserialize_VkSwapchainKHR(swapchain_json, member.swapchain);}();
auto& timeout_json=json["timeout"];
[&](){member.timeout=static_cast<uint64_t>(value_to<int>(timeout_json));}();
auto& semaphore_json=json["semaphore"];
[&](){deserialize_VkSemaphore(semaphore_json, member.semaphore);}();
auto& fence_json=json["fence"];
[&](){deserialize_VkFence(fence_json, member.fence);}();
auto& deviceMask_json=json["deviceMask"];
[&](){member.deviceMask=static_cast<uint32_t>(value_to<int>(deviceMask_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceGroupPresentInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchainCount_json=json["swapchainCount"];
[&](){swapchainCount_json=member.swapchainCount;}();
auto& pDeviceMasks_json=json["pDeviceMasks"];
[&](){
            if (member.pDeviceMasks==NULL){
                pDeviceMasks_json=boost::json::array();
            return; }pDeviceMasks_json=boost::json::array(member.swapchainCount);
        auto& arr_wjDKIas=pDeviceMasks_json.as_array();
        for(int pSguQXR=0; pSguQXR < member.swapchainCount; pSguQXR++){
            [&](){arr_wjDKIas[pSguQXR]=member.pDeviceMasks[pSguQXR];}();
        }
        }();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceGroupPresentInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchainCount_json=json["swapchainCount"];
[&](){member.swapchainCount=static_cast<uint32_t>(value_to<int>(swapchainCount_json));}();
auto& pDeviceMasks_json=json["pDeviceMasks"];
[&](){ uint32_t* temp_WYRaIcO;;[&](){
            if (pDeviceMasks_json.as_array().size()==0){
                temp_WYRaIcO=NULL;
            return; }temp_WYRaIcO=(uint32_t*)malloc(member.swapchainCount*sizeof(uint32_t));
        auto& arr_DNmntvk=pDeviceMasks_json.as_array();
        for(int SEjujOn=0; SEjujOn < member.swapchainCount; SEjujOn++){
            [&](){temp_WYRaIcO[SEjujOn]=static_cast<uint32_t>(value_to<int>(arr_DNmntvk[SEjujOn]));}();
        }
        }();member.pDeviceMasks=temp_WYRaIcO;}();
auto& mode_json=json["mode"];
[&](){[&](){int temp_LgapcGG;[&](){temp_LgapcGG=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkDeviceGroupPresentModeFlagBitsKHR)temp_LgapcGG;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceGroupDeviceCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& physicalDeviceCount_json=json["physicalDeviceCount"];
[&](){physicalDeviceCount_json=member.physicalDeviceCount;}();
auto& pPhysicalDevices_json=json["pPhysicalDevices"];
[&](){
            if (member.pPhysicalDevices==NULL){
                pPhysicalDevices_json=boost::json::array();
            return; }pPhysicalDevices_json=boost::json::array(member.physicalDeviceCount);
        auto& arr_JJiHDoF=pPhysicalDevices_json.as_array();
        for(int oqOlCTN=0; oqOlCTN < member.physicalDeviceCount; oqOlCTN++){
            [&](){serialize_VkPhysicalDevice(arr_JJiHDoF[oqOlCTN],member.pPhysicalDevices[oqOlCTN]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDeviceGroupDeviceCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& physicalDeviceCount_json=json["physicalDeviceCount"];
[&](){member.physicalDeviceCount=static_cast<uint32_t>(value_to<int>(physicalDeviceCount_json));}();
auto& pPhysicalDevices_json=json["pPhysicalDevices"];
[&](){ VkPhysicalDevice* temp_wsvDXPF;;[&](){
            if (pPhysicalDevices_json.as_array().size()==0){
                temp_wsvDXPF=NULL;
            return; }temp_wsvDXPF=(VkPhysicalDevice*)malloc(member.physicalDeviceCount*sizeof(VkPhysicalDevice));
        auto& arr_oImiiar=pPhysicalDevices_json.as_array();
        for(int rsLzJos=0; rsLzJos < member.physicalDeviceCount; rsLzJos++){
            [&](){deserialize_VkPhysicalDevice(arr_oImiiar[rsLzJos], temp_wsvDXPF[rsLzJos]);}();
        }
        }();member.pPhysicalDevices=temp_wsvDXPF;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceGroupSwapchainCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& modes_json=json["modes"];
[&](){[&](){[&](){modes_json=member.modes;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceGroupSwapchainCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& modes_json=json["modes"];
[&](){[&](){int temp_uiGUyqC;[&](){temp_uiGUyqC=static_cast<int>(value_to<int>(modes_json));}();member.modes=(VkDeviceGroupPresentModeFlagsKHR)temp_uiGUyqC;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorUpdateTemplateEntry& member){
        
    
auto& dstBinding_json=json["dstBinding"];
[&](){dstBinding_json=member.dstBinding;}();
auto& dstArrayElement_json=json["dstArrayElement"];
[&](){dstArrayElement_json=member.dstArrayElement;}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){descriptorCount_json=member.descriptorCount;}();
auto& descriptorType_json=json["descriptorType"];
[&](){[&](){[&](){descriptorType_json=member.descriptorType;}();}();}();
auto& offset_json=json["offset"];
[&](){offset_json=member.offset;}();
auto& stride_json=json["stride"];
[&](){stride_json=member.stride;}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorUpdateTemplateEntry& member){
auto& dstBinding_json=json["dstBinding"];
[&](){member.dstBinding=static_cast<uint32_t>(value_to<int>(dstBinding_json));}();
auto& dstArrayElement_json=json["dstArrayElement"];
[&](){member.dstArrayElement=static_cast<uint32_t>(value_to<int>(dstArrayElement_json));}();
auto& descriptorCount_json=json["descriptorCount"];
[&](){member.descriptorCount=static_cast<uint32_t>(value_to<int>(descriptorCount_json));}();
auto& descriptorType_json=json["descriptorType"];
[&](){[&](){int temp_LETzuZb;[&](){temp_LETzuZb=static_cast<int>(value_to<int>(descriptorType_json));}();member.descriptorType=(VkDescriptorType)temp_LETzuZb;}();}();
auto& offset_json=json["offset"];
[&](){member.offset=static_cast<size_t>(value_to<int>(offset_json));}();
auto& stride_json=json["stride"];
[&](){member.stride=static_cast<size_t>(value_to<int>(stride_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorUpdateTemplateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& descriptorUpdateEntryCount_json=json["descriptorUpdateEntryCount"];
[&](){descriptorUpdateEntryCount_json=member.descriptorUpdateEntryCount;}();
auto& pDescriptorUpdateEntries_json=json["pDescriptorUpdateEntries"];
[&](){
            if (member.pDescriptorUpdateEntries==NULL){
                pDescriptorUpdateEntries_json=boost::json::array();
            return; }pDescriptorUpdateEntries_json=boost::json::array(member.descriptorUpdateEntryCount);
        auto& arr_BLOEwgs=pDescriptorUpdateEntries_json.as_array();
        for(int WgnFqqF=0; WgnFqqF < member.descriptorUpdateEntryCount; WgnFqqF++){
            [&](){
            auto& temp=arr_BLOEwgs[WgnFqqF].emplace_object();
            return serialize_struct(temp, member.pDescriptorUpdateEntries[WgnFqqF]);
            }();
        }
        }();
auto& templateType_json=json["templateType"];
[&](){[&](){[&](){templateType_json=member.templateType;}();}();}();
auto& descriptorSetLayout_json=json["descriptorSetLayout"];
[&](){serialize_VkDescriptorSetLayout(descriptorSetLayout_json,member.descriptorSetLayout);}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){[&](){pipelineBindPoint_json=member.pipelineBindPoint;}();}();}();
auto& pipelineLayout_json=json["pipelineLayout"];
[&](){serialize_VkPipelineLayout(pipelineLayout_json,member.pipelineLayout);}();
auto& set_json=json["set"];
[&](){set_json=member.set;}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorUpdateTemplateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_aeiGJAz;[&](){temp_aeiGJAz=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDescriptorUpdateTemplateCreateFlags)temp_aeiGJAz;}();}();
auto& descriptorUpdateEntryCount_json=json["descriptorUpdateEntryCount"];
[&](){member.descriptorUpdateEntryCount=static_cast<uint32_t>(value_to<int>(descriptorUpdateEntryCount_json));}();
auto& pDescriptorUpdateEntries_json=json["pDescriptorUpdateEntries"];
[&](){ VkDescriptorUpdateTemplateEntry* temp_iyHOWoc;;[&](){
            if (pDescriptorUpdateEntries_json.as_array().size()==0){
                temp_iyHOWoc=NULL;
            return; }temp_iyHOWoc=(VkDescriptorUpdateTemplateEntry*)malloc(member.descriptorUpdateEntryCount*sizeof(VkDescriptorUpdateTemplateEntry));
        auto& arr_BznpzTz=pDescriptorUpdateEntries_json.as_array();
        for(int LqVfgTl=0; LqVfgTl < member.descriptorUpdateEntryCount; LqVfgTl++){
            [&](){
            auto& temp=arr_BznpzTz[LqVfgTl].as_object();
            deserialize_struct(temp,temp_iyHOWoc[LqVfgTl]);
            }();
        }
        }();member.pDescriptorUpdateEntries=temp_iyHOWoc;}();
auto& templateType_json=json["templateType"];
[&](){[&](){int temp_wUAPLnX;[&](){temp_wUAPLnX=static_cast<int>(value_to<int>(templateType_json));}();member.templateType=(VkDescriptorUpdateTemplateType)temp_wUAPLnX;}();}();
auto& descriptorSetLayout_json=json["descriptorSetLayout"];
[&](){deserialize_VkDescriptorSetLayout(descriptorSetLayout_json, member.descriptorSetLayout);}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){int temp_WiAtSfj;[&](){temp_WiAtSfj=static_cast<int>(value_to<int>(pipelineBindPoint_json));}();member.pipelineBindPoint=(VkPipelineBindPoint)temp_WiAtSfj;}();}();
auto& pipelineLayout_json=json["pipelineLayout"];
[&](){deserialize_VkPipelineLayout(pipelineLayout_json, member.pipelineLayout);}();
auto& set_json=json["set"];
[&](){member.set=static_cast<uint32_t>(value_to<int>(set_json));}();
}

    void serialize_struct(boost::json::object& json, const VkXYColorEXT& member){
        
    
auto& x_json=json["x"];
[&](){x_json=member.x;}();
auto& y_json=json["y"];
[&](){y_json=member.y;}();
}
void deserialize_struct(boost::json::object& json, VkXYColorEXT& member){
auto& x_json=json["x"];
[&](){member.x=static_cast<float>(value_to<int>(x_json));}();
auto& y_json=json["y"];
[&](){member.y=static_cast<float>(value_to<int>(y_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePresentIdFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& presentId_json=json["presentId"];
[&](){[&](){presentId_json=member.presentId;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePresentIdFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& presentId_json=json["presentId"];
[&](){uint32_t temp_CTbfxaZ;[&](){temp_CTbfxaZ=static_cast<uint32_t>(value_to<int>(presentId_json));}();member.presentId=(VkBool32)temp_CTbfxaZ;}();
}

    void serialize_struct(boost::json::object& json, const VkPresentIdKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchainCount_json=json["swapchainCount"];
[&](){swapchainCount_json=member.swapchainCount;}();
auto& pPresentIds_json=json["pPresentIds"];
[&](){
            if (member.pPresentIds==NULL){
                pPresentIds_json=boost::json::array();
            return; }pPresentIds_json=boost::json::array(member.swapchainCount);
        auto& arr_JbMyrXK=pPresentIds_json.as_array();
        for(int KzCxaLT=0; KzCxaLT < member.swapchainCount; KzCxaLT++){
            [&](){arr_JbMyrXK[KzCxaLT]=member.pPresentIds[KzCxaLT];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPresentIdKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchainCount_json=json["swapchainCount"];
[&](){member.swapchainCount=static_cast<uint32_t>(value_to<int>(swapchainCount_json));}();
auto& pPresentIds_json=json["pPresentIds"];
[&](){ uint64_t* temp_gazNfWi;;[&](){
            if (pPresentIds_json.as_array().size()==0){
                temp_gazNfWi=NULL;
            return; }temp_gazNfWi=(uint64_t*)malloc(member.swapchainCount*sizeof(uint64_t));
        auto& arr_obaJmrk=pPresentIds_json.as_array();
        for(int UdVGywH=0; UdVGywH < member.swapchainCount; UdVGywH++){
            [&](){temp_gazNfWi[UdVGywH]=static_cast<uint64_t>(value_to<int>(arr_obaJmrk[UdVGywH]));}();
        }
        }();member.pPresentIds=temp_gazNfWi;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePresentWaitFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& presentWait_json=json["presentWait"];
[&](){[&](){presentWait_json=member.presentWait;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePresentWaitFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& presentWait_json=json["presentWait"];
[&](){uint32_t temp_tEldlAC;[&](){temp_tEldlAC=static_cast<uint32_t>(value_to<int>(presentWait_json));}();member.presentWait=(VkBool32)temp_tEldlAC;}();
}

    void serialize_struct(boost::json::object& json, const VkHdrMetadataEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& displayPrimaryRed_json=json["displayPrimaryRed"];
[&](){
            auto& temp=displayPrimaryRed_json.emplace_object();
            return serialize_struct(temp, member.displayPrimaryRed);
            }();
auto& displayPrimaryGreen_json=json["displayPrimaryGreen"];
[&](){
            auto& temp=displayPrimaryGreen_json.emplace_object();
            return serialize_struct(temp, member.displayPrimaryGreen);
            }();
auto& displayPrimaryBlue_json=json["displayPrimaryBlue"];
[&](){
            auto& temp=displayPrimaryBlue_json.emplace_object();
            return serialize_struct(temp, member.displayPrimaryBlue);
            }();
auto& whitePoint_json=json["whitePoint"];
[&](){
            auto& temp=whitePoint_json.emplace_object();
            return serialize_struct(temp, member.whitePoint);
            }();
auto& maxLuminance_json=json["maxLuminance"];
[&](){maxLuminance_json=member.maxLuminance;}();
auto& minLuminance_json=json["minLuminance"];
[&](){minLuminance_json=member.minLuminance;}();
auto& maxContentLightLevel_json=json["maxContentLightLevel"];
[&](){maxContentLightLevel_json=member.maxContentLightLevel;}();
auto& maxFrameAverageLightLevel_json=json["maxFrameAverageLightLevel"];
[&](){maxFrameAverageLightLevel_json=member.maxFrameAverageLightLevel;}();
}
void deserialize_struct(boost::json::object& json, VkHdrMetadataEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& displayPrimaryRed_json=json["displayPrimaryRed"];
[&](){
            auto& temp=displayPrimaryRed_json.as_object();
            deserialize_struct(temp,member.displayPrimaryRed);
            }();
auto& displayPrimaryGreen_json=json["displayPrimaryGreen"];
[&](){
            auto& temp=displayPrimaryGreen_json.as_object();
            deserialize_struct(temp,member.displayPrimaryGreen);
            }();
auto& displayPrimaryBlue_json=json["displayPrimaryBlue"];
[&](){
            auto& temp=displayPrimaryBlue_json.as_object();
            deserialize_struct(temp,member.displayPrimaryBlue);
            }();
auto& whitePoint_json=json["whitePoint"];
[&](){
            auto& temp=whitePoint_json.as_object();
            deserialize_struct(temp,member.whitePoint);
            }();
auto& maxLuminance_json=json["maxLuminance"];
[&](){member.maxLuminance=static_cast<float>(value_to<int>(maxLuminance_json));}();
auto& minLuminance_json=json["minLuminance"];
[&](){member.minLuminance=static_cast<float>(value_to<int>(minLuminance_json));}();
auto& maxContentLightLevel_json=json["maxContentLightLevel"];
[&](){member.maxContentLightLevel=static_cast<float>(value_to<int>(maxContentLightLevel_json));}();
auto& maxFrameAverageLightLevel_json=json["maxFrameAverageLightLevel"];
[&](){member.maxFrameAverageLightLevel=static_cast<float>(value_to<int>(maxFrameAverageLightLevel_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDisplayNativeHdrSurfaceCapabilitiesAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& localDimmingSupport_json=json["localDimmingSupport"];
[&](){[&](){localDimmingSupport_json=member.localDimmingSupport;}();}();
}
void deserialize_struct(boost::json::object& json, VkDisplayNativeHdrSurfaceCapabilitiesAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& localDimmingSupport_json=json["localDimmingSupport"];
[&](){uint32_t temp_CjudapB;[&](){temp_CjudapB=static_cast<uint32_t>(value_to<int>(localDimmingSupport_json));}();member.localDimmingSupport=(VkBool32)temp_CjudapB;}();
}

    void serialize_struct(boost::json::object& json, const VkSwapchainDisplayNativeHdrCreateInfoAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& localDimmingEnable_json=json["localDimmingEnable"];
[&](){[&](){localDimmingEnable_json=member.localDimmingEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkSwapchainDisplayNativeHdrCreateInfoAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& localDimmingEnable_json=json["localDimmingEnable"];
[&](){uint32_t temp_tONrOkU;[&](){temp_tONrOkU=static_cast<uint32_t>(value_to<int>(localDimmingEnable_json));}();member.localDimmingEnable=(VkBool32)temp_tONrOkU;}();
}

    void serialize_struct(boost::json::object& json, const VkRefreshCycleDurationGOOGLE& member){
        
    
auto& refreshDuration_json=json["refreshDuration"];
[&](){refreshDuration_json=member.refreshDuration;}();
}
void deserialize_struct(boost::json::object& json, VkRefreshCycleDurationGOOGLE& member){
auto& refreshDuration_json=json["refreshDuration"];
[&](){member.refreshDuration=static_cast<uint64_t>(value_to<int>(refreshDuration_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPastPresentationTimingGOOGLE& member){
        
    
auto& presentID_json=json["presentID"];
[&](){presentID_json=member.presentID;}();
auto& desiredPresentTime_json=json["desiredPresentTime"];
[&](){desiredPresentTime_json=member.desiredPresentTime;}();
auto& actualPresentTime_json=json["actualPresentTime"];
[&](){actualPresentTime_json=member.actualPresentTime;}();
auto& earliestPresentTime_json=json["earliestPresentTime"];
[&](){earliestPresentTime_json=member.earliestPresentTime;}();
auto& presentMargin_json=json["presentMargin"];
[&](){presentMargin_json=member.presentMargin;}();
}
void deserialize_struct(boost::json::object& json, VkPastPresentationTimingGOOGLE& member){
auto& presentID_json=json["presentID"];
[&](){member.presentID=static_cast<uint32_t>(value_to<int>(presentID_json));}();
auto& desiredPresentTime_json=json["desiredPresentTime"];
[&](){member.desiredPresentTime=static_cast<uint64_t>(value_to<int>(desiredPresentTime_json));}();
auto& actualPresentTime_json=json["actualPresentTime"];
[&](){member.actualPresentTime=static_cast<uint64_t>(value_to<int>(actualPresentTime_json));}();
auto& earliestPresentTime_json=json["earliestPresentTime"];
[&](){member.earliestPresentTime=static_cast<uint64_t>(value_to<int>(earliestPresentTime_json));}();
auto& presentMargin_json=json["presentMargin"];
[&](){member.presentMargin=static_cast<uint64_t>(value_to<int>(presentMargin_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPresentTimesInfoGOOGLE& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchainCount_json=json["swapchainCount"];
[&](){swapchainCount_json=member.swapchainCount;}();
auto& pTimes_json=json["pTimes"];
[&](){
            if (member.pTimes==NULL){
                pTimes_json=boost::json::array();
            return; }pTimes_json=boost::json::array(member.swapchainCount);
        auto& arr_bWdteDC=pTimes_json.as_array();
        for(int rQvvJDb=0; rQvvJDb < member.swapchainCount; rQvvJDb++){
            [&](){
            auto& temp=arr_bWdteDC[rQvvJDb].emplace_object();
            return serialize_struct(temp, member.pTimes[rQvvJDb]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPresentTimesInfoGOOGLE& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchainCount_json=json["swapchainCount"];
[&](){member.swapchainCount=static_cast<uint32_t>(value_to<int>(swapchainCount_json));}();
auto& pTimes_json=json["pTimes"];
[&](){ VkPresentTimeGOOGLE* temp_jAJCyel;;[&](){
            if (pTimes_json.as_array().size()==0){
                temp_jAJCyel=NULL;
            return; }temp_jAJCyel=(VkPresentTimeGOOGLE*)malloc(member.swapchainCount*sizeof(VkPresentTimeGOOGLE));
        auto& arr_ROmOpDb=pTimes_json.as_array();
        for(int amIHkza=0; amIHkza < member.swapchainCount; amIHkza++){
            [&](){
            auto& temp=arr_ROmOpDb[amIHkza].as_object();
            deserialize_struct(temp,temp_jAJCyel[amIHkza]);
            }();
        }
        }();member.pTimes=temp_jAJCyel;}();
}

    void serialize_struct(boost::json::object& json, const VkPresentTimeGOOGLE& member){
        
    
auto& presentID_json=json["presentID"];
[&](){presentID_json=member.presentID;}();
auto& desiredPresentTime_json=json["desiredPresentTime"];
[&](){desiredPresentTime_json=member.desiredPresentTime;}();
}
void deserialize_struct(boost::json::object& json, VkPresentTimeGOOGLE& member){
auto& presentID_json=json["presentID"];
[&](){member.presentID=static_cast<uint32_t>(value_to<int>(presentID_json));}();
auto& desiredPresentTime_json=json["desiredPresentTime"];
[&](){member.desiredPresentTime=static_cast<uint64_t>(value_to<int>(desiredPresentTime_json));}();
}

    void serialize_struct(boost::json::object& json, const VkViewportWScalingNV& member){
        
    
auto& xcoeff_json=json["xcoeff"];
[&](){xcoeff_json=member.xcoeff;}();
auto& ycoeff_json=json["ycoeff"];
[&](){ycoeff_json=member.ycoeff;}();
}
void deserialize_struct(boost::json::object& json, VkViewportWScalingNV& member){
auto& xcoeff_json=json["xcoeff"];
[&](){member.xcoeff=static_cast<float>(value_to<int>(xcoeff_json));}();
auto& ycoeff_json=json["ycoeff"];
[&](){member.ycoeff=static_cast<float>(value_to<int>(ycoeff_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineViewportWScalingStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& viewportWScalingEnable_json=json["viewportWScalingEnable"];
[&](){[&](){viewportWScalingEnable_json=member.viewportWScalingEnable;}();}();
auto& viewportCount_json=json["viewportCount"];
[&](){viewportCount_json=member.viewportCount;}();
auto& pViewportWScalings_json=json["pViewportWScalings"];
[&](){
            if (member.pViewportWScalings==NULL){
                pViewportWScalings_json=boost::json::array();
            return; }pViewportWScalings_json=boost::json::array(member.viewportCount);
        auto& arr_mPSOmwe=pViewportWScalings_json.as_array();
        for(int ApYwLDM=0; ApYwLDM < member.viewportCount; ApYwLDM++){
            [&](){
            auto& temp=arr_mPSOmwe[ApYwLDM].emplace_object();
            return serialize_struct(temp, member.pViewportWScalings[ApYwLDM]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineViewportWScalingStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& viewportWScalingEnable_json=json["viewportWScalingEnable"];
[&](){uint32_t temp_WfRIzwT;[&](){temp_WfRIzwT=static_cast<uint32_t>(value_to<int>(viewportWScalingEnable_json));}();member.viewportWScalingEnable=(VkBool32)temp_WfRIzwT;}();
auto& viewportCount_json=json["viewportCount"];
[&](){member.viewportCount=static_cast<uint32_t>(value_to<int>(viewportCount_json));}();
auto& pViewportWScalings_json=json["pViewportWScalings"];
[&](){ VkViewportWScalingNV* temp_zTiAHBj;;[&](){
            if (pViewportWScalings_json.as_array().size()==0){
                temp_zTiAHBj=NULL;
            return; }temp_zTiAHBj=(VkViewportWScalingNV*)malloc(member.viewportCount*sizeof(VkViewportWScalingNV));
        auto& arr_hsOZZjb=pViewportWScalings_json.as_array();
        for(int zxuNYEg=0; zxuNYEg < member.viewportCount; zxuNYEg++){
            [&](){
            auto& temp=arr_hsOZZjb[zxuNYEg].as_object();
            deserialize_struct(temp,temp_zTiAHBj[zxuNYEg]);
            }();
        }
        }();member.pViewportWScalings=temp_zTiAHBj;}();
}

    void serialize_struct(boost::json::object& json, const VkViewportSwizzleNV& member){
        
    
auto& x_json=json["x"];
[&](){[&](){[&](){x_json=member.x;}();}();}();
auto& y_json=json["y"];
[&](){[&](){[&](){y_json=member.y;}();}();}();
auto& z_json=json["z"];
[&](){[&](){[&](){z_json=member.z;}();}();}();
auto& w_json=json["w"];
[&](){[&](){[&](){w_json=member.w;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkViewportSwizzleNV& member){
auto& x_json=json["x"];
[&](){[&](){int temp_eQYBMQb;[&](){temp_eQYBMQb=static_cast<int>(value_to<int>(x_json));}();member.x=(VkViewportCoordinateSwizzleNV)temp_eQYBMQb;}();}();
auto& y_json=json["y"];
[&](){[&](){int temp_nFMATCs;[&](){temp_nFMATCs=static_cast<int>(value_to<int>(y_json));}();member.y=(VkViewportCoordinateSwizzleNV)temp_nFMATCs;}();}();
auto& z_json=json["z"];
[&](){[&](){int temp_zcirilm;[&](){temp_zcirilm=static_cast<int>(value_to<int>(z_json));}();member.z=(VkViewportCoordinateSwizzleNV)temp_zcirilm;}();}();
auto& w_json=json["w"];
[&](){[&](){int temp_RiLXRas;[&](){temp_RiLXRas=static_cast<int>(value_to<int>(w_json));}();member.w=(VkViewportCoordinateSwizzleNV)temp_RiLXRas;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineViewportSwizzleStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& viewportCount_json=json["viewportCount"];
[&](){viewportCount_json=member.viewportCount;}();
auto& pViewportSwizzles_json=json["pViewportSwizzles"];
[&](){
            if (member.pViewportSwizzles==NULL){
                pViewportSwizzles_json=boost::json::array();
            return; }pViewportSwizzles_json=boost::json::array(member.viewportCount);
        auto& arr_SkrWsuC=pViewportSwizzles_json.as_array();
        for(int ftRPdsX=0; ftRPdsX < member.viewportCount; ftRPdsX++){
            [&](){
            auto& temp=arr_SkrWsuC[ftRPdsX].emplace_object();
            return serialize_struct(temp, member.pViewportSwizzles[ftRPdsX]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineViewportSwizzleStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_Hvglrwe;[&](){temp_Hvglrwe=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineViewportSwizzleStateCreateFlagsNV)temp_Hvglrwe;}();}();
auto& viewportCount_json=json["viewportCount"];
[&](){member.viewportCount=static_cast<uint32_t>(value_to<int>(viewportCount_json));}();
auto& pViewportSwizzles_json=json["pViewportSwizzles"];
[&](){ VkViewportSwizzleNV* temp_wMNvvyi;;[&](){
            if (pViewportSwizzles_json.as_array().size()==0){
                temp_wMNvvyi=NULL;
            return; }temp_wMNvvyi=(VkViewportSwizzleNV*)malloc(member.viewportCount*sizeof(VkViewportSwizzleNV));
        auto& arr_kCpJpjb=pViewportSwizzles_json.as_array();
        for(int utCdAoZ=0; utCdAoZ < member.viewportCount; utCdAoZ++){
            [&](){
            auto& temp=arr_kCpJpjb[utCdAoZ].as_object();
            deserialize_struct(temp,temp_wMNvvyi[utCdAoZ]);
            }();
        }
        }();member.pViewportSwizzles=temp_wMNvvyi;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDiscardRectanglePropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxDiscardRectangles_json=json["maxDiscardRectangles"];
[&](){maxDiscardRectangles_json=member.maxDiscardRectangles;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDiscardRectanglePropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxDiscardRectangles_json=json["maxDiscardRectangles"];
[&](){member.maxDiscardRectangles=static_cast<uint32_t>(value_to<int>(maxDiscardRectangles_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineDiscardRectangleStateCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& discardRectangleMode_json=json["discardRectangleMode"];
[&](){[&](){[&](){discardRectangleMode_json=member.discardRectangleMode;}();}();}();
auto& discardRectangleCount_json=json["discardRectangleCount"];
[&](){discardRectangleCount_json=member.discardRectangleCount;}();
auto& pDiscardRectangles_json=json["pDiscardRectangles"];
[&](){
            if (member.pDiscardRectangles==NULL){
                pDiscardRectangles_json=boost::json::array();
            return; }pDiscardRectangles_json=boost::json::array(member.discardRectangleCount);
        auto& arr_ZVpWtvh=pDiscardRectangles_json.as_array();
        for(int tYocrha=0; tYocrha < member.discardRectangleCount; tYocrha++){
            [&](){
            auto& temp=arr_ZVpWtvh[tYocrha].emplace_object();
            return serialize_struct(temp, member.pDiscardRectangles[tYocrha]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineDiscardRectangleStateCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_Qikfisv;[&](){temp_Qikfisv=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineDiscardRectangleStateCreateFlagsEXT)temp_Qikfisv;}();}();
auto& discardRectangleMode_json=json["discardRectangleMode"];
[&](){[&](){int temp_Bzpgmbl;[&](){temp_Bzpgmbl=static_cast<int>(value_to<int>(discardRectangleMode_json));}();member.discardRectangleMode=(VkDiscardRectangleModeEXT)temp_Bzpgmbl;}();}();
auto& discardRectangleCount_json=json["discardRectangleCount"];
[&](){member.discardRectangleCount=static_cast<uint32_t>(value_to<int>(discardRectangleCount_json));}();
auto& pDiscardRectangles_json=json["pDiscardRectangles"];
[&](){ VkRect2D* temp_SQELzFf;;[&](){
            if (pDiscardRectangles_json.as_array().size()==0){
                temp_SQELzFf=NULL;
            return; }temp_SQELzFf=(VkRect2D*)malloc(member.discardRectangleCount*sizeof(VkRect2D));
        auto& arr_qkYLEdR=pDiscardRectangles_json.as_array();
        for(int PxdJbfG=0; PxdJbfG < member.discardRectangleCount; PxdJbfG++){
            [&](){
            auto& temp=arr_qkYLEdR[PxdJbfG].as_object();
            deserialize_struct(temp,temp_SQELzFf[PxdJbfG]);
            }();
        }
        }();member.pDiscardRectangles=temp_SQELzFf;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& perViewPositionAllComponents_json=json["perViewPositionAllComponents"];
[&](){[&](){perViewPositionAllComponents_json=member.perViewPositionAllComponents;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& perViewPositionAllComponents_json=json["perViewPositionAllComponents"];
[&](){uint32_t temp_OFRXQFS;[&](){temp_OFRXQFS=static_cast<uint32_t>(value_to<int>(perViewPositionAllComponents_json));}();member.perViewPositionAllComponents=(VkBool32)temp_OFRXQFS;}();
}

    void serialize_struct(boost::json::object& json, const VkInputAttachmentAspectReference& member){
        
    
auto& subpass_json=json["subpass"];
[&](){subpass_json=member.subpass;}();
auto& inputAttachmentIndex_json=json["inputAttachmentIndex"];
[&](){inputAttachmentIndex_json=member.inputAttachmentIndex;}();
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){[&](){aspectMask_json=member.aspectMask;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkInputAttachmentAspectReference& member){
auto& subpass_json=json["subpass"];
[&](){member.subpass=static_cast<uint32_t>(value_to<int>(subpass_json));}();
auto& inputAttachmentIndex_json=json["inputAttachmentIndex"];
[&](){member.inputAttachmentIndex=static_cast<uint32_t>(value_to<int>(inputAttachmentIndex_json));}();
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){int temp_srmSgxC;[&](){temp_srmSgxC=static_cast<int>(value_to<int>(aspectMask_json));}();member.aspectMask=(VkImageAspectFlags)temp_srmSgxC;}();}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassInputAttachmentAspectCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& aspectReferenceCount_json=json["aspectReferenceCount"];
[&](){aspectReferenceCount_json=member.aspectReferenceCount;}();
auto& pAspectReferences_json=json["pAspectReferences"];
[&](){
            if (member.pAspectReferences==NULL){
                pAspectReferences_json=boost::json::array();
            return; }pAspectReferences_json=boost::json::array(member.aspectReferenceCount);
        auto& arr_oSwzVqm=pAspectReferences_json.as_array();
        for(int uEBOsiT=0; uEBOsiT < member.aspectReferenceCount; uEBOsiT++){
            [&](){
            auto& temp=arr_oSwzVqm[uEBOsiT].emplace_object();
            return serialize_struct(temp, member.pAspectReferences[uEBOsiT]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassInputAttachmentAspectCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& aspectReferenceCount_json=json["aspectReferenceCount"];
[&](){member.aspectReferenceCount=static_cast<uint32_t>(value_to<int>(aspectReferenceCount_json));}();
auto& pAspectReferences_json=json["pAspectReferences"];
[&](){ VkInputAttachmentAspectReference* temp_iGHcwXW;;[&](){
            if (pAspectReferences_json.as_array().size()==0){
                temp_iGHcwXW=NULL;
            return; }temp_iGHcwXW=(VkInputAttachmentAspectReference*)malloc(member.aspectReferenceCount*sizeof(VkInputAttachmentAspectReference));
        auto& arr_YEveuLs=pAspectReferences_json.as_array();
        for(int khdmELH=0; khdmELH < member.aspectReferenceCount; khdmELH++){
            [&](){
            auto& temp=arr_YEveuLs[khdmELH].as_object();
            deserialize_struct(temp,temp_iGHcwXW[khdmELH]);
            }();
        }
        }();member.pAspectReferences=temp_iGHcwXW;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSurfaceInfo2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& surface_json=json["surface"];
[&](){serialize_VkSurfaceKHR(surface_json,member.surface);}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSurfaceInfo2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& surface_json=json["surface"];
[&](){deserialize_VkSurfaceKHR(surface_json, member.surface);}();
}

    void serialize_struct(boost::json::object& json, const VkSurfaceCapabilities2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& surfaceCapabilities_json=json["surfaceCapabilities"];
[&](){
            auto& temp=surfaceCapabilities_json.emplace_object();
            return serialize_struct(temp, member.surfaceCapabilities);
            }();
}
void deserialize_struct(boost::json::object& json, VkSurfaceCapabilities2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& surfaceCapabilities_json=json["surfaceCapabilities"];
[&](){
            auto& temp=surfaceCapabilities_json.as_object();
            deserialize_struct(temp,member.surfaceCapabilities);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSurfaceFormat2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& surfaceFormat_json=json["surfaceFormat"];
[&](){
            auto& temp=surfaceFormat_json.emplace_object();
            return serialize_struct(temp, member.surfaceFormat);
            }();
}
void deserialize_struct(boost::json::object& json, VkSurfaceFormat2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& surfaceFormat_json=json["surfaceFormat"];
[&](){
            auto& temp=surfaceFormat_json.as_object();
            deserialize_struct(temp,member.surfaceFormat);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDisplayProperties2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& displayProperties_json=json["displayProperties"];
[&](){
            auto& temp=displayProperties_json.emplace_object();
            return serialize_struct(temp, member.displayProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkDisplayProperties2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& displayProperties_json=json["displayProperties"];
[&](){
            auto& temp=displayProperties_json.as_object();
            deserialize_struct(temp,member.displayProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDisplayPlaneProperties2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& displayPlaneProperties_json=json["displayPlaneProperties"];
[&](){
            auto& temp=displayPlaneProperties_json.emplace_object();
            return serialize_struct(temp, member.displayPlaneProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkDisplayPlaneProperties2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& displayPlaneProperties_json=json["displayPlaneProperties"];
[&](){
            auto& temp=displayPlaneProperties_json.as_object();
            deserialize_struct(temp,member.displayPlaneProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDisplayModeProperties2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& displayModeProperties_json=json["displayModeProperties"];
[&](){
            auto& temp=displayModeProperties_json.emplace_object();
            return serialize_struct(temp, member.displayModeProperties);
            }();
}
void deserialize_struct(boost::json::object& json, VkDisplayModeProperties2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& displayModeProperties_json=json["displayModeProperties"];
[&](){
            auto& temp=displayModeProperties_json.as_object();
            deserialize_struct(temp,member.displayModeProperties);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDisplayPlaneInfo2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& mode_json=json["mode"];
[&](){serialize_VkDisplayModeKHR(mode_json,member.mode);}();
auto& planeIndex_json=json["planeIndex"];
[&](){planeIndex_json=member.planeIndex;}();
}
void deserialize_struct(boost::json::object& json, VkDisplayPlaneInfo2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& mode_json=json["mode"];
[&](){deserialize_VkDisplayModeKHR(mode_json, member.mode);}();
auto& planeIndex_json=json["planeIndex"];
[&](){member.planeIndex=static_cast<uint32_t>(value_to<int>(planeIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDisplayPlaneCapabilities2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& capabilities_json=json["capabilities"];
[&](){
            auto& temp=capabilities_json.emplace_object();
            return serialize_struct(temp, member.capabilities);
            }();
}
void deserialize_struct(boost::json::object& json, VkDisplayPlaneCapabilities2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& capabilities_json=json["capabilities"];
[&](){
            auto& temp=capabilities_json.as_object();
            deserialize_struct(temp,member.capabilities);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSharedPresentSurfaceCapabilitiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& sharedPresentSupportedUsageFlags_json=json["sharedPresentSupportedUsageFlags"];
[&](){[&](){[&](){sharedPresentSupportedUsageFlags_json=member.sharedPresentSupportedUsageFlags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSharedPresentSurfaceCapabilitiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& sharedPresentSupportedUsageFlags_json=json["sharedPresentSupportedUsageFlags"];
[&](){[&](){int temp_tmscFhP;[&](){temp_tmscFhP=static_cast<int>(value_to<int>(sharedPresentSupportedUsageFlags_json));}();member.sharedPresentSupportedUsageFlags=(VkImageUsageFlags)temp_tmscFhP;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevice16BitStorageFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& storageBuffer16BitAccess_json=json["storageBuffer16BitAccess"];
[&](){[&](){storageBuffer16BitAccess_json=member.storageBuffer16BitAccess;}();}();
auto& uniformAndStorageBuffer16BitAccess_json=json["uniformAndStorageBuffer16BitAccess"];
[&](){[&](){uniformAndStorageBuffer16BitAccess_json=member.uniformAndStorageBuffer16BitAccess;}();}();
auto& storagePushConstant16_json=json["storagePushConstant16"];
[&](){[&](){storagePushConstant16_json=member.storagePushConstant16;}();}();
auto& storageInputOutput16_json=json["storageInputOutput16"];
[&](){[&](){storageInputOutput16_json=member.storageInputOutput16;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevice16BitStorageFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& storageBuffer16BitAccess_json=json["storageBuffer16BitAccess"];
[&](){uint32_t temp_yIPuXaQ;[&](){temp_yIPuXaQ=static_cast<uint32_t>(value_to<int>(storageBuffer16BitAccess_json));}();member.storageBuffer16BitAccess=(VkBool32)temp_yIPuXaQ;}();
auto& uniformAndStorageBuffer16BitAccess_json=json["uniformAndStorageBuffer16BitAccess"];
[&](){uint32_t temp_QYvUxzG;[&](){temp_QYvUxzG=static_cast<uint32_t>(value_to<int>(uniformAndStorageBuffer16BitAccess_json));}();member.uniformAndStorageBuffer16BitAccess=(VkBool32)temp_QYvUxzG;}();
auto& storagePushConstant16_json=json["storagePushConstant16"];
[&](){uint32_t temp_CaAqFdq;[&](){temp_CaAqFdq=static_cast<uint32_t>(value_to<int>(storagePushConstant16_json));}();member.storagePushConstant16=(VkBool32)temp_CaAqFdq;}();
auto& storageInputOutput16_json=json["storageInputOutput16"];
[&](){uint32_t temp_YzwMlAd;[&](){temp_YzwMlAd=static_cast<uint32_t>(value_to<int>(storageInputOutput16_json));}();member.storageInputOutput16=(VkBool32)temp_YzwMlAd;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSubgroupProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& subgroupSize_json=json["subgroupSize"];
[&](){subgroupSize_json=member.subgroupSize;}();
auto& supportedStages_json=json["supportedStages"];
[&](){[&](){[&](){supportedStages_json=member.supportedStages;}();}();}();
auto& supportedOperations_json=json["supportedOperations"];
[&](){[&](){[&](){supportedOperations_json=member.supportedOperations;}();}();}();
auto& quadOperationsInAllStages_json=json["quadOperationsInAllStages"];
[&](){[&](){quadOperationsInAllStages_json=member.quadOperationsInAllStages;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSubgroupProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& subgroupSize_json=json["subgroupSize"];
[&](){member.subgroupSize=static_cast<uint32_t>(value_to<int>(subgroupSize_json));}();
auto& supportedStages_json=json["supportedStages"];
[&](){[&](){int temp_OFDqMhI;[&](){temp_OFDqMhI=static_cast<int>(value_to<int>(supportedStages_json));}();member.supportedStages=(VkShaderStageFlags)temp_OFDqMhI;}();}();
auto& supportedOperations_json=json["supportedOperations"];
[&](){[&](){int temp_upTDdut;[&](){temp_upTDdut=static_cast<int>(value_to<int>(supportedOperations_json));}();member.supportedOperations=(VkSubgroupFeatureFlags)temp_upTDdut;}();}();
auto& quadOperationsInAllStages_json=json["quadOperationsInAllStages"];
[&](){uint32_t temp_dUXXFdv;[&](){temp_dUXXFdv=static_cast<uint32_t>(value_to<int>(quadOperationsInAllStages_json));}();member.quadOperationsInAllStages=(VkBool32)temp_dUXXFdv;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderSubgroupExtendedTypes_json=json["shaderSubgroupExtendedTypes"];
[&](){[&](){shaderSubgroupExtendedTypes_json=member.shaderSubgroupExtendedTypes;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderSubgroupExtendedTypes_json=json["shaderSubgroupExtendedTypes"];
[&](){uint32_t temp_ITZfDXI;[&](){temp_ITZfDXI=static_cast<uint32_t>(value_to<int>(shaderSubgroupExtendedTypes_json));}();member.shaderSubgroupExtendedTypes=(VkBool32)temp_ITZfDXI;}();
}

    void serialize_struct(boost::json::object& json, const VkBufferMemoryRequirementsInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
}
void deserialize_struct(boost::json::object& json, VkBufferMemoryRequirementsInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceBufferMemoryRequirements& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pCreateInfo_json=json["pCreateInfo"];
[&](){
            if (member.pCreateInfo==NULL){
                pCreateInfo_json=boost::json::array();
            return; }pCreateInfo_json=boost::json::array(1);
        auto& arr_RLcYbMX=pCreateInfo_json.as_array();
        for(int iwONMow=0; iwONMow < 1; iwONMow++){
            [&](){
            auto& temp=arr_RLcYbMX[iwONMow].emplace_object();
            return serialize_struct(temp, member.pCreateInfo[iwONMow]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDeviceBufferMemoryRequirements& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pCreateInfo_json=json["pCreateInfo"];
[&](){ VkBufferCreateInfo* temp_TtWQDRn;;[&](){
            if (pCreateInfo_json.as_array().size()==0){
                temp_TtWQDRn=NULL;
            return; }temp_TtWQDRn=(VkBufferCreateInfo*)malloc(1*sizeof(VkBufferCreateInfo));
        auto& arr_DnfECXh=pCreateInfo_json.as_array();
        for(int PKBixuu=0; PKBixuu < 1; PKBixuu++){
            [&](){
            auto& temp=arr_DnfECXh[PKBixuu].as_object();
            deserialize_struct(temp,temp_TtWQDRn[PKBixuu]);
            }();
        }
        }();member.pCreateInfo=temp_TtWQDRn;}();
}

    void serialize_struct(boost::json::object& json, const VkImageMemoryRequirementsInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
}
void deserialize_struct(boost::json::object& json, VkImageMemoryRequirementsInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
}

    void serialize_struct(boost::json::object& json, const VkImageSparseMemoryRequirementsInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
}
void deserialize_struct(boost::json::object& json, VkImageSparseMemoryRequirementsInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceImageMemoryRequirements& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pCreateInfo_json=json["pCreateInfo"];
[&](){
            if (member.pCreateInfo==NULL){
                pCreateInfo_json=boost::json::array();
            return; }pCreateInfo_json=boost::json::array(1);
        auto& arr_ZehFYFR=pCreateInfo_json.as_array();
        for(int WlalFpx=0; WlalFpx < 1; WlalFpx++){
            [&](){
            auto& temp=arr_ZehFYFR[WlalFpx].emplace_object();
            return serialize_struct(temp, member.pCreateInfo[WlalFpx]);
            }();
        }
        }();
auto& planeAspect_json=json["planeAspect"];
[&](){[&](){[&](){planeAspect_json=member.planeAspect;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceImageMemoryRequirements& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pCreateInfo_json=json["pCreateInfo"];
[&](){ VkImageCreateInfo* temp_qYyheZw;;[&](){
            if (pCreateInfo_json.as_array().size()==0){
                temp_qYyheZw=NULL;
            return; }temp_qYyheZw=(VkImageCreateInfo*)malloc(1*sizeof(VkImageCreateInfo));
        auto& arr_okKoGgS=pCreateInfo_json.as_array();
        for(int jLxWavY=0; jLxWavY < 1; jLxWavY++){
            [&](){
            auto& temp=arr_okKoGgS[jLxWavY].as_object();
            deserialize_struct(temp,temp_qYyheZw[jLxWavY]);
            }();
        }
        }();member.pCreateInfo=temp_qYyheZw;}();
auto& planeAspect_json=json["planeAspect"];
[&](){[&](){int temp_uKQOPbr;[&](){temp_uKQOPbr=static_cast<int>(value_to<int>(planeAspect_json));}();member.planeAspect=(VkImageAspectFlagBits)temp_uKQOPbr;}();}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryRequirements2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memoryRequirements_json=json["memoryRequirements"];
[&](){
            auto& temp=memoryRequirements_json.emplace_object();
            return serialize_struct(temp, member.memoryRequirements);
            }();
}
void deserialize_struct(boost::json::object& json, VkMemoryRequirements2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& memoryRequirements_json=json["memoryRequirements"];
[&](){
            auto& temp=memoryRequirements_json.as_object();
            deserialize_struct(temp,member.memoryRequirements);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSparseImageMemoryRequirements2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memoryRequirements_json=json["memoryRequirements"];
[&](){
            auto& temp=memoryRequirements_json.emplace_object();
            return serialize_struct(temp, member.memoryRequirements);
            }();
}
void deserialize_struct(boost::json::object& json, VkSparseImageMemoryRequirements2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& memoryRequirements_json=json["memoryRequirements"];
[&](){
            auto& temp=memoryRequirements_json.as_object();
            deserialize_struct(temp,member.memoryRequirements);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePointClippingProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pointClippingBehavior_json=json["pointClippingBehavior"];
[&](){[&](){[&](){pointClippingBehavior_json=member.pointClippingBehavior;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePointClippingProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pointClippingBehavior_json=json["pointClippingBehavior"];
[&](){[&](){int temp_AuXEWUF;[&](){temp_AuXEWUF=static_cast<int>(value_to<int>(pointClippingBehavior_json));}();member.pointClippingBehavior=(VkPointClippingBehavior)temp_AuXEWUF;}();}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryDedicatedRequirements& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& prefersDedicatedAllocation_json=json["prefersDedicatedAllocation"];
[&](){[&](){prefersDedicatedAllocation_json=member.prefersDedicatedAllocation;}();}();
auto& requiresDedicatedAllocation_json=json["requiresDedicatedAllocation"];
[&](){[&](){requiresDedicatedAllocation_json=member.requiresDedicatedAllocation;}();}();
}
void deserialize_struct(boost::json::object& json, VkMemoryDedicatedRequirements& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& prefersDedicatedAllocation_json=json["prefersDedicatedAllocation"];
[&](){uint32_t temp_IZlpoKw;[&](){temp_IZlpoKw=static_cast<uint32_t>(value_to<int>(prefersDedicatedAllocation_json));}();member.prefersDedicatedAllocation=(VkBool32)temp_IZlpoKw;}();
auto& requiresDedicatedAllocation_json=json["requiresDedicatedAllocation"];
[&](){uint32_t temp_EHatEnp;[&](){temp_EHatEnp=static_cast<uint32_t>(value_to<int>(requiresDedicatedAllocation_json));}();member.requiresDedicatedAllocation=(VkBool32)temp_EHatEnp;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryDedicatedAllocateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
}
void deserialize_struct(boost::json::object& json, VkMemoryDedicatedAllocateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
}

    void serialize_struct(boost::json::object& json, const VkImageViewUsageCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkImageViewUsageCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_FIcOdeK;[&](){temp_FIcOdeK=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkImageUsageFlags)temp_FIcOdeK;}();}();
}

    void serialize_struct(boost::json::object& json, const VkImageViewSlicedCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& sliceOffset_json=json["sliceOffset"];
[&](){sliceOffset_json=member.sliceOffset;}();
auto& sliceCount_json=json["sliceCount"];
[&](){sliceCount_json=member.sliceCount;}();
}
void deserialize_struct(boost::json::object& json, VkImageViewSlicedCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& sliceOffset_json=json["sliceOffset"];
[&](){member.sliceOffset=static_cast<uint32_t>(value_to<int>(sliceOffset_json));}();
auto& sliceCount_json=json["sliceCount"];
[&](){member.sliceCount=static_cast<uint32_t>(value_to<int>(sliceCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineTessellationDomainOriginStateCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& domainOrigin_json=json["domainOrigin"];
[&](){[&](){[&](){domainOrigin_json=member.domainOrigin;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineTessellationDomainOriginStateCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& domainOrigin_json=json["domainOrigin"];
[&](){[&](){int temp_xElrYrI;[&](){temp_xElrYrI=static_cast<int>(value_to<int>(domainOrigin_json));}();member.domainOrigin=(VkTessellationDomainOrigin)temp_xElrYrI;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSamplerYcbcrConversionInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& conversion_json=json["conversion"];
[&](){serialize_VkSamplerYcbcrConversion(conversion_json,member.conversion);}();
}
void deserialize_struct(boost::json::object& json, VkSamplerYcbcrConversionInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& conversion_json=json["conversion"];
[&](){deserialize_VkSamplerYcbcrConversion(conversion_json, member.conversion);}();
}

    void serialize_struct(boost::json::object& json, const VkSamplerYcbcrConversionCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& ycbcrModel_json=json["ycbcrModel"];
[&](){[&](){[&](){ycbcrModel_json=member.ycbcrModel;}();}();}();
auto& ycbcrRange_json=json["ycbcrRange"];
[&](){[&](){[&](){ycbcrRange_json=member.ycbcrRange;}();}();}();
auto& components_json=json["components"];
[&](){
            auto& temp=components_json.emplace_object();
            return serialize_struct(temp, member.components);
            }();
auto& xChromaOffset_json=json["xChromaOffset"];
[&](){[&](){[&](){xChromaOffset_json=member.xChromaOffset;}();}();}();
auto& yChromaOffset_json=json["yChromaOffset"];
[&](){[&](){[&](){yChromaOffset_json=member.yChromaOffset;}();}();}();
auto& chromaFilter_json=json["chromaFilter"];
[&](){[&](){[&](){chromaFilter_json=member.chromaFilter;}();}();}();
auto& forceExplicitReconstruction_json=json["forceExplicitReconstruction"];
[&](){[&](){forceExplicitReconstruction_json=member.forceExplicitReconstruction;}();}();
}
void deserialize_struct(boost::json::object& json, VkSamplerYcbcrConversionCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& ycbcrModel_json=json["ycbcrModel"];
[&](){[&](){int temp_BMMEGPe;[&](){temp_BMMEGPe=static_cast<int>(value_to<int>(ycbcrModel_json));}();member.ycbcrModel=(VkSamplerYcbcrModelConversion)temp_BMMEGPe;}();}();
auto& ycbcrRange_json=json["ycbcrRange"];
[&](){[&](){int temp_avaCJZi;[&](){temp_avaCJZi=static_cast<int>(value_to<int>(ycbcrRange_json));}();member.ycbcrRange=(VkSamplerYcbcrRange)temp_avaCJZi;}();}();
auto& components_json=json["components"];
[&](){
            auto& temp=components_json.as_object();
            deserialize_struct(temp,member.components);
            }();
auto& xChromaOffset_json=json["xChromaOffset"];
[&](){[&](){int temp_SXahONB;[&](){temp_SXahONB=static_cast<int>(value_to<int>(xChromaOffset_json));}();member.xChromaOffset=(VkChromaLocation)temp_SXahONB;}();}();
auto& yChromaOffset_json=json["yChromaOffset"];
[&](){[&](){int temp_pzHYNBa;[&](){temp_pzHYNBa=static_cast<int>(value_to<int>(yChromaOffset_json));}();member.yChromaOffset=(VkChromaLocation)temp_pzHYNBa;}();}();
auto& chromaFilter_json=json["chromaFilter"];
[&](){[&](){int temp_mdkTJZe;[&](){temp_mdkTJZe=static_cast<int>(value_to<int>(chromaFilter_json));}();member.chromaFilter=(VkFilter)temp_mdkTJZe;}();}();
auto& forceExplicitReconstruction_json=json["forceExplicitReconstruction"];
[&](){uint32_t temp_CNGmvtx;[&](){temp_CNGmvtx=static_cast<uint32_t>(value_to<int>(forceExplicitReconstruction_json));}();member.forceExplicitReconstruction=(VkBool32)temp_CNGmvtx;}();
}

    void serialize_struct(boost::json::object& json, const VkBindImagePlaneMemoryInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& planeAspect_json=json["planeAspect"];
[&](){[&](){[&](){planeAspect_json=member.planeAspect;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkBindImagePlaneMemoryInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& planeAspect_json=json["planeAspect"];
[&](){[&](){int temp_uKQOPbr;[&](){temp_uKQOPbr=static_cast<int>(value_to<int>(planeAspect_json));}();member.planeAspect=(VkImageAspectFlagBits)temp_uKQOPbr;}();}();
}

    void serialize_struct(boost::json::object& json, const VkImagePlaneMemoryRequirementsInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& planeAspect_json=json["planeAspect"];
[&](){[&](){[&](){planeAspect_json=member.planeAspect;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkImagePlaneMemoryRequirementsInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& planeAspect_json=json["planeAspect"];
[&](){[&](){int temp_uKQOPbr;[&](){temp_uKQOPbr=static_cast<int>(value_to<int>(planeAspect_json));}();member.planeAspect=(VkImageAspectFlagBits)temp_uKQOPbr;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSamplerYcbcrConversionFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& samplerYcbcrConversion_json=json["samplerYcbcrConversion"];
[&](){[&](){samplerYcbcrConversion_json=member.samplerYcbcrConversion;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSamplerYcbcrConversionFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& samplerYcbcrConversion_json=json["samplerYcbcrConversion"];
[&](){uint32_t temp_FgETtiO;[&](){temp_FgETtiO=static_cast<uint32_t>(value_to<int>(samplerYcbcrConversion_json));}();member.samplerYcbcrConversion=(VkBool32)temp_FgETtiO;}();
}

    void serialize_struct(boost::json::object& json, const VkSamplerYcbcrConversionImageFormatProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& combinedImageSamplerDescriptorCount_json=json["combinedImageSamplerDescriptorCount"];
[&](){combinedImageSamplerDescriptorCount_json=member.combinedImageSamplerDescriptorCount;}();
}
void deserialize_struct(boost::json::object& json, VkSamplerYcbcrConversionImageFormatProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& combinedImageSamplerDescriptorCount_json=json["combinedImageSamplerDescriptorCount"];
[&](){member.combinedImageSamplerDescriptorCount=static_cast<uint32_t>(value_to<int>(combinedImageSamplerDescriptorCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkTextureLODGatherFormatPropertiesAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& supportsTextureGatherLODBiasAMD_json=json["supportsTextureGatherLODBiasAMD"];
[&](){[&](){supportsTextureGatherLODBiasAMD_json=member.supportsTextureGatherLODBiasAMD;}();}();
}
void deserialize_struct(boost::json::object& json, VkTextureLODGatherFormatPropertiesAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& supportsTextureGatherLODBiasAMD_json=json["supportsTextureGatherLODBiasAMD"];
[&](){uint32_t temp_mAzshVL;[&](){temp_mAzshVL=static_cast<uint32_t>(value_to<int>(supportsTextureGatherLODBiasAMD_json));}();member.supportsTextureGatherLODBiasAMD=(VkBool32)temp_mAzshVL;}();
}

    void serialize_struct(boost::json::object& json, const VkConditionalRenderingBeginInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkConditionalRenderingBeginInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_eDwuNuF;[&](){temp_eDwuNuF=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkConditionalRenderingFlagsEXT)temp_eDwuNuF;}();}();
}

    void serialize_struct(boost::json::object& json, const VkProtectedSubmitInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& protectedSubmit_json=json["protectedSubmit"];
[&](){[&](){protectedSubmit_json=member.protectedSubmit;}();}();
}
void deserialize_struct(boost::json::object& json, VkProtectedSubmitInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& protectedSubmit_json=json["protectedSubmit"];
[&](){uint32_t temp_JfDnMlI;[&](){temp_JfDnMlI=static_cast<uint32_t>(value_to<int>(protectedSubmit_json));}();member.protectedSubmit=(VkBool32)temp_JfDnMlI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceProtectedMemoryFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& protectedMemory_json=json["protectedMemory"];
[&](){[&](){protectedMemory_json=member.protectedMemory;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceProtectedMemoryFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& protectedMemory_json=json["protectedMemory"];
[&](){uint32_t temp_GuKmYAX;[&](){temp_GuKmYAX=static_cast<uint32_t>(value_to<int>(protectedMemory_json));}();member.protectedMemory=(VkBool32)temp_GuKmYAX;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceProtectedMemoryProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& protectedNoFault_json=json["protectedNoFault"];
[&](){[&](){protectedNoFault_json=member.protectedNoFault;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceProtectedMemoryProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& protectedNoFault_json=json["protectedNoFault"];
[&](){uint32_t temp_vnlcpsN;[&](){temp_vnlcpsN=static_cast<uint32_t>(value_to<int>(protectedNoFault_json));}();member.protectedNoFault=(VkBool32)temp_vnlcpsN;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceQueueInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){queueFamilyIndex_json=member.queueFamilyIndex;}();
auto& queueIndex_json=json["queueIndex"];
[&](){queueIndex_json=member.queueIndex;}();
}
void deserialize_struct(boost::json::object& json, VkDeviceQueueInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_IUWfgtC;[&](){temp_IUWfgtC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDeviceQueueCreateFlags)temp_IUWfgtC;}();}();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){member.queueFamilyIndex=static_cast<uint32_t>(value_to<int>(queueFamilyIndex_json));}();
auto& queueIndex_json=json["queueIndex"];
[&](){member.queueIndex=static_cast<uint32_t>(value_to<int>(queueIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineCoverageToColorStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& coverageToColorEnable_json=json["coverageToColorEnable"];
[&](){[&](){coverageToColorEnable_json=member.coverageToColorEnable;}();}();
auto& coverageToColorLocation_json=json["coverageToColorLocation"];
[&](){coverageToColorLocation_json=member.coverageToColorLocation;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineCoverageToColorStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_LMiPqil;[&](){temp_LMiPqil=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCoverageToColorStateCreateFlagsNV)temp_LMiPqil;}();}();
auto& coverageToColorEnable_json=json["coverageToColorEnable"];
[&](){uint32_t temp_PZTZgZr;[&](){temp_PZTZgZr=static_cast<uint32_t>(value_to<int>(coverageToColorEnable_json));}();member.coverageToColorEnable=(VkBool32)temp_PZTZgZr;}();
auto& coverageToColorLocation_json=json["coverageToColorLocation"];
[&](){member.coverageToColorLocation=static_cast<uint32_t>(value_to<int>(coverageToColorLocation_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSamplerFilterMinmaxProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& filterMinmaxSingleComponentFormats_json=json["filterMinmaxSingleComponentFormats"];
[&](){[&](){filterMinmaxSingleComponentFormats_json=member.filterMinmaxSingleComponentFormats;}();}();
auto& filterMinmaxImageComponentMapping_json=json["filterMinmaxImageComponentMapping"];
[&](){[&](){filterMinmaxImageComponentMapping_json=member.filterMinmaxImageComponentMapping;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSamplerFilterMinmaxProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& filterMinmaxSingleComponentFormats_json=json["filterMinmaxSingleComponentFormats"];
[&](){uint32_t temp_DdyYeOw;[&](){temp_DdyYeOw=static_cast<uint32_t>(value_to<int>(filterMinmaxSingleComponentFormats_json));}();member.filterMinmaxSingleComponentFormats=(VkBool32)temp_DdyYeOw;}();
auto& filterMinmaxImageComponentMapping_json=json["filterMinmaxImageComponentMapping"];
[&](){uint32_t temp_laYBitp;[&](){temp_laYBitp=static_cast<uint32_t>(value_to<int>(filterMinmaxImageComponentMapping_json));}();member.filterMinmaxImageComponentMapping=(VkBool32)temp_laYBitp;}();
}

    void serialize_struct(boost::json::object& json, const VkSampleLocationEXT& member){
        
    
auto& x_json=json["x"];
[&](){x_json=member.x;}();
auto& y_json=json["y"];
[&](){y_json=member.y;}();
}
void deserialize_struct(boost::json::object& json, VkSampleLocationEXT& member){
auto& x_json=json["x"];
[&](){member.x=static_cast<float>(value_to<int>(x_json));}();
auto& y_json=json["y"];
[&](){member.y=static_cast<float>(value_to<int>(y_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSampleLocationsInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& sampleLocationsPerPixel_json=json["sampleLocationsPerPixel"];
[&](){[&](){[&](){sampleLocationsPerPixel_json=member.sampleLocationsPerPixel;}();}();}();
auto& sampleLocationGridSize_json=json["sampleLocationGridSize"];
[&](){
            auto& temp=sampleLocationGridSize_json.emplace_object();
            return serialize_struct(temp, member.sampleLocationGridSize);
            }();
auto& sampleLocationsCount_json=json["sampleLocationsCount"];
[&](){sampleLocationsCount_json=member.sampleLocationsCount;}();
auto& pSampleLocations_json=json["pSampleLocations"];
[&](){
            if (member.pSampleLocations==NULL){
                pSampleLocations_json=boost::json::array();
            return; }pSampleLocations_json=boost::json::array(member.sampleLocationsCount);
        auto& arr_hcJZIRe=pSampleLocations_json.as_array();
        for(int WDzeUCV=0; WDzeUCV < member.sampleLocationsCount; WDzeUCV++){
            [&](){
            auto& temp=arr_hcJZIRe[WDzeUCV].emplace_object();
            return serialize_struct(temp, member.pSampleLocations[WDzeUCV]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSampleLocationsInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& sampleLocationsPerPixel_json=json["sampleLocationsPerPixel"];
[&](){[&](){int temp_izVjnwK;[&](){temp_izVjnwK=static_cast<int>(value_to<int>(sampleLocationsPerPixel_json));}();member.sampleLocationsPerPixel=(VkSampleCountFlagBits)temp_izVjnwK;}();}();
auto& sampleLocationGridSize_json=json["sampleLocationGridSize"];
[&](){
            auto& temp=sampleLocationGridSize_json.as_object();
            deserialize_struct(temp,member.sampleLocationGridSize);
            }();
auto& sampleLocationsCount_json=json["sampleLocationsCount"];
[&](){member.sampleLocationsCount=static_cast<uint32_t>(value_to<int>(sampleLocationsCount_json));}();
auto& pSampleLocations_json=json["pSampleLocations"];
[&](){ VkSampleLocationEXT* temp_wuRNVDs;;[&](){
            if (pSampleLocations_json.as_array().size()==0){
                temp_wuRNVDs=NULL;
            return; }temp_wuRNVDs=(VkSampleLocationEXT*)malloc(member.sampleLocationsCount*sizeof(VkSampleLocationEXT));
        auto& arr_epBvkbh=pSampleLocations_json.as_array();
        for(int gvcKPCT=0; gvcKPCT < member.sampleLocationsCount; gvcKPCT++){
            [&](){
            auto& temp=arr_epBvkbh[gvcKPCT].as_object();
            deserialize_struct(temp,temp_wuRNVDs[gvcKPCT]);
            }();
        }
        }();member.pSampleLocations=temp_wuRNVDs;}();
}

    void serialize_struct(boost::json::object& json, const VkAttachmentSampleLocationsEXT& member){
        
    
auto& attachmentIndex_json=json["attachmentIndex"];
[&](){attachmentIndex_json=member.attachmentIndex;}();
auto& sampleLocationsInfo_json=json["sampleLocationsInfo"];
[&](){
            auto& temp=sampleLocationsInfo_json.emplace_object();
            return serialize_struct(temp, member.sampleLocationsInfo);
            }();
}
void deserialize_struct(boost::json::object& json, VkAttachmentSampleLocationsEXT& member){
auto& attachmentIndex_json=json["attachmentIndex"];
[&](){member.attachmentIndex=static_cast<uint32_t>(value_to<int>(attachmentIndex_json));}();
auto& sampleLocationsInfo_json=json["sampleLocationsInfo"];
[&](){
            auto& temp=sampleLocationsInfo_json.as_object();
            deserialize_struct(temp,member.sampleLocationsInfo);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSubpassSampleLocationsEXT& member){
        
    
auto& subpassIndex_json=json["subpassIndex"];
[&](){subpassIndex_json=member.subpassIndex;}();
auto& sampleLocationsInfo_json=json["sampleLocationsInfo"];
[&](){
            auto& temp=sampleLocationsInfo_json.emplace_object();
            return serialize_struct(temp, member.sampleLocationsInfo);
            }();
}
void deserialize_struct(boost::json::object& json, VkSubpassSampleLocationsEXT& member){
auto& subpassIndex_json=json["subpassIndex"];
[&](){member.subpassIndex=static_cast<uint32_t>(value_to<int>(subpassIndex_json));}();
auto& sampleLocationsInfo_json=json["sampleLocationsInfo"];
[&](){
            auto& temp=sampleLocationsInfo_json.as_object();
            deserialize_struct(temp,member.sampleLocationsInfo);
            }();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassSampleLocationsBeginInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& attachmentInitialSampleLocationsCount_json=json["attachmentInitialSampleLocationsCount"];
[&](){attachmentInitialSampleLocationsCount_json=member.attachmentInitialSampleLocationsCount;}();
auto& pAttachmentInitialSampleLocations_json=json["pAttachmentInitialSampleLocations"];
[&](){
            if (member.pAttachmentInitialSampleLocations==NULL){
                pAttachmentInitialSampleLocations_json=boost::json::array();
            return; }pAttachmentInitialSampleLocations_json=boost::json::array(member.attachmentInitialSampleLocationsCount);
        auto& arr_uoyEAIr=pAttachmentInitialSampleLocations_json.as_array();
        for(int DOhkhGy=0; DOhkhGy < member.attachmentInitialSampleLocationsCount; DOhkhGy++){
            [&](){
            auto& temp=arr_uoyEAIr[DOhkhGy].emplace_object();
            return serialize_struct(temp, member.pAttachmentInitialSampleLocations[DOhkhGy]);
            }();
        }
        }();
auto& postSubpassSampleLocationsCount_json=json["postSubpassSampleLocationsCount"];
[&](){postSubpassSampleLocationsCount_json=member.postSubpassSampleLocationsCount;}();
auto& pPostSubpassSampleLocations_json=json["pPostSubpassSampleLocations"];
[&](){
            if (member.pPostSubpassSampleLocations==NULL){
                pPostSubpassSampleLocations_json=boost::json::array();
            return; }pPostSubpassSampleLocations_json=boost::json::array(member.postSubpassSampleLocationsCount);
        auto& arr_Xxtsvew=pPostSubpassSampleLocations_json.as_array();
        for(int jURSdBS=0; jURSdBS < member.postSubpassSampleLocationsCount; jURSdBS++){
            [&](){
            auto& temp=arr_Xxtsvew[jURSdBS].emplace_object();
            return serialize_struct(temp, member.pPostSubpassSampleLocations[jURSdBS]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassSampleLocationsBeginInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& attachmentInitialSampleLocationsCount_json=json["attachmentInitialSampleLocationsCount"];
[&](){member.attachmentInitialSampleLocationsCount=static_cast<uint32_t>(value_to<int>(attachmentInitialSampleLocationsCount_json));}();
auto& pAttachmentInitialSampleLocations_json=json["pAttachmentInitialSampleLocations"];
[&](){ VkAttachmentSampleLocationsEXT* temp_ERcHFFU;;[&](){
            if (pAttachmentInitialSampleLocations_json.as_array().size()==0){
                temp_ERcHFFU=NULL;
            return; }temp_ERcHFFU=(VkAttachmentSampleLocationsEXT*)malloc(member.attachmentInitialSampleLocationsCount*sizeof(VkAttachmentSampleLocationsEXT));
        auto& arr_xtIVgyp=pAttachmentInitialSampleLocations_json.as_array();
        for(int BOSAClk=0; BOSAClk < member.attachmentInitialSampleLocationsCount; BOSAClk++){
            [&](){
            auto& temp=arr_xtIVgyp[BOSAClk].as_object();
            deserialize_struct(temp,temp_ERcHFFU[BOSAClk]);
            }();
        }
        }();member.pAttachmentInitialSampleLocations=temp_ERcHFFU;}();
auto& postSubpassSampleLocationsCount_json=json["postSubpassSampleLocationsCount"];
[&](){member.postSubpassSampleLocationsCount=static_cast<uint32_t>(value_to<int>(postSubpassSampleLocationsCount_json));}();
auto& pPostSubpassSampleLocations_json=json["pPostSubpassSampleLocations"];
[&](){ VkSubpassSampleLocationsEXT* temp_ECwamcM;;[&](){
            if (pPostSubpassSampleLocations_json.as_array().size()==0){
                temp_ECwamcM=NULL;
            return; }temp_ECwamcM=(VkSubpassSampleLocationsEXT*)malloc(member.postSubpassSampleLocationsCount*sizeof(VkSubpassSampleLocationsEXT));
        auto& arr_LatqMmO=pPostSubpassSampleLocations_json.as_array();
        for(int VDulbuR=0; VDulbuR < member.postSubpassSampleLocationsCount; VDulbuR++){
            [&](){
            auto& temp=arr_LatqMmO[VDulbuR].as_object();
            deserialize_struct(temp,temp_ECwamcM[VDulbuR]);
            }();
        }
        }();member.pPostSubpassSampleLocations=temp_ECwamcM;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineSampleLocationsStateCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& sampleLocationsEnable_json=json["sampleLocationsEnable"];
[&](){[&](){sampleLocationsEnable_json=member.sampleLocationsEnable;}();}();
auto& sampleLocationsInfo_json=json["sampleLocationsInfo"];
[&](){
            auto& temp=sampleLocationsInfo_json.emplace_object();
            return serialize_struct(temp, member.sampleLocationsInfo);
            }();
}
void deserialize_struct(boost::json::object& json, VkPipelineSampleLocationsStateCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& sampleLocationsEnable_json=json["sampleLocationsEnable"];
[&](){uint32_t temp_zWSXwme;[&](){temp_zWSXwme=static_cast<uint32_t>(value_to<int>(sampleLocationsEnable_json));}();member.sampleLocationsEnable=(VkBool32)temp_zWSXwme;}();
auto& sampleLocationsInfo_json=json["sampleLocationsInfo"];
[&](){
            auto& temp=sampleLocationsInfo_json.as_object();
            deserialize_struct(temp,member.sampleLocationsInfo);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSampleLocationsPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& sampleLocationSampleCounts_json=json["sampleLocationSampleCounts"];
[&](){[&](){[&](){sampleLocationSampleCounts_json=member.sampleLocationSampleCounts;}();}();}();
auto& maxSampleLocationGridSize_json=json["maxSampleLocationGridSize"];
[&](){
            auto& temp=maxSampleLocationGridSize_json.emplace_object();
            return serialize_struct(temp, member.maxSampleLocationGridSize);
            }();
auto& sampleLocationCoordinateRange_json=json["sampleLocationCoordinateRange"];
[&](){sampleLocationCoordinateRange_json=boost::json::array(2);
        auto& arr_lePhSYU=sampleLocationCoordinateRange_json.as_array();
        for(int Heuchfn=0; Heuchfn < 2; Heuchfn++){
            [&](){arr_lePhSYU[Heuchfn]=member.sampleLocationCoordinateRange[Heuchfn];}();
        }
        }();
auto& sampleLocationSubPixelBits_json=json["sampleLocationSubPixelBits"];
[&](){sampleLocationSubPixelBits_json=member.sampleLocationSubPixelBits;}();
auto& variableSampleLocations_json=json["variableSampleLocations"];
[&](){[&](){variableSampleLocations_json=member.variableSampleLocations;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSampleLocationsPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& sampleLocationSampleCounts_json=json["sampleLocationSampleCounts"];
[&](){[&](){int temp_rQuxtGG;[&](){temp_rQuxtGG=static_cast<int>(value_to<int>(sampleLocationSampleCounts_json));}();member.sampleLocationSampleCounts=(VkSampleCountFlags)temp_rQuxtGG;}();}();
auto& maxSampleLocationGridSize_json=json["maxSampleLocationGridSize"];
[&](){
            auto& temp=maxSampleLocationGridSize_json.as_object();
            deserialize_struct(temp,member.maxSampleLocationGridSize);
            }();
auto& sampleLocationCoordinateRange_json=json["sampleLocationCoordinateRange"];
[&](){
        auto& arr_lePhSYU=sampleLocationCoordinateRange_json.as_array();
        for(int Heuchfn=0; Heuchfn < 2; Heuchfn++){
            [&](){member.sampleLocationCoordinateRange[Heuchfn]=static_cast<float>(value_to<int>(arr_lePhSYU[Heuchfn]));}();
        }
        }();
auto& sampleLocationSubPixelBits_json=json["sampleLocationSubPixelBits"];
[&](){member.sampleLocationSubPixelBits=static_cast<uint32_t>(value_to<int>(sampleLocationSubPixelBits_json));}();
auto& variableSampleLocations_json=json["variableSampleLocations"];
[&](){uint32_t temp_zNDCubo;[&](){temp_zNDCubo=static_cast<uint32_t>(value_to<int>(variableSampleLocations_json));}();member.variableSampleLocations=(VkBool32)temp_zNDCubo;}();
}

    void serialize_struct(boost::json::object& json, const VkMultisamplePropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxSampleLocationGridSize_json=json["maxSampleLocationGridSize"];
[&](){
            auto& temp=maxSampleLocationGridSize_json.emplace_object();
            return serialize_struct(temp, member.maxSampleLocationGridSize);
            }();
}
void deserialize_struct(boost::json::object& json, VkMultisamplePropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxSampleLocationGridSize_json=json["maxSampleLocationGridSize"];
[&](){
            auto& temp=maxSampleLocationGridSize_json.as_object();
            deserialize_struct(temp,member.maxSampleLocationGridSize);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSamplerReductionModeCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& reductionMode_json=json["reductionMode"];
[&](){[&](){[&](){reductionMode_json=member.reductionMode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSamplerReductionModeCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& reductionMode_json=json["reductionMode"];
[&](){[&](){int temp_nrAFcix;[&](){temp_nrAFcix=static_cast<int>(value_to<int>(reductionMode_json));}();member.reductionMode=(VkSamplerReductionMode)temp_nrAFcix;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& advancedBlendCoherentOperations_json=json["advancedBlendCoherentOperations"];
[&](){[&](){advancedBlendCoherentOperations_json=member.advancedBlendCoherentOperations;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& advancedBlendCoherentOperations_json=json["advancedBlendCoherentOperations"];
[&](){uint32_t temp_aKEBdfq;[&](){temp_aKEBdfq=static_cast<uint32_t>(value_to<int>(advancedBlendCoherentOperations_json));}();member.advancedBlendCoherentOperations=(VkBool32)temp_aKEBdfq;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMultiDrawFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& multiDraw_json=json["multiDraw"];
[&](){[&](){multiDraw_json=member.multiDraw;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMultiDrawFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& multiDraw_json=json["multiDraw"];
[&](){uint32_t temp_ePPthxq;[&](){temp_ePPthxq=static_cast<uint32_t>(value_to<int>(multiDraw_json));}();member.multiDraw=(VkBool32)temp_ePPthxq;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& advancedBlendMaxColorAttachments_json=json["advancedBlendMaxColorAttachments"];
[&](){advancedBlendMaxColorAttachments_json=member.advancedBlendMaxColorAttachments;}();
auto& advancedBlendIndependentBlend_json=json["advancedBlendIndependentBlend"];
[&](){[&](){advancedBlendIndependentBlend_json=member.advancedBlendIndependentBlend;}();}();
auto& advancedBlendNonPremultipliedSrcColor_json=json["advancedBlendNonPremultipliedSrcColor"];
[&](){[&](){advancedBlendNonPremultipliedSrcColor_json=member.advancedBlendNonPremultipliedSrcColor;}();}();
auto& advancedBlendNonPremultipliedDstColor_json=json["advancedBlendNonPremultipliedDstColor"];
[&](){[&](){advancedBlendNonPremultipliedDstColor_json=member.advancedBlendNonPremultipliedDstColor;}();}();
auto& advancedBlendCorrelatedOverlap_json=json["advancedBlendCorrelatedOverlap"];
[&](){[&](){advancedBlendCorrelatedOverlap_json=member.advancedBlendCorrelatedOverlap;}();}();
auto& advancedBlendAllOperations_json=json["advancedBlendAllOperations"];
[&](){[&](){advancedBlendAllOperations_json=member.advancedBlendAllOperations;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& advancedBlendMaxColorAttachments_json=json["advancedBlendMaxColorAttachments"];
[&](){member.advancedBlendMaxColorAttachments=static_cast<uint32_t>(value_to<int>(advancedBlendMaxColorAttachments_json));}();
auto& advancedBlendIndependentBlend_json=json["advancedBlendIndependentBlend"];
[&](){uint32_t temp_bkdbKgk;[&](){temp_bkdbKgk=static_cast<uint32_t>(value_to<int>(advancedBlendIndependentBlend_json));}();member.advancedBlendIndependentBlend=(VkBool32)temp_bkdbKgk;}();
auto& advancedBlendNonPremultipliedSrcColor_json=json["advancedBlendNonPremultipliedSrcColor"];
[&](){uint32_t temp_oEfxfgi;[&](){temp_oEfxfgi=static_cast<uint32_t>(value_to<int>(advancedBlendNonPremultipliedSrcColor_json));}();member.advancedBlendNonPremultipliedSrcColor=(VkBool32)temp_oEfxfgi;}();
auto& advancedBlendNonPremultipliedDstColor_json=json["advancedBlendNonPremultipliedDstColor"];
[&](){uint32_t temp_NEhLujf;[&](){temp_NEhLujf=static_cast<uint32_t>(value_to<int>(advancedBlendNonPremultipliedDstColor_json));}();member.advancedBlendNonPremultipliedDstColor=(VkBool32)temp_NEhLujf;}();
auto& advancedBlendCorrelatedOverlap_json=json["advancedBlendCorrelatedOverlap"];
[&](){uint32_t temp_hGEpfRj;[&](){temp_hGEpfRj=static_cast<uint32_t>(value_to<int>(advancedBlendCorrelatedOverlap_json));}();member.advancedBlendCorrelatedOverlap=(VkBool32)temp_hGEpfRj;}();
auto& advancedBlendAllOperations_json=json["advancedBlendAllOperations"];
[&](){uint32_t temp_gHyZnYt;[&](){temp_gHyZnYt=static_cast<uint32_t>(value_to<int>(advancedBlendAllOperations_json));}();member.advancedBlendAllOperations=(VkBool32)temp_gHyZnYt;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineColorBlendAdvancedStateCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcPremultiplied_json=json["srcPremultiplied"];
[&](){[&](){srcPremultiplied_json=member.srcPremultiplied;}();}();
auto& dstPremultiplied_json=json["dstPremultiplied"];
[&](){[&](){dstPremultiplied_json=member.dstPremultiplied;}();}();
auto& blendOverlap_json=json["blendOverlap"];
[&](){[&](){[&](){blendOverlap_json=member.blendOverlap;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineColorBlendAdvancedStateCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcPremultiplied_json=json["srcPremultiplied"];
[&](){uint32_t temp_INMFoxF;[&](){temp_INMFoxF=static_cast<uint32_t>(value_to<int>(srcPremultiplied_json));}();member.srcPremultiplied=(VkBool32)temp_INMFoxF;}();
auto& dstPremultiplied_json=json["dstPremultiplied"];
[&](){uint32_t temp_IepqSXd;[&](){temp_IepqSXd=static_cast<uint32_t>(value_to<int>(dstPremultiplied_json));}();member.dstPremultiplied=(VkBool32)temp_IepqSXd;}();
auto& blendOverlap_json=json["blendOverlap"];
[&](){[&](){int temp_mSHDMhO;[&](){temp_mSHDMhO=static_cast<int>(value_to<int>(blendOverlap_json));}();member.blendOverlap=(VkBlendOverlapEXT)temp_mSHDMhO;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceInlineUniformBlockFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& inlineUniformBlock_json=json["inlineUniformBlock"];
[&](){[&](){inlineUniformBlock_json=member.inlineUniformBlock;}();}();
auto& descriptorBindingInlineUniformBlockUpdateAfterBind_json=json["descriptorBindingInlineUniformBlockUpdateAfterBind"];
[&](){[&](){descriptorBindingInlineUniformBlockUpdateAfterBind_json=member.descriptorBindingInlineUniformBlockUpdateAfterBind;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceInlineUniformBlockFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& inlineUniformBlock_json=json["inlineUniformBlock"];
[&](){uint32_t temp_AHQNchS;[&](){temp_AHQNchS=static_cast<uint32_t>(value_to<int>(inlineUniformBlock_json));}();member.inlineUniformBlock=(VkBool32)temp_AHQNchS;}();
auto& descriptorBindingInlineUniformBlockUpdateAfterBind_json=json["descriptorBindingInlineUniformBlockUpdateAfterBind"];
[&](){uint32_t temp_HCUdNQI;[&](){temp_HCUdNQI=static_cast<uint32_t>(value_to<int>(descriptorBindingInlineUniformBlockUpdateAfterBind_json));}();member.descriptorBindingInlineUniformBlockUpdateAfterBind=(VkBool32)temp_HCUdNQI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceInlineUniformBlockProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxInlineUniformBlockSize_json=json["maxInlineUniformBlockSize"];
[&](){maxInlineUniformBlockSize_json=member.maxInlineUniformBlockSize;}();
auto& maxPerStageDescriptorInlineUniformBlocks_json=json["maxPerStageDescriptorInlineUniformBlocks"];
[&](){maxPerStageDescriptorInlineUniformBlocks_json=member.maxPerStageDescriptorInlineUniformBlocks;}();
auto& maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_json=json["maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks"];
[&](){maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_json=member.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;}();
auto& maxDescriptorSetInlineUniformBlocks_json=json["maxDescriptorSetInlineUniformBlocks"];
[&](){maxDescriptorSetInlineUniformBlocks_json=member.maxDescriptorSetInlineUniformBlocks;}();
auto& maxDescriptorSetUpdateAfterBindInlineUniformBlocks_json=json["maxDescriptorSetUpdateAfterBindInlineUniformBlocks"];
[&](){maxDescriptorSetUpdateAfterBindInlineUniformBlocks_json=member.maxDescriptorSetUpdateAfterBindInlineUniformBlocks;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceInlineUniformBlockProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxInlineUniformBlockSize_json=json["maxInlineUniformBlockSize"];
[&](){member.maxInlineUniformBlockSize=static_cast<uint32_t>(value_to<int>(maxInlineUniformBlockSize_json));}();
auto& maxPerStageDescriptorInlineUniformBlocks_json=json["maxPerStageDescriptorInlineUniformBlocks"];
[&](){member.maxPerStageDescriptorInlineUniformBlocks=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorInlineUniformBlocks_json));}();
auto& maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_json=json["maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks"];
[&](){member.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_json));}();
auto& maxDescriptorSetInlineUniformBlocks_json=json["maxDescriptorSetInlineUniformBlocks"];
[&](){member.maxDescriptorSetInlineUniformBlocks=static_cast<uint32_t>(value_to<int>(maxDescriptorSetInlineUniformBlocks_json));}();
auto& maxDescriptorSetUpdateAfterBindInlineUniformBlocks_json=json["maxDescriptorSetUpdateAfterBindInlineUniformBlocks"];
[&](){member.maxDescriptorSetUpdateAfterBindInlineUniformBlocks=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindInlineUniformBlocks_json));}();
}

    void serialize_struct(boost::json::object& json, const VkWriteDescriptorSetInlineUniformBlock& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dataSize_json=json["dataSize"];
[&](){dataSize_json=member.dataSize;}();
auto& pData_json=json["pData"];
[&](){
            if (member.pData==NULL){
                pData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pData))==NULL){
                pData_json=boost::json::array();
            return; }pData_json=boost::json::array(member.dataSize);
        auto& arr_cukaPTa=pData_json.as_array();
        for(int UqwNSOA=0; UqwNSOA < member.dataSize; UqwNSOA++){
            [&](){arr_cukaPTa[UqwNSOA]=((char*)(member.pData))[UqwNSOA];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkWriteDescriptorSetInlineUniformBlock& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& dataSize_json=json["dataSize"];
[&](){member.dataSize=static_cast<uint32_t>(value_to<int>(dataSize_json));}();
auto& pData_json=json["pData"];
[&](){ void* temp_rZvPbwc;;[&](){
            if (pData_json.as_array().size()==0){
                temp_rZvPbwc=NULL;
            return; }char* temp_qtCaFHh;[&](){
            if (pData_json.as_array().size()==0){
                temp_qtCaFHh=NULL;
            return; }temp_qtCaFHh=(char*)malloc(member.dataSize*sizeof(char));
        auto& arr_XpObFOU=pData_json.as_array();
        for(int tUplioR=0; tUplioR < member.dataSize; tUplioR++){
            [&](){temp_qtCaFHh[tUplioR]=static_cast<char>(value_to<int>(arr_XpObFOU[tUplioR]));}();
        }
        }();temp_rZvPbwc=temp_qtCaFHh;}();member.pData=temp_rZvPbwc;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorPoolInlineUniformBlockCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxInlineUniformBlockBindings_json=json["maxInlineUniformBlockBindings"];
[&](){maxInlineUniformBlockBindings_json=member.maxInlineUniformBlockBindings;}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorPoolInlineUniformBlockCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& maxInlineUniformBlockBindings_json=json["maxInlineUniformBlockBindings"];
[&](){member.maxInlineUniformBlockBindings=static_cast<uint32_t>(value_to<int>(maxInlineUniformBlockBindings_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineCoverageModulationStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& coverageModulationMode_json=json["coverageModulationMode"];
[&](){[&](){[&](){coverageModulationMode_json=member.coverageModulationMode;}();}();}();
auto& coverageModulationTableEnable_json=json["coverageModulationTableEnable"];
[&](){[&](){coverageModulationTableEnable_json=member.coverageModulationTableEnable;}();}();
auto& coverageModulationTableCount_json=json["coverageModulationTableCount"];
[&](){coverageModulationTableCount_json=member.coverageModulationTableCount;}();
auto& pCoverageModulationTable_json=json["pCoverageModulationTable"];
[&](){
            if (member.pCoverageModulationTable==NULL){
                pCoverageModulationTable_json=boost::json::array();
            return; }pCoverageModulationTable_json=boost::json::array(member.coverageModulationTableCount);
        auto& arr_FjPQHFM=pCoverageModulationTable_json.as_array();
        for(int XyJiZTx=0; XyJiZTx < member.coverageModulationTableCount; XyJiZTx++){
            [&](){arr_FjPQHFM[XyJiZTx]=member.pCoverageModulationTable[XyJiZTx];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineCoverageModulationStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_LcwKvUi;[&](){temp_LcwKvUi=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCoverageModulationStateCreateFlagsNV)temp_LcwKvUi;}();}();
auto& coverageModulationMode_json=json["coverageModulationMode"];
[&](){[&](){int temp_MRYVPuK;[&](){temp_MRYVPuK=static_cast<int>(value_to<int>(coverageModulationMode_json));}();member.coverageModulationMode=(VkCoverageModulationModeNV)temp_MRYVPuK;}();}();
auto& coverageModulationTableEnable_json=json["coverageModulationTableEnable"];
[&](){uint32_t temp_tHfYfQs;[&](){temp_tHfYfQs=static_cast<uint32_t>(value_to<int>(coverageModulationTableEnable_json));}();member.coverageModulationTableEnable=(VkBool32)temp_tHfYfQs;}();
auto& coverageModulationTableCount_json=json["coverageModulationTableCount"];
[&](){member.coverageModulationTableCount=static_cast<uint32_t>(value_to<int>(coverageModulationTableCount_json));}();
auto& pCoverageModulationTable_json=json["pCoverageModulationTable"];
[&](){ float* temp_LmWguXJ;;[&](){
            if (pCoverageModulationTable_json.as_array().size()==0){
                temp_LmWguXJ=NULL;
            return; }temp_LmWguXJ=(float*)malloc(member.coverageModulationTableCount*sizeof(float));
        auto& arr_lJinxAF=pCoverageModulationTable_json.as_array();
        for(int ESdXHEn=0; ESdXHEn < member.coverageModulationTableCount; ESdXHEn++){
            [&](){temp_LmWguXJ[ESdXHEn]=static_cast<float>(value_to<int>(arr_lJinxAF[ESdXHEn]));}();
        }
        }();member.pCoverageModulationTable=temp_LmWguXJ;}();
}

    void serialize_struct(boost::json::object& json, const VkImageFormatListCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& viewFormatCount_json=json["viewFormatCount"];
[&](){viewFormatCount_json=member.viewFormatCount;}();
auto& pViewFormats_json=json["pViewFormats"];
[&](){
            if (member.pViewFormats==NULL){
                pViewFormats_json=boost::json::array();
            return; }pViewFormats_json=boost::json::array(member.viewFormatCount);
        auto& arr_WbFQnzp=pViewFormats_json.as_array();
        for(int fIUeIsy=0; fIUeIsy < member.viewFormatCount; fIUeIsy++){
            [&](){[&](){[&](){arr_WbFQnzp[fIUeIsy]=member.pViewFormats[fIUeIsy];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkImageFormatListCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& viewFormatCount_json=json["viewFormatCount"];
[&](){member.viewFormatCount=static_cast<uint32_t>(value_to<int>(viewFormatCount_json));}();
auto& pViewFormats_json=json["pViewFormats"];
[&](){ VkFormat* temp_SOycFlu;;[&](){
            if (pViewFormats_json.as_array().size()==0){
                temp_SOycFlu=NULL;
            return; }temp_SOycFlu=(VkFormat*)malloc(member.viewFormatCount*sizeof(VkFormat));
        auto& arr_rDRQrBj=pViewFormats_json.as_array();
        for(int GVlCsiU=0; GVlCsiU < member.viewFormatCount; GVlCsiU++){
            [&](){[&](){int temp_rkEfzeZ;[&](){temp_rkEfzeZ=static_cast<int>(value_to<int>(arr_rDRQrBj[GVlCsiU]));}();temp_SOycFlu[GVlCsiU]=(VkFormat)temp_rkEfzeZ;}();}();
        }
        }();member.pViewFormats=temp_SOycFlu;}();
}

    void serialize_struct(boost::json::object& json, const VkValidationCacheCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& initialDataSize_json=json["initialDataSize"];
[&](){initialDataSize_json=member.initialDataSize;}();
auto& pInitialData_json=json["pInitialData"];
[&](){
            if (member.pInitialData==NULL){
                pInitialData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pInitialData))==NULL){
                pInitialData_json=boost::json::array();
            return; }pInitialData_json=boost::json::array(member.initialDataSize);
        auto& arr_cScJjND=pInitialData_json.as_array();
        for(int iGwyJEq=0; iGwyJEq < member.initialDataSize; iGwyJEq++){
            [&](){arr_cScJjND[iGwyJEq]=((char*)(member.pInitialData))[iGwyJEq];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkValidationCacheCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_zYBBiYm;[&](){temp_zYBBiYm=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkValidationCacheCreateFlagsEXT)temp_zYBBiYm;}();}();
auto& initialDataSize_json=json["initialDataSize"];
[&](){member.initialDataSize=static_cast<size_t>(value_to<int>(initialDataSize_json));}();
auto& pInitialData_json=json["pInitialData"];
[&](){ void* temp_sCprdNy;;[&](){
            if (pInitialData_json.as_array().size()==0){
                temp_sCprdNy=NULL;
            return; }char* temp_jJhMRIG;[&](){
            if (pInitialData_json.as_array().size()==0){
                temp_jJhMRIG=NULL;
            return; }temp_jJhMRIG=(char*)malloc(member.initialDataSize*sizeof(char));
        auto& arr_COCjXDl=pInitialData_json.as_array();
        for(int zledvTk=0; zledvTk < member.initialDataSize; zledvTk++){
            [&](){temp_jJhMRIG[zledvTk]=static_cast<char>(value_to<int>(arr_COCjXDl[zledvTk]));}();
        }
        }();temp_sCprdNy=temp_jJhMRIG;}();member.pInitialData=temp_sCprdNy;}();
}

    void serialize_struct(boost::json::object& json, const VkShaderModuleValidationCacheCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& validationCache_json=json["validationCache"];
[&](){serialize_VkValidationCacheEXT(validationCache_json,member.validationCache);}();
}
void deserialize_struct(boost::json::object& json, VkShaderModuleValidationCacheCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& validationCache_json=json["validationCache"];
[&](){deserialize_VkValidationCacheEXT(validationCache_json, member.validationCache);}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMaintenance3Properties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxPerSetDescriptors_json=json["maxPerSetDescriptors"];
[&](){maxPerSetDescriptors_json=member.maxPerSetDescriptors;}();
auto& maxMemoryAllocationSize_json=json["maxMemoryAllocationSize"];
[&](){[&](){maxMemoryAllocationSize_json=member.maxMemoryAllocationSize;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMaintenance3Properties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxPerSetDescriptors_json=json["maxPerSetDescriptors"];
[&](){member.maxPerSetDescriptors=static_cast<uint32_t>(value_to<int>(maxPerSetDescriptors_json));}();
auto& maxMemoryAllocationSize_json=json["maxMemoryAllocationSize"];
[&](){uint64_t temp_mtnouHJ;[&](){temp_mtnouHJ=static_cast<uint64_t>(value_to<int>(maxMemoryAllocationSize_json));}();member.maxMemoryAllocationSize=(VkDeviceSize)temp_mtnouHJ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMaintenance4Features& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maintenance4_json=json["maintenance4"];
[&](){[&](){maintenance4_json=member.maintenance4;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMaintenance4Features& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maintenance4_json=json["maintenance4"];
[&](){uint32_t temp_nYvfKwI;[&](){temp_nYvfKwI=static_cast<uint32_t>(value_to<int>(maintenance4_json));}();member.maintenance4=(VkBool32)temp_nYvfKwI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMaintenance4Properties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxBufferSize_json=json["maxBufferSize"];
[&](){[&](){maxBufferSize_json=member.maxBufferSize;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMaintenance4Properties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxBufferSize_json=json["maxBufferSize"];
[&](){uint64_t temp_tgfIjmh;[&](){temp_tgfIjmh=static_cast<uint64_t>(value_to<int>(maxBufferSize_json));}();member.maxBufferSize=(VkDeviceSize)temp_tgfIjmh;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMaintenance5FeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maintenance5_json=json["maintenance5"];
[&](){[&](){maintenance5_json=member.maintenance5;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMaintenance5FeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maintenance5_json=json["maintenance5"];
[&](){uint32_t temp_GpunevI;[&](){temp_GpunevI=static_cast<uint32_t>(value_to<int>(maintenance5_json));}();member.maintenance5=(VkBool32)temp_GpunevI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMaintenance5PropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& earlyFragmentMultisampleCoverageAfterSampleCounting_json=json["earlyFragmentMultisampleCoverageAfterSampleCounting"];
[&](){[&](){earlyFragmentMultisampleCoverageAfterSampleCounting_json=member.earlyFragmentMultisampleCoverageAfterSampleCounting;}();}();
auto& earlyFragmentSampleMaskTestBeforeSampleCounting_json=json["earlyFragmentSampleMaskTestBeforeSampleCounting"];
[&](){[&](){earlyFragmentSampleMaskTestBeforeSampleCounting_json=member.earlyFragmentSampleMaskTestBeforeSampleCounting;}();}();
auto& depthStencilSwizzleOneSupport_json=json["depthStencilSwizzleOneSupport"];
[&](){[&](){depthStencilSwizzleOneSupport_json=member.depthStencilSwizzleOneSupport;}();}();
auto& polygonModePointSize_json=json["polygonModePointSize"];
[&](){[&](){polygonModePointSize_json=member.polygonModePointSize;}();}();
auto& nonStrictSinglePixelWideLinesUseParallelogram_json=json["nonStrictSinglePixelWideLinesUseParallelogram"];
[&](){[&](){nonStrictSinglePixelWideLinesUseParallelogram_json=member.nonStrictSinglePixelWideLinesUseParallelogram;}();}();
auto& nonStrictWideLinesUseParallelogram_json=json["nonStrictWideLinesUseParallelogram"];
[&](){[&](){nonStrictWideLinesUseParallelogram_json=member.nonStrictWideLinesUseParallelogram;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMaintenance5PropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& earlyFragmentMultisampleCoverageAfterSampleCounting_json=json["earlyFragmentMultisampleCoverageAfterSampleCounting"];
[&](){uint32_t temp_VTxSJlE;[&](){temp_VTxSJlE=static_cast<uint32_t>(value_to<int>(earlyFragmentMultisampleCoverageAfterSampleCounting_json));}();member.earlyFragmentMultisampleCoverageAfterSampleCounting=(VkBool32)temp_VTxSJlE;}();
auto& earlyFragmentSampleMaskTestBeforeSampleCounting_json=json["earlyFragmentSampleMaskTestBeforeSampleCounting"];
[&](){uint32_t temp_xLzFsvY;[&](){temp_xLzFsvY=static_cast<uint32_t>(value_to<int>(earlyFragmentSampleMaskTestBeforeSampleCounting_json));}();member.earlyFragmentSampleMaskTestBeforeSampleCounting=(VkBool32)temp_xLzFsvY;}();
auto& depthStencilSwizzleOneSupport_json=json["depthStencilSwizzleOneSupport"];
[&](){uint32_t temp_gMvLnIJ;[&](){temp_gMvLnIJ=static_cast<uint32_t>(value_to<int>(depthStencilSwizzleOneSupport_json));}();member.depthStencilSwizzleOneSupport=(VkBool32)temp_gMvLnIJ;}();
auto& polygonModePointSize_json=json["polygonModePointSize"];
[&](){uint32_t temp_pYRQvOn;[&](){temp_pYRQvOn=static_cast<uint32_t>(value_to<int>(polygonModePointSize_json));}();member.polygonModePointSize=(VkBool32)temp_pYRQvOn;}();
auto& nonStrictSinglePixelWideLinesUseParallelogram_json=json["nonStrictSinglePixelWideLinesUseParallelogram"];
[&](){uint32_t temp_VcjEdRk;[&](){temp_VcjEdRk=static_cast<uint32_t>(value_to<int>(nonStrictSinglePixelWideLinesUseParallelogram_json));}();member.nonStrictSinglePixelWideLinesUseParallelogram=(VkBool32)temp_VcjEdRk;}();
auto& nonStrictWideLinesUseParallelogram_json=json["nonStrictWideLinesUseParallelogram"];
[&](){uint32_t temp_vBgmEOz;[&](){temp_vBgmEOz=static_cast<uint32_t>(value_to<int>(nonStrictWideLinesUseParallelogram_json));}();member.nonStrictWideLinesUseParallelogram=(VkBool32)temp_vBgmEOz;}();
}

    void serialize_struct(boost::json::object& json, const VkRenderingAreaInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& viewMask_json=json["viewMask"];
[&](){viewMask_json=member.viewMask;}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){colorAttachmentCount_json=member.colorAttachmentCount;}();
auto& pColorAttachmentFormats_json=json["pColorAttachmentFormats"];
[&](){
            if (member.pColorAttachmentFormats==NULL){
                pColorAttachmentFormats_json=boost::json::array();
            return; }pColorAttachmentFormats_json=boost::json::array(member.colorAttachmentCount);
        auto& arr_rhmCrPX=pColorAttachmentFormats_json.as_array();
        for(int yamBoue=0; yamBoue < member.colorAttachmentCount; yamBoue++){
            [&](){[&](){[&](){arr_rhmCrPX[yamBoue]=member.pColorAttachmentFormats[yamBoue];}();}();}();
        }
        }();
auto& depthAttachmentFormat_json=json["depthAttachmentFormat"];
[&](){[&](){[&](){depthAttachmentFormat_json=member.depthAttachmentFormat;}();}();}();
auto& stencilAttachmentFormat_json=json["stencilAttachmentFormat"];
[&](){[&](){[&](){stencilAttachmentFormat_json=member.stencilAttachmentFormat;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkRenderingAreaInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& viewMask_json=json["viewMask"];
[&](){member.viewMask=static_cast<uint32_t>(value_to<int>(viewMask_json));}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){member.colorAttachmentCount=static_cast<uint32_t>(value_to<int>(colorAttachmentCount_json));}();
auto& pColorAttachmentFormats_json=json["pColorAttachmentFormats"];
[&](){ VkFormat* temp_GSTTjFs;;[&](){
            if (pColorAttachmentFormats_json.as_array().size()==0){
                temp_GSTTjFs=NULL;
            return; }temp_GSTTjFs=(VkFormat*)malloc(member.colorAttachmentCount*sizeof(VkFormat));
        auto& arr_ysBTEbK=pColorAttachmentFormats_json.as_array();
        for(int kpUTDXF=0; kpUTDXF < member.colorAttachmentCount; kpUTDXF++){
            [&](){[&](){int temp_KScoGUe;[&](){temp_KScoGUe=static_cast<int>(value_to<int>(arr_ysBTEbK[kpUTDXF]));}();temp_GSTTjFs[kpUTDXF]=(VkFormat)temp_KScoGUe;}();}();
        }
        }();member.pColorAttachmentFormats=temp_GSTTjFs;}();
auto& depthAttachmentFormat_json=json["depthAttachmentFormat"];
[&](){[&](){int temp_MlsQvpU;[&](){temp_MlsQvpU=static_cast<int>(value_to<int>(depthAttachmentFormat_json));}();member.depthAttachmentFormat=(VkFormat)temp_MlsQvpU;}();}();
auto& stencilAttachmentFormat_json=json["stencilAttachmentFormat"];
[&](){[&](){int temp_XITlXNi;[&](){temp_XITlXNi=static_cast<int>(value_to<int>(stencilAttachmentFormat_json));}();member.stencilAttachmentFormat=(VkFormat)temp_XITlXNi;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorSetLayoutSupport& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& supported_json=json["supported"];
[&](){[&](){supported_json=member.supported;}();}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorSetLayoutSupport& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& supported_json=json["supported"];
[&](){uint32_t temp_gsfTEBC;[&](){temp_gsfTEBC=static_cast<uint32_t>(value_to<int>(supported_json));}();member.supported=(VkBool32)temp_gsfTEBC;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderDrawParametersFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderDrawParameters_json=json["shaderDrawParameters"];
[&](){[&](){shaderDrawParameters_json=member.shaderDrawParameters;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderDrawParametersFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderDrawParameters_json=json["shaderDrawParameters"];
[&](){uint32_t temp_RrCBUNI;[&](){temp_RrCBUNI=static_cast<uint32_t>(value_to<int>(shaderDrawParameters_json));}();member.shaderDrawParameters=(VkBool32)temp_RrCBUNI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderFloat16Int8Features& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderFloat16_json=json["shaderFloat16"];
[&](){[&](){shaderFloat16_json=member.shaderFloat16;}();}();
auto& shaderInt8_json=json["shaderInt8"];
[&](){[&](){shaderInt8_json=member.shaderInt8;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderFloat16Int8Features& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderFloat16_json=json["shaderFloat16"];
[&](){uint32_t temp_HaJynSC;[&](){temp_HaJynSC=static_cast<uint32_t>(value_to<int>(shaderFloat16_json));}();member.shaderFloat16=(VkBool32)temp_HaJynSC;}();
auto& shaderInt8_json=json["shaderInt8"];
[&](){uint32_t temp_PUHXULH;[&](){temp_PUHXULH=static_cast<uint32_t>(value_to<int>(shaderInt8_json));}();member.shaderInt8=(VkBool32)temp_PUHXULH;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFloatControlsProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& denormBehaviorIndependence_json=json["denormBehaviorIndependence"];
[&](){[&](){[&](){denormBehaviorIndependence_json=member.denormBehaviorIndependence;}();}();}();
auto& roundingModeIndependence_json=json["roundingModeIndependence"];
[&](){[&](){[&](){roundingModeIndependence_json=member.roundingModeIndependence;}();}();}();
auto& shaderSignedZeroInfNanPreserveFloat16_json=json["shaderSignedZeroInfNanPreserveFloat16"];
[&](){[&](){shaderSignedZeroInfNanPreserveFloat16_json=member.shaderSignedZeroInfNanPreserveFloat16;}();}();
auto& shaderSignedZeroInfNanPreserveFloat32_json=json["shaderSignedZeroInfNanPreserveFloat32"];
[&](){[&](){shaderSignedZeroInfNanPreserveFloat32_json=member.shaderSignedZeroInfNanPreserveFloat32;}();}();
auto& shaderSignedZeroInfNanPreserveFloat64_json=json["shaderSignedZeroInfNanPreserveFloat64"];
[&](){[&](){shaderSignedZeroInfNanPreserveFloat64_json=member.shaderSignedZeroInfNanPreserveFloat64;}();}();
auto& shaderDenormPreserveFloat16_json=json["shaderDenormPreserveFloat16"];
[&](){[&](){shaderDenormPreserveFloat16_json=member.shaderDenormPreserveFloat16;}();}();
auto& shaderDenormPreserveFloat32_json=json["shaderDenormPreserveFloat32"];
[&](){[&](){shaderDenormPreserveFloat32_json=member.shaderDenormPreserveFloat32;}();}();
auto& shaderDenormPreserveFloat64_json=json["shaderDenormPreserveFloat64"];
[&](){[&](){shaderDenormPreserveFloat64_json=member.shaderDenormPreserveFloat64;}();}();
auto& shaderDenormFlushToZeroFloat16_json=json["shaderDenormFlushToZeroFloat16"];
[&](){[&](){shaderDenormFlushToZeroFloat16_json=member.shaderDenormFlushToZeroFloat16;}();}();
auto& shaderDenormFlushToZeroFloat32_json=json["shaderDenormFlushToZeroFloat32"];
[&](){[&](){shaderDenormFlushToZeroFloat32_json=member.shaderDenormFlushToZeroFloat32;}();}();
auto& shaderDenormFlushToZeroFloat64_json=json["shaderDenormFlushToZeroFloat64"];
[&](){[&](){shaderDenormFlushToZeroFloat64_json=member.shaderDenormFlushToZeroFloat64;}();}();
auto& shaderRoundingModeRTEFloat16_json=json["shaderRoundingModeRTEFloat16"];
[&](){[&](){shaderRoundingModeRTEFloat16_json=member.shaderRoundingModeRTEFloat16;}();}();
auto& shaderRoundingModeRTEFloat32_json=json["shaderRoundingModeRTEFloat32"];
[&](){[&](){shaderRoundingModeRTEFloat32_json=member.shaderRoundingModeRTEFloat32;}();}();
auto& shaderRoundingModeRTEFloat64_json=json["shaderRoundingModeRTEFloat64"];
[&](){[&](){shaderRoundingModeRTEFloat64_json=member.shaderRoundingModeRTEFloat64;}();}();
auto& shaderRoundingModeRTZFloat16_json=json["shaderRoundingModeRTZFloat16"];
[&](){[&](){shaderRoundingModeRTZFloat16_json=member.shaderRoundingModeRTZFloat16;}();}();
auto& shaderRoundingModeRTZFloat32_json=json["shaderRoundingModeRTZFloat32"];
[&](){[&](){shaderRoundingModeRTZFloat32_json=member.shaderRoundingModeRTZFloat32;}();}();
auto& shaderRoundingModeRTZFloat64_json=json["shaderRoundingModeRTZFloat64"];
[&](){[&](){shaderRoundingModeRTZFloat64_json=member.shaderRoundingModeRTZFloat64;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFloatControlsProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& denormBehaviorIndependence_json=json["denormBehaviorIndependence"];
[&](){[&](){int temp_BLtKgXu;[&](){temp_BLtKgXu=static_cast<int>(value_to<int>(denormBehaviorIndependence_json));}();member.denormBehaviorIndependence=(VkShaderFloatControlsIndependence)temp_BLtKgXu;}();}();
auto& roundingModeIndependence_json=json["roundingModeIndependence"];
[&](){[&](){int temp_HJUeGxa;[&](){temp_HJUeGxa=static_cast<int>(value_to<int>(roundingModeIndependence_json));}();member.roundingModeIndependence=(VkShaderFloatControlsIndependence)temp_HJUeGxa;}();}();
auto& shaderSignedZeroInfNanPreserveFloat16_json=json["shaderSignedZeroInfNanPreserveFloat16"];
[&](){uint32_t temp_rWhIHaR;[&](){temp_rWhIHaR=static_cast<uint32_t>(value_to<int>(shaderSignedZeroInfNanPreserveFloat16_json));}();member.shaderSignedZeroInfNanPreserveFloat16=(VkBool32)temp_rWhIHaR;}();
auto& shaderSignedZeroInfNanPreserveFloat32_json=json["shaderSignedZeroInfNanPreserveFloat32"];
[&](){uint32_t temp_TvnMBEH;[&](){temp_TvnMBEH=static_cast<uint32_t>(value_to<int>(shaderSignedZeroInfNanPreserveFloat32_json));}();member.shaderSignedZeroInfNanPreserveFloat32=(VkBool32)temp_TvnMBEH;}();
auto& shaderSignedZeroInfNanPreserveFloat64_json=json["shaderSignedZeroInfNanPreserveFloat64"];
[&](){uint32_t temp_kwFSZOJ;[&](){temp_kwFSZOJ=static_cast<uint32_t>(value_to<int>(shaderSignedZeroInfNanPreserveFloat64_json));}();member.shaderSignedZeroInfNanPreserveFloat64=(VkBool32)temp_kwFSZOJ;}();
auto& shaderDenormPreserveFloat16_json=json["shaderDenormPreserveFloat16"];
[&](){uint32_t temp_ZYjrgpL;[&](){temp_ZYjrgpL=static_cast<uint32_t>(value_to<int>(shaderDenormPreserveFloat16_json));}();member.shaderDenormPreserveFloat16=(VkBool32)temp_ZYjrgpL;}();
auto& shaderDenormPreserveFloat32_json=json["shaderDenormPreserveFloat32"];
[&](){uint32_t temp_sfVRrPx;[&](){temp_sfVRrPx=static_cast<uint32_t>(value_to<int>(shaderDenormPreserveFloat32_json));}();member.shaderDenormPreserveFloat32=(VkBool32)temp_sfVRrPx;}();
auto& shaderDenormPreserveFloat64_json=json["shaderDenormPreserveFloat64"];
[&](){uint32_t temp_UPaBbGA;[&](){temp_UPaBbGA=static_cast<uint32_t>(value_to<int>(shaderDenormPreserveFloat64_json));}();member.shaderDenormPreserveFloat64=(VkBool32)temp_UPaBbGA;}();
auto& shaderDenormFlushToZeroFloat16_json=json["shaderDenormFlushToZeroFloat16"];
[&](){uint32_t temp_GmxfgYW;[&](){temp_GmxfgYW=static_cast<uint32_t>(value_to<int>(shaderDenormFlushToZeroFloat16_json));}();member.shaderDenormFlushToZeroFloat16=(VkBool32)temp_GmxfgYW;}();
auto& shaderDenormFlushToZeroFloat32_json=json["shaderDenormFlushToZeroFloat32"];
[&](){uint32_t temp_nWzegbQ;[&](){temp_nWzegbQ=static_cast<uint32_t>(value_to<int>(shaderDenormFlushToZeroFloat32_json));}();member.shaderDenormFlushToZeroFloat32=(VkBool32)temp_nWzegbQ;}();
auto& shaderDenormFlushToZeroFloat64_json=json["shaderDenormFlushToZeroFloat64"];
[&](){uint32_t temp_LCXslrc;[&](){temp_LCXslrc=static_cast<uint32_t>(value_to<int>(shaderDenormFlushToZeroFloat64_json));}();member.shaderDenormFlushToZeroFloat64=(VkBool32)temp_LCXslrc;}();
auto& shaderRoundingModeRTEFloat16_json=json["shaderRoundingModeRTEFloat16"];
[&](){uint32_t temp_OoWLdCy;[&](){temp_OoWLdCy=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTEFloat16_json));}();member.shaderRoundingModeRTEFloat16=(VkBool32)temp_OoWLdCy;}();
auto& shaderRoundingModeRTEFloat32_json=json["shaderRoundingModeRTEFloat32"];
[&](){uint32_t temp_WzAzxFg;[&](){temp_WzAzxFg=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTEFloat32_json));}();member.shaderRoundingModeRTEFloat32=(VkBool32)temp_WzAzxFg;}();
auto& shaderRoundingModeRTEFloat64_json=json["shaderRoundingModeRTEFloat64"];
[&](){uint32_t temp_OLqczsx;[&](){temp_OLqczsx=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTEFloat64_json));}();member.shaderRoundingModeRTEFloat64=(VkBool32)temp_OLqczsx;}();
auto& shaderRoundingModeRTZFloat16_json=json["shaderRoundingModeRTZFloat16"];
[&](){uint32_t temp_xlTjUUK;[&](){temp_xlTjUUK=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTZFloat16_json));}();member.shaderRoundingModeRTZFloat16=(VkBool32)temp_xlTjUUK;}();
auto& shaderRoundingModeRTZFloat32_json=json["shaderRoundingModeRTZFloat32"];
[&](){uint32_t temp_CVmsBXR;[&](){temp_CVmsBXR=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTZFloat32_json));}();member.shaderRoundingModeRTZFloat32=(VkBool32)temp_CVmsBXR;}();
auto& shaderRoundingModeRTZFloat64_json=json["shaderRoundingModeRTZFloat64"];
[&](){uint32_t temp_jLYPXAU;[&](){temp_jLYPXAU=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTZFloat64_json));}();member.shaderRoundingModeRTZFloat64=(VkBool32)temp_jLYPXAU;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceHostQueryResetFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& hostQueryReset_json=json["hostQueryReset"];
[&](){[&](){hostQueryReset_json=member.hostQueryReset;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceHostQueryResetFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& hostQueryReset_json=json["hostQueryReset"];
[&](){uint32_t temp_xScjSSB;[&](){temp_xScjSSB=static_cast<uint32_t>(value_to<int>(hostQueryReset_json));}();member.hostQueryReset=(VkBool32)temp_xScjSSB;}();
}

    void serialize_struct(boost::json::object& json, const VkShaderResourceUsageAMD& member){
        
    
auto& numUsedVgprs_json=json["numUsedVgprs"];
[&](){numUsedVgprs_json=member.numUsedVgprs;}();
auto& numUsedSgprs_json=json["numUsedSgprs"];
[&](){numUsedSgprs_json=member.numUsedSgprs;}();
auto& ldsSizePerLocalWorkGroup_json=json["ldsSizePerLocalWorkGroup"];
[&](){ldsSizePerLocalWorkGroup_json=member.ldsSizePerLocalWorkGroup;}();
auto& ldsUsageSizeInBytes_json=json["ldsUsageSizeInBytes"];
[&](){ldsUsageSizeInBytes_json=member.ldsUsageSizeInBytes;}();
auto& scratchMemUsageInBytes_json=json["scratchMemUsageInBytes"];
[&](){scratchMemUsageInBytes_json=member.scratchMemUsageInBytes;}();
}
void deserialize_struct(boost::json::object& json, VkShaderResourceUsageAMD& member){
auto& numUsedVgprs_json=json["numUsedVgprs"];
[&](){member.numUsedVgprs=static_cast<uint32_t>(value_to<int>(numUsedVgprs_json));}();
auto& numUsedSgprs_json=json["numUsedSgprs"];
[&](){member.numUsedSgprs=static_cast<uint32_t>(value_to<int>(numUsedSgprs_json));}();
auto& ldsSizePerLocalWorkGroup_json=json["ldsSizePerLocalWorkGroup"];
[&](){member.ldsSizePerLocalWorkGroup=static_cast<uint32_t>(value_to<int>(ldsSizePerLocalWorkGroup_json));}();
auto& ldsUsageSizeInBytes_json=json["ldsUsageSizeInBytes"];
[&](){member.ldsUsageSizeInBytes=static_cast<size_t>(value_to<int>(ldsUsageSizeInBytes_json));}();
auto& scratchMemUsageInBytes_json=json["scratchMemUsageInBytes"];
[&](){member.scratchMemUsageInBytes=static_cast<size_t>(value_to<int>(scratchMemUsageInBytes_json));}();
}

    void serialize_struct(boost::json::object& json, const VkShaderStatisticsInfoAMD& member){
        
    
auto& shaderStageMask_json=json["shaderStageMask"];
[&](){[&](){[&](){shaderStageMask_json=member.shaderStageMask;}();}();}();
auto& resourceUsage_json=json["resourceUsage"];
[&](){
            auto& temp=resourceUsage_json.emplace_object();
            return serialize_struct(temp, member.resourceUsage);
            }();
auto& numPhysicalVgprs_json=json["numPhysicalVgprs"];
[&](){numPhysicalVgprs_json=member.numPhysicalVgprs;}();
auto& numPhysicalSgprs_json=json["numPhysicalSgprs"];
[&](){numPhysicalSgprs_json=member.numPhysicalSgprs;}();
auto& numAvailableVgprs_json=json["numAvailableVgprs"];
[&](){numAvailableVgprs_json=member.numAvailableVgprs;}();
auto& numAvailableSgprs_json=json["numAvailableSgprs"];
[&](){numAvailableSgprs_json=member.numAvailableSgprs;}();
auto& computeWorkGroupSize_json=json["computeWorkGroupSize"];
[&](){computeWorkGroupSize_json=boost::json::array(3);
        auto& arr_rCufpRy=computeWorkGroupSize_json.as_array();
        for(int OPIgNhg=0; OPIgNhg < 3; OPIgNhg++){
            [&](){arr_rCufpRy[OPIgNhg]=member.computeWorkGroupSize[OPIgNhg];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkShaderStatisticsInfoAMD& member){
auto& shaderStageMask_json=json["shaderStageMask"];
[&](){[&](){int temp_VjbDmam;[&](){temp_VjbDmam=static_cast<int>(value_to<int>(shaderStageMask_json));}();member.shaderStageMask=(VkShaderStageFlags)temp_VjbDmam;}();}();
auto& resourceUsage_json=json["resourceUsage"];
[&](){
            auto& temp=resourceUsage_json.as_object();
            deserialize_struct(temp,member.resourceUsage);
            }();
auto& numPhysicalVgprs_json=json["numPhysicalVgprs"];
[&](){member.numPhysicalVgprs=static_cast<uint32_t>(value_to<int>(numPhysicalVgprs_json));}();
auto& numPhysicalSgprs_json=json["numPhysicalSgprs"];
[&](){member.numPhysicalSgprs=static_cast<uint32_t>(value_to<int>(numPhysicalSgprs_json));}();
auto& numAvailableVgprs_json=json["numAvailableVgprs"];
[&](){member.numAvailableVgprs=static_cast<uint32_t>(value_to<int>(numAvailableVgprs_json));}();
auto& numAvailableSgprs_json=json["numAvailableSgprs"];
[&](){member.numAvailableSgprs=static_cast<uint32_t>(value_to<int>(numAvailableSgprs_json));}();
auto& computeWorkGroupSize_json=json["computeWorkGroupSize"];
[&](){
        auto& arr_rCufpRy=computeWorkGroupSize_json.as_array();
        for(int OPIgNhg=0; OPIgNhg < 3; OPIgNhg++){
            [&](){member.computeWorkGroupSize[OPIgNhg]=static_cast<uint32_t>(value_to<int>(arr_rCufpRy[OPIgNhg]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkDeviceQueueGlobalPriorityCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& globalPriority_json=json["globalPriority"];
[&](){[&](){[&](){globalPriority_json=member.globalPriority;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceQueueGlobalPriorityCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& globalPriority_json=json["globalPriority"];
[&](){[&](){int temp_LBEXLYn;[&](){temp_LBEXLYn=static_cast<int>(value_to<int>(globalPriority_json));}();member.globalPriority=(VkQueueGlobalPriorityKHR)temp_LBEXLYn;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& globalPriorityQuery_json=json["globalPriorityQuery"];
[&](){[&](){globalPriorityQuery_json=member.globalPriorityQuery;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& globalPriorityQuery_json=json["globalPriorityQuery"];
[&](){uint32_t temp_hEzHnzc;[&](){temp_hEzHnzc=static_cast<uint32_t>(value_to<int>(globalPriorityQuery_json));}();member.globalPriorityQuery=(VkBool32)temp_hEzHnzc;}();
}

    void serialize_struct(boost::json::object& json, const VkQueueFamilyGlobalPriorityPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& priorityCount_json=json["priorityCount"];
[&](){priorityCount_json=member.priorityCount;}();
auto& priorities_json=json["priorities"];
[&](){priorities_json=boost::json::array(VK_MAX_GLOBAL_PRIORITY_SIZE_KHR);
        auto& arr_PFJGkBc=priorities_json.as_array();
        for(int wieuBKX=0; wieuBKX < VK_MAX_GLOBAL_PRIORITY_SIZE_KHR; wieuBKX++){
            [&](){[&](){[&](){arr_PFJGkBc[wieuBKX]=member.priorities[wieuBKX];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkQueueFamilyGlobalPriorityPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& priorityCount_json=json["priorityCount"];
[&](){member.priorityCount=static_cast<uint32_t>(value_to<int>(priorityCount_json));}();
auto& priorities_json=json["priorities"];
[&](){
        auto& arr_PFJGkBc=priorities_json.as_array();
        for(int wieuBKX=0; wieuBKX < VK_MAX_GLOBAL_PRIORITY_SIZE_KHR; wieuBKX++){
            [&](){[&](){int temp_taULkPn;[&](){temp_taULkPn=static_cast<int>(value_to<int>(arr_PFJGkBc[wieuBKX]));}();member.priorities[wieuBKX]=(VkQueueGlobalPriorityKHR)temp_taULkPn;}();}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkDebugUtilsObjectNameInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& objectType_json=json["objectType"];
[&](){[&](){[&](){objectType_json=member.objectType;}();}();}();
auto& objectHandle_json=json["objectHandle"];
[&](){objectHandle_json=member.objectHandle;}();
auto& pObjectName_json=json["pObjectName"];
[&](){
            if (member.pObjectName==NULL){
                pObjectName_json=boost::json::array();
            return; }pObjectName_json=boost::json::array(strlen(member.pObjectName)+1);
        auto& arr_iVlKnsS=pObjectName_json.as_array();
        for(int ScjeCfd=0; ScjeCfd < strlen(member.pObjectName)+1; ScjeCfd++){
            [&](){arr_iVlKnsS[ScjeCfd]=member.pObjectName[ScjeCfd];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDebugUtilsObjectNameInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& objectType_json=json["objectType"];
[&](){[&](){int temp_zeBpQnH;[&](){temp_zeBpQnH=static_cast<int>(value_to<int>(objectType_json));}();member.objectType=(VkObjectType)temp_zeBpQnH;}();}();
auto& objectHandle_json=json["objectHandle"];
[&](){member.objectHandle=static_cast<uint64_t>(value_to<int>(objectHandle_json));}();
auto& pObjectName_json=json["pObjectName"];
[&](){ char* temp_QsnbdsB;;[&](){
            if (pObjectName_json.as_array().size()==0){
                temp_QsnbdsB=NULL;
            return; }temp_QsnbdsB=(char*)malloc(pObjectName_json.as_array().size()*sizeof(char));
        auto& arr_aGdfwIy=pObjectName_json.as_array();
        for(int VmCdhEn=0; VmCdhEn < pObjectName_json.as_array().size(); VmCdhEn++){
            [&](){temp_QsnbdsB[VmCdhEn]=static_cast<char>(value_to<int>(arr_aGdfwIy[VmCdhEn]));}();
        }
        }();member.pObjectName=temp_QsnbdsB;}();
}

    void serialize_struct(boost::json::object& json, const VkDebugUtilsObjectTagInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& objectType_json=json["objectType"];
[&](){[&](){[&](){objectType_json=member.objectType;}();}();}();
auto& objectHandle_json=json["objectHandle"];
[&](){objectHandle_json=member.objectHandle;}();
auto& tagName_json=json["tagName"];
[&](){tagName_json=member.tagName;}();
auto& tagSize_json=json["tagSize"];
[&](){tagSize_json=member.tagSize;}();
auto& pTag_json=json["pTag"];
[&](){
            if (member.pTag==NULL){
                pTag_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pTag))==NULL){
                pTag_json=boost::json::array();
            return; }pTag_json=boost::json::array(member.tagSize);
        auto& arr_FJzNXuD=pTag_json.as_array();
        for(int LCdjkoW=0; LCdjkoW < member.tagSize; LCdjkoW++){
            [&](){arr_FJzNXuD[LCdjkoW]=((char*)(member.pTag))[LCdjkoW];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkDebugUtilsObjectTagInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& objectType_json=json["objectType"];
[&](){[&](){int temp_zeBpQnH;[&](){temp_zeBpQnH=static_cast<int>(value_to<int>(objectType_json));}();member.objectType=(VkObjectType)temp_zeBpQnH;}();}();
auto& objectHandle_json=json["objectHandle"];
[&](){member.objectHandle=static_cast<uint64_t>(value_to<int>(objectHandle_json));}();
auto& tagName_json=json["tagName"];
[&](){member.tagName=static_cast<uint64_t>(value_to<int>(tagName_json));}();
auto& tagSize_json=json["tagSize"];
[&](){member.tagSize=static_cast<size_t>(value_to<int>(tagSize_json));}();
auto& pTag_json=json["pTag"];
[&](){ void* temp_lyAiwyk;;[&](){
            if (pTag_json.as_array().size()==0){
                temp_lyAiwyk=NULL;
            return; }char* temp_pWZkwTB;[&](){
            if (pTag_json.as_array().size()==0){
                temp_pWZkwTB=NULL;
            return; }temp_pWZkwTB=(char*)malloc(member.tagSize*sizeof(char));
        auto& arr_ewjwcVs=pTag_json.as_array();
        for(int uOzVzVX=0; uOzVzVX < member.tagSize; uOzVzVX++){
            [&](){temp_pWZkwTB[uOzVzVX]=static_cast<char>(value_to<int>(arr_ewjwcVs[uOzVzVX]));}();
        }
        }();temp_lyAiwyk=temp_pWZkwTB;}();member.pTag=temp_lyAiwyk;}();
}

    void serialize_struct(boost::json::object& json, const VkDebugUtilsLabelEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pLabelName_json=json["pLabelName"];
[&](){
            if (member.pLabelName==NULL){
                pLabelName_json=boost::json::array();
            return; }pLabelName_json=boost::json::array(strlen(member.pLabelName)+1);
        auto& arr_yQnoqFI=pLabelName_json.as_array();
        for(int RYyWHAs=0; RYyWHAs < strlen(member.pLabelName)+1; RYyWHAs++){
            [&](){arr_yQnoqFI[RYyWHAs]=member.pLabelName[RYyWHAs];}();
        }
        }();
auto& color_json=json["color"];
[&](){color_json=boost::json::array(4);
        auto& arr_gJbxAWU=color_json.as_array();
        for(int oOlCIuz=0; oOlCIuz < 4; oOlCIuz++){
            [&](){arr_gJbxAWU[oOlCIuz]=member.color[oOlCIuz];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDebugUtilsLabelEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pLabelName_json=json["pLabelName"];
[&](){ char* temp_vvdFeeA;;[&](){
            if (pLabelName_json.as_array().size()==0){
                temp_vvdFeeA=NULL;
            return; }temp_vvdFeeA=(char*)malloc(pLabelName_json.as_array().size()*sizeof(char));
        auto& arr_PonqeWU=pLabelName_json.as_array();
        for(int gTaBNXg=0; gTaBNXg < pLabelName_json.as_array().size(); gTaBNXg++){
            [&](){temp_vvdFeeA[gTaBNXg]=static_cast<char>(value_to<int>(arr_PonqeWU[gTaBNXg]));}();
        }
        }();member.pLabelName=temp_vvdFeeA;}();
auto& color_json=json["color"];
[&](){
        auto& arr_gJbxAWU=color_json.as_array();
        for(int oOlCIuz=0; oOlCIuz < 4; oOlCIuz++){
            [&](){member.color[oOlCIuz]=static_cast<float>(value_to<int>(arr_gJbxAWU[oOlCIuz]));}();
        }
        }();
}

        void serialize_pUserData(boost::json::object& json, const VkDebugUtilsMessengerCreateInfoEXT& member){
        auto& pUserData_json=json["pUserData"];
        
[&](){
            if (member.pUserData==NULL){
                pUserData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pUserData))==NULL){
                pUserData_json=boost::json::array();
            return; }pUserData_json=boost::json::array(strlen(((char*)(member.pUserData)))+1);
        auto& arr_svgqjpy=pUserData_json.as_array();
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData)))+1; lQswvtW++){
            [&](){arr_svgqjpy[lQswvtW]=((char*)(member.pUserData))[lQswvtW];}();
        }
        }();}();
json["PFN_vkDebugUtilsMessengerCallbackEXT"]=(uintptr_t)(member.pfnUserCallback);
}

        void deserialize_pUserData(boost::json::object& json, VkDebugUtilsMessengerCreateInfoEXT& member){
            #ifdef CLIENT
               void* pUserData;
               [&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData=temp_YghEUhF;}();
            #else 
                auto pUserData=new pUserData_struct();
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData->pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData->pUserData=temp_YghEUhF;}();
pUserData->PFN_vkDebugUtilsMessengerCallbackEXT=(value_to<uintptr_t>(json["PFN_vkDebugUtilsMessengerCallbackEXT"]));

        #endif
        member.pUserData=pUserData;
        }
        

    void serialize_struct(boost::json::object& json, const VkDebugUtilsMessengerCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& messageSeverity_json=json["messageSeverity"];
[&](){[&](){[&](){messageSeverity_json=member.messageSeverity;}();}();}();
auto& messageType_json=json["messageType"];
[&](){[&](){[&](){messageType_json=member.messageType;}();}();}();
auto& pfnUserCallback_json=json["pfnUserCallback"];
[&](){
            auto& temp=pfnUserCallback_json.emplace_object();
            return serialize_PFN_vkDebugUtilsMessengerCallbackEXT(temp, member.pfnUserCallback);
            }();
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.emplace_object();
            serialize_pUserData(pUserData_json_1, member);
            
}
void deserialize_struct(boost::json::object& json, VkDebugUtilsMessengerCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_QgcKtzD;[&](){temp_QgcKtzD=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDebugUtilsMessengerCreateFlagsEXT)temp_QgcKtzD;}();}();
auto& messageSeverity_json=json["messageSeverity"];
[&](){[&](){int temp_LzRJGKb;[&](){temp_LzRJGKb=static_cast<int>(value_to<int>(messageSeverity_json));}();member.messageSeverity=(VkDebugUtilsMessageSeverityFlagsEXT)temp_LzRJGKb;}();}();
auto& messageType_json=json["messageType"];
[&](){[&](){int temp_YnjxONA;[&](){temp_YnjxONA=static_cast<int>(value_to<int>(messageType_json));}();member.messageType=(VkDebugUtilsMessageTypeFlagsEXT)temp_YnjxONA;}();}();
auto& pfnUserCallback_json=json["pfnUserCallback"];
[&](){
            auto& temp=pfnUserCallback_json.as_object();
            deserialize_PFN_vkDebugUtilsMessengerCallbackEXT(temp,member.pfnUserCallback);
            }();
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.as_object();
            deserialize_pUserData(pUserData_json_1, member);
            
}

    void serialize_struct(boost::json::object& json, const VkDebugUtilsMessengerCallbackDataEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pMessageIdName_json=json["pMessageIdName"];
[&](){
            if (member.pMessageIdName==NULL){
                pMessageIdName_json=boost::json::array();
            return; }pMessageIdName_json=boost::json::array(strlen(member.pMessageIdName)+1);
        auto& arr_UGznVRE=pMessageIdName_json.as_array();
        for(int KdHGzSs=0; KdHGzSs < strlen(member.pMessageIdName)+1; KdHGzSs++){
            [&](){arr_UGznVRE[KdHGzSs]=member.pMessageIdName[KdHGzSs];}();
        }
        }();
auto& messageIdNumber_json=json["messageIdNumber"];
[&](){messageIdNumber_json=member.messageIdNumber;}();
auto& pMessage_json=json["pMessage"];
[&](){
            if (member.pMessage==NULL){
                pMessage_json=boost::json::array();
            return; }pMessage_json=boost::json::array(strlen(member.pMessage)+1);
        auto& arr_ythKveO=pMessage_json.as_array();
        for(int QfGQUPm=0; QfGQUPm < strlen(member.pMessage)+1; QfGQUPm++){
            [&](){arr_ythKveO[QfGQUPm]=member.pMessage[QfGQUPm];}();
        }
        }();
auto& queueLabelCount_json=json["queueLabelCount"];
[&](){queueLabelCount_json=member.queueLabelCount;}();
auto& pQueueLabels_json=json["pQueueLabels"];
[&](){
            if (member.pQueueLabels==NULL){
                pQueueLabels_json=boost::json::array();
            return; }pQueueLabels_json=boost::json::array(member.queueLabelCount);
        auto& arr_IpkStDc=pQueueLabels_json.as_array();
        for(int ZZBwdpK=0; ZZBwdpK < member.queueLabelCount; ZZBwdpK++){
            [&](){
            auto& temp=arr_IpkStDc[ZZBwdpK].emplace_object();
            return serialize_struct(temp, member.pQueueLabels[ZZBwdpK]);
            }();
        }
        }();
auto& cmdBufLabelCount_json=json["cmdBufLabelCount"];
[&](){cmdBufLabelCount_json=member.cmdBufLabelCount;}();
auto& pCmdBufLabels_json=json["pCmdBufLabels"];
[&](){
            if (member.pCmdBufLabels==NULL){
                pCmdBufLabels_json=boost::json::array();
            return; }pCmdBufLabels_json=boost::json::array(member.cmdBufLabelCount);
        auto& arr_HLGbjmn=pCmdBufLabels_json.as_array();
        for(int HKywEmj=0; HKywEmj < member.cmdBufLabelCount; HKywEmj++){
            [&](){
            auto& temp=arr_HLGbjmn[HKywEmj].emplace_object();
            return serialize_struct(temp, member.pCmdBufLabels[HKywEmj]);
            }();
        }
        }();
auto& objectCount_json=json["objectCount"];
[&](){objectCount_json=member.objectCount;}();
auto& pObjects_json=json["pObjects"];
[&](){
            if (member.pObjects==NULL){
                pObjects_json=boost::json::array();
            return; }pObjects_json=boost::json::array(member.objectCount);
        auto& arr_hOsJpYV=pObjects_json.as_array();
        for(int GslpiKr=0; GslpiKr < member.objectCount; GslpiKr++){
            [&](){
            auto& temp=arr_hOsJpYV[GslpiKr].emplace_object();
            return serialize_struct(temp, member.pObjects[GslpiKr]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDebugUtilsMessengerCallbackDataEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_tbiUSao;[&](){temp_tbiUSao=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDebugUtilsMessengerCallbackDataFlagsEXT)temp_tbiUSao;}();}();
auto& pMessageIdName_json=json["pMessageIdName"];
[&](){ char* temp_CpwLSAk;;[&](){
            if (pMessageIdName_json.as_array().size()==0){
                temp_CpwLSAk=NULL;
            return; }temp_CpwLSAk=(char*)malloc(pMessageIdName_json.as_array().size()*sizeof(char));
        auto& arr_NomLQvU=pMessageIdName_json.as_array();
        for(int GiGXeqq=0; GiGXeqq < pMessageIdName_json.as_array().size(); GiGXeqq++){
            [&](){temp_CpwLSAk[GiGXeqq]=static_cast<char>(value_to<int>(arr_NomLQvU[GiGXeqq]));}();
        }
        }();member.pMessageIdName=temp_CpwLSAk;}();
auto& messageIdNumber_json=json["messageIdNumber"];
[&](){member.messageIdNumber=static_cast<int32_t>(value_to<int>(messageIdNumber_json));}();
auto& pMessage_json=json["pMessage"];
[&](){ char* temp_gJghduP;;[&](){
            if (pMessage_json.as_array().size()==0){
                temp_gJghduP=NULL;
            return; }temp_gJghduP=(char*)malloc(pMessage_json.as_array().size()*sizeof(char));
        auto& arr_FpxaMIa=pMessage_json.as_array();
        for(int vCXzbqZ=0; vCXzbqZ < pMessage_json.as_array().size(); vCXzbqZ++){
            [&](){temp_gJghduP[vCXzbqZ]=static_cast<char>(value_to<int>(arr_FpxaMIa[vCXzbqZ]));}();
        }
        }();member.pMessage=temp_gJghduP;}();
auto& queueLabelCount_json=json["queueLabelCount"];
[&](){member.queueLabelCount=static_cast<uint32_t>(value_to<int>(queueLabelCount_json));}();
auto& pQueueLabels_json=json["pQueueLabels"];
[&](){ VkDebugUtilsLabelEXT* temp_KMcZFlj;;[&](){
            if (pQueueLabels_json.as_array().size()==0){
                temp_KMcZFlj=NULL;
            return; }temp_KMcZFlj=(VkDebugUtilsLabelEXT*)malloc(member.queueLabelCount*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_JTCPDNr=pQueueLabels_json.as_array();
        for(int xelAPEb=0; xelAPEb < member.queueLabelCount; xelAPEb++){
            [&](){
            auto& temp=arr_JTCPDNr[xelAPEb].as_object();
            deserialize_struct(temp,temp_KMcZFlj[xelAPEb]);
            }();
        }
        }();member.pQueueLabels=temp_KMcZFlj;}();
auto& cmdBufLabelCount_json=json["cmdBufLabelCount"];
[&](){member.cmdBufLabelCount=static_cast<uint32_t>(value_to<int>(cmdBufLabelCount_json));}();
auto& pCmdBufLabels_json=json["pCmdBufLabels"];
[&](){ VkDebugUtilsLabelEXT* temp_nYQrAxG;;[&](){
            if (pCmdBufLabels_json.as_array().size()==0){
                temp_nYQrAxG=NULL;
            return; }temp_nYQrAxG=(VkDebugUtilsLabelEXT*)malloc(member.cmdBufLabelCount*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_DzqvCUy=pCmdBufLabels_json.as_array();
        for(int gMrskMF=0; gMrskMF < member.cmdBufLabelCount; gMrskMF++){
            [&](){
            auto& temp=arr_DzqvCUy[gMrskMF].as_object();
            deserialize_struct(temp,temp_nYQrAxG[gMrskMF]);
            }();
        }
        }();member.pCmdBufLabels=temp_nYQrAxG;}();
auto& objectCount_json=json["objectCount"];
[&](){member.objectCount=static_cast<uint32_t>(value_to<int>(objectCount_json));}();
auto& pObjects_json=json["pObjects"];
[&](){ VkDebugUtilsObjectNameInfoEXT* temp_rytMCkU;;[&](){
            if (pObjects_json.as_array().size()==0){
                temp_rytMCkU=NULL;
            return; }temp_rytMCkU=(VkDebugUtilsObjectNameInfoEXT*)malloc(member.objectCount*sizeof(VkDebugUtilsObjectNameInfoEXT));
        auto& arr_FsuYctU=pObjects_json.as_array();
        for(int ixJSqXg=0; ixJSqXg < member.objectCount; ixJSqXg++){
            [&](){
            auto& temp=arr_FsuYctU[ixJSqXg].as_object();
            deserialize_struct(temp,temp_rytMCkU[ixJSqXg]);
            }();
        }
        }();member.pObjects=temp_rytMCkU;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceMemoryReport_json=json["deviceMemoryReport"];
[&](){[&](){deviceMemoryReport_json=member.deviceMemoryReport;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& deviceMemoryReport_json=json["deviceMemoryReport"];
[&](){uint32_t temp_sNWJkrc;[&](){temp_sNWJkrc=static_cast<uint32_t>(value_to<int>(deviceMemoryReport_json));}();member.deviceMemoryReport=(VkBool32)temp_sNWJkrc;}();
}

        void serialize_pUserData(boost::json::object& json, const VkDeviceDeviceMemoryReportCreateInfoEXT& member){
        auto& pUserData_json=json["pUserData"];
        
[&](){
            if (member.pUserData==NULL){
                pUserData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pUserData))==NULL){
                pUserData_json=boost::json::array();
            return; }pUserData_json=boost::json::array(strlen(((char*)(member.pUserData)))+1);
        auto& arr_svgqjpy=pUserData_json.as_array();
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData)))+1; lQswvtW++){
            [&](){arr_svgqjpy[lQswvtW]=((char*)(member.pUserData))[lQswvtW];}();
        }
        }();}();
json["PFN_vkDeviceMemoryReportCallbackEXT"]=(uintptr_t)(member.pfnUserCallback);
}

        void deserialize_pUserData(boost::json::object& json, VkDeviceDeviceMemoryReportCreateInfoEXT& member){
            #ifdef CLIENT
               void* pUserData;
               [&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData=temp_YghEUhF;}();
            #else 
                auto pUserData=new pUserData_struct();
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData->pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData->pUserData=temp_YghEUhF;}();
pUserData->PFN_vkDeviceMemoryReportCallbackEXT=(value_to<uintptr_t>(json["PFN_vkDeviceMemoryReportCallbackEXT"]));

        #endif
        member.pUserData=pUserData;
        }
        

    void serialize_struct(boost::json::object& json, const VkDeviceDeviceMemoryReportCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pfnUserCallback_json=json["pfnUserCallback"];
[&](){
            auto& temp=pfnUserCallback_json.emplace_object();
            return serialize_PFN_vkDeviceMemoryReportCallbackEXT(temp, member.pfnUserCallback);
            }();
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.emplace_object();
            serialize_pUserData(pUserData_json_1, member);
            
}
void deserialize_struct(boost::json::object& json, VkDeviceDeviceMemoryReportCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_AaIroFx;[&](){temp_AaIroFx=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDeviceMemoryReportFlagsEXT)temp_AaIroFx;}();}();
auto& pfnUserCallback_json=json["pfnUserCallback"];
[&](){
            auto& temp=pfnUserCallback_json.as_object();
            deserialize_PFN_vkDeviceMemoryReportCallbackEXT(temp,member.pfnUserCallback);
            }();
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.as_object();
            deserialize_pUserData(pUserData_json_1, member);
            
}

    void serialize_struct(boost::json::object& json, const VkDeviceMemoryReportCallbackDataEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& memoryObjectId_json=json["memoryObjectId"];
[&](){memoryObjectId_json=member.memoryObjectId;}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& objectType_json=json["objectType"];
[&](){[&](){[&](){objectType_json=member.objectType;}();}();}();
auto& objectHandle_json=json["objectHandle"];
[&](){objectHandle_json=member.objectHandle;}();
auto& heapIndex_json=json["heapIndex"];
[&](){heapIndex_json=member.heapIndex;}();
}
void deserialize_struct(boost::json::object& json, VkDeviceMemoryReportCallbackDataEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_AaIroFx;[&](){temp_AaIroFx=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDeviceMemoryReportFlagsEXT)temp_AaIroFx;}();}();
auto& type_json=json["type"];
[&](){[&](){int temp_FJaCTUW;[&](){temp_FJaCTUW=static_cast<int>(value_to<int>(type_json));}();member.type=(VkDeviceMemoryReportEventTypeEXT)temp_FJaCTUW;}();}();
auto& memoryObjectId_json=json["memoryObjectId"];
[&](){member.memoryObjectId=static_cast<uint64_t>(value_to<int>(memoryObjectId_json));}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& objectType_json=json["objectType"];
[&](){[&](){int temp_zeBpQnH;[&](){temp_zeBpQnH=static_cast<int>(value_to<int>(objectType_json));}();member.objectType=(VkObjectType)temp_zeBpQnH;}();}();
auto& objectHandle_json=json["objectHandle"];
[&](){member.objectHandle=static_cast<uint64_t>(value_to<int>(objectHandle_json));}();
auto& heapIndex_json=json["heapIndex"];
[&](){member.heapIndex=static_cast<uint32_t>(value_to<int>(heapIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkImportMemoryHostPointerInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
auto& pHostPointer_json=json["pHostPointer"];
[&](){
            if (member.pHostPointer==NULL){
                pHostPointer_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pHostPointer))==NULL){
                pHostPointer_json=boost::json::array();
            return; }pHostPointer_json=boost::json::array(strlen(((char*)(member.pHostPointer)))+1);
        auto& arr_BrxoFPy=pHostPointer_json.as_array();
        for(int ZYyfYiy=0; ZYyfYiy < strlen(((char*)(member.pHostPointer)))+1; ZYyfYiy++){
            [&](){arr_BrxoFPy[ZYyfYiy]=((char*)(member.pHostPointer))[ZYyfYiy];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkImportMemoryHostPointerInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_eyKBrDS;[&](){temp_eyKBrDS=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalMemoryHandleTypeFlagBits)temp_eyKBrDS;}();}();
auto& pHostPointer_json=json["pHostPointer"];
[&](){
            if (pHostPointer_json.as_array().size()==0){
                member.pHostPointer=NULL;
            return; }char* temp_XgjXTho;[&](){
            if (pHostPointer_json.as_array().size()==0){
                temp_XgjXTho=NULL;
            return; }temp_XgjXTho=(char*)malloc(pHostPointer_json.as_array().size()*sizeof(char));
        auto& arr_BrxoFPy=pHostPointer_json.as_array();
        for(int ZYyfYiy=0; ZYyfYiy < pHostPointer_json.as_array().size(); ZYyfYiy++){
            [&](){temp_XgjXTho[ZYyfYiy]=static_cast<char>(value_to<int>(arr_BrxoFPy[ZYyfYiy]));}();
        }
        }();member.pHostPointer=temp_XgjXTho;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryHostPointerPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memoryTypeBits_json=json["memoryTypeBits"];
[&](){memoryTypeBits_json=member.memoryTypeBits;}();
}
void deserialize_struct(boost::json::object& json, VkMemoryHostPointerPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& memoryTypeBits_json=json["memoryTypeBits"];
[&](){member.memoryTypeBits=static_cast<uint32_t>(value_to<int>(memoryTypeBits_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExternalMemoryHostPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& minImportedHostPointerAlignment_json=json["minImportedHostPointerAlignment"];
[&](){[&](){minImportedHostPointerAlignment_json=member.minImportedHostPointerAlignment;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExternalMemoryHostPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& minImportedHostPointerAlignment_json=json["minImportedHostPointerAlignment"];
[&](){uint64_t temp_gRJfWAL;[&](){temp_gRJfWAL=static_cast<uint64_t>(value_to<int>(minImportedHostPointerAlignment_json));}();member.minImportedHostPointerAlignment=(VkDeviceSize)temp_gRJfWAL;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceConservativeRasterizationPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& primitiveOverestimationSize_json=json["primitiveOverestimationSize"];
[&](){primitiveOverestimationSize_json=member.primitiveOverestimationSize;}();
auto& maxExtraPrimitiveOverestimationSize_json=json["maxExtraPrimitiveOverestimationSize"];
[&](){maxExtraPrimitiveOverestimationSize_json=member.maxExtraPrimitiveOverestimationSize;}();
auto& extraPrimitiveOverestimationSizeGranularity_json=json["extraPrimitiveOverestimationSizeGranularity"];
[&](){extraPrimitiveOverestimationSizeGranularity_json=member.extraPrimitiveOverestimationSizeGranularity;}();
auto& primitiveUnderestimation_json=json["primitiveUnderestimation"];
[&](){[&](){primitiveUnderestimation_json=member.primitiveUnderestimation;}();}();
auto& conservativePointAndLineRasterization_json=json["conservativePointAndLineRasterization"];
[&](){[&](){conservativePointAndLineRasterization_json=member.conservativePointAndLineRasterization;}();}();
auto& degenerateTrianglesRasterized_json=json["degenerateTrianglesRasterized"];
[&](){[&](){degenerateTrianglesRasterized_json=member.degenerateTrianglesRasterized;}();}();
auto& degenerateLinesRasterized_json=json["degenerateLinesRasterized"];
[&](){[&](){degenerateLinesRasterized_json=member.degenerateLinesRasterized;}();}();
auto& fullyCoveredFragmentShaderInputVariable_json=json["fullyCoveredFragmentShaderInputVariable"];
[&](){[&](){fullyCoveredFragmentShaderInputVariable_json=member.fullyCoveredFragmentShaderInputVariable;}();}();
auto& conservativeRasterizationPostDepthCoverage_json=json["conservativeRasterizationPostDepthCoverage"];
[&](){[&](){conservativeRasterizationPostDepthCoverage_json=member.conservativeRasterizationPostDepthCoverage;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceConservativeRasterizationPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& primitiveOverestimationSize_json=json["primitiveOverestimationSize"];
[&](){member.primitiveOverestimationSize=static_cast<float>(value_to<int>(primitiveOverestimationSize_json));}();
auto& maxExtraPrimitiveOverestimationSize_json=json["maxExtraPrimitiveOverestimationSize"];
[&](){member.maxExtraPrimitiveOverestimationSize=static_cast<float>(value_to<int>(maxExtraPrimitiveOverestimationSize_json));}();
auto& extraPrimitiveOverestimationSizeGranularity_json=json["extraPrimitiveOverestimationSizeGranularity"];
[&](){member.extraPrimitiveOverestimationSizeGranularity=static_cast<float>(value_to<int>(extraPrimitiveOverestimationSizeGranularity_json));}();
auto& primitiveUnderestimation_json=json["primitiveUnderestimation"];
[&](){uint32_t temp_PWZvHqd;[&](){temp_PWZvHqd=static_cast<uint32_t>(value_to<int>(primitiveUnderestimation_json));}();member.primitiveUnderestimation=(VkBool32)temp_PWZvHqd;}();
auto& conservativePointAndLineRasterization_json=json["conservativePointAndLineRasterization"];
[&](){uint32_t temp_cDNPOJI;[&](){temp_cDNPOJI=static_cast<uint32_t>(value_to<int>(conservativePointAndLineRasterization_json));}();member.conservativePointAndLineRasterization=(VkBool32)temp_cDNPOJI;}();
auto& degenerateTrianglesRasterized_json=json["degenerateTrianglesRasterized"];
[&](){uint32_t temp_rHbvjkV;[&](){temp_rHbvjkV=static_cast<uint32_t>(value_to<int>(degenerateTrianglesRasterized_json));}();member.degenerateTrianglesRasterized=(VkBool32)temp_rHbvjkV;}();
auto& degenerateLinesRasterized_json=json["degenerateLinesRasterized"];
[&](){uint32_t temp_TNiFGtM;[&](){temp_TNiFGtM=static_cast<uint32_t>(value_to<int>(degenerateLinesRasterized_json));}();member.degenerateLinesRasterized=(VkBool32)temp_TNiFGtM;}();
auto& fullyCoveredFragmentShaderInputVariable_json=json["fullyCoveredFragmentShaderInputVariable"];
[&](){uint32_t temp_hiBUxlS;[&](){temp_hiBUxlS=static_cast<uint32_t>(value_to<int>(fullyCoveredFragmentShaderInputVariable_json));}();member.fullyCoveredFragmentShaderInputVariable=(VkBool32)temp_hiBUxlS;}();
auto& conservativeRasterizationPostDepthCoverage_json=json["conservativeRasterizationPostDepthCoverage"];
[&](){uint32_t temp_BpJcBtF;[&](){temp_BpJcBtF=static_cast<uint32_t>(value_to<int>(conservativeRasterizationPostDepthCoverage_json));}();member.conservativeRasterizationPostDepthCoverage=(VkBool32)temp_BpJcBtF;}();
}

    void serialize_struct(boost::json::object& json, const VkCalibratedTimestampInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& timeDomain_json=json["timeDomain"];
[&](){[&](){[&](){timeDomain_json=member.timeDomain;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCalibratedTimestampInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& timeDomain_json=json["timeDomain"];
[&](){[&](){int temp_qOniBzF;[&](){temp_qOniBzF=static_cast<int>(value_to<int>(timeDomain_json));}();member.timeDomain=(VkTimeDomainEXT)temp_qOniBzF;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderCorePropertiesAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderEngineCount_json=json["shaderEngineCount"];
[&](){shaderEngineCount_json=member.shaderEngineCount;}();
auto& shaderArraysPerEngineCount_json=json["shaderArraysPerEngineCount"];
[&](){shaderArraysPerEngineCount_json=member.shaderArraysPerEngineCount;}();
auto& computeUnitsPerShaderArray_json=json["computeUnitsPerShaderArray"];
[&](){computeUnitsPerShaderArray_json=member.computeUnitsPerShaderArray;}();
auto& simdPerComputeUnit_json=json["simdPerComputeUnit"];
[&](){simdPerComputeUnit_json=member.simdPerComputeUnit;}();
auto& wavefrontsPerSimd_json=json["wavefrontsPerSimd"];
[&](){wavefrontsPerSimd_json=member.wavefrontsPerSimd;}();
auto& wavefrontSize_json=json["wavefrontSize"];
[&](){wavefrontSize_json=member.wavefrontSize;}();
auto& sgprsPerSimd_json=json["sgprsPerSimd"];
[&](){sgprsPerSimd_json=member.sgprsPerSimd;}();
auto& minSgprAllocation_json=json["minSgprAllocation"];
[&](){minSgprAllocation_json=member.minSgprAllocation;}();
auto& maxSgprAllocation_json=json["maxSgprAllocation"];
[&](){maxSgprAllocation_json=member.maxSgprAllocation;}();
auto& sgprAllocationGranularity_json=json["sgprAllocationGranularity"];
[&](){sgprAllocationGranularity_json=member.sgprAllocationGranularity;}();
auto& vgprsPerSimd_json=json["vgprsPerSimd"];
[&](){vgprsPerSimd_json=member.vgprsPerSimd;}();
auto& minVgprAllocation_json=json["minVgprAllocation"];
[&](){minVgprAllocation_json=member.minVgprAllocation;}();
auto& maxVgprAllocation_json=json["maxVgprAllocation"];
[&](){maxVgprAllocation_json=member.maxVgprAllocation;}();
auto& vgprAllocationGranularity_json=json["vgprAllocationGranularity"];
[&](){vgprAllocationGranularity_json=member.vgprAllocationGranularity;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderCorePropertiesAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderEngineCount_json=json["shaderEngineCount"];
[&](){member.shaderEngineCount=static_cast<uint32_t>(value_to<int>(shaderEngineCount_json));}();
auto& shaderArraysPerEngineCount_json=json["shaderArraysPerEngineCount"];
[&](){member.shaderArraysPerEngineCount=static_cast<uint32_t>(value_to<int>(shaderArraysPerEngineCount_json));}();
auto& computeUnitsPerShaderArray_json=json["computeUnitsPerShaderArray"];
[&](){member.computeUnitsPerShaderArray=static_cast<uint32_t>(value_to<int>(computeUnitsPerShaderArray_json));}();
auto& simdPerComputeUnit_json=json["simdPerComputeUnit"];
[&](){member.simdPerComputeUnit=static_cast<uint32_t>(value_to<int>(simdPerComputeUnit_json));}();
auto& wavefrontsPerSimd_json=json["wavefrontsPerSimd"];
[&](){member.wavefrontsPerSimd=static_cast<uint32_t>(value_to<int>(wavefrontsPerSimd_json));}();
auto& wavefrontSize_json=json["wavefrontSize"];
[&](){member.wavefrontSize=static_cast<uint32_t>(value_to<int>(wavefrontSize_json));}();
auto& sgprsPerSimd_json=json["sgprsPerSimd"];
[&](){member.sgprsPerSimd=static_cast<uint32_t>(value_to<int>(sgprsPerSimd_json));}();
auto& minSgprAllocation_json=json["minSgprAllocation"];
[&](){member.minSgprAllocation=static_cast<uint32_t>(value_to<int>(minSgprAllocation_json));}();
auto& maxSgprAllocation_json=json["maxSgprAllocation"];
[&](){member.maxSgprAllocation=static_cast<uint32_t>(value_to<int>(maxSgprAllocation_json));}();
auto& sgprAllocationGranularity_json=json["sgprAllocationGranularity"];
[&](){member.sgprAllocationGranularity=static_cast<uint32_t>(value_to<int>(sgprAllocationGranularity_json));}();
auto& vgprsPerSimd_json=json["vgprsPerSimd"];
[&](){member.vgprsPerSimd=static_cast<uint32_t>(value_to<int>(vgprsPerSimd_json));}();
auto& minVgprAllocation_json=json["minVgprAllocation"];
[&](){member.minVgprAllocation=static_cast<uint32_t>(value_to<int>(minVgprAllocation_json));}();
auto& maxVgprAllocation_json=json["maxVgprAllocation"];
[&](){member.maxVgprAllocation=static_cast<uint32_t>(value_to<int>(maxVgprAllocation_json));}();
auto& vgprAllocationGranularity_json=json["vgprAllocationGranularity"];
[&](){member.vgprAllocationGranularity=static_cast<uint32_t>(value_to<int>(vgprAllocationGranularity_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderCoreProperties2AMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderCoreFeatures_json=json["shaderCoreFeatures"];
[&](){[&](){[&](){shaderCoreFeatures_json=member.shaderCoreFeatures;}();}();}();
auto& activeComputeUnitCount_json=json["activeComputeUnitCount"];
[&](){activeComputeUnitCount_json=member.activeComputeUnitCount;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderCoreProperties2AMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderCoreFeatures_json=json["shaderCoreFeatures"];
[&](){[&](){int temp_ysaoWeF;[&](){temp_ysaoWeF=static_cast<int>(value_to<int>(shaderCoreFeatures_json));}();member.shaderCoreFeatures=(VkShaderCorePropertiesFlagsAMD)temp_ysaoWeF;}();}();
auto& activeComputeUnitCount_json=json["activeComputeUnitCount"];
[&](){member.activeComputeUnitCount=static_cast<uint32_t>(value_to<int>(activeComputeUnitCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRasterizationConservativeStateCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& conservativeRasterizationMode_json=json["conservativeRasterizationMode"];
[&](){[&](){[&](){conservativeRasterizationMode_json=member.conservativeRasterizationMode;}();}();}();
auto& extraPrimitiveOverestimationSize_json=json["extraPrimitiveOverestimationSize"];
[&](){extraPrimitiveOverestimationSize_json=member.extraPrimitiveOverestimationSize;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRasterizationConservativeStateCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_LGgcvOy;[&](){temp_LGgcvOy=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineRasterizationConservativeStateCreateFlagsEXT)temp_LGgcvOy;}();}();
auto& conservativeRasterizationMode_json=json["conservativeRasterizationMode"];
[&](){[&](){int temp_HqQJLnm;[&](){temp_HqQJLnm=static_cast<int>(value_to<int>(conservativeRasterizationMode_json));}();member.conservativeRasterizationMode=(VkConservativeRasterizationModeEXT)temp_HqQJLnm;}();}();
auto& extraPrimitiveOverestimationSize_json=json["extraPrimitiveOverestimationSize"];
[&](){member.extraPrimitiveOverestimationSize=static_cast<float>(value_to<int>(extraPrimitiveOverestimationSize_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDescriptorIndexingFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderInputAttachmentArrayDynamicIndexing_json=json["shaderInputAttachmentArrayDynamicIndexing"];
[&](){[&](){shaderInputAttachmentArrayDynamicIndexing_json=member.shaderInputAttachmentArrayDynamicIndexing;}();}();
auto& shaderUniformTexelBufferArrayDynamicIndexing_json=json["shaderUniformTexelBufferArrayDynamicIndexing"];
[&](){[&](){shaderUniformTexelBufferArrayDynamicIndexing_json=member.shaderUniformTexelBufferArrayDynamicIndexing;}();}();
auto& shaderStorageTexelBufferArrayDynamicIndexing_json=json["shaderStorageTexelBufferArrayDynamicIndexing"];
[&](){[&](){shaderStorageTexelBufferArrayDynamicIndexing_json=member.shaderStorageTexelBufferArrayDynamicIndexing;}();}();
auto& shaderUniformBufferArrayNonUniformIndexing_json=json["shaderUniformBufferArrayNonUniformIndexing"];
[&](){[&](){shaderUniformBufferArrayNonUniformIndexing_json=member.shaderUniformBufferArrayNonUniformIndexing;}();}();
auto& shaderSampledImageArrayNonUniformIndexing_json=json["shaderSampledImageArrayNonUniformIndexing"];
[&](){[&](){shaderSampledImageArrayNonUniformIndexing_json=member.shaderSampledImageArrayNonUniformIndexing;}();}();
auto& shaderStorageBufferArrayNonUniformIndexing_json=json["shaderStorageBufferArrayNonUniformIndexing"];
[&](){[&](){shaderStorageBufferArrayNonUniformIndexing_json=member.shaderStorageBufferArrayNonUniformIndexing;}();}();
auto& shaderStorageImageArrayNonUniformIndexing_json=json["shaderStorageImageArrayNonUniformIndexing"];
[&](){[&](){shaderStorageImageArrayNonUniformIndexing_json=member.shaderStorageImageArrayNonUniformIndexing;}();}();
auto& shaderInputAttachmentArrayNonUniformIndexing_json=json["shaderInputAttachmentArrayNonUniformIndexing"];
[&](){[&](){shaderInputAttachmentArrayNonUniformIndexing_json=member.shaderInputAttachmentArrayNonUniformIndexing;}();}();
auto& shaderUniformTexelBufferArrayNonUniformIndexing_json=json["shaderUniformTexelBufferArrayNonUniformIndexing"];
[&](){[&](){shaderUniformTexelBufferArrayNonUniformIndexing_json=member.shaderUniformTexelBufferArrayNonUniformIndexing;}();}();
auto& shaderStorageTexelBufferArrayNonUniformIndexing_json=json["shaderStorageTexelBufferArrayNonUniformIndexing"];
[&](){[&](){shaderStorageTexelBufferArrayNonUniformIndexing_json=member.shaderStorageTexelBufferArrayNonUniformIndexing;}();}();
auto& descriptorBindingUniformBufferUpdateAfterBind_json=json["descriptorBindingUniformBufferUpdateAfterBind"];
[&](){[&](){descriptorBindingUniformBufferUpdateAfterBind_json=member.descriptorBindingUniformBufferUpdateAfterBind;}();}();
auto& descriptorBindingSampledImageUpdateAfterBind_json=json["descriptorBindingSampledImageUpdateAfterBind"];
[&](){[&](){descriptorBindingSampledImageUpdateAfterBind_json=member.descriptorBindingSampledImageUpdateAfterBind;}();}();
auto& descriptorBindingStorageImageUpdateAfterBind_json=json["descriptorBindingStorageImageUpdateAfterBind"];
[&](){[&](){descriptorBindingStorageImageUpdateAfterBind_json=member.descriptorBindingStorageImageUpdateAfterBind;}();}();
auto& descriptorBindingStorageBufferUpdateAfterBind_json=json["descriptorBindingStorageBufferUpdateAfterBind"];
[&](){[&](){descriptorBindingStorageBufferUpdateAfterBind_json=member.descriptorBindingStorageBufferUpdateAfterBind;}();}();
auto& descriptorBindingUniformTexelBufferUpdateAfterBind_json=json["descriptorBindingUniformTexelBufferUpdateAfterBind"];
[&](){[&](){descriptorBindingUniformTexelBufferUpdateAfterBind_json=member.descriptorBindingUniformTexelBufferUpdateAfterBind;}();}();
auto& descriptorBindingStorageTexelBufferUpdateAfterBind_json=json["descriptorBindingStorageTexelBufferUpdateAfterBind"];
[&](){[&](){descriptorBindingStorageTexelBufferUpdateAfterBind_json=member.descriptorBindingStorageTexelBufferUpdateAfterBind;}();}();
auto& descriptorBindingUpdateUnusedWhilePending_json=json["descriptorBindingUpdateUnusedWhilePending"];
[&](){[&](){descriptorBindingUpdateUnusedWhilePending_json=member.descriptorBindingUpdateUnusedWhilePending;}();}();
auto& descriptorBindingPartiallyBound_json=json["descriptorBindingPartiallyBound"];
[&](){[&](){descriptorBindingPartiallyBound_json=member.descriptorBindingPartiallyBound;}();}();
auto& descriptorBindingVariableDescriptorCount_json=json["descriptorBindingVariableDescriptorCount"];
[&](){[&](){descriptorBindingVariableDescriptorCount_json=member.descriptorBindingVariableDescriptorCount;}();}();
auto& runtimeDescriptorArray_json=json["runtimeDescriptorArray"];
[&](){[&](){runtimeDescriptorArray_json=member.runtimeDescriptorArray;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDescriptorIndexingFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderInputAttachmentArrayDynamicIndexing_json=json["shaderInputAttachmentArrayDynamicIndexing"];
[&](){uint32_t temp_fyJbpOD;[&](){temp_fyJbpOD=static_cast<uint32_t>(value_to<int>(shaderInputAttachmentArrayDynamicIndexing_json));}();member.shaderInputAttachmentArrayDynamicIndexing=(VkBool32)temp_fyJbpOD;}();
auto& shaderUniformTexelBufferArrayDynamicIndexing_json=json["shaderUniformTexelBufferArrayDynamicIndexing"];
[&](){uint32_t temp_MMQkhrI;[&](){temp_MMQkhrI=static_cast<uint32_t>(value_to<int>(shaderUniformTexelBufferArrayDynamicIndexing_json));}();member.shaderUniformTexelBufferArrayDynamicIndexing=(VkBool32)temp_MMQkhrI;}();
auto& shaderStorageTexelBufferArrayDynamicIndexing_json=json["shaderStorageTexelBufferArrayDynamicIndexing"];
[&](){uint32_t temp_dJdOALu;[&](){temp_dJdOALu=static_cast<uint32_t>(value_to<int>(shaderStorageTexelBufferArrayDynamicIndexing_json));}();member.shaderStorageTexelBufferArrayDynamicIndexing=(VkBool32)temp_dJdOALu;}();
auto& shaderUniformBufferArrayNonUniformIndexing_json=json["shaderUniformBufferArrayNonUniformIndexing"];
[&](){uint32_t temp_bpPwNfg;[&](){temp_bpPwNfg=static_cast<uint32_t>(value_to<int>(shaderUniformBufferArrayNonUniformIndexing_json));}();member.shaderUniformBufferArrayNonUniformIndexing=(VkBool32)temp_bpPwNfg;}();
auto& shaderSampledImageArrayNonUniformIndexing_json=json["shaderSampledImageArrayNonUniformIndexing"];
[&](){uint32_t temp_lVzKpVq;[&](){temp_lVzKpVq=static_cast<uint32_t>(value_to<int>(shaderSampledImageArrayNonUniformIndexing_json));}();member.shaderSampledImageArrayNonUniformIndexing=(VkBool32)temp_lVzKpVq;}();
auto& shaderStorageBufferArrayNonUniformIndexing_json=json["shaderStorageBufferArrayNonUniformIndexing"];
[&](){uint32_t temp_UtOakrN;[&](){temp_UtOakrN=static_cast<uint32_t>(value_to<int>(shaderStorageBufferArrayNonUniformIndexing_json));}();member.shaderStorageBufferArrayNonUniformIndexing=(VkBool32)temp_UtOakrN;}();
auto& shaderStorageImageArrayNonUniformIndexing_json=json["shaderStorageImageArrayNonUniformIndexing"];
[&](){uint32_t temp_mNnhHJv;[&](){temp_mNnhHJv=static_cast<uint32_t>(value_to<int>(shaderStorageImageArrayNonUniformIndexing_json));}();member.shaderStorageImageArrayNonUniformIndexing=(VkBool32)temp_mNnhHJv;}();
auto& shaderInputAttachmentArrayNonUniformIndexing_json=json["shaderInputAttachmentArrayNonUniformIndexing"];
[&](){uint32_t temp_iOZaHHL;[&](){temp_iOZaHHL=static_cast<uint32_t>(value_to<int>(shaderInputAttachmentArrayNonUniformIndexing_json));}();member.shaderInputAttachmentArrayNonUniformIndexing=(VkBool32)temp_iOZaHHL;}();
auto& shaderUniformTexelBufferArrayNonUniformIndexing_json=json["shaderUniformTexelBufferArrayNonUniformIndexing"];
[&](){uint32_t temp_cftOXUy;[&](){temp_cftOXUy=static_cast<uint32_t>(value_to<int>(shaderUniformTexelBufferArrayNonUniformIndexing_json));}();member.shaderUniformTexelBufferArrayNonUniformIndexing=(VkBool32)temp_cftOXUy;}();
auto& shaderStorageTexelBufferArrayNonUniformIndexing_json=json["shaderStorageTexelBufferArrayNonUniformIndexing"];
[&](){uint32_t temp_EPBIyHy;[&](){temp_EPBIyHy=static_cast<uint32_t>(value_to<int>(shaderStorageTexelBufferArrayNonUniformIndexing_json));}();member.shaderStorageTexelBufferArrayNonUniformIndexing=(VkBool32)temp_EPBIyHy;}();
auto& descriptorBindingUniformBufferUpdateAfterBind_json=json["descriptorBindingUniformBufferUpdateAfterBind"];
[&](){uint32_t temp_fUMytxk;[&](){temp_fUMytxk=static_cast<uint32_t>(value_to<int>(descriptorBindingUniformBufferUpdateAfterBind_json));}();member.descriptorBindingUniformBufferUpdateAfterBind=(VkBool32)temp_fUMytxk;}();
auto& descriptorBindingSampledImageUpdateAfterBind_json=json["descriptorBindingSampledImageUpdateAfterBind"];
[&](){uint32_t temp_xaqghGY;[&](){temp_xaqghGY=static_cast<uint32_t>(value_to<int>(descriptorBindingSampledImageUpdateAfterBind_json));}();member.descriptorBindingSampledImageUpdateAfterBind=(VkBool32)temp_xaqghGY;}();
auto& descriptorBindingStorageImageUpdateAfterBind_json=json["descriptorBindingStorageImageUpdateAfterBind"];
[&](){uint32_t temp_sFIjULV;[&](){temp_sFIjULV=static_cast<uint32_t>(value_to<int>(descriptorBindingStorageImageUpdateAfterBind_json));}();member.descriptorBindingStorageImageUpdateAfterBind=(VkBool32)temp_sFIjULV;}();
auto& descriptorBindingStorageBufferUpdateAfterBind_json=json["descriptorBindingStorageBufferUpdateAfterBind"];
[&](){uint32_t temp_IMOOVIt;[&](){temp_IMOOVIt=static_cast<uint32_t>(value_to<int>(descriptorBindingStorageBufferUpdateAfterBind_json));}();member.descriptorBindingStorageBufferUpdateAfterBind=(VkBool32)temp_IMOOVIt;}();
auto& descriptorBindingUniformTexelBufferUpdateAfterBind_json=json["descriptorBindingUniformTexelBufferUpdateAfterBind"];
[&](){uint32_t temp_FjRggwM;[&](){temp_FjRggwM=static_cast<uint32_t>(value_to<int>(descriptorBindingUniformTexelBufferUpdateAfterBind_json));}();member.descriptorBindingUniformTexelBufferUpdateAfterBind=(VkBool32)temp_FjRggwM;}();
auto& descriptorBindingStorageTexelBufferUpdateAfterBind_json=json["descriptorBindingStorageTexelBufferUpdateAfterBind"];
[&](){uint32_t temp_PYbExfI;[&](){temp_PYbExfI=static_cast<uint32_t>(value_to<int>(descriptorBindingStorageTexelBufferUpdateAfterBind_json));}();member.descriptorBindingStorageTexelBufferUpdateAfterBind=(VkBool32)temp_PYbExfI;}();
auto& descriptorBindingUpdateUnusedWhilePending_json=json["descriptorBindingUpdateUnusedWhilePending"];
[&](){uint32_t temp_znoAjAs;[&](){temp_znoAjAs=static_cast<uint32_t>(value_to<int>(descriptorBindingUpdateUnusedWhilePending_json));}();member.descriptorBindingUpdateUnusedWhilePending=(VkBool32)temp_znoAjAs;}();
auto& descriptorBindingPartiallyBound_json=json["descriptorBindingPartiallyBound"];
[&](){uint32_t temp_BCHGQDa;[&](){temp_BCHGQDa=static_cast<uint32_t>(value_to<int>(descriptorBindingPartiallyBound_json));}();member.descriptorBindingPartiallyBound=(VkBool32)temp_BCHGQDa;}();
auto& descriptorBindingVariableDescriptorCount_json=json["descriptorBindingVariableDescriptorCount"];
[&](){uint32_t temp_BHqFqTR;[&](){temp_BHqFqTR=static_cast<uint32_t>(value_to<int>(descriptorBindingVariableDescriptorCount_json));}();member.descriptorBindingVariableDescriptorCount=(VkBool32)temp_BHqFqTR;}();
auto& runtimeDescriptorArray_json=json["runtimeDescriptorArray"];
[&](){uint32_t temp_nSZVBTY;[&](){temp_nSZVBTY=static_cast<uint32_t>(value_to<int>(runtimeDescriptorArray_json));}();member.runtimeDescriptorArray=(VkBool32)temp_nSZVBTY;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDescriptorIndexingProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxUpdateAfterBindDescriptorsInAllPools_json=json["maxUpdateAfterBindDescriptorsInAllPools"];
[&](){maxUpdateAfterBindDescriptorsInAllPools_json=member.maxUpdateAfterBindDescriptorsInAllPools;}();
auto& shaderUniformBufferArrayNonUniformIndexingNative_json=json["shaderUniformBufferArrayNonUniformIndexingNative"];
[&](){[&](){shaderUniformBufferArrayNonUniformIndexingNative_json=member.shaderUniformBufferArrayNonUniformIndexingNative;}();}();
auto& shaderSampledImageArrayNonUniformIndexingNative_json=json["shaderSampledImageArrayNonUniformIndexingNative"];
[&](){[&](){shaderSampledImageArrayNonUniformIndexingNative_json=member.shaderSampledImageArrayNonUniformIndexingNative;}();}();
auto& shaderStorageBufferArrayNonUniformIndexingNative_json=json["shaderStorageBufferArrayNonUniformIndexingNative"];
[&](){[&](){shaderStorageBufferArrayNonUniformIndexingNative_json=member.shaderStorageBufferArrayNonUniformIndexingNative;}();}();
auto& shaderStorageImageArrayNonUniformIndexingNative_json=json["shaderStorageImageArrayNonUniformIndexingNative"];
[&](){[&](){shaderStorageImageArrayNonUniformIndexingNative_json=member.shaderStorageImageArrayNonUniformIndexingNative;}();}();
auto& shaderInputAttachmentArrayNonUniformIndexingNative_json=json["shaderInputAttachmentArrayNonUniformIndexingNative"];
[&](){[&](){shaderInputAttachmentArrayNonUniformIndexingNative_json=member.shaderInputAttachmentArrayNonUniformIndexingNative;}();}();
auto& robustBufferAccessUpdateAfterBind_json=json["robustBufferAccessUpdateAfterBind"];
[&](){[&](){robustBufferAccessUpdateAfterBind_json=member.robustBufferAccessUpdateAfterBind;}();}();
auto& quadDivergentImplicitLod_json=json["quadDivergentImplicitLod"];
[&](){[&](){quadDivergentImplicitLod_json=member.quadDivergentImplicitLod;}();}();
auto& maxPerStageDescriptorUpdateAfterBindSamplers_json=json["maxPerStageDescriptorUpdateAfterBindSamplers"];
[&](){maxPerStageDescriptorUpdateAfterBindSamplers_json=member.maxPerStageDescriptorUpdateAfterBindSamplers;}();
auto& maxPerStageDescriptorUpdateAfterBindUniformBuffers_json=json["maxPerStageDescriptorUpdateAfterBindUniformBuffers"];
[&](){maxPerStageDescriptorUpdateAfterBindUniformBuffers_json=member.maxPerStageDescriptorUpdateAfterBindUniformBuffers;}();
auto& maxPerStageDescriptorUpdateAfterBindStorageBuffers_json=json["maxPerStageDescriptorUpdateAfterBindStorageBuffers"];
[&](){maxPerStageDescriptorUpdateAfterBindStorageBuffers_json=member.maxPerStageDescriptorUpdateAfterBindStorageBuffers;}();
auto& maxPerStageDescriptorUpdateAfterBindSampledImages_json=json["maxPerStageDescriptorUpdateAfterBindSampledImages"];
[&](){maxPerStageDescriptorUpdateAfterBindSampledImages_json=member.maxPerStageDescriptorUpdateAfterBindSampledImages;}();
auto& maxPerStageDescriptorUpdateAfterBindStorageImages_json=json["maxPerStageDescriptorUpdateAfterBindStorageImages"];
[&](){maxPerStageDescriptorUpdateAfterBindStorageImages_json=member.maxPerStageDescriptorUpdateAfterBindStorageImages;}();
auto& maxPerStageDescriptorUpdateAfterBindInputAttachments_json=json["maxPerStageDescriptorUpdateAfterBindInputAttachments"];
[&](){maxPerStageDescriptorUpdateAfterBindInputAttachments_json=member.maxPerStageDescriptorUpdateAfterBindInputAttachments;}();
auto& maxPerStageUpdateAfterBindResources_json=json["maxPerStageUpdateAfterBindResources"];
[&](){maxPerStageUpdateAfterBindResources_json=member.maxPerStageUpdateAfterBindResources;}();
auto& maxDescriptorSetUpdateAfterBindSamplers_json=json["maxDescriptorSetUpdateAfterBindSamplers"];
[&](){maxDescriptorSetUpdateAfterBindSamplers_json=member.maxDescriptorSetUpdateAfterBindSamplers;}();
auto& maxDescriptorSetUpdateAfterBindUniformBuffers_json=json["maxDescriptorSetUpdateAfterBindUniformBuffers"];
[&](){maxDescriptorSetUpdateAfterBindUniformBuffers_json=member.maxDescriptorSetUpdateAfterBindUniformBuffers;}();
auto& maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_json=json["maxDescriptorSetUpdateAfterBindUniformBuffersDynamic"];
[&](){maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_json=member.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;}();
auto& maxDescriptorSetUpdateAfterBindStorageBuffers_json=json["maxDescriptorSetUpdateAfterBindStorageBuffers"];
[&](){maxDescriptorSetUpdateAfterBindStorageBuffers_json=member.maxDescriptorSetUpdateAfterBindStorageBuffers;}();
auto& maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_json=json["maxDescriptorSetUpdateAfterBindStorageBuffersDynamic"];
[&](){maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_json=member.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;}();
auto& maxDescriptorSetUpdateAfterBindSampledImages_json=json["maxDescriptorSetUpdateAfterBindSampledImages"];
[&](){maxDescriptorSetUpdateAfterBindSampledImages_json=member.maxDescriptorSetUpdateAfterBindSampledImages;}();
auto& maxDescriptorSetUpdateAfterBindStorageImages_json=json["maxDescriptorSetUpdateAfterBindStorageImages"];
[&](){maxDescriptorSetUpdateAfterBindStorageImages_json=member.maxDescriptorSetUpdateAfterBindStorageImages;}();
auto& maxDescriptorSetUpdateAfterBindInputAttachments_json=json["maxDescriptorSetUpdateAfterBindInputAttachments"];
[&](){maxDescriptorSetUpdateAfterBindInputAttachments_json=member.maxDescriptorSetUpdateAfterBindInputAttachments;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDescriptorIndexingProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxUpdateAfterBindDescriptorsInAllPools_json=json["maxUpdateAfterBindDescriptorsInAllPools"];
[&](){member.maxUpdateAfterBindDescriptorsInAllPools=static_cast<uint32_t>(value_to<int>(maxUpdateAfterBindDescriptorsInAllPools_json));}();
auto& shaderUniformBufferArrayNonUniformIndexingNative_json=json["shaderUniformBufferArrayNonUniformIndexingNative"];
[&](){uint32_t temp_cKfmDrI;[&](){temp_cKfmDrI=static_cast<uint32_t>(value_to<int>(shaderUniformBufferArrayNonUniformIndexingNative_json));}();member.shaderUniformBufferArrayNonUniformIndexingNative=(VkBool32)temp_cKfmDrI;}();
auto& shaderSampledImageArrayNonUniformIndexingNative_json=json["shaderSampledImageArrayNonUniformIndexingNative"];
[&](){uint32_t temp_myHZdDe;[&](){temp_myHZdDe=static_cast<uint32_t>(value_to<int>(shaderSampledImageArrayNonUniformIndexingNative_json));}();member.shaderSampledImageArrayNonUniformIndexingNative=(VkBool32)temp_myHZdDe;}();
auto& shaderStorageBufferArrayNonUniformIndexingNative_json=json["shaderStorageBufferArrayNonUniformIndexingNative"];
[&](){uint32_t temp_RezyGAK;[&](){temp_RezyGAK=static_cast<uint32_t>(value_to<int>(shaderStorageBufferArrayNonUniformIndexingNative_json));}();member.shaderStorageBufferArrayNonUniformIndexingNative=(VkBool32)temp_RezyGAK;}();
auto& shaderStorageImageArrayNonUniformIndexingNative_json=json["shaderStorageImageArrayNonUniformIndexingNative"];
[&](){uint32_t temp_FTqVGBQ;[&](){temp_FTqVGBQ=static_cast<uint32_t>(value_to<int>(shaderStorageImageArrayNonUniformIndexingNative_json));}();member.shaderStorageImageArrayNonUniformIndexingNative=(VkBool32)temp_FTqVGBQ;}();
auto& shaderInputAttachmentArrayNonUniformIndexingNative_json=json["shaderInputAttachmentArrayNonUniformIndexingNative"];
[&](){uint32_t temp_KqorXqH;[&](){temp_KqorXqH=static_cast<uint32_t>(value_to<int>(shaderInputAttachmentArrayNonUniformIndexingNative_json));}();member.shaderInputAttachmentArrayNonUniformIndexingNative=(VkBool32)temp_KqorXqH;}();
auto& robustBufferAccessUpdateAfterBind_json=json["robustBufferAccessUpdateAfterBind"];
[&](){uint32_t temp_LlZxjdH;[&](){temp_LlZxjdH=static_cast<uint32_t>(value_to<int>(robustBufferAccessUpdateAfterBind_json));}();member.robustBufferAccessUpdateAfterBind=(VkBool32)temp_LlZxjdH;}();
auto& quadDivergentImplicitLod_json=json["quadDivergentImplicitLod"];
[&](){uint32_t temp_gaWUOsp;[&](){temp_gaWUOsp=static_cast<uint32_t>(value_to<int>(quadDivergentImplicitLod_json));}();member.quadDivergentImplicitLod=(VkBool32)temp_gaWUOsp;}();
auto& maxPerStageDescriptorUpdateAfterBindSamplers_json=json["maxPerStageDescriptorUpdateAfterBindSamplers"];
[&](){member.maxPerStageDescriptorUpdateAfterBindSamplers=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindSamplers_json));}();
auto& maxPerStageDescriptorUpdateAfterBindUniformBuffers_json=json["maxPerStageDescriptorUpdateAfterBindUniformBuffers"];
[&](){member.maxPerStageDescriptorUpdateAfterBindUniformBuffers=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindUniformBuffers_json));}();
auto& maxPerStageDescriptorUpdateAfterBindStorageBuffers_json=json["maxPerStageDescriptorUpdateAfterBindStorageBuffers"];
[&](){member.maxPerStageDescriptorUpdateAfterBindStorageBuffers=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindStorageBuffers_json));}();
auto& maxPerStageDescriptorUpdateAfterBindSampledImages_json=json["maxPerStageDescriptorUpdateAfterBindSampledImages"];
[&](){member.maxPerStageDescriptorUpdateAfterBindSampledImages=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindSampledImages_json));}();
auto& maxPerStageDescriptorUpdateAfterBindStorageImages_json=json["maxPerStageDescriptorUpdateAfterBindStorageImages"];
[&](){member.maxPerStageDescriptorUpdateAfterBindStorageImages=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindStorageImages_json));}();
auto& maxPerStageDescriptorUpdateAfterBindInputAttachments_json=json["maxPerStageDescriptorUpdateAfterBindInputAttachments"];
[&](){member.maxPerStageDescriptorUpdateAfterBindInputAttachments=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindInputAttachments_json));}();
auto& maxPerStageUpdateAfterBindResources_json=json["maxPerStageUpdateAfterBindResources"];
[&](){member.maxPerStageUpdateAfterBindResources=static_cast<uint32_t>(value_to<int>(maxPerStageUpdateAfterBindResources_json));}();
auto& maxDescriptorSetUpdateAfterBindSamplers_json=json["maxDescriptorSetUpdateAfterBindSamplers"];
[&](){member.maxDescriptorSetUpdateAfterBindSamplers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindSamplers_json));}();
auto& maxDescriptorSetUpdateAfterBindUniformBuffers_json=json["maxDescriptorSetUpdateAfterBindUniformBuffers"];
[&](){member.maxDescriptorSetUpdateAfterBindUniformBuffers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindUniformBuffers_json));}();
auto& maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_json=json["maxDescriptorSetUpdateAfterBindUniformBuffersDynamic"];
[&](){member.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_json));}();
auto& maxDescriptorSetUpdateAfterBindStorageBuffers_json=json["maxDescriptorSetUpdateAfterBindStorageBuffers"];
[&](){member.maxDescriptorSetUpdateAfterBindStorageBuffers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindStorageBuffers_json));}();
auto& maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_json=json["maxDescriptorSetUpdateAfterBindStorageBuffersDynamic"];
[&](){member.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_json));}();
auto& maxDescriptorSetUpdateAfterBindSampledImages_json=json["maxDescriptorSetUpdateAfterBindSampledImages"];
[&](){member.maxDescriptorSetUpdateAfterBindSampledImages=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindSampledImages_json));}();
auto& maxDescriptorSetUpdateAfterBindStorageImages_json=json["maxDescriptorSetUpdateAfterBindStorageImages"];
[&](){member.maxDescriptorSetUpdateAfterBindStorageImages=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindStorageImages_json));}();
auto& maxDescriptorSetUpdateAfterBindInputAttachments_json=json["maxDescriptorSetUpdateAfterBindInputAttachments"];
[&](){member.maxDescriptorSetUpdateAfterBindInputAttachments=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindInputAttachments_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorSetLayoutBindingFlagsCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& bindingCount_json=json["bindingCount"];
[&](){bindingCount_json=member.bindingCount;}();
auto& pBindingFlags_json=json["pBindingFlags"];
[&](){
            if (member.pBindingFlags==NULL){
                pBindingFlags_json=boost::json::array();
            return; }pBindingFlags_json=boost::json::array(member.bindingCount);
        auto& arr_MhpouOf=pBindingFlags_json.as_array();
        for(int xmLMcCd=0; xmLMcCd < member.bindingCount; xmLMcCd++){
            [&](){[&](){[&](){arr_MhpouOf[xmLMcCd]=member.pBindingFlags[xmLMcCd];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDescriptorSetLayoutBindingFlagsCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& bindingCount_json=json["bindingCount"];
[&](){member.bindingCount=static_cast<uint32_t>(value_to<int>(bindingCount_json));}();
auto& pBindingFlags_json=json["pBindingFlags"];
[&](){ VkDescriptorBindingFlags* temp_HUpYTXu;;[&](){
            if (pBindingFlags_json.as_array().size()==0){
                temp_HUpYTXu=NULL;
            return; }temp_HUpYTXu=(VkDescriptorBindingFlags*)malloc(member.bindingCount*sizeof(VkDescriptorBindingFlags));
        auto& arr_LngLqhC=pBindingFlags_json.as_array();
        for(int rAcDOwy=0; rAcDOwy < member.bindingCount; rAcDOwy++){
            [&](){[&](){int temp_ONOYTdS;[&](){temp_ONOYTdS=static_cast<int>(value_to<int>(arr_LngLqhC[rAcDOwy]));}();temp_HUpYTXu[rAcDOwy]=(VkDescriptorBindingFlags)temp_ONOYTdS;}();}();
        }
        }();member.pBindingFlags=temp_HUpYTXu;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorSetVariableDescriptorCountAllocateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& descriptorSetCount_json=json["descriptorSetCount"];
[&](){descriptorSetCount_json=member.descriptorSetCount;}();
auto& pDescriptorCounts_json=json["pDescriptorCounts"];
[&](){
            if (member.pDescriptorCounts==NULL){
                pDescriptorCounts_json=boost::json::array();
            return; }pDescriptorCounts_json=boost::json::array(member.descriptorSetCount);
        auto& arr_pEdjHOG=pDescriptorCounts_json.as_array();
        for(int OzBakdo=0; OzBakdo < member.descriptorSetCount; OzBakdo++){
            [&](){arr_pEdjHOG[OzBakdo]=member.pDescriptorCounts[OzBakdo];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDescriptorSetVariableDescriptorCountAllocateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& descriptorSetCount_json=json["descriptorSetCount"];
[&](){member.descriptorSetCount=static_cast<uint32_t>(value_to<int>(descriptorSetCount_json));}();
auto& pDescriptorCounts_json=json["pDescriptorCounts"];
[&](){ uint32_t* temp_FVFbeKw;;[&](){
            if (pDescriptorCounts_json.as_array().size()==0){
                temp_FVFbeKw=NULL;
            return; }temp_FVFbeKw=(uint32_t*)malloc(member.descriptorSetCount*sizeof(uint32_t));
        auto& arr_GMJQFLh=pDescriptorCounts_json.as_array();
        for(int EIobLDz=0; EIobLDz < member.descriptorSetCount; EIobLDz++){
            [&](){temp_FVFbeKw[EIobLDz]=static_cast<uint32_t>(value_to<int>(arr_GMJQFLh[EIobLDz]));}();
        }
        }();member.pDescriptorCounts=temp_FVFbeKw;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorSetVariableDescriptorCountLayoutSupport& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxVariableDescriptorCount_json=json["maxVariableDescriptorCount"];
[&](){maxVariableDescriptorCount_json=member.maxVariableDescriptorCount;}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorSetVariableDescriptorCountLayoutSupport& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxVariableDescriptorCount_json=json["maxVariableDescriptorCount"];
[&](){member.maxVariableDescriptorCount=static_cast<uint32_t>(value_to<int>(maxVariableDescriptorCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkAttachmentDescription2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& samples_json=json["samples"];
[&](){[&](){[&](){samples_json=member.samples;}();}();}();
auto& loadOp_json=json["loadOp"];
[&](){[&](){[&](){loadOp_json=member.loadOp;}();}();}();
auto& storeOp_json=json["storeOp"];
[&](){[&](){[&](){storeOp_json=member.storeOp;}();}();}();
auto& stencilLoadOp_json=json["stencilLoadOp"];
[&](){[&](){[&](){stencilLoadOp_json=member.stencilLoadOp;}();}();}();
auto& stencilStoreOp_json=json["stencilStoreOp"];
[&](){[&](){[&](){stencilStoreOp_json=member.stencilStoreOp;}();}();}();
auto& initialLayout_json=json["initialLayout"];
[&](){[&](){[&](){initialLayout_json=member.initialLayout;}();}();}();
auto& finalLayout_json=json["finalLayout"];
[&](){[&](){[&](){finalLayout_json=member.finalLayout;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkAttachmentDescription2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_ghpfkho;[&](){temp_ghpfkho=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkAttachmentDescriptionFlags)temp_ghpfkho;}();}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& samples_json=json["samples"];
[&](){[&](){int temp_HAQfesR;[&](){temp_HAQfesR=static_cast<int>(value_to<int>(samples_json));}();member.samples=(VkSampleCountFlagBits)temp_HAQfesR;}();}();
auto& loadOp_json=json["loadOp"];
[&](){[&](){int temp_FWnxBHJ;[&](){temp_FWnxBHJ=static_cast<int>(value_to<int>(loadOp_json));}();member.loadOp=(VkAttachmentLoadOp)temp_FWnxBHJ;}();}();
auto& storeOp_json=json["storeOp"];
[&](){[&](){int temp_fIASqxv;[&](){temp_fIASqxv=static_cast<int>(value_to<int>(storeOp_json));}();member.storeOp=(VkAttachmentStoreOp)temp_fIASqxv;}();}();
auto& stencilLoadOp_json=json["stencilLoadOp"];
[&](){[&](){int temp_jznxgLa;[&](){temp_jznxgLa=static_cast<int>(value_to<int>(stencilLoadOp_json));}();member.stencilLoadOp=(VkAttachmentLoadOp)temp_jznxgLa;}();}();
auto& stencilStoreOp_json=json["stencilStoreOp"];
[&](){[&](){int temp_aqhHNNp;[&](){temp_aqhHNNp=static_cast<int>(value_to<int>(stencilStoreOp_json));}();member.stencilStoreOp=(VkAttachmentStoreOp)temp_aqhHNNp;}();}();
auto& initialLayout_json=json["initialLayout"];
[&](){[&](){int temp_TsZaHzS;[&](){temp_TsZaHzS=static_cast<int>(value_to<int>(initialLayout_json));}();member.initialLayout=(VkImageLayout)temp_TsZaHzS;}();}();
auto& finalLayout_json=json["finalLayout"];
[&](){[&](){int temp_ZJMaJVD;[&](){temp_ZJMaJVD=static_cast<int>(value_to<int>(finalLayout_json));}();member.finalLayout=(VkImageLayout)temp_ZJMaJVD;}();}();
}

    void serialize_struct(boost::json::object& json, const VkAttachmentReference2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& attachment_json=json["attachment"];
[&](){attachment_json=member.attachment;}();
auto& layout_json=json["layout"];
[&](){[&](){[&](){layout_json=member.layout;}();}();}();
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){[&](){aspectMask_json=member.aspectMask;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkAttachmentReference2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& attachment_json=json["attachment"];
[&](){member.attachment=static_cast<uint32_t>(value_to<int>(attachment_json));}();
auto& layout_json=json["layout"];
[&](){[&](){int temp_TkPJJWY;[&](){temp_TkPJJWY=static_cast<int>(value_to<int>(layout_json));}();member.layout=(VkImageLayout)temp_TkPJJWY;}();}();
auto& aspectMask_json=json["aspectMask"];
[&](){[&](){int temp_srmSgxC;[&](){temp_srmSgxC=static_cast<int>(value_to<int>(aspectMask_json));}();member.aspectMask=(VkImageAspectFlags)temp_srmSgxC;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSubpassDescription2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){[&](){pipelineBindPoint_json=member.pipelineBindPoint;}();}();}();
auto& viewMask_json=json["viewMask"];
[&](){viewMask_json=member.viewMask;}();
auto& inputAttachmentCount_json=json["inputAttachmentCount"];
[&](){inputAttachmentCount_json=member.inputAttachmentCount;}();
auto& pInputAttachments_json=json["pInputAttachments"];
[&](){
            if (member.pInputAttachments==NULL){
                pInputAttachments_json=boost::json::array();
            return; }pInputAttachments_json=boost::json::array(member.inputAttachmentCount);
        auto& arr_qvnEIay=pInputAttachments_json.as_array();
        for(int VNPAFPg=0; VNPAFPg < member.inputAttachmentCount; VNPAFPg++){
            [&](){
            auto& temp=arr_qvnEIay[VNPAFPg].emplace_object();
            return serialize_struct(temp, member.pInputAttachments[VNPAFPg]);
            }();
        }
        }();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){colorAttachmentCount_json=member.colorAttachmentCount;}();
auto& pColorAttachments_json=json["pColorAttachments"];
[&](){
            if (member.pColorAttachments==NULL){
                pColorAttachments_json=boost::json::array();
            return; }pColorAttachments_json=boost::json::array(member.colorAttachmentCount);
        auto& arr_apqFJnV=pColorAttachments_json.as_array();
        for(int jocEaLc=0; jocEaLc < member.colorAttachmentCount; jocEaLc++){
            [&](){
            auto& temp=arr_apqFJnV[jocEaLc].emplace_object();
            return serialize_struct(temp, member.pColorAttachments[jocEaLc]);
            }();
        }
        }();
auto& pResolveAttachments_json=json["pResolveAttachments"];
[&](){
            if (member.pResolveAttachments==NULL){
                pResolveAttachments_json=boost::json::array();
            return; }pResolveAttachments_json=boost::json::array(member.colorAttachmentCount);
        auto& arr_QUTFZrq=pResolveAttachments_json.as_array();
        for(int LkzezJz=0; LkzezJz < member.colorAttachmentCount; LkzezJz++){
            [&](){
            auto& temp=arr_QUTFZrq[LkzezJz].emplace_object();
            return serialize_struct(temp, member.pResolveAttachments[LkzezJz]);
            }();
        }
        }();
auto& pDepthStencilAttachment_json=json["pDepthStencilAttachment"];
[&](){
            if (member.pDepthStencilAttachment==NULL){
                pDepthStencilAttachment_json=boost::json::array();
            return; }pDepthStencilAttachment_json=boost::json::array(1);
        auto& arr_PirANyH=pDepthStencilAttachment_json.as_array();
        for(int CCLGYro=0; CCLGYro < 1; CCLGYro++){
            [&](){
            auto& temp=arr_PirANyH[CCLGYro].emplace_object();
            return serialize_struct(temp, member.pDepthStencilAttachment[CCLGYro]);
            }();
        }
        }();
auto& preserveAttachmentCount_json=json["preserveAttachmentCount"];
[&](){preserveAttachmentCount_json=member.preserveAttachmentCount;}();
auto& pPreserveAttachments_json=json["pPreserveAttachments"];
[&](){
            if (member.pPreserveAttachments==NULL){
                pPreserveAttachments_json=boost::json::array();
            return; }pPreserveAttachments_json=boost::json::array(member.preserveAttachmentCount);
        auto& arr_JglfHnP=pPreserveAttachments_json.as_array();
        for(int GdjjjYx=0; GdjjjYx < member.preserveAttachmentCount; GdjjjYx++){
            [&](){arr_JglfHnP[GdjjjYx]=member.pPreserveAttachments[GdjjjYx];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSubpassDescription2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_QvdTojH;[&](){temp_QvdTojH=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSubpassDescriptionFlags)temp_QvdTojH;}();}();
auto& pipelineBindPoint_json=json["pipelineBindPoint"];
[&](){[&](){int temp_WiAtSfj;[&](){temp_WiAtSfj=static_cast<int>(value_to<int>(pipelineBindPoint_json));}();member.pipelineBindPoint=(VkPipelineBindPoint)temp_WiAtSfj;}();}();
auto& viewMask_json=json["viewMask"];
[&](){member.viewMask=static_cast<uint32_t>(value_to<int>(viewMask_json));}();
auto& inputAttachmentCount_json=json["inputAttachmentCount"];
[&](){member.inputAttachmentCount=static_cast<uint32_t>(value_to<int>(inputAttachmentCount_json));}();
auto& pInputAttachments_json=json["pInputAttachments"];
[&](){ VkAttachmentReference2* temp_BtJpDtO;;[&](){
            if (pInputAttachments_json.as_array().size()==0){
                temp_BtJpDtO=NULL;
            return; }temp_BtJpDtO=(VkAttachmentReference2*)malloc(member.inputAttachmentCount*sizeof(VkAttachmentReference2));
        auto& arr_ctMhgLh=pInputAttachments_json.as_array();
        for(int RHosagJ=0; RHosagJ < member.inputAttachmentCount; RHosagJ++){
            [&](){
            auto& temp=arr_ctMhgLh[RHosagJ].as_object();
            deserialize_struct(temp,temp_BtJpDtO[RHosagJ]);
            }();
        }
        }();member.pInputAttachments=temp_BtJpDtO;}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){member.colorAttachmentCount=static_cast<uint32_t>(value_to<int>(colorAttachmentCount_json));}();
auto& pColorAttachments_json=json["pColorAttachments"];
[&](){ VkAttachmentReference2* temp_RNvARCD;;[&](){
            if (pColorAttachments_json.as_array().size()==0){
                temp_RNvARCD=NULL;
            return; }temp_RNvARCD=(VkAttachmentReference2*)malloc(member.colorAttachmentCount*sizeof(VkAttachmentReference2));
        auto& arr_mBVnKUa=pColorAttachments_json.as_array();
        for(int izYQlEj=0; izYQlEj < member.colorAttachmentCount; izYQlEj++){
            [&](){
            auto& temp=arr_mBVnKUa[izYQlEj].as_object();
            deserialize_struct(temp,temp_RNvARCD[izYQlEj]);
            }();
        }
        }();member.pColorAttachments=temp_RNvARCD;}();
auto& pResolveAttachments_json=json["pResolveAttachments"];
[&](){ VkAttachmentReference2* temp_PDNkTdF;;[&](){
            if (pResolveAttachments_json.as_array().size()==0){
                temp_PDNkTdF=NULL;
            return; }temp_PDNkTdF=(VkAttachmentReference2*)malloc(member.colorAttachmentCount*sizeof(VkAttachmentReference2));
        auto& arr_FcPTntT=pResolveAttachments_json.as_array();
        for(int EgrMDIf=0; EgrMDIf < member.colorAttachmentCount; EgrMDIf++){
            [&](){
            auto& temp=arr_FcPTntT[EgrMDIf].as_object();
            deserialize_struct(temp,temp_PDNkTdF[EgrMDIf]);
            }();
        }
        }();member.pResolveAttachments=temp_PDNkTdF;}();
auto& pDepthStencilAttachment_json=json["pDepthStencilAttachment"];
[&](){ VkAttachmentReference2* temp_LZtctNF;;[&](){
            if (pDepthStencilAttachment_json.as_array().size()==0){
                temp_LZtctNF=NULL;
            return; }temp_LZtctNF=(VkAttachmentReference2*)malloc(1*sizeof(VkAttachmentReference2));
        auto& arr_UbONBxg=pDepthStencilAttachment_json.as_array();
        for(int fsEDoZE=0; fsEDoZE < 1; fsEDoZE++){
            [&](){
            auto& temp=arr_UbONBxg[fsEDoZE].as_object();
            deserialize_struct(temp,temp_LZtctNF[fsEDoZE]);
            }();
        }
        }();member.pDepthStencilAttachment=temp_LZtctNF;}();
auto& preserveAttachmentCount_json=json["preserveAttachmentCount"];
[&](){member.preserveAttachmentCount=static_cast<uint32_t>(value_to<int>(preserveAttachmentCount_json));}();
auto& pPreserveAttachments_json=json["pPreserveAttachments"];
[&](){ uint32_t* temp_jnYWItN;;[&](){
            if (pPreserveAttachments_json.as_array().size()==0){
                temp_jnYWItN=NULL;
            return; }temp_jnYWItN=(uint32_t*)malloc(member.preserveAttachmentCount*sizeof(uint32_t));
        auto& arr_sEqrXMO=pPreserveAttachments_json.as_array();
        for(int AzzybZu=0; AzzybZu < member.preserveAttachmentCount; AzzybZu++){
            [&](){temp_jnYWItN[AzzybZu]=static_cast<uint32_t>(value_to<int>(arr_sEqrXMO[AzzybZu]));}();
        }
        }();member.pPreserveAttachments=temp_jnYWItN;}();
}

    void serialize_struct(boost::json::object& json, const VkSubpassDependency2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcSubpass_json=json["srcSubpass"];
[&](){srcSubpass_json=member.srcSubpass;}();
auto& dstSubpass_json=json["dstSubpass"];
[&](){dstSubpass_json=member.dstSubpass;}();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){[&](){srcStageMask_json=member.srcStageMask;}();}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){[&](){dstStageMask_json=member.dstStageMask;}();}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){[&](){srcAccessMask_json=member.srcAccessMask;}();}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){[&](){dstAccessMask_json=member.dstAccessMask;}();}();}();
auto& dependencyFlags_json=json["dependencyFlags"];
[&](){[&](){[&](){dependencyFlags_json=member.dependencyFlags;}();}();}();
auto& viewOffset_json=json["viewOffset"];
[&](){viewOffset_json=member.viewOffset;}();
}
void deserialize_struct(boost::json::object& json, VkSubpassDependency2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcSubpass_json=json["srcSubpass"];
[&](){member.srcSubpass=static_cast<uint32_t>(value_to<int>(srcSubpass_json));}();
auto& dstSubpass_json=json["dstSubpass"];
[&](){member.dstSubpass=static_cast<uint32_t>(value_to<int>(dstSubpass_json));}();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){int temp_OagNenu;[&](){temp_OagNenu=static_cast<int>(value_to<int>(srcStageMask_json));}();member.srcStageMask=(VkPipelineStageFlags)temp_OagNenu;}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){int temp_uQeYZtj;[&](){temp_uQeYZtj=static_cast<int>(value_to<int>(dstStageMask_json));}();member.dstStageMask=(VkPipelineStageFlags)temp_uQeYZtj;}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){int temp_YMhhQIt;[&](){temp_YMhhQIt=static_cast<int>(value_to<int>(srcAccessMask_json));}();member.srcAccessMask=(VkAccessFlags)temp_YMhhQIt;}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){int temp_cyeCcOP;[&](){temp_cyeCcOP=static_cast<int>(value_to<int>(dstAccessMask_json));}();member.dstAccessMask=(VkAccessFlags)temp_cyeCcOP;}();}();
auto& dependencyFlags_json=json["dependencyFlags"];
[&](){[&](){int temp_BaltLwx;[&](){temp_BaltLwx=static_cast<int>(value_to<int>(dependencyFlags_json));}();member.dependencyFlags=(VkDependencyFlags)temp_BaltLwx;}();}();
auto& viewOffset_json=json["viewOffset"];
[&](){member.viewOffset=static_cast<int32_t>(value_to<int>(viewOffset_json));}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassCreateInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){attachmentCount_json=member.attachmentCount;}();
auto& pAttachments_json=json["pAttachments"];
[&](){
            if (member.pAttachments==NULL){
                pAttachments_json=boost::json::array();
            return; }pAttachments_json=boost::json::array(member.attachmentCount);
        auto& arr_vQFIUcn=pAttachments_json.as_array();
        for(int rRdEKKp=0; rRdEKKp < member.attachmentCount; rRdEKKp++){
            [&](){
            auto& temp=arr_vQFIUcn[rRdEKKp].emplace_object();
            return serialize_struct(temp, member.pAttachments[rRdEKKp]);
            }();
        }
        }();
auto& subpassCount_json=json["subpassCount"];
[&](){subpassCount_json=member.subpassCount;}();
auto& pSubpasses_json=json["pSubpasses"];
[&](){
            if (member.pSubpasses==NULL){
                pSubpasses_json=boost::json::array();
            return; }pSubpasses_json=boost::json::array(member.subpassCount);
        auto& arr_mAglqQf=pSubpasses_json.as_array();
        for(int GLIEOvQ=0; GLIEOvQ < member.subpassCount; GLIEOvQ++){
            [&](){
            auto& temp=arr_mAglqQf[GLIEOvQ].emplace_object();
            return serialize_struct(temp, member.pSubpasses[GLIEOvQ]);
            }();
        }
        }();
auto& dependencyCount_json=json["dependencyCount"];
[&](){dependencyCount_json=member.dependencyCount;}();
auto& pDependencies_json=json["pDependencies"];
[&](){
            if (member.pDependencies==NULL){
                pDependencies_json=boost::json::array();
            return; }pDependencies_json=boost::json::array(member.dependencyCount);
        auto& arr_OhQRmki=pDependencies_json.as_array();
        for(int haCEAGl=0; haCEAGl < member.dependencyCount; haCEAGl++){
            [&](){
            auto& temp=arr_OhQRmki[haCEAGl].emplace_object();
            return serialize_struct(temp, member.pDependencies[haCEAGl]);
            }();
        }
        }();
auto& correlatedViewMaskCount_json=json["correlatedViewMaskCount"];
[&](){correlatedViewMaskCount_json=member.correlatedViewMaskCount;}();
auto& pCorrelatedViewMasks_json=json["pCorrelatedViewMasks"];
[&](){
            if (member.pCorrelatedViewMasks==NULL){
                pCorrelatedViewMasks_json=boost::json::array();
            return; }pCorrelatedViewMasks_json=boost::json::array(member.correlatedViewMaskCount);
        auto& arr_ilezalj=pCorrelatedViewMasks_json.as_array();
        for(int wIrtcdf=0; wIrtcdf < member.correlatedViewMaskCount; wIrtcdf++){
            [&](){arr_ilezalj[wIrtcdf]=member.pCorrelatedViewMasks[wIrtcdf];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassCreateInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_lmsxAlv;[&](){temp_lmsxAlv=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkRenderPassCreateFlags)temp_lmsxAlv;}();}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){member.attachmentCount=static_cast<uint32_t>(value_to<int>(attachmentCount_json));}();
auto& pAttachments_json=json["pAttachments"];
[&](){ VkAttachmentDescription2* temp_bdhRmkc;;[&](){
            if (pAttachments_json.as_array().size()==0){
                temp_bdhRmkc=NULL;
            return; }temp_bdhRmkc=(VkAttachmentDescription2*)malloc(member.attachmentCount*sizeof(VkAttachmentDescription2));
        auto& arr_UGRvOFM=pAttachments_json.as_array();
        for(int KxYEExS=0; KxYEExS < member.attachmentCount; KxYEExS++){
            [&](){
            auto& temp=arr_UGRvOFM[KxYEExS].as_object();
            deserialize_struct(temp,temp_bdhRmkc[KxYEExS]);
            }();
        }
        }();member.pAttachments=temp_bdhRmkc;}();
auto& subpassCount_json=json["subpassCount"];
[&](){member.subpassCount=static_cast<uint32_t>(value_to<int>(subpassCount_json));}();
auto& pSubpasses_json=json["pSubpasses"];
[&](){ VkSubpassDescription2* temp_EtGgcXq;;[&](){
            if (pSubpasses_json.as_array().size()==0){
                temp_EtGgcXq=NULL;
            return; }temp_EtGgcXq=(VkSubpassDescription2*)malloc(member.subpassCount*sizeof(VkSubpassDescription2));
        auto& arr_sFNUCMm=pSubpasses_json.as_array();
        for(int mCUcMNI=0; mCUcMNI < member.subpassCount; mCUcMNI++){
            [&](){
            auto& temp=arr_sFNUCMm[mCUcMNI].as_object();
            deserialize_struct(temp,temp_EtGgcXq[mCUcMNI]);
            }();
        }
        }();member.pSubpasses=temp_EtGgcXq;}();
auto& dependencyCount_json=json["dependencyCount"];
[&](){member.dependencyCount=static_cast<uint32_t>(value_to<int>(dependencyCount_json));}();
auto& pDependencies_json=json["pDependencies"];
[&](){ VkSubpassDependency2* temp_MaZJiKy;;[&](){
            if (pDependencies_json.as_array().size()==0){
                temp_MaZJiKy=NULL;
            return; }temp_MaZJiKy=(VkSubpassDependency2*)malloc(member.dependencyCount*sizeof(VkSubpassDependency2));
        auto& arr_ljnKQib=pDependencies_json.as_array();
        for(int NZCYNJf=0; NZCYNJf < member.dependencyCount; NZCYNJf++){
            [&](){
            auto& temp=arr_ljnKQib[NZCYNJf].as_object();
            deserialize_struct(temp,temp_MaZJiKy[NZCYNJf]);
            }();
        }
        }();member.pDependencies=temp_MaZJiKy;}();
auto& correlatedViewMaskCount_json=json["correlatedViewMaskCount"];
[&](){member.correlatedViewMaskCount=static_cast<uint32_t>(value_to<int>(correlatedViewMaskCount_json));}();
auto& pCorrelatedViewMasks_json=json["pCorrelatedViewMasks"];
[&](){ uint32_t* temp_EHbycFL;;[&](){
            if (pCorrelatedViewMasks_json.as_array().size()==0){
                temp_EHbycFL=NULL;
            return; }temp_EHbycFL=(uint32_t*)malloc(member.correlatedViewMaskCount*sizeof(uint32_t));
        auto& arr_xNpjjVw=pCorrelatedViewMasks_json.as_array();
        for(int HZvTOkB=0; HZvTOkB < member.correlatedViewMaskCount; HZvTOkB++){
            [&](){temp_EHbycFL[HZvTOkB]=static_cast<uint32_t>(value_to<int>(arr_xNpjjVw[HZvTOkB]));}();
        }
        }();member.pCorrelatedViewMasks=temp_EHbycFL;}();
}

    void serialize_struct(boost::json::object& json, const VkSubpassBeginInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& contents_json=json["contents"];
[&](){[&](){[&](){contents_json=member.contents;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSubpassBeginInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& contents_json=json["contents"];
[&](){[&](){int temp_prjptKw;[&](){temp_prjptKw=static_cast<int>(value_to<int>(contents_json));}();member.contents=(VkSubpassContents)temp_prjptKw;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSubpassEndInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
}
void deserialize_struct(boost::json::object& json, VkSubpassEndInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceTimelineSemaphoreFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& timelineSemaphore_json=json["timelineSemaphore"];
[&](){[&](){timelineSemaphore_json=member.timelineSemaphore;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceTimelineSemaphoreFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& timelineSemaphore_json=json["timelineSemaphore"];
[&](){uint32_t temp_AMuaKRA;[&](){temp_AMuaKRA=static_cast<uint32_t>(value_to<int>(timelineSemaphore_json));}();member.timelineSemaphore=(VkBool32)temp_AMuaKRA;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceTimelineSemaphoreProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxTimelineSemaphoreValueDifference_json=json["maxTimelineSemaphoreValueDifference"];
[&](){maxTimelineSemaphoreValueDifference_json=member.maxTimelineSemaphoreValueDifference;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceTimelineSemaphoreProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxTimelineSemaphoreValueDifference_json=json["maxTimelineSemaphoreValueDifference"];
[&](){member.maxTimelineSemaphoreValueDifference=static_cast<uint64_t>(value_to<int>(maxTimelineSemaphoreValueDifference_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSemaphoreTypeCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& semaphoreType_json=json["semaphoreType"];
[&](){[&](){[&](){semaphoreType_json=member.semaphoreType;}();}();}();
auto& initialValue_json=json["initialValue"];
[&](){initialValue_json=member.initialValue;}();
}
void deserialize_struct(boost::json::object& json, VkSemaphoreTypeCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& semaphoreType_json=json["semaphoreType"];
[&](){[&](){int temp_HcMFBAE;[&](){temp_HcMFBAE=static_cast<int>(value_to<int>(semaphoreType_json));}();member.semaphoreType=(VkSemaphoreType)temp_HcMFBAE;}();}();
auto& initialValue_json=json["initialValue"];
[&](){member.initialValue=static_cast<uint64_t>(value_to<int>(initialValue_json));}();
}

    void serialize_struct(boost::json::object& json, const VkTimelineSemaphoreSubmitInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& waitSemaphoreValueCount_json=json["waitSemaphoreValueCount"];
[&](){waitSemaphoreValueCount_json=member.waitSemaphoreValueCount;}();
auto& pWaitSemaphoreValues_json=json["pWaitSemaphoreValues"];
[&](){
            if (member.pWaitSemaphoreValues==NULL){
                pWaitSemaphoreValues_json=boost::json::array();
            return; }pWaitSemaphoreValues_json=boost::json::array(member.waitSemaphoreValueCount);
        auto& arr_fkHOYwn=pWaitSemaphoreValues_json.as_array();
        for(int TubEEjQ=0; TubEEjQ < member.waitSemaphoreValueCount; TubEEjQ++){
            [&](){arr_fkHOYwn[TubEEjQ]=member.pWaitSemaphoreValues[TubEEjQ];}();
        }
        }();
auto& signalSemaphoreValueCount_json=json["signalSemaphoreValueCount"];
[&](){signalSemaphoreValueCount_json=member.signalSemaphoreValueCount;}();
auto& pSignalSemaphoreValues_json=json["pSignalSemaphoreValues"];
[&](){
            if (member.pSignalSemaphoreValues==NULL){
                pSignalSemaphoreValues_json=boost::json::array();
            return; }pSignalSemaphoreValues_json=boost::json::array(member.signalSemaphoreValueCount);
        auto& arr_yFoiMmC=pSignalSemaphoreValues_json.as_array();
        for(int ZRnKHkn=0; ZRnKHkn < member.signalSemaphoreValueCount; ZRnKHkn++){
            [&](){arr_yFoiMmC[ZRnKHkn]=member.pSignalSemaphoreValues[ZRnKHkn];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkTimelineSemaphoreSubmitInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& waitSemaphoreValueCount_json=json["waitSemaphoreValueCount"];
[&](){member.waitSemaphoreValueCount=static_cast<uint32_t>(value_to<int>(waitSemaphoreValueCount_json));}();
auto& pWaitSemaphoreValues_json=json["pWaitSemaphoreValues"];
[&](){ uint64_t* temp_TsDeRzB;;[&](){
            if (pWaitSemaphoreValues_json.as_array().size()==0){
                temp_TsDeRzB=NULL;
            return; }temp_TsDeRzB=(uint64_t*)malloc(member.waitSemaphoreValueCount*sizeof(uint64_t));
        auto& arr_bYgVRAw=pWaitSemaphoreValues_json.as_array();
        for(int yLXjHsl=0; yLXjHsl < member.waitSemaphoreValueCount; yLXjHsl++){
            [&](){temp_TsDeRzB[yLXjHsl]=static_cast<uint64_t>(value_to<int>(arr_bYgVRAw[yLXjHsl]));}();
        }
        }();member.pWaitSemaphoreValues=temp_TsDeRzB;}();
auto& signalSemaphoreValueCount_json=json["signalSemaphoreValueCount"];
[&](){member.signalSemaphoreValueCount=static_cast<uint32_t>(value_to<int>(signalSemaphoreValueCount_json));}();
auto& pSignalSemaphoreValues_json=json["pSignalSemaphoreValues"];
[&](){ uint64_t* temp_nSPNOKx;;[&](){
            if (pSignalSemaphoreValues_json.as_array().size()==0){
                temp_nSPNOKx=NULL;
            return; }temp_nSPNOKx=(uint64_t*)malloc(member.signalSemaphoreValueCount*sizeof(uint64_t));
        auto& arr_yBxJDwE=pSignalSemaphoreValues_json.as_array();
        for(int dbqGojc=0; dbqGojc < member.signalSemaphoreValueCount; dbqGojc++){
            [&](){temp_nSPNOKx[dbqGojc]=static_cast<uint64_t>(value_to<int>(arr_yBxJDwE[dbqGojc]));}();
        }
        }();member.pSignalSemaphoreValues=temp_nSPNOKx;}();
}

    void serialize_struct(boost::json::object& json, const VkSemaphoreWaitInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& semaphoreCount_json=json["semaphoreCount"];
[&](){semaphoreCount_json=member.semaphoreCount;}();
auto& pSemaphores_json=json["pSemaphores"];
[&](){
            if (member.pSemaphores==NULL){
                pSemaphores_json=boost::json::array();
            return; }pSemaphores_json=boost::json::array(member.semaphoreCount);
        auto& arr_BstIoUP=pSemaphores_json.as_array();
        for(int vemnwmF=0; vemnwmF < member.semaphoreCount; vemnwmF++){
            [&](){serialize_VkSemaphore(arr_BstIoUP[vemnwmF],member.pSemaphores[vemnwmF]);}();
        }
        }();
auto& pValues_json=json["pValues"];
[&](){
            if (member.pValues==NULL){
                pValues_json=boost::json::array();
            return; }pValues_json=boost::json::array(member.semaphoreCount);
        auto& arr_KoluVhX=pValues_json.as_array();
        for(int POsDDOd=0; POsDDOd < member.semaphoreCount; POsDDOd++){
            [&](){arr_KoluVhX[POsDDOd]=member.pValues[POsDDOd];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSemaphoreWaitInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_IkNHdgG;[&](){temp_IkNHdgG=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSemaphoreWaitFlags)temp_IkNHdgG;}();}();
auto& semaphoreCount_json=json["semaphoreCount"];
[&](){member.semaphoreCount=static_cast<uint32_t>(value_to<int>(semaphoreCount_json));}();
auto& pSemaphores_json=json["pSemaphores"];
[&](){ VkSemaphore* temp_cFjUCTQ;;[&](){
            if (pSemaphores_json.as_array().size()==0){
                temp_cFjUCTQ=NULL;
            return; }temp_cFjUCTQ=(VkSemaphore*)malloc(member.semaphoreCount*sizeof(VkSemaphore));
        auto& arr_faEVCQH=pSemaphores_json.as_array();
        for(int XaOYKOY=0; XaOYKOY < member.semaphoreCount; XaOYKOY++){
            [&](){deserialize_VkSemaphore(arr_faEVCQH[XaOYKOY], temp_cFjUCTQ[XaOYKOY]);}();
        }
        }();member.pSemaphores=temp_cFjUCTQ;}();
auto& pValues_json=json["pValues"];
[&](){ uint64_t* temp_qYNqMrx;;[&](){
            if (pValues_json.as_array().size()==0){
                temp_qYNqMrx=NULL;
            return; }temp_qYNqMrx=(uint64_t*)malloc(member.semaphoreCount*sizeof(uint64_t));
        auto& arr_rofshOJ=pValues_json.as_array();
        for(int PbZAJiK=0; PbZAJiK < member.semaphoreCount; PbZAJiK++){
            [&](){temp_qYNqMrx[PbZAJiK]=static_cast<uint64_t>(value_to<int>(arr_rofshOJ[PbZAJiK]));}();
        }
        }();member.pValues=temp_qYNqMrx;}();
}

    void serialize_struct(boost::json::object& json, const VkSemaphoreSignalInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& semaphore_json=json["semaphore"];
[&](){serialize_VkSemaphore(semaphore_json,member.semaphore);}();
auto& value_json=json["value"];
[&](){value_json=member.value;}();
}
void deserialize_struct(boost::json::object& json, VkSemaphoreSignalInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& semaphore_json=json["semaphore"];
[&](){deserialize_VkSemaphore(semaphore_json, member.semaphore);}();
auto& value_json=json["value"];
[&](){member.value=static_cast<uint64_t>(value_to<int>(value_json));}();
}

    void serialize_struct(boost::json::object& json, const VkVertexInputBindingDivisorDescriptionEXT& member){
        
    
auto& binding_json=json["binding"];
[&](){binding_json=member.binding;}();
auto& divisor_json=json["divisor"];
[&](){divisor_json=member.divisor;}();
}
void deserialize_struct(boost::json::object& json, VkVertexInputBindingDivisorDescriptionEXT& member){
auto& binding_json=json["binding"];
[&](){member.binding=static_cast<uint32_t>(value_to<int>(binding_json));}();
auto& divisor_json=json["divisor"];
[&](){member.divisor=static_cast<uint32_t>(value_to<int>(divisor_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineVertexInputDivisorStateCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& vertexBindingDivisorCount_json=json["vertexBindingDivisorCount"];
[&](){vertexBindingDivisorCount_json=member.vertexBindingDivisorCount;}();
auto& pVertexBindingDivisors_json=json["pVertexBindingDivisors"];
[&](){
            if (member.pVertexBindingDivisors==NULL){
                pVertexBindingDivisors_json=boost::json::array();
            return; }pVertexBindingDivisors_json=boost::json::array(member.vertexBindingDivisorCount);
        auto& arr_MVUaEEo=pVertexBindingDivisors_json.as_array();
        for(int LhiCzAa=0; LhiCzAa < member.vertexBindingDivisorCount; LhiCzAa++){
            [&](){
            auto& temp=arr_MVUaEEo[LhiCzAa].emplace_object();
            return serialize_struct(temp, member.pVertexBindingDivisors[LhiCzAa]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineVertexInputDivisorStateCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& vertexBindingDivisorCount_json=json["vertexBindingDivisorCount"];
[&](){member.vertexBindingDivisorCount=static_cast<uint32_t>(value_to<int>(vertexBindingDivisorCount_json));}();
auto& pVertexBindingDivisors_json=json["pVertexBindingDivisors"];
[&](){ VkVertexInputBindingDivisorDescriptionEXT* temp_ZQRopgf;;[&](){
            if (pVertexBindingDivisors_json.as_array().size()==0){
                temp_ZQRopgf=NULL;
            return; }temp_ZQRopgf=(VkVertexInputBindingDivisorDescriptionEXT*)malloc(member.vertexBindingDivisorCount*sizeof(VkVertexInputBindingDivisorDescriptionEXT));
        auto& arr_cJZUuvN=pVertexBindingDivisors_json.as_array();
        for(int ECpupFK=0; ECpupFK < member.vertexBindingDivisorCount; ECpupFK++){
            [&](){
            auto& temp=arr_cJZUuvN[ECpupFK].as_object();
            deserialize_struct(temp,temp_ZQRopgf[ECpupFK]);
            }();
        }
        }();member.pVertexBindingDivisors=temp_ZQRopgf;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxVertexAttribDivisor_json=json["maxVertexAttribDivisor"];
[&](){maxVertexAttribDivisor_json=member.maxVertexAttribDivisor;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxVertexAttribDivisor_json=json["maxVertexAttribDivisor"];
[&](){member.maxVertexAttribDivisor=static_cast<uint32_t>(value_to<int>(maxVertexAttribDivisor_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePCIBusInfoPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pciDomain_json=json["pciDomain"];
[&](){pciDomain_json=member.pciDomain;}();
auto& pciBus_json=json["pciBus"];
[&](){pciBus_json=member.pciBus;}();
auto& pciDevice_json=json["pciDevice"];
[&](){pciDevice_json=member.pciDevice;}();
auto& pciFunction_json=json["pciFunction"];
[&](){pciFunction_json=member.pciFunction;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePCIBusInfoPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pciDomain_json=json["pciDomain"];
[&](){member.pciDomain=static_cast<uint32_t>(value_to<int>(pciDomain_json));}();
auto& pciBus_json=json["pciBus"];
[&](){member.pciBus=static_cast<uint32_t>(value_to<int>(pciBus_json));}();
auto& pciDevice_json=json["pciDevice"];
[&](){member.pciDevice=static_cast<uint32_t>(value_to<int>(pciDevice_json));}();
auto& pciFunction_json=json["pciFunction"];
[&](){member.pciFunction=static_cast<uint32_t>(value_to<int>(pciFunction_json));}();
}

    void serialize_struct(boost::json::object& json, const VkCommandBufferInheritanceConditionalRenderingInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& conditionalRenderingEnable_json=json["conditionalRenderingEnable"];
[&](){[&](){conditionalRenderingEnable_json=member.conditionalRenderingEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkCommandBufferInheritanceConditionalRenderingInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& conditionalRenderingEnable_json=json["conditionalRenderingEnable"];
[&](){uint32_t temp_DSwgBPY;[&](){temp_DSwgBPY=static_cast<uint32_t>(value_to<int>(conditionalRenderingEnable_json));}();member.conditionalRenderingEnable=(VkBool32)temp_DSwgBPY;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevice8BitStorageFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& storageBuffer8BitAccess_json=json["storageBuffer8BitAccess"];
[&](){[&](){storageBuffer8BitAccess_json=member.storageBuffer8BitAccess;}();}();
auto& uniformAndStorageBuffer8BitAccess_json=json["uniformAndStorageBuffer8BitAccess"];
[&](){[&](){uniformAndStorageBuffer8BitAccess_json=member.uniformAndStorageBuffer8BitAccess;}();}();
auto& storagePushConstant8_json=json["storagePushConstant8"];
[&](){[&](){storagePushConstant8_json=member.storagePushConstant8;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevice8BitStorageFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& storageBuffer8BitAccess_json=json["storageBuffer8BitAccess"];
[&](){uint32_t temp_FtJFtaE;[&](){temp_FtJFtaE=static_cast<uint32_t>(value_to<int>(storageBuffer8BitAccess_json));}();member.storageBuffer8BitAccess=(VkBool32)temp_FtJFtaE;}();
auto& uniformAndStorageBuffer8BitAccess_json=json["uniformAndStorageBuffer8BitAccess"];
[&](){uint32_t temp_lQfUyFR;[&](){temp_lQfUyFR=static_cast<uint32_t>(value_to<int>(uniformAndStorageBuffer8BitAccess_json));}();member.uniformAndStorageBuffer8BitAccess=(VkBool32)temp_lQfUyFR;}();
auto& storagePushConstant8_json=json["storagePushConstant8"];
[&](){uint32_t temp_WEvCwTd;[&](){temp_WEvCwTd=static_cast<uint32_t>(value_to<int>(storagePushConstant8_json));}();member.storagePushConstant8=(VkBool32)temp_WEvCwTd;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceConditionalRenderingFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& conditionalRendering_json=json["conditionalRendering"];
[&](){[&](){conditionalRendering_json=member.conditionalRendering;}();}();
auto& inheritedConditionalRendering_json=json["inheritedConditionalRendering"];
[&](){[&](){inheritedConditionalRendering_json=member.inheritedConditionalRendering;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceConditionalRenderingFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& conditionalRendering_json=json["conditionalRendering"];
[&](){uint32_t temp_gxqApGq;[&](){temp_gxqApGq=static_cast<uint32_t>(value_to<int>(conditionalRendering_json));}();member.conditionalRendering=(VkBool32)temp_gxqApGq;}();
auto& inheritedConditionalRendering_json=json["inheritedConditionalRendering"];
[&](){uint32_t temp_sAETZSh;[&](){temp_sAETZSh=static_cast<uint32_t>(value_to<int>(inheritedConditionalRendering_json));}();member.inheritedConditionalRendering=(VkBool32)temp_sAETZSh;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVulkanMemoryModelFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& vulkanMemoryModel_json=json["vulkanMemoryModel"];
[&](){[&](){vulkanMemoryModel_json=member.vulkanMemoryModel;}();}();
auto& vulkanMemoryModelDeviceScope_json=json["vulkanMemoryModelDeviceScope"];
[&](){[&](){vulkanMemoryModelDeviceScope_json=member.vulkanMemoryModelDeviceScope;}();}();
auto& vulkanMemoryModelAvailabilityVisibilityChains_json=json["vulkanMemoryModelAvailabilityVisibilityChains"];
[&](){[&](){vulkanMemoryModelAvailabilityVisibilityChains_json=member.vulkanMemoryModelAvailabilityVisibilityChains;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVulkanMemoryModelFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& vulkanMemoryModel_json=json["vulkanMemoryModel"];
[&](){uint32_t temp_BSWUhSK;[&](){temp_BSWUhSK=static_cast<uint32_t>(value_to<int>(vulkanMemoryModel_json));}();member.vulkanMemoryModel=(VkBool32)temp_BSWUhSK;}();
auto& vulkanMemoryModelDeviceScope_json=json["vulkanMemoryModelDeviceScope"];
[&](){uint32_t temp_rZUhdCm;[&](){temp_rZUhdCm=static_cast<uint32_t>(value_to<int>(vulkanMemoryModelDeviceScope_json));}();member.vulkanMemoryModelDeviceScope=(VkBool32)temp_rZUhdCm;}();
auto& vulkanMemoryModelAvailabilityVisibilityChains_json=json["vulkanMemoryModelAvailabilityVisibilityChains"];
[&](){uint32_t temp_XZLJnrA;[&](){temp_XZLJnrA=static_cast<uint32_t>(value_to<int>(vulkanMemoryModelAvailabilityVisibilityChains_json));}();member.vulkanMemoryModelAvailabilityVisibilityChains=(VkBool32)temp_XZLJnrA;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderAtomicInt64Features& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderBufferInt64Atomics_json=json["shaderBufferInt64Atomics"];
[&](){[&](){shaderBufferInt64Atomics_json=member.shaderBufferInt64Atomics;}();}();
auto& shaderSharedInt64Atomics_json=json["shaderSharedInt64Atomics"];
[&](){[&](){shaderSharedInt64Atomics_json=member.shaderSharedInt64Atomics;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderAtomicInt64Features& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderBufferInt64Atomics_json=json["shaderBufferInt64Atomics"];
[&](){uint32_t temp_yVOKFeL;[&](){temp_yVOKFeL=static_cast<uint32_t>(value_to<int>(shaderBufferInt64Atomics_json));}();member.shaderBufferInt64Atomics=(VkBool32)temp_yVOKFeL;}();
auto& shaderSharedInt64Atomics_json=json["shaderSharedInt64Atomics"];
[&](){uint32_t temp_eiWVlfp;[&](){temp_eiWVlfp=static_cast<uint32_t>(value_to<int>(shaderSharedInt64Atomics_json));}();member.shaderSharedInt64Atomics=(VkBool32)temp_eiWVlfp;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderBufferFloat32Atomics_json=json["shaderBufferFloat32Atomics"];
[&](){[&](){shaderBufferFloat32Atomics_json=member.shaderBufferFloat32Atomics;}();}();
auto& shaderBufferFloat32AtomicAdd_json=json["shaderBufferFloat32AtomicAdd"];
[&](){[&](){shaderBufferFloat32AtomicAdd_json=member.shaderBufferFloat32AtomicAdd;}();}();
auto& shaderBufferFloat64Atomics_json=json["shaderBufferFloat64Atomics"];
[&](){[&](){shaderBufferFloat64Atomics_json=member.shaderBufferFloat64Atomics;}();}();
auto& shaderBufferFloat64AtomicAdd_json=json["shaderBufferFloat64AtomicAdd"];
[&](){[&](){shaderBufferFloat64AtomicAdd_json=member.shaderBufferFloat64AtomicAdd;}();}();
auto& shaderSharedFloat32Atomics_json=json["shaderSharedFloat32Atomics"];
[&](){[&](){shaderSharedFloat32Atomics_json=member.shaderSharedFloat32Atomics;}();}();
auto& shaderSharedFloat32AtomicAdd_json=json["shaderSharedFloat32AtomicAdd"];
[&](){[&](){shaderSharedFloat32AtomicAdd_json=member.shaderSharedFloat32AtomicAdd;}();}();
auto& shaderSharedFloat64Atomics_json=json["shaderSharedFloat64Atomics"];
[&](){[&](){shaderSharedFloat64Atomics_json=member.shaderSharedFloat64Atomics;}();}();
auto& shaderSharedFloat64AtomicAdd_json=json["shaderSharedFloat64AtomicAdd"];
[&](){[&](){shaderSharedFloat64AtomicAdd_json=member.shaderSharedFloat64AtomicAdd;}();}();
auto& shaderImageFloat32Atomics_json=json["shaderImageFloat32Atomics"];
[&](){[&](){shaderImageFloat32Atomics_json=member.shaderImageFloat32Atomics;}();}();
auto& shaderImageFloat32AtomicAdd_json=json["shaderImageFloat32AtomicAdd"];
[&](){[&](){shaderImageFloat32AtomicAdd_json=member.shaderImageFloat32AtomicAdd;}();}();
auto& sparseImageFloat32Atomics_json=json["sparseImageFloat32Atomics"];
[&](){[&](){sparseImageFloat32Atomics_json=member.sparseImageFloat32Atomics;}();}();
auto& sparseImageFloat32AtomicAdd_json=json["sparseImageFloat32AtomicAdd"];
[&](){[&](){sparseImageFloat32AtomicAdd_json=member.sparseImageFloat32AtomicAdd;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderBufferFloat32Atomics_json=json["shaderBufferFloat32Atomics"];
[&](){uint32_t temp_BsNAqSs;[&](){temp_BsNAqSs=static_cast<uint32_t>(value_to<int>(shaderBufferFloat32Atomics_json));}();member.shaderBufferFloat32Atomics=(VkBool32)temp_BsNAqSs;}();
auto& shaderBufferFloat32AtomicAdd_json=json["shaderBufferFloat32AtomicAdd"];
[&](){uint32_t temp_IilNXlm;[&](){temp_IilNXlm=static_cast<uint32_t>(value_to<int>(shaderBufferFloat32AtomicAdd_json));}();member.shaderBufferFloat32AtomicAdd=(VkBool32)temp_IilNXlm;}();
auto& shaderBufferFloat64Atomics_json=json["shaderBufferFloat64Atomics"];
[&](){uint32_t temp_Lmcfvtt;[&](){temp_Lmcfvtt=static_cast<uint32_t>(value_to<int>(shaderBufferFloat64Atomics_json));}();member.shaderBufferFloat64Atomics=(VkBool32)temp_Lmcfvtt;}();
auto& shaderBufferFloat64AtomicAdd_json=json["shaderBufferFloat64AtomicAdd"];
[&](){uint32_t temp_sLYEFjH;[&](){temp_sLYEFjH=static_cast<uint32_t>(value_to<int>(shaderBufferFloat64AtomicAdd_json));}();member.shaderBufferFloat64AtomicAdd=(VkBool32)temp_sLYEFjH;}();
auto& shaderSharedFloat32Atomics_json=json["shaderSharedFloat32Atomics"];
[&](){uint32_t temp_RfYAqvl;[&](){temp_RfYAqvl=static_cast<uint32_t>(value_to<int>(shaderSharedFloat32Atomics_json));}();member.shaderSharedFloat32Atomics=(VkBool32)temp_RfYAqvl;}();
auto& shaderSharedFloat32AtomicAdd_json=json["shaderSharedFloat32AtomicAdd"];
[&](){uint32_t temp_HkQmOmk;[&](){temp_HkQmOmk=static_cast<uint32_t>(value_to<int>(shaderSharedFloat32AtomicAdd_json));}();member.shaderSharedFloat32AtomicAdd=(VkBool32)temp_HkQmOmk;}();
auto& shaderSharedFloat64Atomics_json=json["shaderSharedFloat64Atomics"];
[&](){uint32_t temp_KJnPOsZ;[&](){temp_KJnPOsZ=static_cast<uint32_t>(value_to<int>(shaderSharedFloat64Atomics_json));}();member.shaderSharedFloat64Atomics=(VkBool32)temp_KJnPOsZ;}();
auto& shaderSharedFloat64AtomicAdd_json=json["shaderSharedFloat64AtomicAdd"];
[&](){uint32_t temp_xvdLTqx;[&](){temp_xvdLTqx=static_cast<uint32_t>(value_to<int>(shaderSharedFloat64AtomicAdd_json));}();member.shaderSharedFloat64AtomicAdd=(VkBool32)temp_xvdLTqx;}();
auto& shaderImageFloat32Atomics_json=json["shaderImageFloat32Atomics"];
[&](){uint32_t temp_xwUpKoY;[&](){temp_xwUpKoY=static_cast<uint32_t>(value_to<int>(shaderImageFloat32Atomics_json));}();member.shaderImageFloat32Atomics=(VkBool32)temp_xwUpKoY;}();
auto& shaderImageFloat32AtomicAdd_json=json["shaderImageFloat32AtomicAdd"];
[&](){uint32_t temp_fbzzaEl;[&](){temp_fbzzaEl=static_cast<uint32_t>(value_to<int>(shaderImageFloat32AtomicAdd_json));}();member.shaderImageFloat32AtomicAdd=(VkBool32)temp_fbzzaEl;}();
auto& sparseImageFloat32Atomics_json=json["sparseImageFloat32Atomics"];
[&](){uint32_t temp_UYvkqGQ;[&](){temp_UYvkqGQ=static_cast<uint32_t>(value_to<int>(sparseImageFloat32Atomics_json));}();member.sparseImageFloat32Atomics=(VkBool32)temp_UYvkqGQ;}();
auto& sparseImageFloat32AtomicAdd_json=json["sparseImageFloat32AtomicAdd"];
[&](){uint32_t temp_bfJoFcL;[&](){temp_bfJoFcL=static_cast<uint32_t>(value_to<int>(sparseImageFloat32AtomicAdd_json));}();member.sparseImageFloat32AtomicAdd=(VkBool32)temp_bfJoFcL;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderBufferFloat16Atomics_json=json["shaderBufferFloat16Atomics"];
[&](){[&](){shaderBufferFloat16Atomics_json=member.shaderBufferFloat16Atomics;}();}();
auto& shaderBufferFloat16AtomicAdd_json=json["shaderBufferFloat16AtomicAdd"];
[&](){[&](){shaderBufferFloat16AtomicAdd_json=member.shaderBufferFloat16AtomicAdd;}();}();
auto& shaderBufferFloat16AtomicMinMax_json=json["shaderBufferFloat16AtomicMinMax"];
[&](){[&](){shaderBufferFloat16AtomicMinMax_json=member.shaderBufferFloat16AtomicMinMax;}();}();
auto& shaderBufferFloat32AtomicMinMax_json=json["shaderBufferFloat32AtomicMinMax"];
[&](){[&](){shaderBufferFloat32AtomicMinMax_json=member.shaderBufferFloat32AtomicMinMax;}();}();
auto& shaderBufferFloat64AtomicMinMax_json=json["shaderBufferFloat64AtomicMinMax"];
[&](){[&](){shaderBufferFloat64AtomicMinMax_json=member.shaderBufferFloat64AtomicMinMax;}();}();
auto& shaderSharedFloat16Atomics_json=json["shaderSharedFloat16Atomics"];
[&](){[&](){shaderSharedFloat16Atomics_json=member.shaderSharedFloat16Atomics;}();}();
auto& shaderSharedFloat16AtomicAdd_json=json["shaderSharedFloat16AtomicAdd"];
[&](){[&](){shaderSharedFloat16AtomicAdd_json=member.shaderSharedFloat16AtomicAdd;}();}();
auto& shaderSharedFloat16AtomicMinMax_json=json["shaderSharedFloat16AtomicMinMax"];
[&](){[&](){shaderSharedFloat16AtomicMinMax_json=member.shaderSharedFloat16AtomicMinMax;}();}();
auto& shaderSharedFloat32AtomicMinMax_json=json["shaderSharedFloat32AtomicMinMax"];
[&](){[&](){shaderSharedFloat32AtomicMinMax_json=member.shaderSharedFloat32AtomicMinMax;}();}();
auto& shaderSharedFloat64AtomicMinMax_json=json["shaderSharedFloat64AtomicMinMax"];
[&](){[&](){shaderSharedFloat64AtomicMinMax_json=member.shaderSharedFloat64AtomicMinMax;}();}();
auto& shaderImageFloat32AtomicMinMax_json=json["shaderImageFloat32AtomicMinMax"];
[&](){[&](){shaderImageFloat32AtomicMinMax_json=member.shaderImageFloat32AtomicMinMax;}();}();
auto& sparseImageFloat32AtomicMinMax_json=json["sparseImageFloat32AtomicMinMax"];
[&](){[&](){sparseImageFloat32AtomicMinMax_json=member.sparseImageFloat32AtomicMinMax;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderBufferFloat16Atomics_json=json["shaderBufferFloat16Atomics"];
[&](){uint32_t temp_ppThQao;[&](){temp_ppThQao=static_cast<uint32_t>(value_to<int>(shaderBufferFloat16Atomics_json));}();member.shaderBufferFloat16Atomics=(VkBool32)temp_ppThQao;}();
auto& shaderBufferFloat16AtomicAdd_json=json["shaderBufferFloat16AtomicAdd"];
[&](){uint32_t temp_lSYtrXE;[&](){temp_lSYtrXE=static_cast<uint32_t>(value_to<int>(shaderBufferFloat16AtomicAdd_json));}();member.shaderBufferFloat16AtomicAdd=(VkBool32)temp_lSYtrXE;}();
auto& shaderBufferFloat16AtomicMinMax_json=json["shaderBufferFloat16AtomicMinMax"];
[&](){uint32_t temp_mWUJNKG;[&](){temp_mWUJNKG=static_cast<uint32_t>(value_to<int>(shaderBufferFloat16AtomicMinMax_json));}();member.shaderBufferFloat16AtomicMinMax=(VkBool32)temp_mWUJNKG;}();
auto& shaderBufferFloat32AtomicMinMax_json=json["shaderBufferFloat32AtomicMinMax"];
[&](){uint32_t temp_kbedlkp;[&](){temp_kbedlkp=static_cast<uint32_t>(value_to<int>(shaderBufferFloat32AtomicMinMax_json));}();member.shaderBufferFloat32AtomicMinMax=(VkBool32)temp_kbedlkp;}();
auto& shaderBufferFloat64AtomicMinMax_json=json["shaderBufferFloat64AtomicMinMax"];
[&](){uint32_t temp_nSezmvo;[&](){temp_nSezmvo=static_cast<uint32_t>(value_to<int>(shaderBufferFloat64AtomicMinMax_json));}();member.shaderBufferFloat64AtomicMinMax=(VkBool32)temp_nSezmvo;}();
auto& shaderSharedFloat16Atomics_json=json["shaderSharedFloat16Atomics"];
[&](){uint32_t temp_fTHcvNj;[&](){temp_fTHcvNj=static_cast<uint32_t>(value_to<int>(shaderSharedFloat16Atomics_json));}();member.shaderSharedFloat16Atomics=(VkBool32)temp_fTHcvNj;}();
auto& shaderSharedFloat16AtomicAdd_json=json["shaderSharedFloat16AtomicAdd"];
[&](){uint32_t temp_Ztqxnpv;[&](){temp_Ztqxnpv=static_cast<uint32_t>(value_to<int>(shaderSharedFloat16AtomicAdd_json));}();member.shaderSharedFloat16AtomicAdd=(VkBool32)temp_Ztqxnpv;}();
auto& shaderSharedFloat16AtomicMinMax_json=json["shaderSharedFloat16AtomicMinMax"];
[&](){uint32_t temp_dlKKVqf;[&](){temp_dlKKVqf=static_cast<uint32_t>(value_to<int>(shaderSharedFloat16AtomicMinMax_json));}();member.shaderSharedFloat16AtomicMinMax=(VkBool32)temp_dlKKVqf;}();
auto& shaderSharedFloat32AtomicMinMax_json=json["shaderSharedFloat32AtomicMinMax"];
[&](){uint32_t temp_SJPWNBq;[&](){temp_SJPWNBq=static_cast<uint32_t>(value_to<int>(shaderSharedFloat32AtomicMinMax_json));}();member.shaderSharedFloat32AtomicMinMax=(VkBool32)temp_SJPWNBq;}();
auto& shaderSharedFloat64AtomicMinMax_json=json["shaderSharedFloat64AtomicMinMax"];
[&](){uint32_t temp_cvEdhob;[&](){temp_cvEdhob=static_cast<uint32_t>(value_to<int>(shaderSharedFloat64AtomicMinMax_json));}();member.shaderSharedFloat64AtomicMinMax=(VkBool32)temp_cvEdhob;}();
auto& shaderImageFloat32AtomicMinMax_json=json["shaderImageFloat32AtomicMinMax"];
[&](){uint32_t temp_deQzXqe;[&](){temp_deQzXqe=static_cast<uint32_t>(value_to<int>(shaderImageFloat32AtomicMinMax_json));}();member.shaderImageFloat32AtomicMinMax=(VkBool32)temp_deQzXqe;}();
auto& sparseImageFloat32AtomicMinMax_json=json["sparseImageFloat32AtomicMinMax"];
[&](){uint32_t temp_rDseGhS;[&](){temp_rDseGhS=static_cast<uint32_t>(value_to<int>(sparseImageFloat32AtomicMinMax_json));}();member.sparseImageFloat32AtomicMinMax=(VkBool32)temp_rDseGhS;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& vertexAttributeInstanceRateDivisor_json=json["vertexAttributeInstanceRateDivisor"];
[&](){[&](){vertexAttributeInstanceRateDivisor_json=member.vertexAttributeInstanceRateDivisor;}();}();
auto& vertexAttributeInstanceRateZeroDivisor_json=json["vertexAttributeInstanceRateZeroDivisor"];
[&](){[&](){vertexAttributeInstanceRateZeroDivisor_json=member.vertexAttributeInstanceRateZeroDivisor;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& vertexAttributeInstanceRateDivisor_json=json["vertexAttributeInstanceRateDivisor"];
[&](){uint32_t temp_jMPJVOj;[&](){temp_jMPJVOj=static_cast<uint32_t>(value_to<int>(vertexAttributeInstanceRateDivisor_json));}();member.vertexAttributeInstanceRateDivisor=(VkBool32)temp_jMPJVOj;}();
auto& vertexAttributeInstanceRateZeroDivisor_json=json["vertexAttributeInstanceRateZeroDivisor"];
[&](){uint32_t temp_gOSKHRl;[&](){temp_gOSKHRl=static_cast<uint32_t>(value_to<int>(vertexAttributeInstanceRateZeroDivisor_json));}();member.vertexAttributeInstanceRateZeroDivisor=(VkBool32)temp_gOSKHRl;}();
}

    void serialize_struct(boost::json::object& json, const VkQueueFamilyCheckpointPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& checkpointExecutionStageMask_json=json["checkpointExecutionStageMask"];
[&](){[&](){[&](){checkpointExecutionStageMask_json=member.checkpointExecutionStageMask;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkQueueFamilyCheckpointPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& checkpointExecutionStageMask_json=json["checkpointExecutionStageMask"];
[&](){[&](){int temp_ytOCPwg;[&](){temp_ytOCPwg=static_cast<int>(value_to<int>(checkpointExecutionStageMask_json));}();member.checkpointExecutionStageMask=(VkPipelineStageFlags)temp_ytOCPwg;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCheckpointDataNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stage_json=json["stage"];
[&](){[&](){[&](){stage_json=member.stage;}();}();}();
auto& pCheckpointMarker_json=json["pCheckpointMarker"];
[&](){
            if (member.pCheckpointMarker==NULL){
                pCheckpointMarker_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pCheckpointMarker))==NULL){
                pCheckpointMarker_json=boost::json::array();
            return; }pCheckpointMarker_json=boost::json::array(strlen(((char*)(member.pCheckpointMarker)))+1);
        auto& arr_camgBwN=pCheckpointMarker_json.as_array();
        for(int RrhLchW=0; RrhLchW < strlen(((char*)(member.pCheckpointMarker)))+1; RrhLchW++){
            [&](){arr_camgBwN[RrhLchW]=((char*)(member.pCheckpointMarker))[RrhLchW];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkCheckpointDataNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& stage_json=json["stage"];
[&](){[&](){int temp_AwhUECV;[&](){temp_AwhUECV=static_cast<int>(value_to<int>(stage_json));}();member.stage=(VkPipelineStageFlagBits)temp_AwhUECV;}();}();
auto& pCheckpointMarker_json=json["pCheckpointMarker"];
[&](){
            if (pCheckpointMarker_json.as_array().size()==0){
                member.pCheckpointMarker=NULL;
            return; }char* temp_YQxDhdf;[&](){
            if (pCheckpointMarker_json.as_array().size()==0){
                temp_YQxDhdf=NULL;
            return; }temp_YQxDhdf=(char*)malloc(pCheckpointMarker_json.as_array().size()*sizeof(char));
        auto& arr_camgBwN=pCheckpointMarker_json.as_array();
        for(int RrhLchW=0; RrhLchW < pCheckpointMarker_json.as_array().size(); RrhLchW++){
            [&](){temp_YQxDhdf[RrhLchW]=static_cast<char>(value_to<int>(arr_camgBwN[RrhLchW]));}();
        }
        }();member.pCheckpointMarker=temp_YQxDhdf;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDepthStencilResolveProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& supportedDepthResolveModes_json=json["supportedDepthResolveModes"];
[&](){[&](){[&](){supportedDepthResolveModes_json=member.supportedDepthResolveModes;}();}();}();
auto& supportedStencilResolveModes_json=json["supportedStencilResolveModes"];
[&](){[&](){[&](){supportedStencilResolveModes_json=member.supportedStencilResolveModes;}();}();}();
auto& independentResolveNone_json=json["independentResolveNone"];
[&](){[&](){independentResolveNone_json=member.independentResolveNone;}();}();
auto& independentResolve_json=json["independentResolve"];
[&](){[&](){independentResolve_json=member.independentResolve;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDepthStencilResolveProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& supportedDepthResolveModes_json=json["supportedDepthResolveModes"];
[&](){[&](){int temp_juBDFoI;[&](){temp_juBDFoI=static_cast<int>(value_to<int>(supportedDepthResolveModes_json));}();member.supportedDepthResolveModes=(VkResolveModeFlags)temp_juBDFoI;}();}();
auto& supportedStencilResolveModes_json=json["supportedStencilResolveModes"];
[&](){[&](){int temp_QFrMlAg;[&](){temp_QFrMlAg=static_cast<int>(value_to<int>(supportedStencilResolveModes_json));}();member.supportedStencilResolveModes=(VkResolveModeFlags)temp_QFrMlAg;}();}();
auto& independentResolveNone_json=json["independentResolveNone"];
[&](){uint32_t temp_AhFrMTv;[&](){temp_AhFrMTv=static_cast<uint32_t>(value_to<int>(independentResolveNone_json));}();member.independentResolveNone=(VkBool32)temp_AhFrMTv;}();
auto& independentResolve_json=json["independentResolve"];
[&](){uint32_t temp_anItncR;[&](){temp_anItncR=static_cast<uint32_t>(value_to<int>(independentResolve_json));}();member.independentResolve=(VkBool32)temp_anItncR;}();
}

    void serialize_struct(boost::json::object& json, const VkSubpassDescriptionDepthStencilResolve& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& depthResolveMode_json=json["depthResolveMode"];
[&](){[&](){[&](){depthResolveMode_json=member.depthResolveMode;}();}();}();
auto& stencilResolveMode_json=json["stencilResolveMode"];
[&](){[&](){[&](){stencilResolveMode_json=member.stencilResolveMode;}();}();}();
auto& pDepthStencilResolveAttachment_json=json["pDepthStencilResolveAttachment"];
[&](){
            if (member.pDepthStencilResolveAttachment==NULL){
                pDepthStencilResolveAttachment_json=boost::json::array();
            return; }pDepthStencilResolveAttachment_json=boost::json::array(1);
        auto& arr_ktDximy=pDepthStencilResolveAttachment_json.as_array();
        for(int qMMfkKF=0; qMMfkKF < 1; qMMfkKF++){
            [&](){
            auto& temp=arr_ktDximy[qMMfkKF].emplace_object();
            return serialize_struct(temp, member.pDepthStencilResolveAttachment[qMMfkKF]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSubpassDescriptionDepthStencilResolve& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& depthResolveMode_json=json["depthResolveMode"];
[&](){[&](){int temp_vPvIqdG;[&](){temp_vPvIqdG=static_cast<int>(value_to<int>(depthResolveMode_json));}();member.depthResolveMode=(VkResolveModeFlagBits)temp_vPvIqdG;}();}();
auto& stencilResolveMode_json=json["stencilResolveMode"];
[&](){[&](){int temp_EiLdZbN;[&](){temp_EiLdZbN=static_cast<int>(value_to<int>(stencilResolveMode_json));}();member.stencilResolveMode=(VkResolveModeFlagBits)temp_EiLdZbN;}();}();
auto& pDepthStencilResolveAttachment_json=json["pDepthStencilResolveAttachment"];
[&](){ VkAttachmentReference2* temp_ZgBWRkS;;[&](){
            if (pDepthStencilResolveAttachment_json.as_array().size()==0){
                temp_ZgBWRkS=NULL;
            return; }temp_ZgBWRkS=(VkAttachmentReference2*)malloc(1*sizeof(VkAttachmentReference2));
        auto& arr_iECybIW=pDepthStencilResolveAttachment_json.as_array();
        for(int wZaggnk=0; wZaggnk < 1; wZaggnk++){
            [&](){
            auto& temp=arr_iECybIW[wZaggnk].as_object();
            deserialize_struct(temp,temp_ZgBWRkS[wZaggnk]);
            }();
        }
        }();member.pDepthStencilResolveAttachment=temp_ZgBWRkS;}();
}

    void serialize_struct(boost::json::object& json, const VkImageViewASTCDecodeModeEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& decodeMode_json=json["decodeMode"];
[&](){[&](){[&](){decodeMode_json=member.decodeMode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkImageViewASTCDecodeModeEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& decodeMode_json=json["decodeMode"];
[&](){[&](){int temp_Ipgsyva;[&](){temp_Ipgsyva=static_cast<int>(value_to<int>(decodeMode_json));}();member.decodeMode=(VkFormat)temp_Ipgsyva;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceASTCDecodeFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& decodeModeSharedExponent_json=json["decodeModeSharedExponent"];
[&](){[&](){decodeModeSharedExponent_json=member.decodeModeSharedExponent;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceASTCDecodeFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& decodeModeSharedExponent_json=json["decodeModeSharedExponent"];
[&](){uint32_t temp_rEwnBqr;[&](){temp_rEwnBqr=static_cast<uint32_t>(value_to<int>(decodeModeSharedExponent_json));}();member.decodeModeSharedExponent=(VkBool32)temp_rEwnBqr;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceTransformFeedbackFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& transformFeedback_json=json["transformFeedback"];
[&](){[&](){transformFeedback_json=member.transformFeedback;}();}();
auto& geometryStreams_json=json["geometryStreams"];
[&](){[&](){geometryStreams_json=member.geometryStreams;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceTransformFeedbackFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& transformFeedback_json=json["transformFeedback"];
[&](){uint32_t temp_yeBqTGu;[&](){temp_yeBqTGu=static_cast<uint32_t>(value_to<int>(transformFeedback_json));}();member.transformFeedback=(VkBool32)temp_yeBqTGu;}();
auto& geometryStreams_json=json["geometryStreams"];
[&](){uint32_t temp_WzAtmBY;[&](){temp_WzAtmBY=static_cast<uint32_t>(value_to<int>(geometryStreams_json));}();member.geometryStreams=(VkBool32)temp_WzAtmBY;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceTransformFeedbackPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxTransformFeedbackStreams_json=json["maxTransformFeedbackStreams"];
[&](){maxTransformFeedbackStreams_json=member.maxTransformFeedbackStreams;}();
auto& maxTransformFeedbackBuffers_json=json["maxTransformFeedbackBuffers"];
[&](){maxTransformFeedbackBuffers_json=member.maxTransformFeedbackBuffers;}();
auto& maxTransformFeedbackBufferSize_json=json["maxTransformFeedbackBufferSize"];
[&](){[&](){maxTransformFeedbackBufferSize_json=member.maxTransformFeedbackBufferSize;}();}();
auto& maxTransformFeedbackStreamDataSize_json=json["maxTransformFeedbackStreamDataSize"];
[&](){maxTransformFeedbackStreamDataSize_json=member.maxTransformFeedbackStreamDataSize;}();
auto& maxTransformFeedbackBufferDataSize_json=json["maxTransformFeedbackBufferDataSize"];
[&](){maxTransformFeedbackBufferDataSize_json=member.maxTransformFeedbackBufferDataSize;}();
auto& maxTransformFeedbackBufferDataStride_json=json["maxTransformFeedbackBufferDataStride"];
[&](){maxTransformFeedbackBufferDataStride_json=member.maxTransformFeedbackBufferDataStride;}();
auto& transformFeedbackQueries_json=json["transformFeedbackQueries"];
[&](){[&](){transformFeedbackQueries_json=member.transformFeedbackQueries;}();}();
auto& transformFeedbackStreamsLinesTriangles_json=json["transformFeedbackStreamsLinesTriangles"];
[&](){[&](){transformFeedbackStreamsLinesTriangles_json=member.transformFeedbackStreamsLinesTriangles;}();}();
auto& transformFeedbackRasterizationStreamSelect_json=json["transformFeedbackRasterizationStreamSelect"];
[&](){[&](){transformFeedbackRasterizationStreamSelect_json=member.transformFeedbackRasterizationStreamSelect;}();}();
auto& transformFeedbackDraw_json=json["transformFeedbackDraw"];
[&](){[&](){transformFeedbackDraw_json=member.transformFeedbackDraw;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceTransformFeedbackPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxTransformFeedbackStreams_json=json["maxTransformFeedbackStreams"];
[&](){member.maxTransformFeedbackStreams=static_cast<uint32_t>(value_to<int>(maxTransformFeedbackStreams_json));}();
auto& maxTransformFeedbackBuffers_json=json["maxTransformFeedbackBuffers"];
[&](){member.maxTransformFeedbackBuffers=static_cast<uint32_t>(value_to<int>(maxTransformFeedbackBuffers_json));}();
auto& maxTransformFeedbackBufferSize_json=json["maxTransformFeedbackBufferSize"];
[&](){uint64_t temp_UlExQbo;[&](){temp_UlExQbo=static_cast<uint64_t>(value_to<int>(maxTransformFeedbackBufferSize_json));}();member.maxTransformFeedbackBufferSize=(VkDeviceSize)temp_UlExQbo;}();
auto& maxTransformFeedbackStreamDataSize_json=json["maxTransformFeedbackStreamDataSize"];
[&](){member.maxTransformFeedbackStreamDataSize=static_cast<uint32_t>(value_to<int>(maxTransformFeedbackStreamDataSize_json));}();
auto& maxTransformFeedbackBufferDataSize_json=json["maxTransformFeedbackBufferDataSize"];
[&](){member.maxTransformFeedbackBufferDataSize=static_cast<uint32_t>(value_to<int>(maxTransformFeedbackBufferDataSize_json));}();
auto& maxTransformFeedbackBufferDataStride_json=json["maxTransformFeedbackBufferDataStride"];
[&](){member.maxTransformFeedbackBufferDataStride=static_cast<uint32_t>(value_to<int>(maxTransformFeedbackBufferDataStride_json));}();
auto& transformFeedbackQueries_json=json["transformFeedbackQueries"];
[&](){uint32_t temp_zUhYQHN;[&](){temp_zUhYQHN=static_cast<uint32_t>(value_to<int>(transformFeedbackQueries_json));}();member.transformFeedbackQueries=(VkBool32)temp_zUhYQHN;}();
auto& transformFeedbackStreamsLinesTriangles_json=json["transformFeedbackStreamsLinesTriangles"];
[&](){uint32_t temp_FztIMWe;[&](){temp_FztIMWe=static_cast<uint32_t>(value_to<int>(transformFeedbackStreamsLinesTriangles_json));}();member.transformFeedbackStreamsLinesTriangles=(VkBool32)temp_FztIMWe;}();
auto& transformFeedbackRasterizationStreamSelect_json=json["transformFeedbackRasterizationStreamSelect"];
[&](){uint32_t temp_UjRETXR;[&](){temp_UjRETXR=static_cast<uint32_t>(value_to<int>(transformFeedbackRasterizationStreamSelect_json));}();member.transformFeedbackRasterizationStreamSelect=(VkBool32)temp_UjRETXR;}();
auto& transformFeedbackDraw_json=json["transformFeedbackDraw"];
[&](){uint32_t temp_yfXDkMy;[&](){temp_yfXDkMy=static_cast<uint32_t>(value_to<int>(transformFeedbackDraw_json));}();member.transformFeedbackDraw=(VkBool32)temp_yfXDkMy;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRasterizationStateStreamCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& rasterizationStream_json=json["rasterizationStream"];
[&](){rasterizationStream_json=member.rasterizationStream;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRasterizationStateStreamCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_UJwORLe;[&](){temp_UJwORLe=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineRasterizationStateStreamCreateFlagsEXT)temp_UJwORLe;}();}();
auto& rasterizationStream_json=json["rasterizationStream"];
[&](){member.rasterizationStream=static_cast<uint32_t>(value_to<int>(rasterizationStream_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& representativeFragmentTest_json=json["representativeFragmentTest"];
[&](){[&](){representativeFragmentTest_json=member.representativeFragmentTest;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& representativeFragmentTest_json=json["representativeFragmentTest"];
[&](){uint32_t temp_bcgOsWX;[&](){temp_bcgOsWX=static_cast<uint32_t>(value_to<int>(representativeFragmentTest_json));}();member.representativeFragmentTest=(VkBool32)temp_bcgOsWX;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRepresentativeFragmentTestStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& representativeFragmentTestEnable_json=json["representativeFragmentTestEnable"];
[&](){[&](){representativeFragmentTestEnable_json=member.representativeFragmentTestEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRepresentativeFragmentTestStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& representativeFragmentTestEnable_json=json["representativeFragmentTestEnable"];
[&](){uint32_t temp_JWTxKMX;[&](){temp_JWTxKMX=static_cast<uint32_t>(value_to<int>(representativeFragmentTestEnable_json));}();member.representativeFragmentTestEnable=(VkBool32)temp_JWTxKMX;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExclusiveScissorFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& exclusiveScissor_json=json["exclusiveScissor"];
[&](){[&](){exclusiveScissor_json=member.exclusiveScissor;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExclusiveScissorFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& exclusiveScissor_json=json["exclusiveScissor"];
[&](){uint32_t temp_iMvQwbe;[&](){temp_iMvQwbe=static_cast<uint32_t>(value_to<int>(exclusiveScissor_json));}();member.exclusiveScissor=(VkBool32)temp_iMvQwbe;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineViewportExclusiveScissorStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& exclusiveScissorCount_json=json["exclusiveScissorCount"];
[&](){exclusiveScissorCount_json=member.exclusiveScissorCount;}();
auto& pExclusiveScissors_json=json["pExclusiveScissors"];
[&](){
            if (member.pExclusiveScissors==NULL){
                pExclusiveScissors_json=boost::json::array();
            return; }pExclusiveScissors_json=boost::json::array(member.exclusiveScissorCount);
        auto& arr_KfGvnWP=pExclusiveScissors_json.as_array();
        for(int OubVbuK=0; OubVbuK < member.exclusiveScissorCount; OubVbuK++){
            [&](){
            auto& temp=arr_KfGvnWP[OubVbuK].emplace_object();
            return serialize_struct(temp, member.pExclusiveScissors[OubVbuK]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineViewportExclusiveScissorStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& exclusiveScissorCount_json=json["exclusiveScissorCount"];
[&](){member.exclusiveScissorCount=static_cast<uint32_t>(value_to<int>(exclusiveScissorCount_json));}();
auto& pExclusiveScissors_json=json["pExclusiveScissors"];
[&](){ VkRect2D* temp_PNyTUeJ;;[&](){
            if (pExclusiveScissors_json.as_array().size()==0){
                temp_PNyTUeJ=NULL;
            return; }temp_PNyTUeJ=(VkRect2D*)malloc(member.exclusiveScissorCount*sizeof(VkRect2D));
        auto& arr_TvOsUAg=pExclusiveScissors_json.as_array();
        for(int NTagttt=0; NTagttt < member.exclusiveScissorCount; NTagttt++){
            [&](){
            auto& temp=arr_TvOsUAg[NTagttt].as_object();
            deserialize_struct(temp,temp_PNyTUeJ[NTagttt]);
            }();
        }
        }();member.pExclusiveScissors=temp_PNyTUeJ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCornerSampledImageFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& cornerSampledImage_json=json["cornerSampledImage"];
[&](){[&](){cornerSampledImage_json=member.cornerSampledImage;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCornerSampledImageFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& cornerSampledImage_json=json["cornerSampledImage"];
[&](){uint32_t temp_tHwXdsZ;[&](){temp_tHwXdsZ=static_cast<uint32_t>(value_to<int>(cornerSampledImage_json));}();member.cornerSampledImage=(VkBool32)temp_tHwXdsZ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& computeDerivativeGroupQuads_json=json["computeDerivativeGroupQuads"];
[&](){[&](){computeDerivativeGroupQuads_json=member.computeDerivativeGroupQuads;}();}();
auto& computeDerivativeGroupLinear_json=json["computeDerivativeGroupLinear"];
[&](){[&](){computeDerivativeGroupLinear_json=member.computeDerivativeGroupLinear;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& computeDerivativeGroupQuads_json=json["computeDerivativeGroupQuads"];
[&](){uint32_t temp_vhfPHzZ;[&](){temp_vhfPHzZ=static_cast<uint32_t>(value_to<int>(computeDerivativeGroupQuads_json));}();member.computeDerivativeGroupQuads=(VkBool32)temp_vhfPHzZ;}();
auto& computeDerivativeGroupLinear_json=json["computeDerivativeGroupLinear"];
[&](){uint32_t temp_nYjeayB;[&](){temp_nYjeayB=static_cast<uint32_t>(value_to<int>(computeDerivativeGroupLinear_json));}();member.computeDerivativeGroupLinear=(VkBool32)temp_nYjeayB;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderImageFootprintFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageFootprint_json=json["imageFootprint"];
[&](){[&](){imageFootprint_json=member.imageFootprint;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderImageFootprintFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& imageFootprint_json=json["imageFootprint"];
[&](){uint32_t temp_tVqEkWt;[&](){temp_tVqEkWt=static_cast<uint32_t>(value_to<int>(imageFootprint_json));}();member.imageFootprint=(VkBool32)temp_tVqEkWt;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dedicatedAllocationImageAliasing_json=json["dedicatedAllocationImageAliasing"];
[&](){[&](){dedicatedAllocationImageAliasing_json=member.dedicatedAllocationImageAliasing;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& dedicatedAllocationImageAliasing_json=json["dedicatedAllocationImageAliasing"];
[&](){uint32_t temp_EzsHIQI;[&](){temp_EzsHIQI=static_cast<uint32_t>(value_to<int>(dedicatedAllocationImageAliasing_json));}();member.dedicatedAllocationImageAliasing=(VkBool32)temp_EzsHIQI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& indirectCopy_json=json["indirectCopy"];
[&](){[&](){indirectCopy_json=member.indirectCopy;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCopyMemoryIndirectFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& indirectCopy_json=json["indirectCopy"];
[&](){uint32_t temp_TSiLsux;[&](){temp_TSiLsux=static_cast<uint32_t>(value_to<int>(indirectCopy_json));}();member.indirectCopy=(VkBool32)temp_TSiLsux;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& supportedQueues_json=json["supportedQueues"];
[&](){[&](){[&](){supportedQueues_json=member.supportedQueues;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& supportedQueues_json=json["supportedQueues"];
[&](){[&](){int temp_YLRoQkd;[&](){temp_YLRoQkd=static_cast<int>(value_to<int>(supportedQueues_json));}();member.supportedQueues=(VkQueueFlags)temp_YLRoQkd;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMemoryDecompressionFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memoryDecompression_json=json["memoryDecompression"];
[&](){[&](){memoryDecompression_json=member.memoryDecompression;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMemoryDecompressionFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& memoryDecompression_json=json["memoryDecompression"];
[&](){uint32_t temp_wsFwZDN;[&](){temp_wsFwZDN=static_cast<uint32_t>(value_to<int>(memoryDecompression_json));}();member.memoryDecompression=(VkBool32)temp_wsFwZDN;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMemoryDecompressionPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& decompressionMethods_json=json["decompressionMethods"];
[&](){[&](){[&](){decompressionMethods_json=member.decompressionMethods;}();}();}();
auto& maxDecompressionIndirectCount_json=json["maxDecompressionIndirectCount"];
[&](){maxDecompressionIndirectCount_json=member.maxDecompressionIndirectCount;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMemoryDecompressionPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& decompressionMethods_json=json["decompressionMethods"];
[&](){[&](){int temp_lIGulkm;[&](){temp_lIGulkm=static_cast<int>(value_to<int>(decompressionMethods_json));}();member.decompressionMethods=(VkMemoryDecompressionMethodFlagsNV)temp_lIGulkm;}();}();
auto& maxDecompressionIndirectCount_json=json["maxDecompressionIndirectCount"];
[&](){member.maxDecompressionIndirectCount=static_cast<uint64_t>(value_to<int>(maxDecompressionIndirectCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkShadingRatePaletteNV& member){
        
    
auto& shadingRatePaletteEntryCount_json=json["shadingRatePaletteEntryCount"];
[&](){shadingRatePaletteEntryCount_json=member.shadingRatePaletteEntryCount;}();
auto& pShadingRatePaletteEntries_json=json["pShadingRatePaletteEntries"];
[&](){
            if (member.pShadingRatePaletteEntries==NULL){
                pShadingRatePaletteEntries_json=boost::json::array();
            return; }pShadingRatePaletteEntries_json=boost::json::array(member.shadingRatePaletteEntryCount);
        auto& arr_lauFgVU=pShadingRatePaletteEntries_json.as_array();
        for(int RYTYvLc=0; RYTYvLc < member.shadingRatePaletteEntryCount; RYTYvLc++){
            [&](){[&](){[&](){arr_lauFgVU[RYTYvLc]=member.pShadingRatePaletteEntries[RYTYvLc];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkShadingRatePaletteNV& member){
auto& shadingRatePaletteEntryCount_json=json["shadingRatePaletteEntryCount"];
[&](){member.shadingRatePaletteEntryCount=static_cast<uint32_t>(value_to<int>(shadingRatePaletteEntryCount_json));}();
auto& pShadingRatePaletteEntries_json=json["pShadingRatePaletteEntries"];
[&](){ VkShadingRatePaletteEntryNV* temp_ZOYftDH;;[&](){
            if (pShadingRatePaletteEntries_json.as_array().size()==0){
                temp_ZOYftDH=NULL;
            return; }temp_ZOYftDH=(VkShadingRatePaletteEntryNV*)malloc(member.shadingRatePaletteEntryCount*sizeof(VkShadingRatePaletteEntryNV));
        auto& arr_oJOWwvp=pShadingRatePaletteEntries_json.as_array();
        for(int aTavdIr=0; aTavdIr < member.shadingRatePaletteEntryCount; aTavdIr++){
            [&](){[&](){int temp_BioLFwQ;[&](){temp_BioLFwQ=static_cast<int>(value_to<int>(arr_oJOWwvp[aTavdIr]));}();temp_ZOYftDH[aTavdIr]=(VkShadingRatePaletteEntryNV)temp_BioLFwQ;}();}();
        }
        }();member.pShadingRatePaletteEntries=temp_ZOYftDH;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineViewportShadingRateImageStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shadingRateImageEnable_json=json["shadingRateImageEnable"];
[&](){[&](){shadingRateImageEnable_json=member.shadingRateImageEnable;}();}();
auto& viewportCount_json=json["viewportCount"];
[&](){viewportCount_json=member.viewportCount;}();
auto& pShadingRatePalettes_json=json["pShadingRatePalettes"];
[&](){
            if (member.pShadingRatePalettes==NULL){
                pShadingRatePalettes_json=boost::json::array();
            return; }pShadingRatePalettes_json=boost::json::array(member.viewportCount);
        auto& arr_mlKUZSn=pShadingRatePalettes_json.as_array();
        for(int CvIbxCy=0; CvIbxCy < member.viewportCount; CvIbxCy++){
            [&](){
            auto& temp=arr_mlKUZSn[CvIbxCy].emplace_object();
            return serialize_struct(temp, member.pShadingRatePalettes[CvIbxCy]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineViewportShadingRateImageStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& shadingRateImageEnable_json=json["shadingRateImageEnable"];
[&](){uint32_t temp_tXQhvSt;[&](){temp_tXQhvSt=static_cast<uint32_t>(value_to<int>(shadingRateImageEnable_json));}();member.shadingRateImageEnable=(VkBool32)temp_tXQhvSt;}();
auto& viewportCount_json=json["viewportCount"];
[&](){member.viewportCount=static_cast<uint32_t>(value_to<int>(viewportCount_json));}();
auto& pShadingRatePalettes_json=json["pShadingRatePalettes"];
[&](){ VkShadingRatePaletteNV* temp_YwLkAUc;;[&](){
            if (pShadingRatePalettes_json.as_array().size()==0){
                temp_YwLkAUc=NULL;
            return; }temp_YwLkAUc=(VkShadingRatePaletteNV*)malloc(member.viewportCount*sizeof(VkShadingRatePaletteNV));
        auto& arr_BPcUzmM=pShadingRatePalettes_json.as_array();
        for(int ZKymMJR=0; ZKymMJR < member.viewportCount; ZKymMJR++){
            [&](){
            auto& temp=arr_BPcUzmM[ZKymMJR].as_object();
            deserialize_struct(temp,temp_YwLkAUc[ZKymMJR]);
            }();
        }
        }();member.pShadingRatePalettes=temp_YwLkAUc;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShadingRateImageFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shadingRateImage_json=json["shadingRateImage"];
[&](){[&](){shadingRateImage_json=member.shadingRateImage;}();}();
auto& shadingRateCoarseSampleOrder_json=json["shadingRateCoarseSampleOrder"];
[&](){[&](){shadingRateCoarseSampleOrder_json=member.shadingRateCoarseSampleOrder;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShadingRateImageFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shadingRateImage_json=json["shadingRateImage"];
[&](){uint32_t temp_jiTjKjj;[&](){temp_jiTjKjj=static_cast<uint32_t>(value_to<int>(shadingRateImage_json));}();member.shadingRateImage=(VkBool32)temp_jiTjKjj;}();
auto& shadingRateCoarseSampleOrder_json=json["shadingRateCoarseSampleOrder"];
[&](){uint32_t temp_yEUwhPg;[&](){temp_yEUwhPg=static_cast<uint32_t>(value_to<int>(shadingRateCoarseSampleOrder_json));}();member.shadingRateCoarseSampleOrder=(VkBool32)temp_yEUwhPg;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShadingRateImagePropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shadingRateTexelSize_json=json["shadingRateTexelSize"];
[&](){
            auto& temp=shadingRateTexelSize_json.emplace_object();
            return serialize_struct(temp, member.shadingRateTexelSize);
            }();
auto& shadingRatePaletteSize_json=json["shadingRatePaletteSize"];
[&](){shadingRatePaletteSize_json=member.shadingRatePaletteSize;}();
auto& shadingRateMaxCoarseSamples_json=json["shadingRateMaxCoarseSamples"];
[&](){shadingRateMaxCoarseSamples_json=member.shadingRateMaxCoarseSamples;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShadingRateImagePropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shadingRateTexelSize_json=json["shadingRateTexelSize"];
[&](){
            auto& temp=shadingRateTexelSize_json.as_object();
            deserialize_struct(temp,member.shadingRateTexelSize);
            }();
auto& shadingRatePaletteSize_json=json["shadingRatePaletteSize"];
[&](){member.shadingRatePaletteSize=static_cast<uint32_t>(value_to<int>(shadingRatePaletteSize_json));}();
auto& shadingRateMaxCoarseSamples_json=json["shadingRateMaxCoarseSamples"];
[&](){member.shadingRateMaxCoarseSamples=static_cast<uint32_t>(value_to<int>(shadingRateMaxCoarseSamples_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& invocationMask_json=json["invocationMask"];
[&](){[&](){invocationMask_json=member.invocationMask;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& invocationMask_json=json["invocationMask"];
[&](){uint32_t temp_qGCvqHj;[&](){temp_qGCvqHj=static_cast<uint32_t>(value_to<int>(invocationMask_json));}();member.invocationMask=(VkBool32)temp_qGCvqHj;}();
}

    void serialize_struct(boost::json::object& json, const VkCoarseSampleLocationNV& member){
        
    
auto& pixelX_json=json["pixelX"];
[&](){pixelX_json=member.pixelX;}();
auto& pixelY_json=json["pixelY"];
[&](){pixelY_json=member.pixelY;}();
auto& sample_json=json["sample"];
[&](){sample_json=member.sample;}();
}
void deserialize_struct(boost::json::object& json, VkCoarseSampleLocationNV& member){
auto& pixelX_json=json["pixelX"];
[&](){member.pixelX=static_cast<uint32_t>(value_to<int>(pixelX_json));}();
auto& pixelY_json=json["pixelY"];
[&](){member.pixelY=static_cast<uint32_t>(value_to<int>(pixelY_json));}();
auto& sample_json=json["sample"];
[&](){member.sample=static_cast<uint32_t>(value_to<int>(sample_json));}();
}

    void serialize_struct(boost::json::object& json, const VkCoarseSampleOrderCustomNV& member){
        
    
auto& shadingRate_json=json["shadingRate"];
[&](){[&](){[&](){shadingRate_json=member.shadingRate;}();}();}();
auto& sampleCount_json=json["sampleCount"];
[&](){sampleCount_json=member.sampleCount;}();
auto& sampleLocationCount_json=json["sampleLocationCount"];
[&](){sampleLocationCount_json=member.sampleLocationCount;}();
auto& pSampleLocations_json=json["pSampleLocations"];
[&](){
            if (member.pSampleLocations==NULL){
                pSampleLocations_json=boost::json::array();
            return; }pSampleLocations_json=boost::json::array(member.sampleLocationCount);
        auto& arr_LNrvynN=pSampleLocations_json.as_array();
        for(int QOVVghW=0; QOVVghW < member.sampleLocationCount; QOVVghW++){
            [&](){
            auto& temp=arr_LNrvynN[QOVVghW].emplace_object();
            return serialize_struct(temp, member.pSampleLocations[QOVVghW]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCoarseSampleOrderCustomNV& member){
auto& shadingRate_json=json["shadingRate"];
[&](){[&](){int temp_JhhqpoA;[&](){temp_JhhqpoA=static_cast<int>(value_to<int>(shadingRate_json));}();member.shadingRate=(VkShadingRatePaletteEntryNV)temp_JhhqpoA;}();}();
auto& sampleCount_json=json["sampleCount"];
[&](){member.sampleCount=static_cast<uint32_t>(value_to<int>(sampleCount_json));}();
auto& sampleLocationCount_json=json["sampleLocationCount"];
[&](){member.sampleLocationCount=static_cast<uint32_t>(value_to<int>(sampleLocationCount_json));}();
auto& pSampleLocations_json=json["pSampleLocations"];
[&](){ VkCoarseSampleLocationNV* temp_QUiFCQi;;[&](){
            if (pSampleLocations_json.as_array().size()==0){
                temp_QUiFCQi=NULL;
            return; }temp_QUiFCQi=(VkCoarseSampleLocationNV*)malloc(member.sampleLocationCount*sizeof(VkCoarseSampleLocationNV));
        auto& arr_xsbfGrn=pSampleLocations_json.as_array();
        for(int TRAqGVu=0; TRAqGVu < member.sampleLocationCount; TRAqGVu++){
            [&](){
            auto& temp=arr_xsbfGrn[TRAqGVu].as_object();
            deserialize_struct(temp,temp_QUiFCQi[TRAqGVu]);
            }();
        }
        }();member.pSampleLocations=temp_QUiFCQi;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& sampleOrderType_json=json["sampleOrderType"];
[&](){[&](){[&](){sampleOrderType_json=member.sampleOrderType;}();}();}();
auto& customSampleOrderCount_json=json["customSampleOrderCount"];
[&](){customSampleOrderCount_json=member.customSampleOrderCount;}();
auto& pCustomSampleOrders_json=json["pCustomSampleOrders"];
[&](){
            if (member.pCustomSampleOrders==NULL){
                pCustomSampleOrders_json=boost::json::array();
            return; }pCustomSampleOrders_json=boost::json::array(member.customSampleOrderCount);
        auto& arr_IojdMMd=pCustomSampleOrders_json.as_array();
        for(int disPTmD=0; disPTmD < member.customSampleOrderCount; disPTmD++){
            [&](){
            auto& temp=arr_IojdMMd[disPTmD].emplace_object();
            return serialize_struct(temp, member.pCustomSampleOrders[disPTmD]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& sampleOrderType_json=json["sampleOrderType"];
[&](){[&](){int temp_EwVpGfr;[&](){temp_EwVpGfr=static_cast<int>(value_to<int>(sampleOrderType_json));}();member.sampleOrderType=(VkCoarseSampleOrderTypeNV)temp_EwVpGfr;}();}();
auto& customSampleOrderCount_json=json["customSampleOrderCount"];
[&](){member.customSampleOrderCount=static_cast<uint32_t>(value_to<int>(customSampleOrderCount_json));}();
auto& pCustomSampleOrders_json=json["pCustomSampleOrders"];
[&](){ VkCoarseSampleOrderCustomNV* temp_MWxbKoa;;[&](){
            if (pCustomSampleOrders_json.as_array().size()==0){
                temp_MWxbKoa=NULL;
            return; }temp_MWxbKoa=(VkCoarseSampleOrderCustomNV*)malloc(member.customSampleOrderCount*sizeof(VkCoarseSampleOrderCustomNV));
        auto& arr_mgBRbZw=pCustomSampleOrders_json.as_array();
        for(int uuRNTDV=0; uuRNTDV < member.customSampleOrderCount; uuRNTDV++){
            [&](){
            auto& temp=arr_mgBRbZw[uuRNTDV].as_object();
            deserialize_struct(temp,temp_MWxbKoa[uuRNTDV]);
            }();
        }
        }();member.pCustomSampleOrders=temp_MWxbKoa;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMeshShaderFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& taskShader_json=json["taskShader"];
[&](){[&](){taskShader_json=member.taskShader;}();}();
auto& meshShader_json=json["meshShader"];
[&](){[&](){meshShader_json=member.meshShader;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMeshShaderFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& taskShader_json=json["taskShader"];
[&](){uint32_t temp_NrKuphD;[&](){temp_NrKuphD=static_cast<uint32_t>(value_to<int>(taskShader_json));}();member.taskShader=(VkBool32)temp_NrKuphD;}();
auto& meshShader_json=json["meshShader"];
[&](){uint32_t temp_Dmryzge;[&](){temp_Dmryzge=static_cast<uint32_t>(value_to<int>(meshShader_json));}();member.meshShader=(VkBool32)temp_Dmryzge;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMeshShaderPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxDrawMeshTasksCount_json=json["maxDrawMeshTasksCount"];
[&](){maxDrawMeshTasksCount_json=member.maxDrawMeshTasksCount;}();
auto& maxTaskWorkGroupInvocations_json=json["maxTaskWorkGroupInvocations"];
[&](){maxTaskWorkGroupInvocations_json=member.maxTaskWorkGroupInvocations;}();
auto& maxTaskWorkGroupSize_json=json["maxTaskWorkGroupSize"];
[&](){maxTaskWorkGroupSize_json=boost::json::array(3);
        auto& arr_soXfkeA=maxTaskWorkGroupSize_json.as_array();
        for(int hJJLhFo=0; hJJLhFo < 3; hJJLhFo++){
            [&](){arr_soXfkeA[hJJLhFo]=member.maxTaskWorkGroupSize[hJJLhFo];}();
        }
        }();
auto& maxTaskTotalMemorySize_json=json["maxTaskTotalMemorySize"];
[&](){maxTaskTotalMemorySize_json=member.maxTaskTotalMemorySize;}();
auto& maxTaskOutputCount_json=json["maxTaskOutputCount"];
[&](){maxTaskOutputCount_json=member.maxTaskOutputCount;}();
auto& maxMeshWorkGroupInvocations_json=json["maxMeshWorkGroupInvocations"];
[&](){maxMeshWorkGroupInvocations_json=member.maxMeshWorkGroupInvocations;}();
auto& maxMeshWorkGroupSize_json=json["maxMeshWorkGroupSize"];
[&](){maxMeshWorkGroupSize_json=boost::json::array(3);
        auto& arr_rVdmxxY=maxMeshWorkGroupSize_json.as_array();
        for(int ZcCPNjp=0; ZcCPNjp < 3; ZcCPNjp++){
            [&](){arr_rVdmxxY[ZcCPNjp]=member.maxMeshWorkGroupSize[ZcCPNjp];}();
        }
        }();
auto& maxMeshTotalMemorySize_json=json["maxMeshTotalMemorySize"];
[&](){maxMeshTotalMemorySize_json=member.maxMeshTotalMemorySize;}();
auto& maxMeshOutputVertices_json=json["maxMeshOutputVertices"];
[&](){maxMeshOutputVertices_json=member.maxMeshOutputVertices;}();
auto& maxMeshOutputPrimitives_json=json["maxMeshOutputPrimitives"];
[&](){maxMeshOutputPrimitives_json=member.maxMeshOutputPrimitives;}();
auto& maxMeshMultiviewViewCount_json=json["maxMeshMultiviewViewCount"];
[&](){maxMeshMultiviewViewCount_json=member.maxMeshMultiviewViewCount;}();
auto& meshOutputPerVertexGranularity_json=json["meshOutputPerVertexGranularity"];
[&](){meshOutputPerVertexGranularity_json=member.meshOutputPerVertexGranularity;}();
auto& meshOutputPerPrimitiveGranularity_json=json["meshOutputPerPrimitiveGranularity"];
[&](){meshOutputPerPrimitiveGranularity_json=member.meshOutputPerPrimitiveGranularity;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMeshShaderPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxDrawMeshTasksCount_json=json["maxDrawMeshTasksCount"];
[&](){member.maxDrawMeshTasksCount=static_cast<uint32_t>(value_to<int>(maxDrawMeshTasksCount_json));}();
auto& maxTaskWorkGroupInvocations_json=json["maxTaskWorkGroupInvocations"];
[&](){member.maxTaskWorkGroupInvocations=static_cast<uint32_t>(value_to<int>(maxTaskWorkGroupInvocations_json));}();
auto& maxTaskWorkGroupSize_json=json["maxTaskWorkGroupSize"];
[&](){
        auto& arr_soXfkeA=maxTaskWorkGroupSize_json.as_array();
        for(int hJJLhFo=0; hJJLhFo < 3; hJJLhFo++){
            [&](){member.maxTaskWorkGroupSize[hJJLhFo]=static_cast<uint32_t>(value_to<int>(arr_soXfkeA[hJJLhFo]));}();
        }
        }();
auto& maxTaskTotalMemorySize_json=json["maxTaskTotalMemorySize"];
[&](){member.maxTaskTotalMemorySize=static_cast<uint32_t>(value_to<int>(maxTaskTotalMemorySize_json));}();
auto& maxTaskOutputCount_json=json["maxTaskOutputCount"];
[&](){member.maxTaskOutputCount=static_cast<uint32_t>(value_to<int>(maxTaskOutputCount_json));}();
auto& maxMeshWorkGroupInvocations_json=json["maxMeshWorkGroupInvocations"];
[&](){member.maxMeshWorkGroupInvocations=static_cast<uint32_t>(value_to<int>(maxMeshWorkGroupInvocations_json));}();
auto& maxMeshWorkGroupSize_json=json["maxMeshWorkGroupSize"];
[&](){
        auto& arr_rVdmxxY=maxMeshWorkGroupSize_json.as_array();
        for(int ZcCPNjp=0; ZcCPNjp < 3; ZcCPNjp++){
            [&](){member.maxMeshWorkGroupSize[ZcCPNjp]=static_cast<uint32_t>(value_to<int>(arr_rVdmxxY[ZcCPNjp]));}();
        }
        }();
auto& maxMeshTotalMemorySize_json=json["maxMeshTotalMemorySize"];
[&](){member.maxMeshTotalMemorySize=static_cast<uint32_t>(value_to<int>(maxMeshTotalMemorySize_json));}();
auto& maxMeshOutputVertices_json=json["maxMeshOutputVertices"];
[&](){member.maxMeshOutputVertices=static_cast<uint32_t>(value_to<int>(maxMeshOutputVertices_json));}();
auto& maxMeshOutputPrimitives_json=json["maxMeshOutputPrimitives"];
[&](){member.maxMeshOutputPrimitives=static_cast<uint32_t>(value_to<int>(maxMeshOutputPrimitives_json));}();
auto& maxMeshMultiviewViewCount_json=json["maxMeshMultiviewViewCount"];
[&](){member.maxMeshMultiviewViewCount=static_cast<uint32_t>(value_to<int>(maxMeshMultiviewViewCount_json));}();
auto& meshOutputPerVertexGranularity_json=json["meshOutputPerVertexGranularity"];
[&](){member.meshOutputPerVertexGranularity=static_cast<uint32_t>(value_to<int>(meshOutputPerVertexGranularity_json));}();
auto& meshOutputPerPrimitiveGranularity_json=json["meshOutputPerPrimitiveGranularity"];
[&](){member.meshOutputPerPrimitiveGranularity=static_cast<uint32_t>(value_to<int>(meshOutputPerPrimitiveGranularity_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDrawMeshTasksIndirectCommandNV& member){
        
    
auto& taskCount_json=json["taskCount"];
[&](){taskCount_json=member.taskCount;}();
auto& firstTask_json=json["firstTask"];
[&](){firstTask_json=member.firstTask;}();
}
void deserialize_struct(boost::json::object& json, VkDrawMeshTasksIndirectCommandNV& member){
auto& taskCount_json=json["taskCount"];
[&](){member.taskCount=static_cast<uint32_t>(value_to<int>(taskCount_json));}();
auto& firstTask_json=json["firstTask"];
[&](){member.firstTask=static_cast<uint32_t>(value_to<int>(firstTask_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMeshShaderFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& taskShader_json=json["taskShader"];
[&](){[&](){taskShader_json=member.taskShader;}();}();
auto& meshShader_json=json["meshShader"];
[&](){[&](){meshShader_json=member.meshShader;}();}();
auto& multiviewMeshShader_json=json["multiviewMeshShader"];
[&](){[&](){multiviewMeshShader_json=member.multiviewMeshShader;}();}();
auto& primitiveFragmentShadingRateMeshShader_json=json["primitiveFragmentShadingRateMeshShader"];
[&](){[&](){primitiveFragmentShadingRateMeshShader_json=member.primitiveFragmentShadingRateMeshShader;}();}();
auto& meshShaderQueries_json=json["meshShaderQueries"];
[&](){[&](){meshShaderQueries_json=member.meshShaderQueries;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMeshShaderFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& taskShader_json=json["taskShader"];
[&](){uint32_t temp_NrKuphD;[&](){temp_NrKuphD=static_cast<uint32_t>(value_to<int>(taskShader_json));}();member.taskShader=(VkBool32)temp_NrKuphD;}();
auto& meshShader_json=json["meshShader"];
[&](){uint32_t temp_Dmryzge;[&](){temp_Dmryzge=static_cast<uint32_t>(value_to<int>(meshShader_json));}();member.meshShader=(VkBool32)temp_Dmryzge;}();
auto& multiviewMeshShader_json=json["multiviewMeshShader"];
[&](){uint32_t temp_HdcBKzw;[&](){temp_HdcBKzw=static_cast<uint32_t>(value_to<int>(multiviewMeshShader_json));}();member.multiviewMeshShader=(VkBool32)temp_HdcBKzw;}();
auto& primitiveFragmentShadingRateMeshShader_json=json["primitiveFragmentShadingRateMeshShader"];
[&](){uint32_t temp_KeFwait;[&](){temp_KeFwait=static_cast<uint32_t>(value_to<int>(primitiveFragmentShadingRateMeshShader_json));}();member.primitiveFragmentShadingRateMeshShader=(VkBool32)temp_KeFwait;}();
auto& meshShaderQueries_json=json["meshShaderQueries"];
[&](){uint32_t temp_OgEaOJN;[&](){temp_OgEaOJN=static_cast<uint32_t>(value_to<int>(meshShaderQueries_json));}();member.meshShaderQueries=(VkBool32)temp_OgEaOJN;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMeshShaderPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxTaskWorkGroupTotalCount_json=json["maxTaskWorkGroupTotalCount"];
[&](){maxTaskWorkGroupTotalCount_json=member.maxTaskWorkGroupTotalCount;}();
auto& maxTaskWorkGroupCount_json=json["maxTaskWorkGroupCount"];
[&](){maxTaskWorkGroupCount_json=boost::json::array(3);
        auto& arr_hvbtrfl=maxTaskWorkGroupCount_json.as_array();
        for(int xeUWuzJ=0; xeUWuzJ < 3; xeUWuzJ++){
            [&](){arr_hvbtrfl[xeUWuzJ]=member.maxTaskWorkGroupCount[xeUWuzJ];}();
        }
        }();
auto& maxTaskWorkGroupInvocations_json=json["maxTaskWorkGroupInvocations"];
[&](){maxTaskWorkGroupInvocations_json=member.maxTaskWorkGroupInvocations;}();
auto& maxTaskWorkGroupSize_json=json["maxTaskWorkGroupSize"];
[&](){maxTaskWorkGroupSize_json=boost::json::array(3);
        auto& arr_soXfkeA=maxTaskWorkGroupSize_json.as_array();
        for(int hJJLhFo=0; hJJLhFo < 3; hJJLhFo++){
            [&](){arr_soXfkeA[hJJLhFo]=member.maxTaskWorkGroupSize[hJJLhFo];}();
        }
        }();
auto& maxTaskPayloadSize_json=json["maxTaskPayloadSize"];
[&](){maxTaskPayloadSize_json=member.maxTaskPayloadSize;}();
auto& maxTaskSharedMemorySize_json=json["maxTaskSharedMemorySize"];
[&](){maxTaskSharedMemorySize_json=member.maxTaskSharedMemorySize;}();
auto& maxTaskPayloadAndSharedMemorySize_json=json["maxTaskPayloadAndSharedMemorySize"];
[&](){maxTaskPayloadAndSharedMemorySize_json=member.maxTaskPayloadAndSharedMemorySize;}();
auto& maxMeshWorkGroupTotalCount_json=json["maxMeshWorkGroupTotalCount"];
[&](){maxMeshWorkGroupTotalCount_json=member.maxMeshWorkGroupTotalCount;}();
auto& maxMeshWorkGroupCount_json=json["maxMeshWorkGroupCount"];
[&](){maxMeshWorkGroupCount_json=boost::json::array(3);
        auto& arr_zCqVtXx=maxMeshWorkGroupCount_json.as_array();
        for(int kwoJakk=0; kwoJakk < 3; kwoJakk++){
            [&](){arr_zCqVtXx[kwoJakk]=member.maxMeshWorkGroupCount[kwoJakk];}();
        }
        }();
auto& maxMeshWorkGroupInvocations_json=json["maxMeshWorkGroupInvocations"];
[&](){maxMeshWorkGroupInvocations_json=member.maxMeshWorkGroupInvocations;}();
auto& maxMeshWorkGroupSize_json=json["maxMeshWorkGroupSize"];
[&](){maxMeshWorkGroupSize_json=boost::json::array(3);
        auto& arr_rVdmxxY=maxMeshWorkGroupSize_json.as_array();
        for(int ZcCPNjp=0; ZcCPNjp < 3; ZcCPNjp++){
            [&](){arr_rVdmxxY[ZcCPNjp]=member.maxMeshWorkGroupSize[ZcCPNjp];}();
        }
        }();
auto& maxMeshSharedMemorySize_json=json["maxMeshSharedMemorySize"];
[&](){maxMeshSharedMemorySize_json=member.maxMeshSharedMemorySize;}();
auto& maxMeshPayloadAndSharedMemorySize_json=json["maxMeshPayloadAndSharedMemorySize"];
[&](){maxMeshPayloadAndSharedMemorySize_json=member.maxMeshPayloadAndSharedMemorySize;}();
auto& maxMeshOutputMemorySize_json=json["maxMeshOutputMemorySize"];
[&](){maxMeshOutputMemorySize_json=member.maxMeshOutputMemorySize;}();
auto& maxMeshPayloadAndOutputMemorySize_json=json["maxMeshPayloadAndOutputMemorySize"];
[&](){maxMeshPayloadAndOutputMemorySize_json=member.maxMeshPayloadAndOutputMemorySize;}();
auto& maxMeshOutputComponents_json=json["maxMeshOutputComponents"];
[&](){maxMeshOutputComponents_json=member.maxMeshOutputComponents;}();
auto& maxMeshOutputVertices_json=json["maxMeshOutputVertices"];
[&](){maxMeshOutputVertices_json=member.maxMeshOutputVertices;}();
auto& maxMeshOutputPrimitives_json=json["maxMeshOutputPrimitives"];
[&](){maxMeshOutputPrimitives_json=member.maxMeshOutputPrimitives;}();
auto& maxMeshOutputLayers_json=json["maxMeshOutputLayers"];
[&](){maxMeshOutputLayers_json=member.maxMeshOutputLayers;}();
auto& maxMeshMultiviewViewCount_json=json["maxMeshMultiviewViewCount"];
[&](){maxMeshMultiviewViewCount_json=member.maxMeshMultiviewViewCount;}();
auto& meshOutputPerVertexGranularity_json=json["meshOutputPerVertexGranularity"];
[&](){meshOutputPerVertexGranularity_json=member.meshOutputPerVertexGranularity;}();
auto& meshOutputPerPrimitiveGranularity_json=json["meshOutputPerPrimitiveGranularity"];
[&](){meshOutputPerPrimitiveGranularity_json=member.meshOutputPerPrimitiveGranularity;}();
auto& maxPreferredTaskWorkGroupInvocations_json=json["maxPreferredTaskWorkGroupInvocations"];
[&](){maxPreferredTaskWorkGroupInvocations_json=member.maxPreferredTaskWorkGroupInvocations;}();
auto& maxPreferredMeshWorkGroupInvocations_json=json["maxPreferredMeshWorkGroupInvocations"];
[&](){maxPreferredMeshWorkGroupInvocations_json=member.maxPreferredMeshWorkGroupInvocations;}();
auto& prefersLocalInvocationVertexOutput_json=json["prefersLocalInvocationVertexOutput"];
[&](){[&](){prefersLocalInvocationVertexOutput_json=member.prefersLocalInvocationVertexOutput;}();}();
auto& prefersLocalInvocationPrimitiveOutput_json=json["prefersLocalInvocationPrimitiveOutput"];
[&](){[&](){prefersLocalInvocationPrimitiveOutput_json=member.prefersLocalInvocationPrimitiveOutput;}();}();
auto& prefersCompactVertexOutput_json=json["prefersCompactVertexOutput"];
[&](){[&](){prefersCompactVertexOutput_json=member.prefersCompactVertexOutput;}();}();
auto& prefersCompactPrimitiveOutput_json=json["prefersCompactPrimitiveOutput"];
[&](){[&](){prefersCompactPrimitiveOutput_json=member.prefersCompactPrimitiveOutput;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMeshShaderPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxTaskWorkGroupTotalCount_json=json["maxTaskWorkGroupTotalCount"];
[&](){member.maxTaskWorkGroupTotalCount=static_cast<uint32_t>(value_to<int>(maxTaskWorkGroupTotalCount_json));}();
auto& maxTaskWorkGroupCount_json=json["maxTaskWorkGroupCount"];
[&](){
        auto& arr_hvbtrfl=maxTaskWorkGroupCount_json.as_array();
        for(int xeUWuzJ=0; xeUWuzJ < 3; xeUWuzJ++){
            [&](){member.maxTaskWorkGroupCount[xeUWuzJ]=static_cast<uint32_t>(value_to<int>(arr_hvbtrfl[xeUWuzJ]));}();
        }
        }();
auto& maxTaskWorkGroupInvocations_json=json["maxTaskWorkGroupInvocations"];
[&](){member.maxTaskWorkGroupInvocations=static_cast<uint32_t>(value_to<int>(maxTaskWorkGroupInvocations_json));}();
auto& maxTaskWorkGroupSize_json=json["maxTaskWorkGroupSize"];
[&](){
        auto& arr_soXfkeA=maxTaskWorkGroupSize_json.as_array();
        for(int hJJLhFo=0; hJJLhFo < 3; hJJLhFo++){
            [&](){member.maxTaskWorkGroupSize[hJJLhFo]=static_cast<uint32_t>(value_to<int>(arr_soXfkeA[hJJLhFo]));}();
        }
        }();
auto& maxTaskPayloadSize_json=json["maxTaskPayloadSize"];
[&](){member.maxTaskPayloadSize=static_cast<uint32_t>(value_to<int>(maxTaskPayloadSize_json));}();
auto& maxTaskSharedMemorySize_json=json["maxTaskSharedMemorySize"];
[&](){member.maxTaskSharedMemorySize=static_cast<uint32_t>(value_to<int>(maxTaskSharedMemorySize_json));}();
auto& maxTaskPayloadAndSharedMemorySize_json=json["maxTaskPayloadAndSharedMemorySize"];
[&](){member.maxTaskPayloadAndSharedMemorySize=static_cast<uint32_t>(value_to<int>(maxTaskPayloadAndSharedMemorySize_json));}();
auto& maxMeshWorkGroupTotalCount_json=json["maxMeshWorkGroupTotalCount"];
[&](){member.maxMeshWorkGroupTotalCount=static_cast<uint32_t>(value_to<int>(maxMeshWorkGroupTotalCount_json));}();
auto& maxMeshWorkGroupCount_json=json["maxMeshWorkGroupCount"];
[&](){
        auto& arr_zCqVtXx=maxMeshWorkGroupCount_json.as_array();
        for(int kwoJakk=0; kwoJakk < 3; kwoJakk++){
            [&](){member.maxMeshWorkGroupCount[kwoJakk]=static_cast<uint32_t>(value_to<int>(arr_zCqVtXx[kwoJakk]));}();
        }
        }();
auto& maxMeshWorkGroupInvocations_json=json["maxMeshWorkGroupInvocations"];
[&](){member.maxMeshWorkGroupInvocations=static_cast<uint32_t>(value_to<int>(maxMeshWorkGroupInvocations_json));}();
auto& maxMeshWorkGroupSize_json=json["maxMeshWorkGroupSize"];
[&](){
        auto& arr_rVdmxxY=maxMeshWorkGroupSize_json.as_array();
        for(int ZcCPNjp=0; ZcCPNjp < 3; ZcCPNjp++){
            [&](){member.maxMeshWorkGroupSize[ZcCPNjp]=static_cast<uint32_t>(value_to<int>(arr_rVdmxxY[ZcCPNjp]));}();
        }
        }();
auto& maxMeshSharedMemorySize_json=json["maxMeshSharedMemorySize"];
[&](){member.maxMeshSharedMemorySize=static_cast<uint32_t>(value_to<int>(maxMeshSharedMemorySize_json));}();
auto& maxMeshPayloadAndSharedMemorySize_json=json["maxMeshPayloadAndSharedMemorySize"];
[&](){member.maxMeshPayloadAndSharedMemorySize=static_cast<uint32_t>(value_to<int>(maxMeshPayloadAndSharedMemorySize_json));}();
auto& maxMeshOutputMemorySize_json=json["maxMeshOutputMemorySize"];
[&](){member.maxMeshOutputMemorySize=static_cast<uint32_t>(value_to<int>(maxMeshOutputMemorySize_json));}();
auto& maxMeshPayloadAndOutputMemorySize_json=json["maxMeshPayloadAndOutputMemorySize"];
[&](){member.maxMeshPayloadAndOutputMemorySize=static_cast<uint32_t>(value_to<int>(maxMeshPayloadAndOutputMemorySize_json));}();
auto& maxMeshOutputComponents_json=json["maxMeshOutputComponents"];
[&](){member.maxMeshOutputComponents=static_cast<uint32_t>(value_to<int>(maxMeshOutputComponents_json));}();
auto& maxMeshOutputVertices_json=json["maxMeshOutputVertices"];
[&](){member.maxMeshOutputVertices=static_cast<uint32_t>(value_to<int>(maxMeshOutputVertices_json));}();
auto& maxMeshOutputPrimitives_json=json["maxMeshOutputPrimitives"];
[&](){member.maxMeshOutputPrimitives=static_cast<uint32_t>(value_to<int>(maxMeshOutputPrimitives_json));}();
auto& maxMeshOutputLayers_json=json["maxMeshOutputLayers"];
[&](){member.maxMeshOutputLayers=static_cast<uint32_t>(value_to<int>(maxMeshOutputLayers_json));}();
auto& maxMeshMultiviewViewCount_json=json["maxMeshMultiviewViewCount"];
[&](){member.maxMeshMultiviewViewCount=static_cast<uint32_t>(value_to<int>(maxMeshMultiviewViewCount_json));}();
auto& meshOutputPerVertexGranularity_json=json["meshOutputPerVertexGranularity"];
[&](){member.meshOutputPerVertexGranularity=static_cast<uint32_t>(value_to<int>(meshOutputPerVertexGranularity_json));}();
auto& meshOutputPerPrimitiveGranularity_json=json["meshOutputPerPrimitiveGranularity"];
[&](){member.meshOutputPerPrimitiveGranularity=static_cast<uint32_t>(value_to<int>(meshOutputPerPrimitiveGranularity_json));}();
auto& maxPreferredTaskWorkGroupInvocations_json=json["maxPreferredTaskWorkGroupInvocations"];
[&](){member.maxPreferredTaskWorkGroupInvocations=static_cast<uint32_t>(value_to<int>(maxPreferredTaskWorkGroupInvocations_json));}();
auto& maxPreferredMeshWorkGroupInvocations_json=json["maxPreferredMeshWorkGroupInvocations"];
[&](){member.maxPreferredMeshWorkGroupInvocations=static_cast<uint32_t>(value_to<int>(maxPreferredMeshWorkGroupInvocations_json));}();
auto& prefersLocalInvocationVertexOutput_json=json["prefersLocalInvocationVertexOutput"];
[&](){uint32_t temp_HEEfScr;[&](){temp_HEEfScr=static_cast<uint32_t>(value_to<int>(prefersLocalInvocationVertexOutput_json));}();member.prefersLocalInvocationVertexOutput=(VkBool32)temp_HEEfScr;}();
auto& prefersLocalInvocationPrimitiveOutput_json=json["prefersLocalInvocationPrimitiveOutput"];
[&](){uint32_t temp_kgfNvOM;[&](){temp_kgfNvOM=static_cast<uint32_t>(value_to<int>(prefersLocalInvocationPrimitiveOutput_json));}();member.prefersLocalInvocationPrimitiveOutput=(VkBool32)temp_kgfNvOM;}();
auto& prefersCompactVertexOutput_json=json["prefersCompactVertexOutput"];
[&](){uint32_t temp_MvuSirH;[&](){temp_MvuSirH=static_cast<uint32_t>(value_to<int>(prefersCompactVertexOutput_json));}();member.prefersCompactVertexOutput=(VkBool32)temp_MvuSirH;}();
auto& prefersCompactPrimitiveOutput_json=json["prefersCompactPrimitiveOutput"];
[&](){uint32_t temp_BvFozvb;[&](){temp_BvFozvb=static_cast<uint32_t>(value_to<int>(prefersCompactPrimitiveOutput_json));}();member.prefersCompactPrimitiveOutput=(VkBool32)temp_BvFozvb;}();
}

    void serialize_struct(boost::json::object& json, const VkDrawMeshTasksIndirectCommandEXT& member){
        
    
auto& groupCountX_json=json["groupCountX"];
[&](){groupCountX_json=member.groupCountX;}();
auto& groupCountY_json=json["groupCountY"];
[&](){groupCountY_json=member.groupCountY;}();
auto& groupCountZ_json=json["groupCountZ"];
[&](){groupCountZ_json=member.groupCountZ;}();
}
void deserialize_struct(boost::json::object& json, VkDrawMeshTasksIndirectCommandEXT& member){
auto& groupCountX_json=json["groupCountX"];
[&](){member.groupCountX=static_cast<uint32_t>(value_to<int>(groupCountX_json));}();
auto& groupCountY_json=json["groupCountY"];
[&](){member.groupCountY=static_cast<uint32_t>(value_to<int>(groupCountY_json));}();
auto& groupCountZ_json=json["groupCountZ"];
[&](){member.groupCountZ=static_cast<uint32_t>(value_to<int>(groupCountZ_json));}();
}

    void serialize_struct(boost::json::object& json, const VkRayTracingShaderGroupCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& generalShader_json=json["generalShader"];
[&](){generalShader_json=member.generalShader;}();
auto& closestHitShader_json=json["closestHitShader"];
[&](){closestHitShader_json=member.closestHitShader;}();
auto& anyHitShader_json=json["anyHitShader"];
[&](){anyHitShader_json=member.anyHitShader;}();
auto& intersectionShader_json=json["intersectionShader"];
[&](){intersectionShader_json=member.intersectionShader;}();
}
void deserialize_struct(boost::json::object& json, VkRayTracingShaderGroupCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& type_json=json["type"];
[&](){[&](){int temp_UXlMKGf;[&](){temp_UXlMKGf=static_cast<int>(value_to<int>(type_json));}();member.type=(VkRayTracingShaderGroupTypeKHR)temp_UXlMKGf;}();}();
auto& generalShader_json=json["generalShader"];
[&](){member.generalShader=static_cast<uint32_t>(value_to<int>(generalShader_json));}();
auto& closestHitShader_json=json["closestHitShader"];
[&](){member.closestHitShader=static_cast<uint32_t>(value_to<int>(closestHitShader_json));}();
auto& anyHitShader_json=json["anyHitShader"];
[&](){member.anyHitShader=static_cast<uint32_t>(value_to<int>(anyHitShader_json));}();
auto& intersectionShader_json=json["intersectionShader"];
[&](){member.intersectionShader=static_cast<uint32_t>(value_to<int>(intersectionShader_json));}();
}

    void serialize_struct(boost::json::object& json, const VkRayTracingShaderGroupCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& generalShader_json=json["generalShader"];
[&](){generalShader_json=member.generalShader;}();
auto& closestHitShader_json=json["closestHitShader"];
[&](){closestHitShader_json=member.closestHitShader;}();
auto& anyHitShader_json=json["anyHitShader"];
[&](){anyHitShader_json=member.anyHitShader;}();
auto& intersectionShader_json=json["intersectionShader"];
[&](){intersectionShader_json=member.intersectionShader;}();
auto& pShaderGroupCaptureReplayHandle_json=json["pShaderGroupCaptureReplayHandle"];
[&](){
            if (member.pShaderGroupCaptureReplayHandle==NULL){
                pShaderGroupCaptureReplayHandle_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pShaderGroupCaptureReplayHandle))==NULL){
                pShaderGroupCaptureReplayHandle_json=boost::json::array();
            return; }pShaderGroupCaptureReplayHandle_json=boost::json::array(strlen(((char*)(member.pShaderGroupCaptureReplayHandle)))+1);
        auto& arr_YQnRSSx=pShaderGroupCaptureReplayHandle_json.as_array();
        for(int HWueAJF=0; HWueAJF < strlen(((char*)(member.pShaderGroupCaptureReplayHandle)))+1; HWueAJF++){
            [&](){arr_YQnRSSx[HWueAJF]=((char*)(member.pShaderGroupCaptureReplayHandle))[HWueAJF];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkRayTracingShaderGroupCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& type_json=json["type"];
[&](){[&](){int temp_UXlMKGf;[&](){temp_UXlMKGf=static_cast<int>(value_to<int>(type_json));}();member.type=(VkRayTracingShaderGroupTypeKHR)temp_UXlMKGf;}();}();
auto& generalShader_json=json["generalShader"];
[&](){member.generalShader=static_cast<uint32_t>(value_to<int>(generalShader_json));}();
auto& closestHitShader_json=json["closestHitShader"];
[&](){member.closestHitShader=static_cast<uint32_t>(value_to<int>(closestHitShader_json));}();
auto& anyHitShader_json=json["anyHitShader"];
[&](){member.anyHitShader=static_cast<uint32_t>(value_to<int>(anyHitShader_json));}();
auto& intersectionShader_json=json["intersectionShader"];
[&](){member.intersectionShader=static_cast<uint32_t>(value_to<int>(intersectionShader_json));}();
auto& pShaderGroupCaptureReplayHandle_json=json["pShaderGroupCaptureReplayHandle"];
[&](){ void* temp_BCKEQOX;;[&](){
            if (pShaderGroupCaptureReplayHandle_json.as_array().size()==0){
                temp_BCKEQOX=NULL;
            return; }char* temp_FxNNGvm;[&](){
            if (pShaderGroupCaptureReplayHandle_json.as_array().size()==0){
                temp_FxNNGvm=NULL;
            return; }temp_FxNNGvm=(char*)malloc(pShaderGroupCaptureReplayHandle_json.as_array().size()*sizeof(char));
        auto& arr_RsdjemY=pShaderGroupCaptureReplayHandle_json.as_array();
        for(int vSGMexC=0; vSGMexC < pShaderGroupCaptureReplayHandle_json.as_array().size(); vSGMexC++){
            [&](){temp_FxNNGvm[vSGMexC]=static_cast<char>(value_to<int>(arr_RsdjemY[vSGMexC]));}();
        }
        }();temp_BCKEQOX=temp_FxNNGvm;}();member.pShaderGroupCaptureReplayHandle=temp_BCKEQOX;}();
}

    void serialize_struct(boost::json::object& json, const VkRayTracingPipelineCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& stageCount_json=json["stageCount"];
[&](){stageCount_json=member.stageCount;}();
auto& pStages_json=json["pStages"];
[&](){
            if (member.pStages==NULL){
                pStages_json=boost::json::array();
            return; }pStages_json=boost::json::array(member.stageCount);
        auto& arr_wJXHhmh=pStages_json.as_array();
        for(int AsBfcSb=0; AsBfcSb < member.stageCount; AsBfcSb++){
            [&](){
            auto& temp=arr_wJXHhmh[AsBfcSb].emplace_object();
            return serialize_struct(temp, member.pStages[AsBfcSb]);
            }();
        }
        }();
auto& groupCount_json=json["groupCount"];
[&](){groupCount_json=member.groupCount;}();
auto& pGroups_json=json["pGroups"];
[&](){
            if (member.pGroups==NULL){
                pGroups_json=boost::json::array();
            return; }pGroups_json=boost::json::array(member.groupCount);
        auto& arr_eKNKIQz=pGroups_json.as_array();
        for(int PHmNpfn=0; PHmNpfn < member.groupCount; PHmNpfn++){
            [&](){
            auto& temp=arr_eKNKIQz[PHmNpfn].emplace_object();
            return serialize_struct(temp, member.pGroups[PHmNpfn]);
            }();
        }
        }();
auto& maxRecursionDepth_json=json["maxRecursionDepth"];
[&](){maxRecursionDepth_json=member.maxRecursionDepth;}();
auto& layout_json=json["layout"];
[&](){serialize_VkPipelineLayout(layout_json,member.layout);}();
auto& basePipelineHandle_json=json["basePipelineHandle"];
[&](){serialize_VkPipeline(basePipelineHandle_json,member.basePipelineHandle);}();
auto& basePipelineIndex_json=json["basePipelineIndex"];
[&](){basePipelineIndex_json=member.basePipelineIndex;}();
}
void deserialize_struct(boost::json::object& json, VkRayTracingPipelineCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_evbgLuC;[&](){temp_evbgLuC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCreateFlags)temp_evbgLuC;}();}();
auto& stageCount_json=json["stageCount"];
[&](){member.stageCount=static_cast<uint32_t>(value_to<int>(stageCount_json));}();
auto& pStages_json=json["pStages"];
[&](){ VkPipelineShaderStageCreateInfo* temp_FhIAThL;;[&](){
            if (pStages_json.as_array().size()==0){
                temp_FhIAThL=NULL;
            return; }temp_FhIAThL=(VkPipelineShaderStageCreateInfo*)malloc(member.stageCount*sizeof(VkPipelineShaderStageCreateInfo));
        auto& arr_qUPPcsa=pStages_json.as_array();
        for(int jQYmLXQ=0; jQYmLXQ < member.stageCount; jQYmLXQ++){
            [&](){
            auto& temp=arr_qUPPcsa[jQYmLXQ].as_object();
            deserialize_struct(temp,temp_FhIAThL[jQYmLXQ]);
            }();
        }
        }();member.pStages=temp_FhIAThL;}();
auto& groupCount_json=json["groupCount"];
[&](){member.groupCount=static_cast<uint32_t>(value_to<int>(groupCount_json));}();
auto& pGroups_json=json["pGroups"];
[&](){ VkRayTracingShaderGroupCreateInfoNV* temp_CVNlmUz;;[&](){
            if (pGroups_json.as_array().size()==0){
                temp_CVNlmUz=NULL;
            return; }temp_CVNlmUz=(VkRayTracingShaderGroupCreateInfoNV*)malloc(member.groupCount*sizeof(VkRayTracingShaderGroupCreateInfoNV));
        auto& arr_VXhCAyf=pGroups_json.as_array();
        for(int xrNGIKE=0; xrNGIKE < member.groupCount; xrNGIKE++){
            [&](){
            auto& temp=arr_VXhCAyf[xrNGIKE].as_object();
            deserialize_struct(temp,temp_CVNlmUz[xrNGIKE]);
            }();
        }
        }();member.pGroups=temp_CVNlmUz;}();
auto& maxRecursionDepth_json=json["maxRecursionDepth"];
[&](){member.maxRecursionDepth=static_cast<uint32_t>(value_to<int>(maxRecursionDepth_json));}();
auto& layout_json=json["layout"];
[&](){deserialize_VkPipelineLayout(layout_json, member.layout);}();
auto& basePipelineHandle_json=json["basePipelineHandle"];
[&](){deserialize_VkPipeline(basePipelineHandle_json, member.basePipelineHandle);}();
auto& basePipelineIndex_json=json["basePipelineIndex"];
[&](){member.basePipelineIndex=static_cast<int32_t>(value_to<int>(basePipelineIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkRayTracingPipelineCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& stageCount_json=json["stageCount"];
[&](){stageCount_json=member.stageCount;}();
auto& pStages_json=json["pStages"];
[&](){
            if (member.pStages==NULL){
                pStages_json=boost::json::array();
            return; }pStages_json=boost::json::array(member.stageCount);
        auto& arr_wJXHhmh=pStages_json.as_array();
        for(int AsBfcSb=0; AsBfcSb < member.stageCount; AsBfcSb++){
            [&](){
            auto& temp=arr_wJXHhmh[AsBfcSb].emplace_object();
            return serialize_struct(temp, member.pStages[AsBfcSb]);
            }();
        }
        }();
auto& groupCount_json=json["groupCount"];
[&](){groupCount_json=member.groupCount;}();
auto& pGroups_json=json["pGroups"];
[&](){
            if (member.pGroups==NULL){
                pGroups_json=boost::json::array();
            return; }pGroups_json=boost::json::array(member.groupCount);
        auto& arr_dkKcDyE=pGroups_json.as_array();
        for(int PUlEUPD=0; PUlEUPD < member.groupCount; PUlEUPD++){
            [&](){
            auto& temp=arr_dkKcDyE[PUlEUPD].emplace_object();
            return serialize_struct(temp, member.pGroups[PUlEUPD]);
            }();
        }
        }();
auto& maxPipelineRayRecursionDepth_json=json["maxPipelineRayRecursionDepth"];
[&](){maxPipelineRayRecursionDepth_json=member.maxPipelineRayRecursionDepth;}();
auto& pLibraryInfo_json=json["pLibraryInfo"];
[&](){
            if (member.pLibraryInfo==NULL){
                pLibraryInfo_json=boost::json::array();
            return; }pLibraryInfo_json=boost::json::array(1);
        auto& arr_qbgGauk=pLibraryInfo_json.as_array();
        for(int cyEoVpU=0; cyEoVpU < 1; cyEoVpU++){
            [&](){
            auto& temp=arr_qbgGauk[cyEoVpU].emplace_object();
            return serialize_struct(temp, member.pLibraryInfo[cyEoVpU]);
            }();
        }
        }();
auto& pLibraryInterface_json=json["pLibraryInterface"];
[&](){
            if (member.pLibraryInterface==NULL){
                pLibraryInterface_json=boost::json::array();
            return; }pLibraryInterface_json=boost::json::array(1);
        auto& arr_eOoROKo=pLibraryInterface_json.as_array();
        for(int tjYViYt=0; tjYViYt < 1; tjYViYt++){
            [&](){
            auto& temp=arr_eOoROKo[tjYViYt].emplace_object();
            return serialize_struct(temp, member.pLibraryInterface[tjYViYt]);
            }();
        }
        }();
auto& pDynamicState_json=json["pDynamicState"];
[&](){
            if (member.pDynamicState==NULL){
                pDynamicState_json=boost::json::array();
            return; }pDynamicState_json=boost::json::array(1);
        auto& arr_iDMMizu=pDynamicState_json.as_array();
        for(int RNPowsf=0; RNPowsf < 1; RNPowsf++){
            [&](){
            auto& temp=arr_iDMMizu[RNPowsf].emplace_object();
            return serialize_struct(temp, member.pDynamicState[RNPowsf]);
            }();
        }
        }();
auto& layout_json=json["layout"];
[&](){serialize_VkPipelineLayout(layout_json,member.layout);}();
auto& basePipelineHandle_json=json["basePipelineHandle"];
[&](){serialize_VkPipeline(basePipelineHandle_json,member.basePipelineHandle);}();
auto& basePipelineIndex_json=json["basePipelineIndex"];
[&](){basePipelineIndex_json=member.basePipelineIndex;}();
}
void deserialize_struct(boost::json::object& json, VkRayTracingPipelineCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_evbgLuC;[&](){temp_evbgLuC=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCreateFlags)temp_evbgLuC;}();}();
auto& stageCount_json=json["stageCount"];
[&](){member.stageCount=static_cast<uint32_t>(value_to<int>(stageCount_json));}();
auto& pStages_json=json["pStages"];
[&](){ VkPipelineShaderStageCreateInfo* temp_FhIAThL;;[&](){
            if (pStages_json.as_array().size()==0){
                temp_FhIAThL=NULL;
            return; }temp_FhIAThL=(VkPipelineShaderStageCreateInfo*)malloc(member.stageCount*sizeof(VkPipelineShaderStageCreateInfo));
        auto& arr_qUPPcsa=pStages_json.as_array();
        for(int jQYmLXQ=0; jQYmLXQ < member.stageCount; jQYmLXQ++){
            [&](){
            auto& temp=arr_qUPPcsa[jQYmLXQ].as_object();
            deserialize_struct(temp,temp_FhIAThL[jQYmLXQ]);
            }();
        }
        }();member.pStages=temp_FhIAThL;}();
auto& groupCount_json=json["groupCount"];
[&](){member.groupCount=static_cast<uint32_t>(value_to<int>(groupCount_json));}();
auto& pGroups_json=json["pGroups"];
[&](){ VkRayTracingShaderGroupCreateInfoKHR* temp_omQWCZR;;[&](){
            if (pGroups_json.as_array().size()==0){
                temp_omQWCZR=NULL;
            return; }temp_omQWCZR=(VkRayTracingShaderGroupCreateInfoKHR*)malloc(member.groupCount*sizeof(VkRayTracingShaderGroupCreateInfoKHR));
        auto& arr_PRfImvP=pGroups_json.as_array();
        for(int ZkGEgNW=0; ZkGEgNW < member.groupCount; ZkGEgNW++){
            [&](){
            auto& temp=arr_PRfImvP[ZkGEgNW].as_object();
            deserialize_struct(temp,temp_omQWCZR[ZkGEgNW]);
            }();
        }
        }();member.pGroups=temp_omQWCZR;}();
auto& maxPipelineRayRecursionDepth_json=json["maxPipelineRayRecursionDepth"];
[&](){member.maxPipelineRayRecursionDepth=static_cast<uint32_t>(value_to<int>(maxPipelineRayRecursionDepth_json));}();
auto& pLibraryInfo_json=json["pLibraryInfo"];
[&](){ VkPipelineLibraryCreateInfoKHR* temp_aycyulO;;[&](){
            if (pLibraryInfo_json.as_array().size()==0){
                temp_aycyulO=NULL;
            return; }temp_aycyulO=(VkPipelineLibraryCreateInfoKHR*)malloc(1*sizeof(VkPipelineLibraryCreateInfoKHR));
        auto& arr_hkrNyvf=pLibraryInfo_json.as_array();
        for(int YtNkviw=0; YtNkviw < 1; YtNkviw++){
            [&](){
            auto& temp=arr_hkrNyvf[YtNkviw].as_object();
            deserialize_struct(temp,temp_aycyulO[YtNkviw]);
            }();
        }
        }();member.pLibraryInfo=temp_aycyulO;}();
auto& pLibraryInterface_json=json["pLibraryInterface"];
[&](){ VkRayTracingPipelineInterfaceCreateInfoKHR* temp_lSrcfiL;;[&](){
            if (pLibraryInterface_json.as_array().size()==0){
                temp_lSrcfiL=NULL;
            return; }temp_lSrcfiL=(VkRayTracingPipelineInterfaceCreateInfoKHR*)malloc(1*sizeof(VkRayTracingPipelineInterfaceCreateInfoKHR));
        auto& arr_DhwrUVb=pLibraryInterface_json.as_array();
        for(int rzPlyeO=0; rzPlyeO < 1; rzPlyeO++){
            [&](){
            auto& temp=arr_DhwrUVb[rzPlyeO].as_object();
            deserialize_struct(temp,temp_lSrcfiL[rzPlyeO]);
            }();
        }
        }();member.pLibraryInterface=temp_lSrcfiL;}();
auto& pDynamicState_json=json["pDynamicState"];
[&](){ VkPipelineDynamicStateCreateInfo* temp_xiTcGaw;;[&](){
            if (pDynamicState_json.as_array().size()==0){
                temp_xiTcGaw=NULL;
            return; }temp_xiTcGaw=(VkPipelineDynamicStateCreateInfo*)malloc(1*sizeof(VkPipelineDynamicStateCreateInfo));
        auto& arr_qGMmZys=pDynamicState_json.as_array();
        for(int kbWOyWu=0; kbWOyWu < 1; kbWOyWu++){
            [&](){
            auto& temp=arr_qGMmZys[kbWOyWu].as_object();
            deserialize_struct(temp,temp_xiTcGaw[kbWOyWu]);
            }();
        }
        }();member.pDynamicState=temp_xiTcGaw;}();
auto& layout_json=json["layout"];
[&](){deserialize_VkPipelineLayout(layout_json, member.layout);}();
auto& basePipelineHandle_json=json["basePipelineHandle"];
[&](){deserialize_VkPipeline(basePipelineHandle_json, member.basePipelineHandle);}();
auto& basePipelineIndex_json=json["basePipelineIndex"];
[&](){member.basePipelineIndex=static_cast<int32_t>(value_to<int>(basePipelineIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkGeometryTrianglesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& vertexData_json=json["vertexData"];
[&](){serialize_VkBuffer(vertexData_json,member.vertexData);}();
auto& vertexOffset_json=json["vertexOffset"];
[&](){[&](){vertexOffset_json=member.vertexOffset;}();}();
auto& vertexCount_json=json["vertexCount"];
[&](){vertexCount_json=member.vertexCount;}();
auto& vertexStride_json=json["vertexStride"];
[&](){[&](){vertexStride_json=member.vertexStride;}();}();
auto& vertexFormat_json=json["vertexFormat"];
[&](){[&](){[&](){vertexFormat_json=member.vertexFormat;}();}();}();
auto& indexData_json=json["indexData"];
[&](){serialize_VkBuffer(indexData_json,member.indexData);}();
auto& indexOffset_json=json["indexOffset"];
[&](){[&](){indexOffset_json=member.indexOffset;}();}();
auto& indexCount_json=json["indexCount"];
[&](){indexCount_json=member.indexCount;}();
auto& indexType_json=json["indexType"];
[&](){[&](){[&](){indexType_json=member.indexType;}();}();}();
auto& transformData_json=json["transformData"];
[&](){serialize_VkBuffer(transformData_json,member.transformData);}();
auto& transformOffset_json=json["transformOffset"];
[&](){[&](){transformOffset_json=member.transformOffset;}();}();
}
void deserialize_struct(boost::json::object& json, VkGeometryTrianglesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& vertexData_json=json["vertexData"];
[&](){deserialize_VkBuffer(vertexData_json, member.vertexData);}();
auto& vertexOffset_json=json["vertexOffset"];
[&](){uint64_t temp_QdKbPvX;[&](){temp_QdKbPvX=static_cast<uint64_t>(value_to<int>(vertexOffset_json));}();member.vertexOffset=(VkDeviceSize)temp_QdKbPvX;}();
auto& vertexCount_json=json["vertexCount"];
[&](){member.vertexCount=static_cast<uint32_t>(value_to<int>(vertexCount_json));}();
auto& vertexStride_json=json["vertexStride"];
[&](){uint64_t temp_NJLcxGv;[&](){temp_NJLcxGv=static_cast<uint64_t>(value_to<int>(vertexStride_json));}();member.vertexStride=(VkDeviceSize)temp_NJLcxGv;}();
auto& vertexFormat_json=json["vertexFormat"];
[&](){[&](){int temp_kPQLYRr;[&](){temp_kPQLYRr=static_cast<int>(value_to<int>(vertexFormat_json));}();member.vertexFormat=(VkFormat)temp_kPQLYRr;}();}();
auto& indexData_json=json["indexData"];
[&](){deserialize_VkBuffer(indexData_json, member.indexData);}();
auto& indexOffset_json=json["indexOffset"];
[&](){uint64_t temp_fErBroC;[&](){temp_fErBroC=static_cast<uint64_t>(value_to<int>(indexOffset_json));}();member.indexOffset=(VkDeviceSize)temp_fErBroC;}();
auto& indexCount_json=json["indexCount"];
[&](){member.indexCount=static_cast<uint32_t>(value_to<int>(indexCount_json));}();
auto& indexType_json=json["indexType"];
[&](){[&](){int temp_sCUtzFY;[&](){temp_sCUtzFY=static_cast<int>(value_to<int>(indexType_json));}();member.indexType=(VkIndexType)temp_sCUtzFY;}();}();
auto& transformData_json=json["transformData"];
[&](){deserialize_VkBuffer(transformData_json, member.transformData);}();
auto& transformOffset_json=json["transformOffset"];
[&](){uint64_t temp_WmNXuxn;[&](){temp_WmNXuxn=static_cast<uint64_t>(value_to<int>(transformOffset_json));}();member.transformOffset=(VkDeviceSize)temp_WmNXuxn;}();
}

    void serialize_struct(boost::json::object& json, const VkGeometryAABBNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& aabbData_json=json["aabbData"];
[&](){serialize_VkBuffer(aabbData_json,member.aabbData);}();
auto& numAABBs_json=json["numAABBs"];
[&](){numAABBs_json=member.numAABBs;}();
auto& stride_json=json["stride"];
[&](){stride_json=member.stride;}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
}
void deserialize_struct(boost::json::object& json, VkGeometryAABBNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& aabbData_json=json["aabbData"];
[&](){deserialize_VkBuffer(aabbData_json, member.aabbData);}();
auto& numAABBs_json=json["numAABBs"];
[&](){member.numAABBs=static_cast<uint32_t>(value_to<int>(numAABBs_json));}();
auto& stride_json=json["stride"];
[&](){member.stride=static_cast<uint32_t>(value_to<int>(stride_json));}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
}

    void serialize_struct(boost::json::object& json, const VkGeometryDataNV& member){
        
    
auto& triangles_json=json["triangles"];
[&](){
            auto& temp=triangles_json.emplace_object();
            return serialize_struct(temp, member.triangles);
            }();
auto& aabbs_json=json["aabbs"];
[&](){
            auto& temp=aabbs_json.emplace_object();
            return serialize_struct(temp, member.aabbs);
            }();
}
void deserialize_struct(boost::json::object& json, VkGeometryDataNV& member){
auto& triangles_json=json["triangles"];
[&](){
            auto& temp=triangles_json.as_object();
            deserialize_struct(temp,member.triangles);
            }();
auto& aabbs_json=json["aabbs"];
[&](){
            auto& temp=aabbs_json.as_object();
            deserialize_struct(temp,member.aabbs);
            }();
}

    void serialize_struct(boost::json::object& json, const VkGeometryNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& geometryType_json=json["geometryType"];
[&](){[&](){[&](){geometryType_json=member.geometryType;}();}();}();
auto& geometry_json=json["geometry"];
[&](){
            auto& temp=geometry_json.emplace_object();
            return serialize_struct(temp, member.geometry);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkGeometryNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& geometryType_json=json["geometryType"];
[&](){[&](){int temp_fDjxHTD;[&](){temp_fDjxHTD=static_cast<int>(value_to<int>(geometryType_json));}();member.geometryType=(VkGeometryTypeKHR)temp_fDjxHTD;}();}();
auto& geometry_json=json["geometry"];
[&](){
            auto& temp=geometry_json.as_object();
            deserialize_struct(temp,member.geometry);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_qsfLWQJ;[&](){temp_qsfLWQJ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkGeometryFlagsKHR)temp_qsfLWQJ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& instanceCount_json=json["instanceCount"];
[&](){instanceCount_json=member.instanceCount;}();
auto& geometryCount_json=json["geometryCount"];
[&](){geometryCount_json=member.geometryCount;}();
auto& pGeometries_json=json["pGeometries"];
[&](){
            if (member.pGeometries==NULL){
                pGeometries_json=boost::json::array();
            return; }pGeometries_json=boost::json::array(member.geometryCount);
        auto& arr_vgMFzCl=pGeometries_json.as_array();
        for(int NWQDElF=0; NWQDElF < member.geometryCount; NWQDElF++){
            [&](){
            auto& temp=arr_vgMFzCl[NWQDElF].emplace_object();
            return serialize_struct(temp, member.pGeometries[NWQDElF]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& type_json=json["type"];
[&](){[&](){int temp_rTUZxGQ;[&](){temp_rTUZxGQ=static_cast<int>(value_to<int>(type_json));}();member.type=(VkAccelerationStructureTypeNV)temp_rTUZxGQ;}();}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_tHhrSeQ;[&](){temp_tHhrSeQ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkBuildAccelerationStructureFlagsNV)temp_tHhrSeQ;}();}();
auto& instanceCount_json=json["instanceCount"];
[&](){member.instanceCount=static_cast<uint32_t>(value_to<int>(instanceCount_json));}();
auto& geometryCount_json=json["geometryCount"];
[&](){member.geometryCount=static_cast<uint32_t>(value_to<int>(geometryCount_json));}();
auto& pGeometries_json=json["pGeometries"];
[&](){ VkGeometryNV* temp_kEaSYlY;;[&](){
            if (pGeometries_json.as_array().size()==0){
                temp_kEaSYlY=NULL;
            return; }temp_kEaSYlY=(VkGeometryNV*)malloc(member.geometryCount*sizeof(VkGeometryNV));
        auto& arr_AGRSWuZ=pGeometries_json.as_array();
        for(int pKlYKaP=0; pKlYKaP < member.geometryCount; pKlYKaP++){
            [&](){
            auto& temp=arr_AGRSWuZ[pKlYKaP].as_object();
            deserialize_struct(temp,temp_kEaSYlY[pKlYKaP]);
            }();
        }
        }();member.pGeometries=temp_kEaSYlY;}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& compactedSize_json=json["compactedSize"];
[&](){[&](){compactedSize_json=member.compactedSize;}();}();
auto& info_json=json["info"];
[&](){
            auto& temp=info_json.emplace_object();
            return serialize_struct(temp, member.info);
            }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& compactedSize_json=json["compactedSize"];
[&](){uint64_t temp_tlpuiMW;[&](){temp_tlpuiMW=static_cast<uint64_t>(value_to<int>(compactedSize_json));}();member.compactedSize=(VkDeviceSize)temp_tlpuiMW;}();
auto& info_json=json["info"];
[&](){
            auto& temp=info_json.as_object();
            deserialize_struct(temp,member.info);
            }();
}

    void serialize_struct(boost::json::object& json, const VkBindAccelerationStructureMemoryInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){serialize_VkAccelerationStructureNV(accelerationStructure_json,member.accelerationStructure);}();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){[&](){memoryOffset_json=member.memoryOffset;}();}();
auto& deviceIndexCount_json=json["deviceIndexCount"];
[&](){deviceIndexCount_json=member.deviceIndexCount;}();
auto& pDeviceIndices_json=json["pDeviceIndices"];
[&](){
            if (member.pDeviceIndices==NULL){
                pDeviceIndices_json=boost::json::array();
            return; }pDeviceIndices_json=boost::json::array(member.deviceIndexCount);
        auto& arr_ljPbTMN=pDeviceIndices_json.as_array();
        for(int MmIaHqo=0; MmIaHqo < member.deviceIndexCount; MmIaHqo++){
            [&](){arr_ljPbTMN[MmIaHqo]=member.pDeviceIndices[MmIaHqo];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkBindAccelerationStructureMemoryInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){deserialize_VkAccelerationStructureNV(accelerationStructure_json, member.accelerationStructure);}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){uint64_t temp_VWSGqtD;[&](){temp_VWSGqtD=static_cast<uint64_t>(value_to<int>(memoryOffset_json));}();member.memoryOffset=(VkDeviceSize)temp_VWSGqtD;}();
auto& deviceIndexCount_json=json["deviceIndexCount"];
[&](){member.deviceIndexCount=static_cast<uint32_t>(value_to<int>(deviceIndexCount_json));}();
auto& pDeviceIndices_json=json["pDeviceIndices"];
[&](){ uint32_t* temp_RfExfNJ;;[&](){
            if (pDeviceIndices_json.as_array().size()==0){
                temp_RfExfNJ=NULL;
            return; }temp_RfExfNJ=(uint32_t*)malloc(member.deviceIndexCount*sizeof(uint32_t));
        auto& arr_QDynsLg=pDeviceIndices_json.as_array();
        for(int YTdkCPI=0; YTdkCPI < member.deviceIndexCount; YTdkCPI++){
            [&](){temp_RfExfNJ[YTdkCPI]=static_cast<uint32_t>(value_to<int>(arr_QDynsLg[YTdkCPI]));}();
        }
        }();member.pDeviceIndices=temp_RfExfNJ;}();
}

    void serialize_struct(boost::json::object& json, const VkWriteDescriptorSetAccelerationStructureKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& accelerationStructureCount_json=json["accelerationStructureCount"];
[&](){accelerationStructureCount_json=member.accelerationStructureCount;}();
auto& pAccelerationStructures_json=json["pAccelerationStructures"];
[&](){
            if (member.pAccelerationStructures==NULL){
                pAccelerationStructures_json=boost::json::array();
            return; }pAccelerationStructures_json=boost::json::array(member.accelerationStructureCount);
        auto& arr_uHQjQvO=pAccelerationStructures_json.as_array();
        for(int iPAgAKv=0; iPAgAKv < member.accelerationStructureCount; iPAgAKv++){
            [&](){serialize_VkAccelerationStructureKHR(arr_uHQjQvO[iPAgAKv],member.pAccelerationStructures[iPAgAKv]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkWriteDescriptorSetAccelerationStructureKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& accelerationStructureCount_json=json["accelerationStructureCount"];
[&](){member.accelerationStructureCount=static_cast<uint32_t>(value_to<int>(accelerationStructureCount_json));}();
auto& pAccelerationStructures_json=json["pAccelerationStructures"];
[&](){ VkAccelerationStructureKHR* temp_HFqwzSr;;[&](){
            if (pAccelerationStructures_json.as_array().size()==0){
                temp_HFqwzSr=NULL;
            return; }temp_HFqwzSr=(VkAccelerationStructureKHR*)malloc(member.accelerationStructureCount*sizeof(VkAccelerationStructureKHR));
        auto& arr_MRpGGhr=pAccelerationStructures_json.as_array();
        for(int XOtxByx=0; XOtxByx < member.accelerationStructureCount; XOtxByx++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_MRpGGhr[XOtxByx], temp_HFqwzSr[XOtxByx]);}();
        }
        }();member.pAccelerationStructures=temp_HFqwzSr;}();
}

    void serialize_struct(boost::json::object& json, const VkWriteDescriptorSetAccelerationStructureNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& accelerationStructureCount_json=json["accelerationStructureCount"];
[&](){accelerationStructureCount_json=member.accelerationStructureCount;}();
auto& pAccelerationStructures_json=json["pAccelerationStructures"];
[&](){
            if (member.pAccelerationStructures==NULL){
                pAccelerationStructures_json=boost::json::array();
            return; }pAccelerationStructures_json=boost::json::array(member.accelerationStructureCount);
        auto& arr_HXpgyAy=pAccelerationStructures_json.as_array();
        for(int FlujVVM=0; FlujVVM < member.accelerationStructureCount; FlujVVM++){
            [&](){serialize_VkAccelerationStructureNV(arr_HXpgyAy[FlujVVM],member.pAccelerationStructures[FlujVVM]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkWriteDescriptorSetAccelerationStructureNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& accelerationStructureCount_json=json["accelerationStructureCount"];
[&](){member.accelerationStructureCount=static_cast<uint32_t>(value_to<int>(accelerationStructureCount_json));}();
auto& pAccelerationStructures_json=json["pAccelerationStructures"];
[&](){ VkAccelerationStructureNV* temp_UPiSSsI;;[&](){
            if (pAccelerationStructures_json.as_array().size()==0){
                temp_UPiSSsI=NULL;
            return; }temp_UPiSSsI=(VkAccelerationStructureNV*)malloc(member.accelerationStructureCount*sizeof(VkAccelerationStructureNV));
        auto& arr_jkmfxUC=pAccelerationStructures_json.as_array();
        for(int rAXFBqW=0; rAXFBqW < member.accelerationStructureCount; rAXFBqW++){
            [&](){deserialize_VkAccelerationStructureNV(arr_jkmfxUC[rAXFBqW], temp_UPiSSsI[rAXFBqW]);}();
        }
        }();member.pAccelerationStructures=temp_UPiSSsI;}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureMemoryRequirementsInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){serialize_VkAccelerationStructureNV(accelerationStructure_json,member.accelerationStructure);}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureMemoryRequirementsInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& type_json=json["type"];
[&](){[&](){int temp_KUvsPAc;[&](){temp_KUvsPAc=static_cast<int>(value_to<int>(type_json));}();member.type=(VkAccelerationStructureMemoryRequirementsTypeNV)temp_KUvsPAc;}();}();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){deserialize_VkAccelerationStructureNV(accelerationStructure_json, member.accelerationStructure);}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceAccelerationStructureFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){[&](){accelerationStructure_json=member.accelerationStructure;}();}();
auto& accelerationStructureCaptureReplay_json=json["accelerationStructureCaptureReplay"];
[&](){[&](){accelerationStructureCaptureReplay_json=member.accelerationStructureCaptureReplay;}();}();
auto& accelerationStructureIndirectBuild_json=json["accelerationStructureIndirectBuild"];
[&](){[&](){accelerationStructureIndirectBuild_json=member.accelerationStructureIndirectBuild;}();}();
auto& accelerationStructureHostCommands_json=json["accelerationStructureHostCommands"];
[&](){[&](){accelerationStructureHostCommands_json=member.accelerationStructureHostCommands;}();}();
auto& descriptorBindingAccelerationStructureUpdateAfterBind_json=json["descriptorBindingAccelerationStructureUpdateAfterBind"];
[&](){[&](){descriptorBindingAccelerationStructureUpdateAfterBind_json=member.descriptorBindingAccelerationStructureUpdateAfterBind;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceAccelerationStructureFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){uint32_t temp_OidOqhC;[&](){temp_OidOqhC=static_cast<uint32_t>(value_to<int>(accelerationStructure_json));}();member.accelerationStructure=(VkBool32)temp_OidOqhC;}();
auto& accelerationStructureCaptureReplay_json=json["accelerationStructureCaptureReplay"];
[&](){uint32_t temp_QQhntMO;[&](){temp_QQhntMO=static_cast<uint32_t>(value_to<int>(accelerationStructureCaptureReplay_json));}();member.accelerationStructureCaptureReplay=(VkBool32)temp_QQhntMO;}();
auto& accelerationStructureIndirectBuild_json=json["accelerationStructureIndirectBuild"];
[&](){uint32_t temp_KVpnXtc;[&](){temp_KVpnXtc=static_cast<uint32_t>(value_to<int>(accelerationStructureIndirectBuild_json));}();member.accelerationStructureIndirectBuild=(VkBool32)temp_KVpnXtc;}();
auto& accelerationStructureHostCommands_json=json["accelerationStructureHostCommands"];
[&](){uint32_t temp_VnVKhXS;[&](){temp_VnVKhXS=static_cast<uint32_t>(value_to<int>(accelerationStructureHostCommands_json));}();member.accelerationStructureHostCommands=(VkBool32)temp_VnVKhXS;}();
auto& descriptorBindingAccelerationStructureUpdateAfterBind_json=json["descriptorBindingAccelerationStructureUpdateAfterBind"];
[&](){uint32_t temp_AuKKZFf;[&](){temp_AuKKZFf=static_cast<uint32_t>(value_to<int>(descriptorBindingAccelerationStructureUpdateAfterBind_json));}();member.descriptorBindingAccelerationStructureUpdateAfterBind=(VkBool32)temp_AuKKZFf;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRayTracingPipelineFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rayTracingPipeline_json=json["rayTracingPipeline"];
[&](){[&](){rayTracingPipeline_json=member.rayTracingPipeline;}();}();
auto& rayTracingPipelineShaderGroupHandleCaptureReplay_json=json["rayTracingPipelineShaderGroupHandleCaptureReplay"];
[&](){[&](){rayTracingPipelineShaderGroupHandleCaptureReplay_json=member.rayTracingPipelineShaderGroupHandleCaptureReplay;}();}();
auto& rayTracingPipelineShaderGroupHandleCaptureReplayMixed_json=json["rayTracingPipelineShaderGroupHandleCaptureReplayMixed"];
[&](){[&](){rayTracingPipelineShaderGroupHandleCaptureReplayMixed_json=member.rayTracingPipelineShaderGroupHandleCaptureReplayMixed;}();}();
auto& rayTracingPipelineTraceRaysIndirect_json=json["rayTracingPipelineTraceRaysIndirect"];
[&](){[&](){rayTracingPipelineTraceRaysIndirect_json=member.rayTracingPipelineTraceRaysIndirect;}();}();
auto& rayTraversalPrimitiveCulling_json=json["rayTraversalPrimitiveCulling"];
[&](){[&](){rayTraversalPrimitiveCulling_json=member.rayTraversalPrimitiveCulling;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRayTracingPipelineFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& rayTracingPipeline_json=json["rayTracingPipeline"];
[&](){uint32_t temp_lNaKPgi;[&](){temp_lNaKPgi=static_cast<uint32_t>(value_to<int>(rayTracingPipeline_json));}();member.rayTracingPipeline=(VkBool32)temp_lNaKPgi;}();
auto& rayTracingPipelineShaderGroupHandleCaptureReplay_json=json["rayTracingPipelineShaderGroupHandleCaptureReplay"];
[&](){uint32_t temp_rJquJRB;[&](){temp_rJquJRB=static_cast<uint32_t>(value_to<int>(rayTracingPipelineShaderGroupHandleCaptureReplay_json));}();member.rayTracingPipelineShaderGroupHandleCaptureReplay=(VkBool32)temp_rJquJRB;}();
auto& rayTracingPipelineShaderGroupHandleCaptureReplayMixed_json=json["rayTracingPipelineShaderGroupHandleCaptureReplayMixed"];
[&](){uint32_t temp_AkHCTFp;[&](){temp_AkHCTFp=static_cast<uint32_t>(value_to<int>(rayTracingPipelineShaderGroupHandleCaptureReplayMixed_json));}();member.rayTracingPipelineShaderGroupHandleCaptureReplayMixed=(VkBool32)temp_AkHCTFp;}();
auto& rayTracingPipelineTraceRaysIndirect_json=json["rayTracingPipelineTraceRaysIndirect"];
[&](){uint32_t temp_unRPhsw;[&](){temp_unRPhsw=static_cast<uint32_t>(value_to<int>(rayTracingPipelineTraceRaysIndirect_json));}();member.rayTracingPipelineTraceRaysIndirect=(VkBool32)temp_unRPhsw;}();
auto& rayTraversalPrimitiveCulling_json=json["rayTraversalPrimitiveCulling"];
[&](){uint32_t temp_FteWqaV;[&](){temp_FteWqaV=static_cast<uint32_t>(value_to<int>(rayTraversalPrimitiveCulling_json));}();member.rayTraversalPrimitiveCulling=(VkBool32)temp_FteWqaV;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRayQueryFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rayQuery_json=json["rayQuery"];
[&](){[&](){rayQuery_json=member.rayQuery;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRayQueryFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& rayQuery_json=json["rayQuery"];
[&](){uint32_t temp_xHOnNHq;[&](){temp_xHOnNHq=static_cast<uint32_t>(value_to<int>(rayQuery_json));}();member.rayQuery=(VkBool32)temp_xHOnNHq;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceAccelerationStructurePropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxGeometryCount_json=json["maxGeometryCount"];
[&](){maxGeometryCount_json=member.maxGeometryCount;}();
auto& maxInstanceCount_json=json["maxInstanceCount"];
[&](){maxInstanceCount_json=member.maxInstanceCount;}();
auto& maxPrimitiveCount_json=json["maxPrimitiveCount"];
[&](){maxPrimitiveCount_json=member.maxPrimitiveCount;}();
auto& maxPerStageDescriptorAccelerationStructures_json=json["maxPerStageDescriptorAccelerationStructures"];
[&](){maxPerStageDescriptorAccelerationStructures_json=member.maxPerStageDescriptorAccelerationStructures;}();
auto& maxPerStageDescriptorUpdateAfterBindAccelerationStructures_json=json["maxPerStageDescriptorUpdateAfterBindAccelerationStructures"];
[&](){maxPerStageDescriptorUpdateAfterBindAccelerationStructures_json=member.maxPerStageDescriptorUpdateAfterBindAccelerationStructures;}();
auto& maxDescriptorSetAccelerationStructures_json=json["maxDescriptorSetAccelerationStructures"];
[&](){maxDescriptorSetAccelerationStructures_json=member.maxDescriptorSetAccelerationStructures;}();
auto& maxDescriptorSetUpdateAfterBindAccelerationStructures_json=json["maxDescriptorSetUpdateAfterBindAccelerationStructures"];
[&](){maxDescriptorSetUpdateAfterBindAccelerationStructures_json=member.maxDescriptorSetUpdateAfterBindAccelerationStructures;}();
auto& minAccelerationStructureScratchOffsetAlignment_json=json["minAccelerationStructureScratchOffsetAlignment"];
[&](){minAccelerationStructureScratchOffsetAlignment_json=member.minAccelerationStructureScratchOffsetAlignment;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceAccelerationStructurePropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxGeometryCount_json=json["maxGeometryCount"];
[&](){member.maxGeometryCount=static_cast<uint64_t>(value_to<int>(maxGeometryCount_json));}();
auto& maxInstanceCount_json=json["maxInstanceCount"];
[&](){member.maxInstanceCount=static_cast<uint64_t>(value_to<int>(maxInstanceCount_json));}();
auto& maxPrimitiveCount_json=json["maxPrimitiveCount"];
[&](){member.maxPrimitiveCount=static_cast<uint64_t>(value_to<int>(maxPrimitiveCount_json));}();
auto& maxPerStageDescriptorAccelerationStructures_json=json["maxPerStageDescriptorAccelerationStructures"];
[&](){member.maxPerStageDescriptorAccelerationStructures=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorAccelerationStructures_json));}();
auto& maxPerStageDescriptorUpdateAfterBindAccelerationStructures_json=json["maxPerStageDescriptorUpdateAfterBindAccelerationStructures"];
[&](){member.maxPerStageDescriptorUpdateAfterBindAccelerationStructures=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindAccelerationStructures_json));}();
auto& maxDescriptorSetAccelerationStructures_json=json["maxDescriptorSetAccelerationStructures"];
[&](){member.maxDescriptorSetAccelerationStructures=static_cast<uint32_t>(value_to<int>(maxDescriptorSetAccelerationStructures_json));}();
auto& maxDescriptorSetUpdateAfterBindAccelerationStructures_json=json["maxDescriptorSetUpdateAfterBindAccelerationStructures"];
[&](){member.maxDescriptorSetUpdateAfterBindAccelerationStructures=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindAccelerationStructures_json));}();
auto& minAccelerationStructureScratchOffsetAlignment_json=json["minAccelerationStructureScratchOffsetAlignment"];
[&](){member.minAccelerationStructureScratchOffsetAlignment=static_cast<uint32_t>(value_to<int>(minAccelerationStructureScratchOffsetAlignment_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRayTracingPipelinePropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderGroupHandleSize_json=json["shaderGroupHandleSize"];
[&](){shaderGroupHandleSize_json=member.shaderGroupHandleSize;}();
auto& maxRayRecursionDepth_json=json["maxRayRecursionDepth"];
[&](){maxRayRecursionDepth_json=member.maxRayRecursionDepth;}();
auto& maxShaderGroupStride_json=json["maxShaderGroupStride"];
[&](){maxShaderGroupStride_json=member.maxShaderGroupStride;}();
auto& shaderGroupBaseAlignment_json=json["shaderGroupBaseAlignment"];
[&](){shaderGroupBaseAlignment_json=member.shaderGroupBaseAlignment;}();
auto& shaderGroupHandleCaptureReplaySize_json=json["shaderGroupHandleCaptureReplaySize"];
[&](){shaderGroupHandleCaptureReplaySize_json=member.shaderGroupHandleCaptureReplaySize;}();
auto& maxRayDispatchInvocationCount_json=json["maxRayDispatchInvocationCount"];
[&](){maxRayDispatchInvocationCount_json=member.maxRayDispatchInvocationCount;}();
auto& shaderGroupHandleAlignment_json=json["shaderGroupHandleAlignment"];
[&](){shaderGroupHandleAlignment_json=member.shaderGroupHandleAlignment;}();
auto& maxRayHitAttributeSize_json=json["maxRayHitAttributeSize"];
[&](){maxRayHitAttributeSize_json=member.maxRayHitAttributeSize;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRayTracingPipelinePropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderGroupHandleSize_json=json["shaderGroupHandleSize"];
[&](){member.shaderGroupHandleSize=static_cast<uint32_t>(value_to<int>(shaderGroupHandleSize_json));}();
auto& maxRayRecursionDepth_json=json["maxRayRecursionDepth"];
[&](){member.maxRayRecursionDepth=static_cast<uint32_t>(value_to<int>(maxRayRecursionDepth_json));}();
auto& maxShaderGroupStride_json=json["maxShaderGroupStride"];
[&](){member.maxShaderGroupStride=static_cast<uint32_t>(value_to<int>(maxShaderGroupStride_json));}();
auto& shaderGroupBaseAlignment_json=json["shaderGroupBaseAlignment"];
[&](){member.shaderGroupBaseAlignment=static_cast<uint32_t>(value_to<int>(shaderGroupBaseAlignment_json));}();
auto& shaderGroupHandleCaptureReplaySize_json=json["shaderGroupHandleCaptureReplaySize"];
[&](){member.shaderGroupHandleCaptureReplaySize=static_cast<uint32_t>(value_to<int>(shaderGroupHandleCaptureReplaySize_json));}();
auto& maxRayDispatchInvocationCount_json=json["maxRayDispatchInvocationCount"];
[&](){member.maxRayDispatchInvocationCount=static_cast<uint32_t>(value_to<int>(maxRayDispatchInvocationCount_json));}();
auto& shaderGroupHandleAlignment_json=json["shaderGroupHandleAlignment"];
[&](){member.shaderGroupHandleAlignment=static_cast<uint32_t>(value_to<int>(shaderGroupHandleAlignment_json));}();
auto& maxRayHitAttributeSize_json=json["maxRayHitAttributeSize"];
[&](){member.maxRayHitAttributeSize=static_cast<uint32_t>(value_to<int>(maxRayHitAttributeSize_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRayTracingPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderGroupHandleSize_json=json["shaderGroupHandleSize"];
[&](){shaderGroupHandleSize_json=member.shaderGroupHandleSize;}();
auto& maxRecursionDepth_json=json["maxRecursionDepth"];
[&](){maxRecursionDepth_json=member.maxRecursionDepth;}();
auto& maxShaderGroupStride_json=json["maxShaderGroupStride"];
[&](){maxShaderGroupStride_json=member.maxShaderGroupStride;}();
auto& shaderGroupBaseAlignment_json=json["shaderGroupBaseAlignment"];
[&](){shaderGroupBaseAlignment_json=member.shaderGroupBaseAlignment;}();
auto& maxGeometryCount_json=json["maxGeometryCount"];
[&](){maxGeometryCount_json=member.maxGeometryCount;}();
auto& maxInstanceCount_json=json["maxInstanceCount"];
[&](){maxInstanceCount_json=member.maxInstanceCount;}();
auto& maxTriangleCount_json=json["maxTriangleCount"];
[&](){maxTriangleCount_json=member.maxTriangleCount;}();
auto& maxDescriptorSetAccelerationStructures_json=json["maxDescriptorSetAccelerationStructures"];
[&](){maxDescriptorSetAccelerationStructures_json=member.maxDescriptorSetAccelerationStructures;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRayTracingPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderGroupHandleSize_json=json["shaderGroupHandleSize"];
[&](){member.shaderGroupHandleSize=static_cast<uint32_t>(value_to<int>(shaderGroupHandleSize_json));}();
auto& maxRecursionDepth_json=json["maxRecursionDepth"];
[&](){member.maxRecursionDepth=static_cast<uint32_t>(value_to<int>(maxRecursionDepth_json));}();
auto& maxShaderGroupStride_json=json["maxShaderGroupStride"];
[&](){member.maxShaderGroupStride=static_cast<uint32_t>(value_to<int>(maxShaderGroupStride_json));}();
auto& shaderGroupBaseAlignment_json=json["shaderGroupBaseAlignment"];
[&](){member.shaderGroupBaseAlignment=static_cast<uint32_t>(value_to<int>(shaderGroupBaseAlignment_json));}();
auto& maxGeometryCount_json=json["maxGeometryCount"];
[&](){member.maxGeometryCount=static_cast<uint64_t>(value_to<int>(maxGeometryCount_json));}();
auto& maxInstanceCount_json=json["maxInstanceCount"];
[&](){member.maxInstanceCount=static_cast<uint64_t>(value_to<int>(maxInstanceCount_json));}();
auto& maxTriangleCount_json=json["maxTriangleCount"];
[&](){member.maxTriangleCount=static_cast<uint64_t>(value_to<int>(maxTriangleCount_json));}();
auto& maxDescriptorSetAccelerationStructures_json=json["maxDescriptorSetAccelerationStructures"];
[&](){member.maxDescriptorSetAccelerationStructures=static_cast<uint32_t>(value_to<int>(maxDescriptorSetAccelerationStructures_json));}();
}

    void serialize_struct(boost::json::object& json, const VkStridedDeviceAddressRegionKHR& member){
        
    
auto& deviceAddress_json=json["deviceAddress"];
[&](){[&](){deviceAddress_json=member.deviceAddress;}();}();
auto& stride_json=json["stride"];
[&](){[&](){stride_json=member.stride;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkStridedDeviceAddressRegionKHR& member){
auto& deviceAddress_json=json["deviceAddress"];
[&](){uint64_t temp_JcebElc;[&](){temp_JcebElc=static_cast<uint64_t>(value_to<int>(deviceAddress_json));}();member.deviceAddress=(VkDeviceAddress)temp_JcebElc;}();
auto& stride_json=json["stride"];
[&](){uint64_t temp_TOKWKUv;[&](){temp_TOKWKUv=static_cast<uint64_t>(value_to<int>(stride_json));}();member.stride=(VkDeviceSize)temp_TOKWKUv;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkTraceRaysIndirectCommandKHR& member){
        
    
auto& width_json=json["width"];
[&](){width_json=member.width;}();
auto& height_json=json["height"];
[&](){height_json=member.height;}();
auto& depth_json=json["depth"];
[&](){depth_json=member.depth;}();
}
void deserialize_struct(boost::json::object& json, VkTraceRaysIndirectCommandKHR& member){
auto& width_json=json["width"];
[&](){member.width=static_cast<uint32_t>(value_to<int>(width_json));}();
auto& height_json=json["height"];
[&](){member.height=static_cast<uint32_t>(value_to<int>(height_json));}();
auto& depth_json=json["depth"];
[&](){member.depth=static_cast<uint32_t>(value_to<int>(depth_json));}();
}

    void serialize_struct(boost::json::object& json, const VkTraceRaysIndirectCommand2KHR& member){
        
    
auto& raygenShaderRecordAddress_json=json["raygenShaderRecordAddress"];
[&](){[&](){raygenShaderRecordAddress_json=member.raygenShaderRecordAddress;}();}();
auto& raygenShaderRecordSize_json=json["raygenShaderRecordSize"];
[&](){[&](){raygenShaderRecordSize_json=member.raygenShaderRecordSize;}();}();
auto& missShaderBindingTableAddress_json=json["missShaderBindingTableAddress"];
[&](){[&](){missShaderBindingTableAddress_json=member.missShaderBindingTableAddress;}();}();
auto& missShaderBindingTableSize_json=json["missShaderBindingTableSize"];
[&](){[&](){missShaderBindingTableSize_json=member.missShaderBindingTableSize;}();}();
auto& missShaderBindingTableStride_json=json["missShaderBindingTableStride"];
[&](){[&](){missShaderBindingTableStride_json=member.missShaderBindingTableStride;}();}();
auto& hitShaderBindingTableAddress_json=json["hitShaderBindingTableAddress"];
[&](){[&](){hitShaderBindingTableAddress_json=member.hitShaderBindingTableAddress;}();}();
auto& hitShaderBindingTableSize_json=json["hitShaderBindingTableSize"];
[&](){[&](){hitShaderBindingTableSize_json=member.hitShaderBindingTableSize;}();}();
auto& hitShaderBindingTableStride_json=json["hitShaderBindingTableStride"];
[&](){[&](){hitShaderBindingTableStride_json=member.hitShaderBindingTableStride;}();}();
auto& callableShaderBindingTableAddress_json=json["callableShaderBindingTableAddress"];
[&](){[&](){callableShaderBindingTableAddress_json=member.callableShaderBindingTableAddress;}();}();
auto& callableShaderBindingTableSize_json=json["callableShaderBindingTableSize"];
[&](){[&](){callableShaderBindingTableSize_json=member.callableShaderBindingTableSize;}();}();
auto& callableShaderBindingTableStride_json=json["callableShaderBindingTableStride"];
[&](){[&](){callableShaderBindingTableStride_json=member.callableShaderBindingTableStride;}();}();
auto& width_json=json["width"];
[&](){width_json=member.width;}();
auto& height_json=json["height"];
[&](){height_json=member.height;}();
auto& depth_json=json["depth"];
[&](){depth_json=member.depth;}();
}
void deserialize_struct(boost::json::object& json, VkTraceRaysIndirectCommand2KHR& member){
auto& raygenShaderRecordAddress_json=json["raygenShaderRecordAddress"];
[&](){uint64_t temp_fWrvPjg;[&](){temp_fWrvPjg=static_cast<uint64_t>(value_to<int>(raygenShaderRecordAddress_json));}();member.raygenShaderRecordAddress=(VkDeviceAddress)temp_fWrvPjg;}();
auto& raygenShaderRecordSize_json=json["raygenShaderRecordSize"];
[&](){uint64_t temp_qAXUTog;[&](){temp_qAXUTog=static_cast<uint64_t>(value_to<int>(raygenShaderRecordSize_json));}();member.raygenShaderRecordSize=(VkDeviceSize)temp_qAXUTog;}();
auto& missShaderBindingTableAddress_json=json["missShaderBindingTableAddress"];
[&](){uint64_t temp_ooLPUxh;[&](){temp_ooLPUxh=static_cast<uint64_t>(value_to<int>(missShaderBindingTableAddress_json));}();member.missShaderBindingTableAddress=(VkDeviceAddress)temp_ooLPUxh;}();
auto& missShaderBindingTableSize_json=json["missShaderBindingTableSize"];
[&](){uint64_t temp_ZnEmRpq;[&](){temp_ZnEmRpq=static_cast<uint64_t>(value_to<int>(missShaderBindingTableSize_json));}();member.missShaderBindingTableSize=(VkDeviceSize)temp_ZnEmRpq;}();
auto& missShaderBindingTableStride_json=json["missShaderBindingTableStride"];
[&](){uint64_t temp_YttpSYZ;[&](){temp_YttpSYZ=static_cast<uint64_t>(value_to<int>(missShaderBindingTableStride_json));}();member.missShaderBindingTableStride=(VkDeviceSize)temp_YttpSYZ;}();
auto& hitShaderBindingTableAddress_json=json["hitShaderBindingTableAddress"];
[&](){uint64_t temp_TQwZBvJ;[&](){temp_TQwZBvJ=static_cast<uint64_t>(value_to<int>(hitShaderBindingTableAddress_json));}();member.hitShaderBindingTableAddress=(VkDeviceAddress)temp_TQwZBvJ;}();
auto& hitShaderBindingTableSize_json=json["hitShaderBindingTableSize"];
[&](){uint64_t temp_SCUdsqF;[&](){temp_SCUdsqF=static_cast<uint64_t>(value_to<int>(hitShaderBindingTableSize_json));}();member.hitShaderBindingTableSize=(VkDeviceSize)temp_SCUdsqF;}();
auto& hitShaderBindingTableStride_json=json["hitShaderBindingTableStride"];
[&](){uint64_t temp_GpDHyKc;[&](){temp_GpDHyKc=static_cast<uint64_t>(value_to<int>(hitShaderBindingTableStride_json));}();member.hitShaderBindingTableStride=(VkDeviceSize)temp_GpDHyKc;}();
auto& callableShaderBindingTableAddress_json=json["callableShaderBindingTableAddress"];
[&](){uint64_t temp_hQKHHAe;[&](){temp_hQKHHAe=static_cast<uint64_t>(value_to<int>(callableShaderBindingTableAddress_json));}();member.callableShaderBindingTableAddress=(VkDeviceAddress)temp_hQKHHAe;}();
auto& callableShaderBindingTableSize_json=json["callableShaderBindingTableSize"];
[&](){uint64_t temp_uvsrkZa;[&](){temp_uvsrkZa=static_cast<uint64_t>(value_to<int>(callableShaderBindingTableSize_json));}();member.callableShaderBindingTableSize=(VkDeviceSize)temp_uvsrkZa;}();
auto& callableShaderBindingTableStride_json=json["callableShaderBindingTableStride"];
[&](){uint64_t temp_oHJHoLp;[&](){temp_oHJHoLp=static_cast<uint64_t>(value_to<int>(callableShaderBindingTableStride_json));}();member.callableShaderBindingTableStride=(VkDeviceSize)temp_oHJHoLp;}();
auto& width_json=json["width"];
[&](){member.width=static_cast<uint32_t>(value_to<int>(width_json));}();
auto& height_json=json["height"];
[&](){member.height=static_cast<uint32_t>(value_to<int>(height_json));}();
auto& depth_json=json["depth"];
[&](){member.depth=static_cast<uint32_t>(value_to<int>(depth_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rayTracingMaintenance1_json=json["rayTracingMaintenance1"];
[&](){[&](){rayTracingMaintenance1_json=member.rayTracingMaintenance1;}();}();
auto& rayTracingPipelineTraceRaysIndirect2_json=json["rayTracingPipelineTraceRaysIndirect2"];
[&](){[&](){rayTracingPipelineTraceRaysIndirect2_json=member.rayTracingPipelineTraceRaysIndirect2;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& rayTracingMaintenance1_json=json["rayTracingMaintenance1"];
[&](){uint32_t temp_MFqAHAq;[&](){temp_MFqAHAq=static_cast<uint32_t>(value_to<int>(rayTracingMaintenance1_json));}();member.rayTracingMaintenance1=(VkBool32)temp_MFqAHAq;}();
auto& rayTracingPipelineTraceRaysIndirect2_json=json["rayTracingPipelineTraceRaysIndirect2"];
[&](){uint32_t temp_PBnBJmB;[&](){temp_PBnBJmB=static_cast<uint32_t>(value_to<int>(rayTracingPipelineTraceRaysIndirect2_json));}();member.rayTracingPipelineTraceRaysIndirect2=(VkBool32)temp_PBnBJmB;}();
}

    void serialize_struct(boost::json::object& json, const VkDrmFormatModifierPropertiesListEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& drmFormatModifierCount_json=json["drmFormatModifierCount"];
[&](){drmFormatModifierCount_json=member.drmFormatModifierCount;}();
auto& pDrmFormatModifierProperties_json=json["pDrmFormatModifierProperties"];
[&](){
            if (member.pDrmFormatModifierProperties==NULL){
                pDrmFormatModifierProperties_json=boost::json::array();
            return; }pDrmFormatModifierProperties_json=boost::json::array(member.drmFormatModifierCount);
        auto& arr_VcNefkq=pDrmFormatModifierProperties_json.as_array();
        for(int BRMKPmI=0; BRMKPmI < member.drmFormatModifierCount; BRMKPmI++){
            [&](){
            auto& temp=arr_VcNefkq[BRMKPmI].emplace_object();
            return serialize_struct(temp, member.pDrmFormatModifierProperties[BRMKPmI]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDrmFormatModifierPropertiesListEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& drmFormatModifierCount_json=json["drmFormatModifierCount"];
[&](){member.drmFormatModifierCount=static_cast<uint32_t>(value_to<int>(drmFormatModifierCount_json));}();
auto& pDrmFormatModifierProperties_json=json["pDrmFormatModifierProperties"];
[&](){
            if (pDrmFormatModifierProperties_json.as_array().size()==0){
                member.pDrmFormatModifierProperties=NULL;
            return; }member.pDrmFormatModifierProperties=(VkDrmFormatModifierPropertiesEXT*)malloc(member.drmFormatModifierCount*sizeof(VkDrmFormatModifierPropertiesEXT));
        auto& arr_VcNefkq=pDrmFormatModifierProperties_json.as_array();
        for(int BRMKPmI=0; BRMKPmI < member.drmFormatModifierCount; BRMKPmI++){
            [&](){
            auto& temp=arr_VcNefkq[BRMKPmI].as_object();
            deserialize_struct(temp,member.pDrmFormatModifierProperties[BRMKPmI]);
            }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkDrmFormatModifierPropertiesEXT& member){
        
    
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){drmFormatModifier_json=member.drmFormatModifier;}();
auto& drmFormatModifierPlaneCount_json=json["drmFormatModifierPlaneCount"];
[&](){drmFormatModifierPlaneCount_json=member.drmFormatModifierPlaneCount;}();
auto& drmFormatModifierTilingFeatures_json=json["drmFormatModifierTilingFeatures"];
[&](){[&](){[&](){drmFormatModifierTilingFeatures_json=member.drmFormatModifierTilingFeatures;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDrmFormatModifierPropertiesEXT& member){
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){member.drmFormatModifier=static_cast<uint64_t>(value_to<int>(drmFormatModifier_json));}();
auto& drmFormatModifierPlaneCount_json=json["drmFormatModifierPlaneCount"];
[&](){member.drmFormatModifierPlaneCount=static_cast<uint32_t>(value_to<int>(drmFormatModifierPlaneCount_json));}();
auto& drmFormatModifierTilingFeatures_json=json["drmFormatModifierTilingFeatures"];
[&](){[&](){int temp_YrxdPDN;[&](){temp_YrxdPDN=static_cast<int>(value_to<int>(drmFormatModifierTilingFeatures_json));}();member.drmFormatModifierTilingFeatures=(VkFormatFeatureFlags)temp_YrxdPDN;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageDrmFormatModifierInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){drmFormatModifier_json=member.drmFormatModifier;}();
auto& sharingMode_json=json["sharingMode"];
[&](){[&](){[&](){sharingMode_json=member.sharingMode;}();}();}();
auto& queueFamilyIndexCount_json=json["queueFamilyIndexCount"];
[&](){queueFamilyIndexCount_json=member.queueFamilyIndexCount;}();
auto& pQueueFamilyIndices_json=json["pQueueFamilyIndices"];
[&](){
            if (member.pQueueFamilyIndices==NULL){
                pQueueFamilyIndices_json=boost::json::array();
            return; }pQueueFamilyIndices_json=boost::json::array(member.queueFamilyIndexCount);
        auto& arr_miZGtyX=pQueueFamilyIndices_json.as_array();
        for(int VJZTqbB=0; VJZTqbB < member.queueFamilyIndexCount; VJZTqbB++){
            [&](){arr_miZGtyX[VJZTqbB]=member.pQueueFamilyIndices[VJZTqbB];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageDrmFormatModifierInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){member.drmFormatModifier=static_cast<uint64_t>(value_to<int>(drmFormatModifier_json));}();
auto& sharingMode_json=json["sharingMode"];
[&](){[&](){int temp_lEqLxkW;[&](){temp_lEqLxkW=static_cast<int>(value_to<int>(sharingMode_json));}();member.sharingMode=(VkSharingMode)temp_lEqLxkW;}();}();
auto& queueFamilyIndexCount_json=json["queueFamilyIndexCount"];
[&](){member.queueFamilyIndexCount=static_cast<uint32_t>(value_to<int>(queueFamilyIndexCount_json));}();
auto& pQueueFamilyIndices_json=json["pQueueFamilyIndices"];
[&](){ uint32_t* temp_RQIKvOJ;;[&](){
            if (pQueueFamilyIndices_json.as_array().size()==0){
                temp_RQIKvOJ=NULL;
            return; }temp_RQIKvOJ=(uint32_t*)malloc(member.queueFamilyIndexCount*sizeof(uint32_t));
        auto& arr_PLMLiyU=pQueueFamilyIndices_json.as_array();
        for(int CXBfdQH=0; CXBfdQH < member.queueFamilyIndexCount; CXBfdQH++){
            [&](){temp_RQIKvOJ[CXBfdQH]=static_cast<uint32_t>(value_to<int>(arr_PLMLiyU[CXBfdQH]));}();
        }
        }();member.pQueueFamilyIndices=temp_RQIKvOJ;}();
}

    void serialize_struct(boost::json::object& json, const VkImageDrmFormatModifierListCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& drmFormatModifierCount_json=json["drmFormatModifierCount"];
[&](){drmFormatModifierCount_json=member.drmFormatModifierCount;}();
auto& pDrmFormatModifiers_json=json["pDrmFormatModifiers"];
[&](){
            if (member.pDrmFormatModifiers==NULL){
                pDrmFormatModifiers_json=boost::json::array();
            return; }pDrmFormatModifiers_json=boost::json::array(member.drmFormatModifierCount);
        auto& arr_wpvecAb=pDrmFormatModifiers_json.as_array();
        for(int AxfnHXf=0; AxfnHXf < member.drmFormatModifierCount; AxfnHXf++){
            [&](){arr_wpvecAb[AxfnHXf]=member.pDrmFormatModifiers[AxfnHXf];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkImageDrmFormatModifierListCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& drmFormatModifierCount_json=json["drmFormatModifierCount"];
[&](){member.drmFormatModifierCount=static_cast<uint32_t>(value_to<int>(drmFormatModifierCount_json));}();
auto& pDrmFormatModifiers_json=json["pDrmFormatModifiers"];
[&](){ uint64_t* temp_EjQSBxO;;[&](){
            if (pDrmFormatModifiers_json.as_array().size()==0){
                temp_EjQSBxO=NULL;
            return; }temp_EjQSBxO=(uint64_t*)malloc(member.drmFormatModifierCount*sizeof(uint64_t));
        auto& arr_fHdepUX=pDrmFormatModifiers_json.as_array();
        for(int GGILywl=0; GGILywl < member.drmFormatModifierCount; GGILywl++){
            [&](){temp_EjQSBxO[GGILywl]=static_cast<uint64_t>(value_to<int>(arr_fHdepUX[GGILywl]));}();
        }
        }();member.pDrmFormatModifiers=temp_EjQSBxO;}();
}

    void serialize_struct(boost::json::object& json, const VkImageDrmFormatModifierExplicitCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){drmFormatModifier_json=member.drmFormatModifier;}();
auto& drmFormatModifierPlaneCount_json=json["drmFormatModifierPlaneCount"];
[&](){drmFormatModifierPlaneCount_json=member.drmFormatModifierPlaneCount;}();
auto& pPlaneLayouts_json=json["pPlaneLayouts"];
[&](){
            if (member.pPlaneLayouts==NULL){
                pPlaneLayouts_json=boost::json::array();
            return; }pPlaneLayouts_json=boost::json::array(member.drmFormatModifierPlaneCount);
        auto& arr_QRGNGnb=pPlaneLayouts_json.as_array();
        for(int nhHhqug=0; nhHhqug < member.drmFormatModifierPlaneCount; nhHhqug++){
            [&](){
            auto& temp=arr_QRGNGnb[nhHhqug].emplace_object();
            return serialize_struct(temp, member.pPlaneLayouts[nhHhqug]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkImageDrmFormatModifierExplicitCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){member.drmFormatModifier=static_cast<uint64_t>(value_to<int>(drmFormatModifier_json));}();
auto& drmFormatModifierPlaneCount_json=json["drmFormatModifierPlaneCount"];
[&](){member.drmFormatModifierPlaneCount=static_cast<uint32_t>(value_to<int>(drmFormatModifierPlaneCount_json));}();
auto& pPlaneLayouts_json=json["pPlaneLayouts"];
[&](){ VkSubresourceLayout* temp_geUabVC;;[&](){
            if (pPlaneLayouts_json.as_array().size()==0){
                temp_geUabVC=NULL;
            return; }temp_geUabVC=(VkSubresourceLayout*)malloc(member.drmFormatModifierPlaneCount*sizeof(VkSubresourceLayout));
        auto& arr_oLeZhZQ=pPlaneLayouts_json.as_array();
        for(int rfyeaZO=0; rfyeaZO < member.drmFormatModifierPlaneCount; rfyeaZO++){
            [&](){
            auto& temp=arr_oLeZhZQ[rfyeaZO].as_object();
            deserialize_struct(temp,temp_geUabVC[rfyeaZO]);
            }();
        }
        }();member.pPlaneLayouts=temp_geUabVC;}();
}

    void serialize_struct(boost::json::object& json, const VkImageDrmFormatModifierPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){drmFormatModifier_json=member.drmFormatModifier;}();
}
void deserialize_struct(boost::json::object& json, VkImageDrmFormatModifierPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){member.drmFormatModifier=static_cast<uint64_t>(value_to<int>(drmFormatModifier_json));}();
}

    void serialize_struct(boost::json::object& json, const VkImageStencilUsageCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stencilUsage_json=json["stencilUsage"];
[&](){[&](){[&](){stencilUsage_json=member.stencilUsage;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkImageStencilUsageCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& stencilUsage_json=json["stencilUsage"];
[&](){[&](){int temp_LAdyKhO;[&](){temp_LAdyKhO=static_cast<int>(value_to<int>(stencilUsage_json));}();member.stencilUsage=(VkImageUsageFlags)temp_LAdyKhO;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceMemoryOverallocationCreateInfoAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& overallocationBehavior_json=json["overallocationBehavior"];
[&](){[&](){[&](){overallocationBehavior_json=member.overallocationBehavior;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceMemoryOverallocationCreateInfoAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& overallocationBehavior_json=json["overallocationBehavior"];
[&](){[&](){int temp_ycKWiQT;[&](){temp_ycKWiQT=static_cast<int>(value_to<int>(overallocationBehavior_json));}();member.overallocationBehavior=(VkMemoryOverallocationBehaviorAMD)temp_ycKWiQT;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentDensityMapFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentDensityMap_json=json["fragmentDensityMap"];
[&](){[&](){fragmentDensityMap_json=member.fragmentDensityMap;}();}();
auto& fragmentDensityMapDynamic_json=json["fragmentDensityMapDynamic"];
[&](){[&](){fragmentDensityMapDynamic_json=member.fragmentDensityMapDynamic;}();}();
auto& fragmentDensityMapNonSubsampledImages_json=json["fragmentDensityMapNonSubsampledImages"];
[&](){[&](){fragmentDensityMapNonSubsampledImages_json=member.fragmentDensityMapNonSubsampledImages;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentDensityMapFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& fragmentDensityMap_json=json["fragmentDensityMap"];
[&](){uint32_t temp_hsqgonv;[&](){temp_hsqgonv=static_cast<uint32_t>(value_to<int>(fragmentDensityMap_json));}();member.fragmentDensityMap=(VkBool32)temp_hsqgonv;}();
auto& fragmentDensityMapDynamic_json=json["fragmentDensityMapDynamic"];
[&](){uint32_t temp_pYPVxxi;[&](){temp_pYPVxxi=static_cast<uint32_t>(value_to<int>(fragmentDensityMapDynamic_json));}();member.fragmentDensityMapDynamic=(VkBool32)temp_pYPVxxi;}();
auto& fragmentDensityMapNonSubsampledImages_json=json["fragmentDensityMapNonSubsampledImages"];
[&](){uint32_t temp_YrFreCX;[&](){temp_YrFreCX=static_cast<uint32_t>(value_to<int>(fragmentDensityMapNonSubsampledImages_json));}();member.fragmentDensityMapNonSubsampledImages=(VkBool32)temp_YrFreCX;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentDensityMapDeferred_json=json["fragmentDensityMapDeferred"];
[&](){[&](){fragmentDensityMapDeferred_json=member.fragmentDensityMapDeferred;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& fragmentDensityMapDeferred_json=json["fragmentDensityMapDeferred"];
[&](){uint32_t temp_hqZHOAo;[&](){temp_hqZHOAo=static_cast<uint32_t>(value_to<int>(fragmentDensityMapDeferred_json));}();member.fragmentDensityMapDeferred=(VkBool32)temp_hqZHOAo;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentDensityMapOffset_json=json["fragmentDensityMapOffset"];
[&](){[&](){fragmentDensityMapOffset_json=member.fragmentDensityMapOffset;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& fragmentDensityMapOffset_json=json["fragmentDensityMapOffset"];
[&](){uint32_t temp_XQmTbYk;[&](){temp_XQmTbYk=static_cast<uint32_t>(value_to<int>(fragmentDensityMapOffset_json));}();member.fragmentDensityMapOffset=(VkBool32)temp_XQmTbYk;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentDensityMapPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& minFragmentDensityTexelSize_json=json["minFragmentDensityTexelSize"];
[&](){
            auto& temp=minFragmentDensityTexelSize_json.emplace_object();
            return serialize_struct(temp, member.minFragmentDensityTexelSize);
            }();
auto& maxFragmentDensityTexelSize_json=json["maxFragmentDensityTexelSize"];
[&](){
            auto& temp=maxFragmentDensityTexelSize_json.emplace_object();
            return serialize_struct(temp, member.maxFragmentDensityTexelSize);
            }();
auto& fragmentDensityInvocations_json=json["fragmentDensityInvocations"];
[&](){[&](){fragmentDensityInvocations_json=member.fragmentDensityInvocations;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentDensityMapPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& minFragmentDensityTexelSize_json=json["minFragmentDensityTexelSize"];
[&](){
            auto& temp=minFragmentDensityTexelSize_json.as_object();
            deserialize_struct(temp,member.minFragmentDensityTexelSize);
            }();
auto& maxFragmentDensityTexelSize_json=json["maxFragmentDensityTexelSize"];
[&](){
            auto& temp=maxFragmentDensityTexelSize_json.as_object();
            deserialize_struct(temp,member.maxFragmentDensityTexelSize);
            }();
auto& fragmentDensityInvocations_json=json["fragmentDensityInvocations"];
[&](){uint32_t temp_TlCrNRb;[&](){temp_TlCrNRb=static_cast<uint32_t>(value_to<int>(fragmentDensityInvocations_json));}();member.fragmentDensityInvocations=(VkBool32)temp_TlCrNRb;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& subsampledLoads_json=json["subsampledLoads"];
[&](){[&](){subsampledLoads_json=member.subsampledLoads;}();}();
auto& subsampledCoarseReconstructionEarlyAccess_json=json["subsampledCoarseReconstructionEarlyAccess"];
[&](){[&](){subsampledCoarseReconstructionEarlyAccess_json=member.subsampledCoarseReconstructionEarlyAccess;}();}();
auto& maxSubsampledArrayLayers_json=json["maxSubsampledArrayLayers"];
[&](){maxSubsampledArrayLayers_json=member.maxSubsampledArrayLayers;}();
auto& maxDescriptorSetSubsampledSamplers_json=json["maxDescriptorSetSubsampledSamplers"];
[&](){maxDescriptorSetSubsampledSamplers_json=member.maxDescriptorSetSubsampledSamplers;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& subsampledLoads_json=json["subsampledLoads"];
[&](){uint32_t temp_eGYZtLx;[&](){temp_eGYZtLx=static_cast<uint32_t>(value_to<int>(subsampledLoads_json));}();member.subsampledLoads=(VkBool32)temp_eGYZtLx;}();
auto& subsampledCoarseReconstructionEarlyAccess_json=json["subsampledCoarseReconstructionEarlyAccess"];
[&](){uint32_t temp_NsbMBvx;[&](){temp_NsbMBvx=static_cast<uint32_t>(value_to<int>(subsampledCoarseReconstructionEarlyAccess_json));}();member.subsampledCoarseReconstructionEarlyAccess=(VkBool32)temp_NsbMBvx;}();
auto& maxSubsampledArrayLayers_json=json["maxSubsampledArrayLayers"];
[&](){member.maxSubsampledArrayLayers=static_cast<uint32_t>(value_to<int>(maxSubsampledArrayLayers_json));}();
auto& maxDescriptorSetSubsampledSamplers_json=json["maxDescriptorSetSubsampledSamplers"];
[&](){member.maxDescriptorSetSubsampledSamplers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetSubsampledSamplers_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentDensityOffsetGranularity_json=json["fragmentDensityOffsetGranularity"];
[&](){
            auto& temp=fragmentDensityOffsetGranularity_json.emplace_object();
            return serialize_struct(temp, member.fragmentDensityOffsetGranularity);
            }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& fragmentDensityOffsetGranularity_json=json["fragmentDensityOffsetGranularity"];
[&](){
            auto& temp=fragmentDensityOffsetGranularity_json.as_object();
            deserialize_struct(temp,member.fragmentDensityOffsetGranularity);
            }();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassFragmentDensityMapCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentDensityMapAttachment_json=json["fragmentDensityMapAttachment"];
[&](){
            auto& temp=fragmentDensityMapAttachment_json.emplace_object();
            return serialize_struct(temp, member.fragmentDensityMapAttachment);
            }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassFragmentDensityMapCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& fragmentDensityMapAttachment_json=json["fragmentDensityMapAttachment"];
[&](){
            auto& temp=fragmentDensityMapAttachment_json.as_object();
            deserialize_struct(temp,member.fragmentDensityMapAttachment);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSubpassFragmentDensityMapOffsetEndInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentDensityOffsetCount_json=json["fragmentDensityOffsetCount"];
[&](){fragmentDensityOffsetCount_json=member.fragmentDensityOffsetCount;}();
auto& pFragmentDensityOffsets_json=json["pFragmentDensityOffsets"];
[&](){
            if (member.pFragmentDensityOffsets==NULL){
                pFragmentDensityOffsets_json=boost::json::array();
            return; }pFragmentDensityOffsets_json=boost::json::array(member.fragmentDensityOffsetCount);
        auto& arr_cwxXEeQ=pFragmentDensityOffsets_json.as_array();
        for(int WMsPool=0; WMsPool < member.fragmentDensityOffsetCount; WMsPool++){
            [&](){
            auto& temp=arr_cwxXEeQ[WMsPool].emplace_object();
            return serialize_struct(temp, member.pFragmentDensityOffsets[WMsPool]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSubpassFragmentDensityMapOffsetEndInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& fragmentDensityOffsetCount_json=json["fragmentDensityOffsetCount"];
[&](){member.fragmentDensityOffsetCount=static_cast<uint32_t>(value_to<int>(fragmentDensityOffsetCount_json));}();
auto& pFragmentDensityOffsets_json=json["pFragmentDensityOffsets"];
[&](){ VkOffset2D* temp_WRNzsoL;;[&](){
            if (pFragmentDensityOffsets_json.as_array().size()==0){
                temp_WRNzsoL=NULL;
            return; }temp_WRNzsoL=(VkOffset2D*)malloc(member.fragmentDensityOffsetCount*sizeof(VkOffset2D));
        auto& arr_guImHkx=pFragmentDensityOffsets_json.as_array();
        for(int uYmAvJR=0; uYmAvJR < member.fragmentDensityOffsetCount; uYmAvJR++){
            [&](){
            auto& temp=arr_guImHkx[uYmAvJR].as_object();
            deserialize_struct(temp,temp_WRNzsoL[uYmAvJR]);
            }();
        }
        }();member.pFragmentDensityOffsets=temp_WRNzsoL;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceScalarBlockLayoutFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& scalarBlockLayout_json=json["scalarBlockLayout"];
[&](){[&](){scalarBlockLayout_json=member.scalarBlockLayout;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceScalarBlockLayoutFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& scalarBlockLayout_json=json["scalarBlockLayout"];
[&](){uint32_t temp_CKSkRNT;[&](){temp_CKSkRNT=static_cast<uint32_t>(value_to<int>(scalarBlockLayout_json));}();member.scalarBlockLayout=(VkBool32)temp_CKSkRNT;}();
}

    void serialize_struct(boost::json::object& json, const VkSurfaceProtectedCapabilitiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& supportsProtected_json=json["supportsProtected"];
[&](){[&](){supportsProtected_json=member.supportsProtected;}();}();
}
void deserialize_struct(boost::json::object& json, VkSurfaceProtectedCapabilitiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& supportsProtected_json=json["supportsProtected"];
[&](){uint32_t temp_NzopDbV;[&](){temp_NzopDbV=static_cast<uint32_t>(value_to<int>(supportsProtected_json));}();member.supportsProtected=(VkBool32)temp_NzopDbV;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceUniformBufferStandardLayoutFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& uniformBufferStandardLayout_json=json["uniformBufferStandardLayout"];
[&](){[&](){uniformBufferStandardLayout_json=member.uniformBufferStandardLayout;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceUniformBufferStandardLayoutFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& uniformBufferStandardLayout_json=json["uniformBufferStandardLayout"];
[&](){uint32_t temp_BdhQgZA;[&](){temp_BdhQgZA=static_cast<uint32_t>(value_to<int>(uniformBufferStandardLayout_json));}();member.uniformBufferStandardLayout=(VkBool32)temp_BdhQgZA;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDepthClipEnableFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& depthClipEnable_json=json["depthClipEnable"];
[&](){[&](){depthClipEnable_json=member.depthClipEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDepthClipEnableFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& depthClipEnable_json=json["depthClipEnable"];
[&](){uint32_t temp_ZfNavsP;[&](){temp_ZfNavsP=static_cast<uint32_t>(value_to<int>(depthClipEnable_json));}();member.depthClipEnable=(VkBool32)temp_ZfNavsP;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRasterizationDepthClipStateCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& depthClipEnable_json=json["depthClipEnable"];
[&](){[&](){depthClipEnable_json=member.depthClipEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRasterizationDepthClipStateCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_faKvIgV;[&](){temp_faKvIgV=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineRasterizationDepthClipStateCreateFlagsEXT)temp_faKvIgV;}();}();
auto& depthClipEnable_json=json["depthClipEnable"];
[&](){uint32_t temp_ZfNavsP;[&](){temp_ZfNavsP=static_cast<uint32_t>(value_to<int>(depthClipEnable_json));}();member.depthClipEnable=(VkBool32)temp_ZfNavsP;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMemoryBudgetPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& heapBudget_json=json["heapBudget"];
[&](){heapBudget_json=boost::json::array(VK_MAX_MEMORY_HEAPS);
        auto& arr_TZvTVXq=heapBudget_json.as_array();
        for(int rgFNxRG=0; rgFNxRG < VK_MAX_MEMORY_HEAPS; rgFNxRG++){
            [&](){[&](){arr_TZvTVXq[rgFNxRG]=member.heapBudget[rgFNxRG];}();}();
        }
        }();
auto& heapUsage_json=json["heapUsage"];
[&](){heapUsage_json=boost::json::array(VK_MAX_MEMORY_HEAPS);
        auto& arr_JRgQoEM=heapUsage_json.as_array();
        for(int QthsrSi=0; QthsrSi < VK_MAX_MEMORY_HEAPS; QthsrSi++){
            [&](){[&](){arr_JRgQoEM[QthsrSi]=member.heapUsage[QthsrSi];}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMemoryBudgetPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& heapBudget_json=json["heapBudget"];
[&](){
        auto& arr_TZvTVXq=heapBudget_json.as_array();
        for(int rgFNxRG=0; rgFNxRG < VK_MAX_MEMORY_HEAPS; rgFNxRG++){
            [&](){uint64_t temp_TZvTVXq;[&](){temp_TZvTVXq=static_cast<uint64_t>(value_to<int>(arr_TZvTVXq[rgFNxRG]));}();member.heapBudget[rgFNxRG]=(VkDeviceSize)temp_TZvTVXq;}();
        }
        }();
auto& heapUsage_json=json["heapUsage"];
[&](){
        auto& arr_JRgQoEM=heapUsage_json.as_array();
        for(int QthsrSi=0; QthsrSi < VK_MAX_MEMORY_HEAPS; QthsrSi++){
            [&](){uint64_t temp_JRgQoEM;[&](){temp_JRgQoEM=static_cast<uint64_t>(value_to<int>(arr_JRgQoEM[QthsrSi]));}();member.heapUsage[QthsrSi]=(VkDeviceSize)temp_JRgQoEM;}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMemoryPriorityFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memoryPriority_json=json["memoryPriority"];
[&](){[&](){memoryPriority_json=member.memoryPriority;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMemoryPriorityFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& memoryPriority_json=json["memoryPriority"];
[&](){uint32_t temp_LhSTqCq;[&](){temp_LhSTqCq=static_cast<uint32_t>(value_to<int>(memoryPriority_json));}();member.memoryPriority=(VkBool32)temp_LhSTqCq;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryPriorityAllocateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& priority_json=json["priority"];
[&](){priority_json=member.priority;}();
}
void deserialize_struct(boost::json::object& json, VkMemoryPriorityAllocateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& priority_json=json["priority"];
[&](){member.priority=static_cast<float>(value_to<int>(priority_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pageableDeviceLocalMemory_json=json["pageableDeviceLocalMemory"];
[&](){[&](){pageableDeviceLocalMemory_json=member.pageableDeviceLocalMemory;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pageableDeviceLocalMemory_json=json["pageableDeviceLocalMemory"];
[&](){uint32_t temp_fBxUUEY;[&](){temp_fBxUUEY=static_cast<uint32_t>(value_to<int>(pageableDeviceLocalMemory_json));}();member.pageableDeviceLocalMemory=(VkBool32)temp_fBxUUEY;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceBufferDeviceAddressFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& bufferDeviceAddress_json=json["bufferDeviceAddress"];
[&](){[&](){bufferDeviceAddress_json=member.bufferDeviceAddress;}();}();
auto& bufferDeviceAddressCaptureReplay_json=json["bufferDeviceAddressCaptureReplay"];
[&](){[&](){bufferDeviceAddressCaptureReplay_json=member.bufferDeviceAddressCaptureReplay;}();}();
auto& bufferDeviceAddressMultiDevice_json=json["bufferDeviceAddressMultiDevice"];
[&](){[&](){bufferDeviceAddressMultiDevice_json=member.bufferDeviceAddressMultiDevice;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceBufferDeviceAddressFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& bufferDeviceAddress_json=json["bufferDeviceAddress"];
[&](){uint32_t temp_yVSfIxJ;[&](){temp_yVSfIxJ=static_cast<uint32_t>(value_to<int>(bufferDeviceAddress_json));}();member.bufferDeviceAddress=(VkBool32)temp_yVSfIxJ;}();
auto& bufferDeviceAddressCaptureReplay_json=json["bufferDeviceAddressCaptureReplay"];
[&](){uint32_t temp_ZdaRGga;[&](){temp_ZdaRGga=static_cast<uint32_t>(value_to<int>(bufferDeviceAddressCaptureReplay_json));}();member.bufferDeviceAddressCaptureReplay=(VkBool32)temp_ZdaRGga;}();
auto& bufferDeviceAddressMultiDevice_json=json["bufferDeviceAddressMultiDevice"];
[&](){uint32_t temp_XwIBhTJ;[&](){temp_XwIBhTJ=static_cast<uint32_t>(value_to<int>(bufferDeviceAddressMultiDevice_json));}();member.bufferDeviceAddressMultiDevice=(VkBool32)temp_XwIBhTJ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& bufferDeviceAddress_json=json["bufferDeviceAddress"];
[&](){[&](){bufferDeviceAddress_json=member.bufferDeviceAddress;}();}();
auto& bufferDeviceAddressCaptureReplay_json=json["bufferDeviceAddressCaptureReplay"];
[&](){[&](){bufferDeviceAddressCaptureReplay_json=member.bufferDeviceAddressCaptureReplay;}();}();
auto& bufferDeviceAddressMultiDevice_json=json["bufferDeviceAddressMultiDevice"];
[&](){[&](){bufferDeviceAddressMultiDevice_json=member.bufferDeviceAddressMultiDevice;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& bufferDeviceAddress_json=json["bufferDeviceAddress"];
[&](){uint32_t temp_yVSfIxJ;[&](){temp_yVSfIxJ=static_cast<uint32_t>(value_to<int>(bufferDeviceAddress_json));}();member.bufferDeviceAddress=(VkBool32)temp_yVSfIxJ;}();
auto& bufferDeviceAddressCaptureReplay_json=json["bufferDeviceAddressCaptureReplay"];
[&](){uint32_t temp_ZdaRGga;[&](){temp_ZdaRGga=static_cast<uint32_t>(value_to<int>(bufferDeviceAddressCaptureReplay_json));}();member.bufferDeviceAddressCaptureReplay=(VkBool32)temp_ZdaRGga;}();
auto& bufferDeviceAddressMultiDevice_json=json["bufferDeviceAddressMultiDevice"];
[&](){uint32_t temp_XwIBhTJ;[&](){temp_XwIBhTJ=static_cast<uint32_t>(value_to<int>(bufferDeviceAddressMultiDevice_json));}();member.bufferDeviceAddressMultiDevice=(VkBool32)temp_XwIBhTJ;}();
}

    void serialize_struct(boost::json::object& json, const VkBufferDeviceAddressInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
}
void deserialize_struct(boost::json::object& json, VkBufferDeviceAddressInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
}

    void serialize_struct(boost::json::object& json, const VkBufferOpaqueCaptureAddressCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& opaqueCaptureAddress_json=json["opaqueCaptureAddress"];
[&](){opaqueCaptureAddress_json=member.opaqueCaptureAddress;}();
}
void deserialize_struct(boost::json::object& json, VkBufferOpaqueCaptureAddressCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& opaqueCaptureAddress_json=json["opaqueCaptureAddress"];
[&](){member.opaqueCaptureAddress=static_cast<uint64_t>(value_to<int>(opaqueCaptureAddress_json));}();
}

    void serialize_struct(boost::json::object& json, const VkBufferDeviceAddressCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceAddress_json=json["deviceAddress"];
[&](){[&](){deviceAddress_json=member.deviceAddress;}();}();
}
void deserialize_struct(boost::json::object& json, VkBufferDeviceAddressCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& deviceAddress_json=json["deviceAddress"];
[&](){uint64_t temp_JcebElc;[&](){temp_JcebElc=static_cast<uint64_t>(value_to<int>(deviceAddress_json));}();member.deviceAddress=(VkDeviceAddress)temp_JcebElc;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageViewImageFormatInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageViewType_json=json["imageViewType"];
[&](){[&](){[&](){imageViewType_json=member.imageViewType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageViewImageFormatInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& imageViewType_json=json["imageViewType"];
[&](){[&](){int temp_ewNNXHU;[&](){temp_ewNNXHU=static_cast<int>(value_to<int>(imageViewType_json));}();member.imageViewType=(VkImageViewType)temp_ewNNXHU;}();}();
}

    void serialize_struct(boost::json::object& json, const VkFilterCubicImageViewImageFormatPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& filterCubic_json=json["filterCubic"];
[&](){[&](){filterCubic_json=member.filterCubic;}();}();
auto& filterCubicMinmax_json=json["filterCubicMinmax"];
[&](){[&](){filterCubicMinmax_json=member.filterCubicMinmax;}();}();
}
void deserialize_struct(boost::json::object& json, VkFilterCubicImageViewImageFormatPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& filterCubic_json=json["filterCubic"];
[&](){uint32_t temp_qAZUzeQ;[&](){temp_qAZUzeQ=static_cast<uint32_t>(value_to<int>(filterCubic_json));}();member.filterCubic=(VkBool32)temp_qAZUzeQ;}();
auto& filterCubicMinmax_json=json["filterCubicMinmax"];
[&](){uint32_t temp_DNisxBi;[&](){temp_DNisxBi=static_cast<uint32_t>(value_to<int>(filterCubicMinmax_json));}();member.filterCubicMinmax=(VkBool32)temp_DNisxBi;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImagelessFramebufferFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imagelessFramebuffer_json=json["imagelessFramebuffer"];
[&](){[&](){imagelessFramebuffer_json=member.imagelessFramebuffer;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImagelessFramebufferFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& imagelessFramebuffer_json=json["imagelessFramebuffer"];
[&](){uint32_t temp_eYtbOdU;[&](){temp_eYtbOdU=static_cast<uint32_t>(value_to<int>(imagelessFramebuffer_json));}();member.imagelessFramebuffer=(VkBool32)temp_eYtbOdU;}();
}

    void serialize_struct(boost::json::object& json, const VkFramebufferAttachmentsCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& attachmentImageInfoCount_json=json["attachmentImageInfoCount"];
[&](){attachmentImageInfoCount_json=member.attachmentImageInfoCount;}();
auto& pAttachmentImageInfos_json=json["pAttachmentImageInfos"];
[&](){
            if (member.pAttachmentImageInfos==NULL){
                pAttachmentImageInfos_json=boost::json::array();
            return; }pAttachmentImageInfos_json=boost::json::array(member.attachmentImageInfoCount);
        auto& arr_uyGGMQY=pAttachmentImageInfos_json.as_array();
        for(int KZYqupS=0; KZYqupS < member.attachmentImageInfoCount; KZYqupS++){
            [&](){
            auto& temp=arr_uyGGMQY[KZYqupS].emplace_object();
            return serialize_struct(temp, member.pAttachmentImageInfos[KZYqupS]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkFramebufferAttachmentsCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& attachmentImageInfoCount_json=json["attachmentImageInfoCount"];
[&](){member.attachmentImageInfoCount=static_cast<uint32_t>(value_to<int>(attachmentImageInfoCount_json));}();
auto& pAttachmentImageInfos_json=json["pAttachmentImageInfos"];
[&](){ VkFramebufferAttachmentImageInfo* temp_kDeKHko;;[&](){
            if (pAttachmentImageInfos_json.as_array().size()==0){
                temp_kDeKHko=NULL;
            return; }temp_kDeKHko=(VkFramebufferAttachmentImageInfo*)malloc(member.attachmentImageInfoCount*sizeof(VkFramebufferAttachmentImageInfo));
        auto& arr_ahfqMuj=pAttachmentImageInfos_json.as_array();
        for(int DqfkvCY=0; DqfkvCY < member.attachmentImageInfoCount; DqfkvCY++){
            [&](){
            auto& temp=arr_ahfqMuj[DqfkvCY].as_object();
            deserialize_struct(temp,temp_kDeKHko[DqfkvCY]);
            }();
        }
        }();member.pAttachmentImageInfos=temp_kDeKHko;}();
}

    void serialize_struct(boost::json::object& json, const VkFramebufferAttachmentImageInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
auto& width_json=json["width"];
[&](){width_json=member.width;}();
auto& height_json=json["height"];
[&](){height_json=member.height;}();
auto& layerCount_json=json["layerCount"];
[&](){layerCount_json=member.layerCount;}();
auto& viewFormatCount_json=json["viewFormatCount"];
[&](){viewFormatCount_json=member.viewFormatCount;}();
auto& pViewFormats_json=json["pViewFormats"];
[&](){
            if (member.pViewFormats==NULL){
                pViewFormats_json=boost::json::array();
            return; }pViewFormats_json=boost::json::array(member.viewFormatCount);
        auto& arr_WbFQnzp=pViewFormats_json.as_array();
        for(int fIUeIsy=0; fIUeIsy < member.viewFormatCount; fIUeIsy++){
            [&](){[&](){[&](){arr_WbFQnzp[fIUeIsy]=member.pViewFormats[fIUeIsy];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkFramebufferAttachmentImageInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_gikCMkV;[&](){temp_gikCMkV=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkImageCreateFlags)temp_gikCMkV;}();}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_FIcOdeK;[&](){temp_FIcOdeK=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkImageUsageFlags)temp_FIcOdeK;}();}();
auto& width_json=json["width"];
[&](){member.width=static_cast<uint32_t>(value_to<int>(width_json));}();
auto& height_json=json["height"];
[&](){member.height=static_cast<uint32_t>(value_to<int>(height_json));}();
auto& layerCount_json=json["layerCount"];
[&](){member.layerCount=static_cast<uint32_t>(value_to<int>(layerCount_json));}();
auto& viewFormatCount_json=json["viewFormatCount"];
[&](){member.viewFormatCount=static_cast<uint32_t>(value_to<int>(viewFormatCount_json));}();
auto& pViewFormats_json=json["pViewFormats"];
[&](){ VkFormat* temp_SOycFlu;;[&](){
            if (pViewFormats_json.as_array().size()==0){
                temp_SOycFlu=NULL;
            return; }temp_SOycFlu=(VkFormat*)malloc(member.viewFormatCount*sizeof(VkFormat));
        auto& arr_rDRQrBj=pViewFormats_json.as_array();
        for(int GVlCsiU=0; GVlCsiU < member.viewFormatCount; GVlCsiU++){
            [&](){[&](){int temp_rkEfzeZ;[&](){temp_rkEfzeZ=static_cast<int>(value_to<int>(arr_rDRQrBj[GVlCsiU]));}();temp_SOycFlu[GVlCsiU]=(VkFormat)temp_rkEfzeZ;}();}();
        }
        }();member.pViewFormats=temp_SOycFlu;}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassAttachmentBeginInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& attachmentCount_json=json["attachmentCount"];
[&](){attachmentCount_json=member.attachmentCount;}();
auto& pAttachments_json=json["pAttachments"];
[&](){
            if (member.pAttachments==NULL){
                pAttachments_json=boost::json::array();
            return; }pAttachments_json=boost::json::array(member.attachmentCount);
        auto& arr_XUnbodX=pAttachments_json.as_array();
        for(int FOVxLSQ=0; FOVxLSQ < member.attachmentCount; FOVxLSQ++){
            [&](){serialize_VkImageView(arr_XUnbodX[FOVxLSQ],member.pAttachments[FOVxLSQ]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassAttachmentBeginInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){member.attachmentCount=static_cast<uint32_t>(value_to<int>(attachmentCount_json));}();
auto& pAttachments_json=json["pAttachments"];
[&](){ VkImageView* temp_veJtHuE;;[&](){
            if (pAttachments_json.as_array().size()==0){
                temp_veJtHuE=NULL;
            return; }temp_veJtHuE=(VkImageView*)malloc(member.attachmentCount*sizeof(VkImageView));
        auto& arr_vOukWcp=pAttachments_json.as_array();
        for(int SjNLYTr=0; SjNLYTr < member.attachmentCount; SjNLYTr++){
            [&](){deserialize_VkImageView(arr_vOukWcp[SjNLYTr], temp_veJtHuE[SjNLYTr]);}();
        }
        }();member.pAttachments=temp_veJtHuE;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceTextureCompressionASTCHDRFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& textureCompressionASTC_HDR_json=json["textureCompressionASTC_HDR"];
[&](){[&](){textureCompressionASTC_HDR_json=member.textureCompressionASTC_HDR;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceTextureCompressionASTCHDRFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& textureCompressionASTC_HDR_json=json["textureCompressionASTC_HDR"];
[&](){uint32_t temp_FUhDyOz;[&](){temp_FUhDyOz=static_cast<uint32_t>(value_to<int>(textureCompressionASTC_HDR_json));}();member.textureCompressionASTC_HDR=(VkBool32)temp_FUhDyOz;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCooperativeMatrixFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& cooperativeMatrix_json=json["cooperativeMatrix"];
[&](){[&](){cooperativeMatrix_json=member.cooperativeMatrix;}();}();
auto& cooperativeMatrixRobustBufferAccess_json=json["cooperativeMatrixRobustBufferAccess"];
[&](){[&](){cooperativeMatrixRobustBufferAccess_json=member.cooperativeMatrixRobustBufferAccess;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCooperativeMatrixFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& cooperativeMatrix_json=json["cooperativeMatrix"];
[&](){uint32_t temp_qiHCmYX;[&](){temp_qiHCmYX=static_cast<uint32_t>(value_to<int>(cooperativeMatrix_json));}();member.cooperativeMatrix=(VkBool32)temp_qiHCmYX;}();
auto& cooperativeMatrixRobustBufferAccess_json=json["cooperativeMatrixRobustBufferAccess"];
[&](){uint32_t temp_bJZwwLn;[&](){temp_bJZwwLn=static_cast<uint32_t>(value_to<int>(cooperativeMatrixRobustBufferAccess_json));}();member.cooperativeMatrixRobustBufferAccess=(VkBool32)temp_bJZwwLn;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCooperativeMatrixPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& cooperativeMatrixSupportedStages_json=json["cooperativeMatrixSupportedStages"];
[&](){[&](){[&](){cooperativeMatrixSupportedStages_json=member.cooperativeMatrixSupportedStages;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCooperativeMatrixPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& cooperativeMatrixSupportedStages_json=json["cooperativeMatrixSupportedStages"];
[&](){[&](){int temp_viFKXIW;[&](){temp_viFKXIW=static_cast<int>(value_to<int>(cooperativeMatrixSupportedStages_json));}();member.cooperativeMatrixSupportedStages=(VkShaderStageFlags)temp_viFKXIW;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCooperativeMatrixPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& MSize_json=json["MSize"];
[&](){MSize_json=member.MSize;}();
auto& NSize_json=json["NSize"];
[&](){NSize_json=member.NSize;}();
auto& KSize_json=json["KSize"];
[&](){KSize_json=member.KSize;}();
auto& AType_json=json["AType"];
[&](){[&](){[&](){AType_json=member.AType;}();}();}();
auto& BType_json=json["BType"];
[&](){[&](){[&](){BType_json=member.BType;}();}();}();
auto& CType_json=json["CType"];
[&](){[&](){[&](){CType_json=member.CType;}();}();}();
auto& DType_json=json["DType"];
[&](){[&](){[&](){DType_json=member.DType;}();}();}();
auto& scope_json=json["scope"];
[&](){[&](){[&](){scope_json=member.scope;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCooperativeMatrixPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& MSize_json=json["MSize"];
[&](){member.MSize=static_cast<uint32_t>(value_to<int>(MSize_json));}();
auto& NSize_json=json["NSize"];
[&](){member.NSize=static_cast<uint32_t>(value_to<int>(NSize_json));}();
auto& KSize_json=json["KSize"];
[&](){member.KSize=static_cast<uint32_t>(value_to<int>(KSize_json));}();
auto& AType_json=json["AType"];
[&](){[&](){int temp_doIadCX;[&](){temp_doIadCX=static_cast<int>(value_to<int>(AType_json));}();member.AType=(VkComponentTypeNV)temp_doIadCX;}();}();
auto& BType_json=json["BType"];
[&](){[&](){int temp_eeRePfN;[&](){temp_eeRePfN=static_cast<int>(value_to<int>(BType_json));}();member.BType=(VkComponentTypeNV)temp_eeRePfN;}();}();
auto& CType_json=json["CType"];
[&](){[&](){int temp_gerMxsY;[&](){temp_gerMxsY=static_cast<int>(value_to<int>(CType_json));}();member.CType=(VkComponentTypeNV)temp_gerMxsY;}();}();
auto& DType_json=json["DType"];
[&](){[&](){int temp_GMiAWyi;[&](){temp_GMiAWyi=static_cast<int>(value_to<int>(DType_json));}();member.DType=(VkComponentTypeNV)temp_GMiAWyi;}();}();
auto& scope_json=json["scope"];
[&](){[&](){int temp_NDvPWfO;[&](){temp_NDvPWfO=static_cast<int>(value_to<int>(scope_json));}();member.scope=(VkScopeNV)temp_NDvPWfO;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& ycbcrImageArrays_json=json["ycbcrImageArrays"];
[&](){[&](){ycbcrImageArrays_json=member.ycbcrImageArrays;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& ycbcrImageArrays_json=json["ycbcrImageArrays"];
[&](){uint32_t temp_WmwOawC;[&](){temp_WmwOawC=static_cast<uint32_t>(value_to<int>(ycbcrImageArrays_json));}();member.ycbcrImageArrays=(VkBool32)temp_WmwOawC;}();
}

    void serialize_struct(boost::json::object& json, const VkImageViewHandleInfoNVX& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageView_json=json["imageView"];
[&](){serialize_VkImageView(imageView_json,member.imageView);}();
auto& descriptorType_json=json["descriptorType"];
[&](){[&](){[&](){descriptorType_json=member.descriptorType;}();}();}();
auto& sampler_json=json["sampler"];
[&](){serialize_VkSampler(sampler_json,member.sampler);}();
}
void deserialize_struct(boost::json::object& json, VkImageViewHandleInfoNVX& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& imageView_json=json["imageView"];
[&](){deserialize_VkImageView(imageView_json, member.imageView);}();
auto& descriptorType_json=json["descriptorType"];
[&](){[&](){int temp_LETzuZb;[&](){temp_LETzuZb=static_cast<int>(value_to<int>(descriptorType_json));}();member.descriptorType=(VkDescriptorType)temp_LETzuZb;}();}();
auto& sampler_json=json["sampler"];
[&](){deserialize_VkSampler(sampler_json, member.sampler);}();
}

    void serialize_struct(boost::json::object& json, const VkImageViewAddressPropertiesNVX& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceAddress_json=json["deviceAddress"];
[&](){[&](){deviceAddress_json=member.deviceAddress;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkImageViewAddressPropertiesNVX& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& deviceAddress_json=json["deviceAddress"];
[&](){uint64_t temp_JcebElc;[&](){temp_JcebElc=static_cast<uint64_t>(value_to<int>(deviceAddress_json));}();member.deviceAddress=(VkDeviceAddress)temp_JcebElc;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineCreationFeedback& member){
        
    
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& duration_json=json["duration"];
[&](){duration_json=member.duration;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineCreationFeedback& member){
auto& flags_json=json["flags"];
[&](){[&](){int temp_MXuApuv;[&](){temp_MXuApuv=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCreationFeedbackFlags)temp_MXuApuv;}();}();
auto& duration_json=json["duration"];
[&](){member.duration=static_cast<uint64_t>(value_to<int>(duration_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineCreationFeedbackCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pPipelineCreationFeedback_json=json["pPipelineCreationFeedback"];
[&](){
            if (member.pPipelineCreationFeedback==NULL){
                pPipelineCreationFeedback_json=boost::json::array();
            return; }pPipelineCreationFeedback_json=boost::json::array(1);
        auto& arr_bLfUuds=pPipelineCreationFeedback_json.as_array();
        for(int Xwezzqt=0; Xwezzqt < 1; Xwezzqt++){
            [&](){
            auto& temp=arr_bLfUuds[Xwezzqt].emplace_object();
            return serialize_struct(temp, member.pPipelineCreationFeedback[Xwezzqt]);
            }();
        }
        }();
auto& pipelineStageCreationFeedbackCount_json=json["pipelineStageCreationFeedbackCount"];
[&](){pipelineStageCreationFeedbackCount_json=member.pipelineStageCreationFeedbackCount;}();
auto& pPipelineStageCreationFeedbacks_json=json["pPipelineStageCreationFeedbacks"];
[&](){
            if (member.pPipelineStageCreationFeedbacks==NULL){
                pPipelineStageCreationFeedbacks_json=boost::json::array();
            return; }pPipelineStageCreationFeedbacks_json=boost::json::array(member.pipelineStageCreationFeedbackCount);
        auto& arr_RxVpsqW=pPipelineStageCreationFeedbacks_json.as_array();
        for(int xcJecwD=0; xcJecwD < member.pipelineStageCreationFeedbackCount; xcJecwD++){
            [&](){
            auto& temp=arr_RxVpsqW[xcJecwD].emplace_object();
            return serialize_struct(temp, member.pPipelineStageCreationFeedbacks[xcJecwD]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineCreationFeedbackCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pPipelineCreationFeedback_json=json["pPipelineCreationFeedback"];
[&](){
            if (pPipelineCreationFeedback_json.as_array().size()==0){
                member.pPipelineCreationFeedback=NULL;
            return; }member.pPipelineCreationFeedback=(VkPipelineCreationFeedback*)malloc(1*sizeof(VkPipelineCreationFeedback));
        auto& arr_bLfUuds=pPipelineCreationFeedback_json.as_array();
        for(int Xwezzqt=0; Xwezzqt < 1; Xwezzqt++){
            [&](){
            auto& temp=arr_bLfUuds[Xwezzqt].as_object();
            deserialize_struct(temp,member.pPipelineCreationFeedback[Xwezzqt]);
            }();
        }
        }();
auto& pipelineStageCreationFeedbackCount_json=json["pipelineStageCreationFeedbackCount"];
[&](){member.pipelineStageCreationFeedbackCount=static_cast<uint32_t>(value_to<int>(pipelineStageCreationFeedbackCount_json));}();
auto& pPipelineStageCreationFeedbacks_json=json["pPipelineStageCreationFeedbacks"];
[&](){
            if (pPipelineStageCreationFeedbacks_json.as_array().size()==0){
                member.pPipelineStageCreationFeedbacks=NULL;
            return; }member.pPipelineStageCreationFeedbacks=(VkPipelineCreationFeedback*)malloc(member.pipelineStageCreationFeedbackCount*sizeof(VkPipelineCreationFeedback));
        auto& arr_RxVpsqW=pPipelineStageCreationFeedbacks_json.as_array();
        for(int xcJecwD=0; xcJecwD < member.pipelineStageCreationFeedbackCount; xcJecwD++){
            [&](){
            auto& temp=arr_RxVpsqW[xcJecwD].as_object();
            deserialize_struct(temp,member.pPipelineStageCreationFeedbacks[xcJecwD]);
            }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePresentBarrierFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& presentBarrier_json=json["presentBarrier"];
[&](){[&](){presentBarrier_json=member.presentBarrier;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePresentBarrierFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& presentBarrier_json=json["presentBarrier"];
[&](){uint32_t temp_YlgOErj;[&](){temp_YlgOErj=static_cast<uint32_t>(value_to<int>(presentBarrier_json));}();member.presentBarrier=(VkBool32)temp_YlgOErj;}();
}

    void serialize_struct(boost::json::object& json, const VkSurfaceCapabilitiesPresentBarrierNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& presentBarrierSupported_json=json["presentBarrierSupported"];
[&](){[&](){presentBarrierSupported_json=member.presentBarrierSupported;}();}();
}
void deserialize_struct(boost::json::object& json, VkSurfaceCapabilitiesPresentBarrierNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& presentBarrierSupported_json=json["presentBarrierSupported"];
[&](){uint32_t temp_OagmxMZ;[&](){temp_OagmxMZ=static_cast<uint32_t>(value_to<int>(presentBarrierSupported_json));}();member.presentBarrierSupported=(VkBool32)temp_OagmxMZ;}();
}

    void serialize_struct(boost::json::object& json, const VkSwapchainPresentBarrierCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& presentBarrierEnable_json=json["presentBarrierEnable"];
[&](){[&](){presentBarrierEnable_json=member.presentBarrierEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkSwapchainPresentBarrierCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& presentBarrierEnable_json=json["presentBarrierEnable"];
[&](){uint32_t temp_mIzglzM;[&](){temp_mIzglzM=static_cast<uint32_t>(value_to<int>(presentBarrierEnable_json));}();member.presentBarrierEnable=(VkBool32)temp_mIzglzM;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePerformanceQueryFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& performanceCounterQueryPools_json=json["performanceCounterQueryPools"];
[&](){[&](){performanceCounterQueryPools_json=member.performanceCounterQueryPools;}();}();
auto& performanceCounterMultipleQueryPools_json=json["performanceCounterMultipleQueryPools"];
[&](){[&](){performanceCounterMultipleQueryPools_json=member.performanceCounterMultipleQueryPools;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePerformanceQueryFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& performanceCounterQueryPools_json=json["performanceCounterQueryPools"];
[&](){uint32_t temp_Iqdromp;[&](){temp_Iqdromp=static_cast<uint32_t>(value_to<int>(performanceCounterQueryPools_json));}();member.performanceCounterQueryPools=(VkBool32)temp_Iqdromp;}();
auto& performanceCounterMultipleQueryPools_json=json["performanceCounterMultipleQueryPools"];
[&](){uint32_t temp_VKdLgkj;[&](){temp_VKdLgkj=static_cast<uint32_t>(value_to<int>(performanceCounterMultipleQueryPools_json));}();member.performanceCounterMultipleQueryPools=(VkBool32)temp_VKdLgkj;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePerformanceQueryPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& allowCommandBufferQueryCopies_json=json["allowCommandBufferQueryCopies"];
[&](){[&](){allowCommandBufferQueryCopies_json=member.allowCommandBufferQueryCopies;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePerformanceQueryPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& allowCommandBufferQueryCopies_json=json["allowCommandBufferQueryCopies"];
[&](){uint32_t temp_KpDAzlT;[&](){temp_KpDAzlT=static_cast<uint32_t>(value_to<int>(allowCommandBufferQueryCopies_json));}();member.allowCommandBufferQueryCopies=(VkBool32)temp_KpDAzlT;}();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceCounterKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& unit_json=json["unit"];
[&](){[&](){[&](){unit_json=member.unit;}();}();}();
auto& scope_json=json["scope"];
[&](){[&](){[&](){scope_json=member.scope;}();}();}();
auto& storage_json=json["storage"];
[&](){[&](){[&](){storage_json=member.storage;}();}();}();
auto& uuid_json=json["uuid"];
[&](){uuid_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_soRjxlm=uuid_json.as_array();
        for(int NXzLCHH=0; NXzLCHH < VK_UUID_SIZE; NXzLCHH++){
            [&](){arr_soRjxlm[NXzLCHH]=member.uuid[NXzLCHH];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPerformanceCounterKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& unit_json=json["unit"];
[&](){[&](){int temp_sZHLJsz;[&](){temp_sZHLJsz=static_cast<int>(value_to<int>(unit_json));}();member.unit=(VkPerformanceCounterUnitKHR)temp_sZHLJsz;}();}();
auto& scope_json=json["scope"];
[&](){[&](){int temp_kMyHQFd;[&](){temp_kMyHQFd=static_cast<int>(value_to<int>(scope_json));}();member.scope=(VkPerformanceCounterScopeKHR)temp_kMyHQFd;}();}();
auto& storage_json=json["storage"];
[&](){[&](){int temp_xyFjISn;[&](){temp_xyFjISn=static_cast<int>(value_to<int>(storage_json));}();member.storage=(VkPerformanceCounterStorageKHR)temp_xyFjISn;}();}();
auto& uuid_json=json["uuid"];
[&](){
        auto& arr_soRjxlm=uuid_json.as_array();
        for(int NXzLCHH=0; NXzLCHH < VK_UUID_SIZE; NXzLCHH++){
            [&](){member.uuid[NXzLCHH]=static_cast<uint8_t>(value_to<int>(arr_soRjxlm[NXzLCHH]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceCounterDescriptionKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& name_json=json["name"];
[&](){name_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_WlDeXhg=name_json.as_array();
        for(int wRQbmpj=0; wRQbmpj < VK_MAX_DESCRIPTION_SIZE; wRQbmpj++){
            [&](){arr_WlDeXhg[wRQbmpj]=member.name[wRQbmpj];}();
        }
        }();
auto& category_json=json["category"];
[&](){category_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_wppWtuV=category_json.as_array();
        for(int lvjMeQH=0; lvjMeQH < VK_MAX_DESCRIPTION_SIZE; lvjMeQH++){
            [&](){arr_wppWtuV[lvjMeQH]=member.category[lvjMeQH];}();
        }
        }();
auto& description_json=json["description"];
[&](){description_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){arr_XKStCoi[xOHuflK]=member.description[xOHuflK];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPerformanceCounterDescriptionKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_aycTwLG;[&](){temp_aycTwLG=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPerformanceCounterDescriptionFlagsKHR)temp_aycTwLG;}();}();
auto& name_json=json["name"];
[&](){
        auto& arr_WlDeXhg=name_json.as_array();
        for(int wRQbmpj=0; wRQbmpj < VK_MAX_DESCRIPTION_SIZE; wRQbmpj++){
            [&](){member.name[wRQbmpj]=static_cast<char>(value_to<int>(arr_WlDeXhg[wRQbmpj]));}();
        }
        }();
auto& category_json=json["category"];
[&](){
        auto& arr_wppWtuV=category_json.as_array();
        for(int lvjMeQH=0; lvjMeQH < VK_MAX_DESCRIPTION_SIZE; lvjMeQH++){
            [&](){member.category[lvjMeQH]=static_cast<char>(value_to<int>(arr_wppWtuV[lvjMeQH]));}();
        }
        }();
auto& description_json=json["description"];
[&](){
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){member.description[xOHuflK]=static_cast<char>(value_to<int>(arr_XKStCoi[xOHuflK]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkQueryPoolPerformanceCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){queueFamilyIndex_json=member.queueFamilyIndex;}();
auto& counterIndexCount_json=json["counterIndexCount"];
[&](){counterIndexCount_json=member.counterIndexCount;}();
auto& pCounterIndices_json=json["pCounterIndices"];
[&](){
            if (member.pCounterIndices==NULL){
                pCounterIndices_json=boost::json::array();
            return; }pCounterIndices_json=boost::json::array(member.counterIndexCount);
        auto& arr_mnDpJbd=pCounterIndices_json.as_array();
        for(int yLZRUEg=0; yLZRUEg < member.counterIndexCount; yLZRUEg++){
            [&](){arr_mnDpJbd[yLZRUEg]=member.pCounterIndices[yLZRUEg];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkQueryPoolPerformanceCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){member.queueFamilyIndex=static_cast<uint32_t>(value_to<int>(queueFamilyIndex_json));}();
auto& counterIndexCount_json=json["counterIndexCount"];
[&](){member.counterIndexCount=static_cast<uint32_t>(value_to<int>(counterIndexCount_json));}();
auto& pCounterIndices_json=json["pCounterIndices"];
[&](){ uint32_t* temp_dgNQIpA;;[&](){
            if (pCounterIndices_json.as_array().size()==0){
                temp_dgNQIpA=NULL;
            return; }temp_dgNQIpA=(uint32_t*)malloc(member.counterIndexCount*sizeof(uint32_t));
        auto& arr_aAhHEgP=pCounterIndices_json.as_array();
        for(int HQIKsyP=0; HQIKsyP < member.counterIndexCount; HQIKsyP++){
            [&](){temp_dgNQIpA[HQIKsyP]=static_cast<uint32_t>(value_to<int>(arr_aAhHEgP[HQIKsyP]));}();
        }
        }();member.pCounterIndices=temp_dgNQIpA;}();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceCounterResultKHR& member){
        
    
auto& int32_json=json["int32"];
[&](){int32_json=member.int32;}();
auto& int64_json=json["int64"];
[&](){int64_json=member.int64;}();
auto& uint32_json=json["uint32"];
[&](){uint32_json=member.uint32;}();
auto& uint64_json=json["uint64"];
[&](){uint64_json=member.uint64;}();
auto& float32_json=json["float32"];
[&](){float32_json=member.float32;}();
auto& float64_json=json["float64"];
[&](){float64_json=member.float64;}();
}
void deserialize_struct(boost::json::object& json, VkPerformanceCounterResultKHR& member){
auto& int32_json=json["int32"];
[&](){member.int32=static_cast<int32_t>(value_to<int>(int32_json));}();
auto& int64_json=json["int64"];
[&](){member.int64=static_cast<int64_t>(value_to<int>(int64_json));}();
auto& uint32_json=json["uint32"];
[&](){member.uint32=static_cast<uint32_t>(value_to<int>(uint32_json));}();
auto& uint64_json=json["uint64"];
[&](){member.uint64=static_cast<uint64_t>(value_to<int>(uint64_json));}();
auto& float32_json=json["float32"];
[&](){member.float32=static_cast<float>(value_to<int>(float32_json));}();
auto& float64_json=json["float64"];
[&](){member.float64=static_cast<double>(value_to<int>(float64_json));}();
}

    void serialize_struct(boost::json::object& json, const VkAcquireProfilingLockInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& timeout_json=json["timeout"];
[&](){timeout_json=member.timeout;}();
}
void deserialize_struct(boost::json::object& json, VkAcquireProfilingLockInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_rCtZfsb;[&](){temp_rCtZfsb=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkAcquireProfilingLockFlagsKHR)temp_rCtZfsb;}();}();
auto& timeout_json=json["timeout"];
[&](){member.timeout=static_cast<uint64_t>(value_to<int>(timeout_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceQuerySubmitInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& counterPassIndex_json=json["counterPassIndex"];
[&](){counterPassIndex_json=member.counterPassIndex;}();
}
void deserialize_struct(boost::json::object& json, VkPerformanceQuerySubmitInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& counterPassIndex_json=json["counterPassIndex"];
[&](){member.counterPassIndex=static_cast<uint32_t>(value_to<int>(counterPassIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkHeadlessSurfaceCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkHeadlessSurfaceCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_gLePalU;[&](){temp_gLePalU=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkHeadlessSurfaceCreateFlagsEXT)temp_gLePalU;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCoverageReductionModeFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& coverageReductionMode_json=json["coverageReductionMode"];
[&](){[&](){coverageReductionMode_json=member.coverageReductionMode;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCoverageReductionModeFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& coverageReductionMode_json=json["coverageReductionMode"];
[&](){uint32_t temp_lHGwQiY;[&](){temp_lHGwQiY=static_cast<uint32_t>(value_to<int>(coverageReductionMode_json));}();member.coverageReductionMode=(VkBool32)temp_lHGwQiY;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineCoverageReductionStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& coverageReductionMode_json=json["coverageReductionMode"];
[&](){[&](){[&](){coverageReductionMode_json=member.coverageReductionMode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineCoverageReductionStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_yIvimVQ;[&](){temp_yIvimVQ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkPipelineCoverageReductionStateCreateFlagsNV)temp_yIvimVQ;}();}();
auto& coverageReductionMode_json=json["coverageReductionMode"];
[&](){[&](){int temp_nnZPBQU;[&](){temp_nnZPBQU=static_cast<int>(value_to<int>(coverageReductionMode_json));}();member.coverageReductionMode=(VkCoverageReductionModeNV)temp_nnZPBQU;}();}();
}

    void serialize_struct(boost::json::object& json, const VkFramebufferMixedSamplesCombinationNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& coverageReductionMode_json=json["coverageReductionMode"];
[&](){[&](){[&](){coverageReductionMode_json=member.coverageReductionMode;}();}();}();
auto& rasterizationSamples_json=json["rasterizationSamples"];
[&](){[&](){[&](){rasterizationSamples_json=member.rasterizationSamples;}();}();}();
auto& depthStencilSamples_json=json["depthStencilSamples"];
[&](){[&](){[&](){depthStencilSamples_json=member.depthStencilSamples;}();}();}();
auto& colorSamples_json=json["colorSamples"];
[&](){[&](){[&](){colorSamples_json=member.colorSamples;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkFramebufferMixedSamplesCombinationNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& coverageReductionMode_json=json["coverageReductionMode"];
[&](){[&](){int temp_nnZPBQU;[&](){temp_nnZPBQU=static_cast<int>(value_to<int>(coverageReductionMode_json));}();member.coverageReductionMode=(VkCoverageReductionModeNV)temp_nnZPBQU;}();}();
auto& rasterizationSamples_json=json["rasterizationSamples"];
[&](){[&](){int temp_cDVWodo;[&](){temp_cDVWodo=static_cast<int>(value_to<int>(rasterizationSamples_json));}();member.rasterizationSamples=(VkSampleCountFlagBits)temp_cDVWodo;}();}();
auto& depthStencilSamples_json=json["depthStencilSamples"];
[&](){[&](){int temp_vBmCfCD;[&](){temp_vBmCfCD=static_cast<int>(value_to<int>(depthStencilSamples_json));}();member.depthStencilSamples=(VkSampleCountFlags)temp_vBmCfCD;}();}();
auto& colorSamples_json=json["colorSamples"];
[&](){[&](){int temp_VxHoEWJ;[&](){temp_VxHoEWJ=static_cast<int>(value_to<int>(colorSamples_json));}();member.colorSamples=(VkSampleCountFlags)temp_VxHoEWJ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderIntegerFunctions2_json=json["shaderIntegerFunctions2"];
[&](){[&](){shaderIntegerFunctions2_json=member.shaderIntegerFunctions2;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderIntegerFunctions2_json=json["shaderIntegerFunctions2"];
[&](){uint32_t temp_xmZTMaP;[&](){temp_xmZTMaP=static_cast<uint32_t>(value_to<int>(shaderIntegerFunctions2_json));}();member.shaderIntegerFunctions2=(VkBool32)temp_xmZTMaP;}();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceValueDataINTEL& member){
        
    
auto& value32_json=json["value32"];
[&](){value32_json=member.value32;}();
auto& value64_json=json["value64"];
[&](){value64_json=member.value64;}();
auto& valueFloat_json=json["valueFloat"];
[&](){valueFloat_json=member.valueFloat;}();
auto& valueBool_json=json["valueBool"];
[&](){[&](){valueBool_json=member.valueBool;}();}();
auto& valueString_json=json["valueString"];
[&](){
            if (member.valueString==NULL){
                valueString_json=boost::json::array();
            return; }valueString_json=boost::json::array(strlen(member.valueString)+1);
        auto& arr_dpbPntF=valueString_json.as_array();
        for(int vBjwNMH=0; vBjwNMH < strlen(member.valueString)+1; vBjwNMH++){
            [&](){arr_dpbPntF[vBjwNMH]=member.valueString[vBjwNMH];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPerformanceValueDataINTEL& member){
auto& value32_json=json["value32"];
[&](){member.value32=static_cast<uint32_t>(value_to<int>(value32_json));}();
auto& value64_json=json["value64"];
[&](){member.value64=static_cast<uint64_t>(value_to<int>(value64_json));}();
auto& valueFloat_json=json["valueFloat"];
[&](){member.valueFloat=static_cast<float>(value_to<int>(valueFloat_json));}();
auto& valueBool_json=json["valueBool"];
[&](){uint32_t temp_diDcRZV;[&](){temp_diDcRZV=static_cast<uint32_t>(value_to<int>(valueBool_json));}();member.valueBool=(VkBool32)temp_diDcRZV;}();
auto& valueString_json=json["valueString"];
[&](){ char* temp_SXBtUvU;;[&](){
            if (valueString_json.as_array().size()==0){
                temp_SXBtUvU=NULL;
            return; }temp_SXBtUvU=(char*)malloc(valueString_json.as_array().size()*sizeof(char));
        auto& arr_kWSTvsX=valueString_json.as_array();
        for(int cCnjzgq=0; cCnjzgq < valueString_json.as_array().size(); cCnjzgq++){
            [&](){temp_SXBtUvU[cCnjzgq]=static_cast<char>(value_to<int>(arr_kWSTvsX[cCnjzgq]));}();
        }
        }();member.valueString=temp_SXBtUvU;}();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceValueINTEL& member){
        
    
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.emplace_object();
            return serialize_struct(temp, member.data);
            }();
}
void deserialize_struct(boost::json::object& json, VkPerformanceValueINTEL& member){
auto& type_json=json["type"];
[&](){[&](){int temp_edcPVjo;[&](){temp_edcPVjo=static_cast<int>(value_to<int>(type_json));}();member.type=(VkPerformanceValueTypeINTEL)temp_edcPVjo;}();}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.as_object();
            deserialize_struct(temp,member.data);
            }();
}

        void serialize_pUserData(boost::json::object& json, const VkInitializePerformanceApiInfoINTEL& member){
        auto& pUserData_json=json["pUserData"];
        
[&](){
            if (member.pUserData==NULL){
                pUserData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pUserData))==NULL){
                pUserData_json=boost::json::array();
            return; }pUserData_json=boost::json::array(strlen(((char*)(member.pUserData)))+1);
        auto& arr_svgqjpy=pUserData_json.as_array();
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData)))+1; lQswvtW++){
            [&](){arr_svgqjpy[lQswvtW]=((char*)(member.pUserData))[lQswvtW];}();
        }
        }();}();
}

        void deserialize_pUserData(boost::json::object& json, VkInitializePerformanceApiInfoINTEL& member){
            #ifdef CLIENT
               void* pUserData;
               [&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData=temp_YghEUhF;}();
            #else 
                auto pUserData=new pUserData_struct();
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData->pUserData=NULL;
            return; }char* temp_YghEUhF;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_YghEUhF=NULL;
            return; }temp_YghEUhF=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_svgqjpy=json["pUserData"].as_array();
        for(int lQswvtW=0; lQswvtW < json["pUserData"].as_array().size(); lQswvtW++){
            [&](){temp_YghEUhF[lQswvtW]=static_cast<char>(value_to<int>(arr_svgqjpy[lQswvtW]));}();
        }
        }();pUserData->pUserData=temp_YghEUhF;}();

        #endif
        member.pUserData=pUserData;
        }
        

    void serialize_struct(boost::json::object& json, const VkInitializePerformanceApiInfoINTEL& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.emplace_object();
            serialize_pUserData(pUserData_json_1, member);
            
}
void deserialize_struct(boost::json::object& json, VkInitializePerformanceApiInfoINTEL& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pUserData_json=json["pUserData"];

            auto& pUserData_json_1=pUserData_json.as_object();
            deserialize_pUserData(pUserData_json_1, member);
            
}

    void serialize_struct(boost::json::object& json, const VkQueryPoolPerformanceQueryCreateInfoINTEL& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& performanceCountersSampling_json=json["performanceCountersSampling"];
[&](){[&](){[&](){performanceCountersSampling_json=member.performanceCountersSampling;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkQueryPoolPerformanceQueryCreateInfoINTEL& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& performanceCountersSampling_json=json["performanceCountersSampling"];
[&](){[&](){int temp_wtMfHdu;[&](){temp_wtMfHdu=static_cast<int>(value_to<int>(performanceCountersSampling_json));}();member.performanceCountersSampling=(VkQueryPoolSamplingModeINTEL)temp_wtMfHdu;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceMarkerInfoINTEL& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& marker_json=json["marker"];
[&](){marker_json=member.marker;}();
}
void deserialize_struct(boost::json::object& json, VkPerformanceMarkerInfoINTEL& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& marker_json=json["marker"];
[&](){member.marker=static_cast<uint64_t>(value_to<int>(marker_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceStreamMarkerInfoINTEL& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& marker_json=json["marker"];
[&](){marker_json=member.marker;}();
}
void deserialize_struct(boost::json::object& json, VkPerformanceStreamMarkerInfoINTEL& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& marker_json=json["marker"];
[&](){member.marker=static_cast<uint32_t>(value_to<int>(marker_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceOverrideInfoINTEL& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& enable_json=json["enable"];
[&](){[&](){enable_json=member.enable;}();}();
auto& parameter_json=json["parameter"];
[&](){parameter_json=member.parameter;}();
}
void deserialize_struct(boost::json::object& json, VkPerformanceOverrideInfoINTEL& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& type_json=json["type"];
[&](){[&](){int temp_JqnmrTJ;[&](){temp_JqnmrTJ=static_cast<int>(value_to<int>(type_json));}();member.type=(VkPerformanceOverrideTypeINTEL)temp_JqnmrTJ;}();}();
auto& enable_json=json["enable"];
[&](){uint32_t temp_BvPtCgW;[&](){temp_BvPtCgW=static_cast<uint32_t>(value_to<int>(enable_json));}();member.enable=(VkBool32)temp_BvPtCgW;}();
auto& parameter_json=json["parameter"];
[&](){member.parameter=static_cast<uint64_t>(value_to<int>(parameter_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPerformanceConfigurationAcquireInfoINTEL& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPerformanceConfigurationAcquireInfoINTEL& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& type_json=json["type"];
[&](){[&](){int temp_RrIblbO;[&](){temp_RrIblbO=static_cast<int>(value_to<int>(type_json));}();member.type=(VkPerformanceConfigurationTypeINTEL)temp_RrIblbO;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderClockFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderSubgroupClock_json=json["shaderSubgroupClock"];
[&](){[&](){shaderSubgroupClock_json=member.shaderSubgroupClock;}();}();
auto& shaderDeviceClock_json=json["shaderDeviceClock"];
[&](){[&](){shaderDeviceClock_json=member.shaderDeviceClock;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderClockFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderSubgroupClock_json=json["shaderSubgroupClock"];
[&](){uint32_t temp_NLpDLhU;[&](){temp_NLpDLhU=static_cast<uint32_t>(value_to<int>(shaderSubgroupClock_json));}();member.shaderSubgroupClock=(VkBool32)temp_NLpDLhU;}();
auto& shaderDeviceClock_json=json["shaderDeviceClock"];
[&](){uint32_t temp_iPOOcek;[&](){temp_iPOOcek=static_cast<uint32_t>(value_to<int>(shaderDeviceClock_json));}();member.shaderDeviceClock=(VkBool32)temp_iPOOcek;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceIndexTypeUint8FeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& indexTypeUint8_json=json["indexTypeUint8"];
[&](){[&](){indexTypeUint8_json=member.indexTypeUint8;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceIndexTypeUint8FeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& indexTypeUint8_json=json["indexTypeUint8"];
[&](){uint32_t temp_ghcBVuG;[&](){temp_ghcBVuG=static_cast<uint32_t>(value_to<int>(indexTypeUint8_json));}();member.indexTypeUint8=(VkBool32)temp_ghcBVuG;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderSMCount_json=json["shaderSMCount"];
[&](){shaderSMCount_json=member.shaderSMCount;}();
auto& shaderWarpsPerSM_json=json["shaderWarpsPerSM"];
[&](){shaderWarpsPerSM_json=member.shaderWarpsPerSM;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderSMCount_json=json["shaderSMCount"];
[&](){member.shaderSMCount=static_cast<uint32_t>(value_to<int>(shaderSMCount_json));}();
auto& shaderWarpsPerSM_json=json["shaderWarpsPerSM"];
[&](){member.shaderWarpsPerSM=static_cast<uint32_t>(value_to<int>(shaderWarpsPerSM_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderSMBuiltins_json=json["shaderSMBuiltins"];
[&](){[&](){shaderSMBuiltins_json=member.shaderSMBuiltins;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderSMBuiltins_json=json["shaderSMBuiltins"];
[&](){uint32_t temp_JIcuJJq;[&](){temp_JIcuJJq=static_cast<uint32_t>(value_to<int>(shaderSMBuiltins_json));}();member.shaderSMBuiltins=(VkBool32)temp_JIcuJJq;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentShaderSampleInterlock_json=json["fragmentShaderSampleInterlock"];
[&](){[&](){fragmentShaderSampleInterlock_json=member.fragmentShaderSampleInterlock;}();}();
auto& fragmentShaderPixelInterlock_json=json["fragmentShaderPixelInterlock"];
[&](){[&](){fragmentShaderPixelInterlock_json=member.fragmentShaderPixelInterlock;}();}();
auto& fragmentShaderShadingRateInterlock_json=json["fragmentShaderShadingRateInterlock"];
[&](){[&](){fragmentShaderShadingRateInterlock_json=member.fragmentShaderShadingRateInterlock;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& fragmentShaderSampleInterlock_json=json["fragmentShaderSampleInterlock"];
[&](){uint32_t temp_qxejHQG;[&](){temp_qxejHQG=static_cast<uint32_t>(value_to<int>(fragmentShaderSampleInterlock_json));}();member.fragmentShaderSampleInterlock=(VkBool32)temp_qxejHQG;}();
auto& fragmentShaderPixelInterlock_json=json["fragmentShaderPixelInterlock"];
[&](){uint32_t temp_myvpsbN;[&](){temp_myvpsbN=static_cast<uint32_t>(value_to<int>(fragmentShaderPixelInterlock_json));}();member.fragmentShaderPixelInterlock=(VkBool32)temp_myvpsbN;}();
auto& fragmentShaderShadingRateInterlock_json=json["fragmentShaderShadingRateInterlock"];
[&](){uint32_t temp_JLlNszD;[&](){temp_JLlNszD=static_cast<uint32_t>(value_to<int>(fragmentShaderShadingRateInterlock_json));}();member.fragmentShaderShadingRateInterlock=(VkBool32)temp_JLlNszD;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& separateDepthStencilLayouts_json=json["separateDepthStencilLayouts"];
[&](){[&](){separateDepthStencilLayouts_json=member.separateDepthStencilLayouts;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& separateDepthStencilLayouts_json=json["separateDepthStencilLayouts"];
[&](){uint32_t temp_XLmmIxV;[&](){temp_XLmmIxV=static_cast<uint32_t>(value_to<int>(separateDepthStencilLayouts_json));}();member.separateDepthStencilLayouts=(VkBool32)temp_XLmmIxV;}();
}

    void serialize_struct(boost::json::object& json, const VkAttachmentReferenceStencilLayout& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stencilLayout_json=json["stencilLayout"];
[&](){[&](){[&](){stencilLayout_json=member.stencilLayout;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkAttachmentReferenceStencilLayout& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& stencilLayout_json=json["stencilLayout"];
[&](){[&](){int temp_UHuHaFd;[&](){temp_UHuHaFd=static_cast<int>(value_to<int>(stencilLayout_json));}();member.stencilLayout=(VkImageLayout)temp_UHuHaFd;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& primitiveTopologyListRestart_json=json["primitiveTopologyListRestart"];
[&](){[&](){primitiveTopologyListRestart_json=member.primitiveTopologyListRestart;}();}();
auto& primitiveTopologyPatchListRestart_json=json["primitiveTopologyPatchListRestart"];
[&](){[&](){primitiveTopologyPatchListRestart_json=member.primitiveTopologyPatchListRestart;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& primitiveTopologyListRestart_json=json["primitiveTopologyListRestart"];
[&](){uint32_t temp_DnJkPYS;[&](){temp_DnJkPYS=static_cast<uint32_t>(value_to<int>(primitiveTopologyListRestart_json));}();member.primitiveTopologyListRestart=(VkBool32)temp_DnJkPYS;}();
auto& primitiveTopologyPatchListRestart_json=json["primitiveTopologyPatchListRestart"];
[&](){uint32_t temp_JmIyIaf;[&](){temp_JmIyIaf=static_cast<uint32_t>(value_to<int>(primitiveTopologyPatchListRestart_json));}();member.primitiveTopologyPatchListRestart=(VkBool32)temp_JmIyIaf;}();
}

    void serialize_struct(boost::json::object& json, const VkAttachmentDescriptionStencilLayout& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stencilInitialLayout_json=json["stencilInitialLayout"];
[&](){[&](){[&](){stencilInitialLayout_json=member.stencilInitialLayout;}();}();}();
auto& stencilFinalLayout_json=json["stencilFinalLayout"];
[&](){[&](){[&](){stencilFinalLayout_json=member.stencilFinalLayout;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkAttachmentDescriptionStencilLayout& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& stencilInitialLayout_json=json["stencilInitialLayout"];
[&](){[&](){int temp_aGVeNof;[&](){temp_aGVeNof=static_cast<int>(value_to<int>(stencilInitialLayout_json));}();member.stencilInitialLayout=(VkImageLayout)temp_aGVeNof;}();}();
auto& stencilFinalLayout_json=json["stencilFinalLayout"];
[&](){[&](){int temp_ydVFKdW;[&](){temp_ydVFKdW=static_cast<int>(value_to<int>(stencilFinalLayout_json));}();member.stencilFinalLayout=(VkImageLayout)temp_ydVFKdW;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineExecutableInfo_json=json["pipelineExecutableInfo"];
[&](){[&](){pipelineExecutableInfo_json=member.pipelineExecutableInfo;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pipelineExecutableInfo_json=json["pipelineExecutableInfo"];
[&](){uint32_t temp_uDiRbgU;[&](){temp_uDiRbgU=static_cast<uint32_t>(value_to<int>(pipelineExecutableInfo_json));}();member.pipelineExecutableInfo=(VkBool32)temp_uDiRbgU;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipeline_json=json["pipeline"];
[&](){serialize_VkPipeline(pipeline_json,member.pipeline);}();
}
void deserialize_struct(boost::json::object& json, VkPipelineInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pipeline_json=json["pipeline"];
[&](){deserialize_VkPipeline(pipeline_json, member.pipeline);}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineExecutablePropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stages_json=json["stages"];
[&](){[&](){[&](){stages_json=member.stages;}();}();}();
auto& name_json=json["name"];
[&](){name_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_WlDeXhg=name_json.as_array();
        for(int wRQbmpj=0; wRQbmpj < VK_MAX_DESCRIPTION_SIZE; wRQbmpj++){
            [&](){arr_WlDeXhg[wRQbmpj]=member.name[wRQbmpj];}();
        }
        }();
auto& description_json=json["description"];
[&](){description_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){arr_XKStCoi[xOHuflK]=member.description[xOHuflK];}();
        }
        }();
auto& subgroupSize_json=json["subgroupSize"];
[&](){subgroupSize_json=member.subgroupSize;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineExecutablePropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& stages_json=json["stages"];
[&](){[&](){int temp_uPdcRug;[&](){temp_uPdcRug=static_cast<int>(value_to<int>(stages_json));}();member.stages=(VkShaderStageFlags)temp_uPdcRug;}();}();
auto& name_json=json["name"];
[&](){
        auto& arr_WlDeXhg=name_json.as_array();
        for(int wRQbmpj=0; wRQbmpj < VK_MAX_DESCRIPTION_SIZE; wRQbmpj++){
            [&](){member.name[wRQbmpj]=static_cast<char>(value_to<int>(arr_WlDeXhg[wRQbmpj]));}();
        }
        }();
auto& description_json=json["description"];
[&](){
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){member.description[xOHuflK]=static_cast<char>(value_to<int>(arr_XKStCoi[xOHuflK]));}();
        }
        }();
auto& subgroupSize_json=json["subgroupSize"];
[&](){member.subgroupSize=static_cast<uint32_t>(value_to<int>(subgroupSize_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineExecutableInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipeline_json=json["pipeline"];
[&](){serialize_VkPipeline(pipeline_json,member.pipeline);}();
auto& executableIndex_json=json["executableIndex"];
[&](){executableIndex_json=member.executableIndex;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineExecutableInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pipeline_json=json["pipeline"];
[&](){deserialize_VkPipeline(pipeline_json, member.pipeline);}();
auto& executableIndex_json=json["executableIndex"];
[&](){member.executableIndex=static_cast<uint32_t>(value_to<int>(executableIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineExecutableStatisticValueKHR& member){
        
    
auto& b32_json=json["b32"];
[&](){[&](){b32_json=member.b32;}();}();
auto& i64_json=json["i64"];
[&](){i64_json=member.i64;}();
auto& u64_json=json["u64"];
[&](){u64_json=member.u64;}();
auto& f64_json=json["f64"];
[&](){f64_json=member.f64;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineExecutableStatisticValueKHR& member){
auto& b32_json=json["b32"];
[&](){uint32_t temp_KazzmuN;[&](){temp_KazzmuN=static_cast<uint32_t>(value_to<int>(b32_json));}();member.b32=(VkBool32)temp_KazzmuN;}();
auto& i64_json=json["i64"];
[&](){member.i64=static_cast<int64_t>(value_to<int>(i64_json));}();
auto& u64_json=json["u64"];
[&](){member.u64=static_cast<uint64_t>(value_to<int>(u64_json));}();
auto& f64_json=json["f64"];
[&](){member.f64=static_cast<double>(value_to<int>(f64_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineExecutableStatisticKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& name_json=json["name"];
[&](){name_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_WlDeXhg=name_json.as_array();
        for(int wRQbmpj=0; wRQbmpj < VK_MAX_DESCRIPTION_SIZE; wRQbmpj++){
            [&](){arr_WlDeXhg[wRQbmpj]=member.name[wRQbmpj];}();
        }
        }();
auto& description_json=json["description"];
[&](){description_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){arr_XKStCoi[xOHuflK]=member.description[xOHuflK];}();
        }
        }();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& value_json=json["value"];
[&](){
            auto& temp=value_json.emplace_object();
            return serialize_struct(temp, member.value);
            }();
}
void deserialize_struct(boost::json::object& json, VkPipelineExecutableStatisticKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& name_json=json["name"];
[&](){
        auto& arr_WlDeXhg=name_json.as_array();
        for(int wRQbmpj=0; wRQbmpj < VK_MAX_DESCRIPTION_SIZE; wRQbmpj++){
            [&](){member.name[wRQbmpj]=static_cast<char>(value_to<int>(arr_WlDeXhg[wRQbmpj]));}();
        }
        }();
auto& description_json=json["description"];
[&](){
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){member.description[xOHuflK]=static_cast<char>(value_to<int>(arr_XKStCoi[xOHuflK]));}();
        }
        }();
auto& format_json=json["format"];
[&](){[&](){int temp_tGDLITY;[&](){temp_tGDLITY=static_cast<int>(value_to<int>(format_json));}();member.format=(VkPipelineExecutableStatisticFormatKHR)temp_tGDLITY;}();}();
auto& value_json=json["value"];
[&](){
            auto& temp=value_json.as_object();
            deserialize_struct(temp,member.value);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPipelineExecutableInternalRepresentationKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& name_json=json["name"];
[&](){name_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_WlDeXhg=name_json.as_array();
        for(int wRQbmpj=0; wRQbmpj < VK_MAX_DESCRIPTION_SIZE; wRQbmpj++){
            [&](){arr_WlDeXhg[wRQbmpj]=member.name[wRQbmpj];}();
        }
        }();
auto& description_json=json["description"];
[&](){description_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){arr_XKStCoi[xOHuflK]=member.description[xOHuflK];}();
        }
        }();
auto& isText_json=json["isText"];
[&](){[&](){isText_json=member.isText;}();}();
auto& dataSize_json=json["dataSize"];
[&](){dataSize_json=member.dataSize;}();
auto& pData_json=json["pData"];
[&](){
            if (member.pData==NULL){
                pData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pData))==NULL){
                pData_json=boost::json::array();
            return; }pData_json=boost::json::array(member.dataSize);
        auto& arr_BbZMMzi=pData_json.as_array();
        for(int NEiuWIo=0; NEiuWIo < member.dataSize; NEiuWIo++){
            [&](){arr_BbZMMzi[NEiuWIo]=((char*)(member.pData))[NEiuWIo];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineExecutableInternalRepresentationKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& name_json=json["name"];
[&](){
        auto& arr_WlDeXhg=name_json.as_array();
        for(int wRQbmpj=0; wRQbmpj < VK_MAX_DESCRIPTION_SIZE; wRQbmpj++){
            [&](){member.name[wRQbmpj]=static_cast<char>(value_to<int>(arr_WlDeXhg[wRQbmpj]));}();
        }
        }();
auto& description_json=json["description"];
[&](){
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){member.description[xOHuflK]=static_cast<char>(value_to<int>(arr_XKStCoi[xOHuflK]));}();
        }
        }();
auto& isText_json=json["isText"];
[&](){uint32_t temp_rQQJAJX;[&](){temp_rQQJAJX=static_cast<uint32_t>(value_to<int>(isText_json));}();member.isText=(VkBool32)temp_rQQJAJX;}();
auto& dataSize_json=json["dataSize"];
[&](){member.dataSize=static_cast<size_t>(value_to<int>(dataSize_json));}();
auto& pData_json=json["pData"];
[&](){
            if (pData_json.as_array().size()==0){
                member.pData=NULL;
            return; }char* temp_BLfUMet;[&](){
            if (pData_json.as_array().size()==0){
                temp_BLfUMet=NULL;
            return; }temp_BLfUMet=(char*)malloc(member.dataSize*sizeof(char));
        auto& arr_BbZMMzi=pData_json.as_array();
        for(int NEiuWIo=0; NEiuWIo < member.dataSize; NEiuWIo++){
            [&](){temp_BLfUMet[NEiuWIo]=static_cast<char>(value_to<int>(arr_BbZMMzi[NEiuWIo]));}();
        }
        }();member.pData=temp_BLfUMet;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderDemoteToHelperInvocation_json=json["shaderDemoteToHelperInvocation"];
[&](){[&](){shaderDemoteToHelperInvocation_json=member.shaderDemoteToHelperInvocation;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderDemoteToHelperInvocation_json=json["shaderDemoteToHelperInvocation"];
[&](){uint32_t temp_VPshPOm;[&](){temp_VPshPOm=static_cast<uint32_t>(value_to<int>(shaderDemoteToHelperInvocation_json));}();member.shaderDemoteToHelperInvocation=(VkBool32)temp_VPshPOm;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& texelBufferAlignment_json=json["texelBufferAlignment"];
[&](){[&](){texelBufferAlignment_json=member.texelBufferAlignment;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& texelBufferAlignment_json=json["texelBufferAlignment"];
[&](){uint32_t temp_lidzPjw;[&](){temp_lidzPjw=static_cast<uint32_t>(value_to<int>(texelBufferAlignment_json));}();member.texelBufferAlignment=(VkBool32)temp_lidzPjw;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceTexelBufferAlignmentProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& storageTexelBufferOffsetAlignmentBytes_json=json["storageTexelBufferOffsetAlignmentBytes"];
[&](){[&](){storageTexelBufferOffsetAlignmentBytes_json=member.storageTexelBufferOffsetAlignmentBytes;}();}();
auto& storageTexelBufferOffsetSingleTexelAlignment_json=json["storageTexelBufferOffsetSingleTexelAlignment"];
[&](){[&](){storageTexelBufferOffsetSingleTexelAlignment_json=member.storageTexelBufferOffsetSingleTexelAlignment;}();}();
auto& uniformTexelBufferOffsetAlignmentBytes_json=json["uniformTexelBufferOffsetAlignmentBytes"];
[&](){[&](){uniformTexelBufferOffsetAlignmentBytes_json=member.uniformTexelBufferOffsetAlignmentBytes;}();}();
auto& uniformTexelBufferOffsetSingleTexelAlignment_json=json["uniformTexelBufferOffsetSingleTexelAlignment"];
[&](){[&](){uniformTexelBufferOffsetSingleTexelAlignment_json=member.uniformTexelBufferOffsetSingleTexelAlignment;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceTexelBufferAlignmentProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& storageTexelBufferOffsetAlignmentBytes_json=json["storageTexelBufferOffsetAlignmentBytes"];
[&](){uint64_t temp_qnaGqom;[&](){temp_qnaGqom=static_cast<uint64_t>(value_to<int>(storageTexelBufferOffsetAlignmentBytes_json));}();member.storageTexelBufferOffsetAlignmentBytes=(VkDeviceSize)temp_qnaGqom;}();
auto& storageTexelBufferOffsetSingleTexelAlignment_json=json["storageTexelBufferOffsetSingleTexelAlignment"];
[&](){uint32_t temp_CiMJyMm;[&](){temp_CiMJyMm=static_cast<uint32_t>(value_to<int>(storageTexelBufferOffsetSingleTexelAlignment_json));}();member.storageTexelBufferOffsetSingleTexelAlignment=(VkBool32)temp_CiMJyMm;}();
auto& uniformTexelBufferOffsetAlignmentBytes_json=json["uniformTexelBufferOffsetAlignmentBytes"];
[&](){uint64_t temp_RIQPxor;[&](){temp_RIQPxor=static_cast<uint64_t>(value_to<int>(uniformTexelBufferOffsetAlignmentBytes_json));}();member.uniformTexelBufferOffsetAlignmentBytes=(VkDeviceSize)temp_RIQPxor;}();
auto& uniformTexelBufferOffsetSingleTexelAlignment_json=json["uniformTexelBufferOffsetSingleTexelAlignment"];
[&](){uint32_t temp_QXNrRGs;[&](){temp_QXNrRGs=static_cast<uint32_t>(value_to<int>(uniformTexelBufferOffsetSingleTexelAlignment_json));}();member.uniformTexelBufferOffsetSingleTexelAlignment=(VkBool32)temp_QXNrRGs;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSubgroupSizeControlFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& subgroupSizeControl_json=json["subgroupSizeControl"];
[&](){[&](){subgroupSizeControl_json=member.subgroupSizeControl;}();}();
auto& computeFullSubgroups_json=json["computeFullSubgroups"];
[&](){[&](){computeFullSubgroups_json=member.computeFullSubgroups;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSubgroupSizeControlFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& subgroupSizeControl_json=json["subgroupSizeControl"];
[&](){uint32_t temp_LqAuymN;[&](){temp_LqAuymN=static_cast<uint32_t>(value_to<int>(subgroupSizeControl_json));}();member.subgroupSizeControl=(VkBool32)temp_LqAuymN;}();
auto& computeFullSubgroups_json=json["computeFullSubgroups"];
[&](){uint32_t temp_niRFeFb;[&](){temp_niRFeFb=static_cast<uint32_t>(value_to<int>(computeFullSubgroups_json));}();member.computeFullSubgroups=(VkBool32)temp_niRFeFb;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSubgroupSizeControlProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& minSubgroupSize_json=json["minSubgroupSize"];
[&](){minSubgroupSize_json=member.minSubgroupSize;}();
auto& maxSubgroupSize_json=json["maxSubgroupSize"];
[&](){maxSubgroupSize_json=member.maxSubgroupSize;}();
auto& maxComputeWorkgroupSubgroups_json=json["maxComputeWorkgroupSubgroups"];
[&](){maxComputeWorkgroupSubgroups_json=member.maxComputeWorkgroupSubgroups;}();
auto& requiredSubgroupSizeStages_json=json["requiredSubgroupSizeStages"];
[&](){[&](){[&](){requiredSubgroupSizeStages_json=member.requiredSubgroupSizeStages;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSubgroupSizeControlProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& minSubgroupSize_json=json["minSubgroupSize"];
[&](){member.minSubgroupSize=static_cast<uint32_t>(value_to<int>(minSubgroupSize_json));}();
auto& maxSubgroupSize_json=json["maxSubgroupSize"];
[&](){member.maxSubgroupSize=static_cast<uint32_t>(value_to<int>(maxSubgroupSize_json));}();
auto& maxComputeWorkgroupSubgroups_json=json["maxComputeWorkgroupSubgroups"];
[&](){member.maxComputeWorkgroupSubgroups=static_cast<uint32_t>(value_to<int>(maxComputeWorkgroupSubgroups_json));}();
auto& requiredSubgroupSizeStages_json=json["requiredSubgroupSizeStages"];
[&](){[&](){int temp_dasyLIM;[&](){temp_dasyLIM=static_cast<int>(value_to<int>(requiredSubgroupSizeStages_json));}();member.requiredSubgroupSizeStages=(VkShaderStageFlags)temp_dasyLIM;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& requiredSubgroupSize_json=json["requiredSubgroupSize"];
[&](){requiredSubgroupSize_json=member.requiredSubgroupSize;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& requiredSubgroupSize_json=json["requiredSubgroupSize"];
[&](){member.requiredSubgroupSize=static_cast<uint32_t>(value_to<int>(requiredSubgroupSize_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSubpassShadingPipelineCreateInfoHUAWEI& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& renderPass_json=json["renderPass"];
[&](){serialize_VkRenderPass(renderPass_json,member.renderPass);}();
auto& subpass_json=json["subpass"];
[&](){subpass_json=member.subpass;}();
}
void deserialize_struct(boost::json::object& json, VkSubpassShadingPipelineCreateInfoHUAWEI& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& renderPass_json=json["renderPass"];
[&](){deserialize_VkRenderPass(renderPass_json, member.renderPass);}();
auto& subpass_json=json["subpass"];
[&](){member.subpass=static_cast<uint32_t>(value_to<int>(subpass_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxSubpassShadingWorkgroupSizeAspectRatio_json=json["maxSubpassShadingWorkgroupSizeAspectRatio"];
[&](){maxSubpassShadingWorkgroupSizeAspectRatio_json=member.maxSubpassShadingWorkgroupSizeAspectRatio;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxSubpassShadingWorkgroupSizeAspectRatio_json=json["maxSubpassShadingWorkgroupSizeAspectRatio"];
[&](){member.maxSubpassShadingWorkgroupSizeAspectRatio=static_cast<uint32_t>(value_to<int>(maxSubpassShadingWorkgroupSizeAspectRatio_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxWorkGroupCount_json=json["maxWorkGroupCount"];
[&](){maxWorkGroupCount_json=boost::json::array(3);
        auto& arr_ZnIpvvs=maxWorkGroupCount_json.as_array();
        for(int StuRCxD=0; StuRCxD < 3; StuRCxD++){
            [&](){arr_ZnIpvvs[StuRCxD]=member.maxWorkGroupCount[StuRCxD];}();
        }
        }();
auto& maxWorkGroupSize_json=json["maxWorkGroupSize"];
[&](){maxWorkGroupSize_json=boost::json::array(3);
        auto& arr_tBcNYBF=maxWorkGroupSize_json.as_array();
        for(int MsNzQqn=0; MsNzQqn < 3; MsNzQqn++){
            [&](){arr_tBcNYBF[MsNzQqn]=member.maxWorkGroupSize[MsNzQqn];}();
        }
        }();
auto& maxOutputClusterCount_json=json["maxOutputClusterCount"];
[&](){maxOutputClusterCount_json=member.maxOutputClusterCount;}();
auto& indirectBufferOffsetAlignment_json=json["indirectBufferOffsetAlignment"];
[&](){[&](){indirectBufferOffsetAlignment_json=member.indirectBufferOffsetAlignment;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxWorkGroupCount_json=json["maxWorkGroupCount"];
[&](){
        auto& arr_ZnIpvvs=maxWorkGroupCount_json.as_array();
        for(int StuRCxD=0; StuRCxD < 3; StuRCxD++){
            [&](){member.maxWorkGroupCount[StuRCxD]=static_cast<uint32_t>(value_to<int>(arr_ZnIpvvs[StuRCxD]));}();
        }
        }();
auto& maxWorkGroupSize_json=json["maxWorkGroupSize"];
[&](){
        auto& arr_tBcNYBF=maxWorkGroupSize_json.as_array();
        for(int MsNzQqn=0; MsNzQqn < 3; MsNzQqn++){
            [&](){member.maxWorkGroupSize[MsNzQqn]=static_cast<uint32_t>(value_to<int>(arr_tBcNYBF[MsNzQqn]));}();
        }
        }();
auto& maxOutputClusterCount_json=json["maxOutputClusterCount"];
[&](){member.maxOutputClusterCount=static_cast<uint32_t>(value_to<int>(maxOutputClusterCount_json));}();
auto& indirectBufferOffsetAlignment_json=json["indirectBufferOffsetAlignment"];
[&](){uint64_t temp_rIfhTlw;[&](){temp_rIfhTlw=static_cast<uint64_t>(value_to<int>(indirectBufferOffsetAlignment_json));}();member.indirectBufferOffsetAlignment=(VkDeviceSize)temp_rIfhTlw;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryOpaqueCaptureAddressAllocateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& opaqueCaptureAddress_json=json["opaqueCaptureAddress"];
[&](){opaqueCaptureAddress_json=member.opaqueCaptureAddress;}();
}
void deserialize_struct(boost::json::object& json, VkMemoryOpaqueCaptureAddressAllocateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& opaqueCaptureAddress_json=json["opaqueCaptureAddress"];
[&](){member.opaqueCaptureAddress=static_cast<uint64_t>(value_to<int>(opaqueCaptureAddress_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceMemoryOpaqueCaptureAddressInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
}
void deserialize_struct(boost::json::object& json, VkDeviceMemoryOpaqueCaptureAddressInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceLineRasterizationFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rectangularLines_json=json["rectangularLines"];
[&](){[&](){rectangularLines_json=member.rectangularLines;}();}();
auto& bresenhamLines_json=json["bresenhamLines"];
[&](){[&](){bresenhamLines_json=member.bresenhamLines;}();}();
auto& smoothLines_json=json["smoothLines"];
[&](){[&](){smoothLines_json=member.smoothLines;}();}();
auto& stippledRectangularLines_json=json["stippledRectangularLines"];
[&](){[&](){stippledRectangularLines_json=member.stippledRectangularLines;}();}();
auto& stippledBresenhamLines_json=json["stippledBresenhamLines"];
[&](){[&](){stippledBresenhamLines_json=member.stippledBresenhamLines;}();}();
auto& stippledSmoothLines_json=json["stippledSmoothLines"];
[&](){[&](){stippledSmoothLines_json=member.stippledSmoothLines;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceLineRasterizationFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& rectangularLines_json=json["rectangularLines"];
[&](){uint32_t temp_TmozgMG;[&](){temp_TmozgMG=static_cast<uint32_t>(value_to<int>(rectangularLines_json));}();member.rectangularLines=(VkBool32)temp_TmozgMG;}();
auto& bresenhamLines_json=json["bresenhamLines"];
[&](){uint32_t temp_quHSfSM;[&](){temp_quHSfSM=static_cast<uint32_t>(value_to<int>(bresenhamLines_json));}();member.bresenhamLines=(VkBool32)temp_quHSfSM;}();
auto& smoothLines_json=json["smoothLines"];
[&](){uint32_t temp_uuSWWeq;[&](){temp_uuSWWeq=static_cast<uint32_t>(value_to<int>(smoothLines_json));}();member.smoothLines=(VkBool32)temp_uuSWWeq;}();
auto& stippledRectangularLines_json=json["stippledRectangularLines"];
[&](){uint32_t temp_sVlJXQG;[&](){temp_sVlJXQG=static_cast<uint32_t>(value_to<int>(stippledRectangularLines_json));}();member.stippledRectangularLines=(VkBool32)temp_sVlJXQG;}();
auto& stippledBresenhamLines_json=json["stippledBresenhamLines"];
[&](){uint32_t temp_rlHcYLi;[&](){temp_rlHcYLi=static_cast<uint32_t>(value_to<int>(stippledBresenhamLines_json));}();member.stippledBresenhamLines=(VkBool32)temp_rlHcYLi;}();
auto& stippledSmoothLines_json=json["stippledSmoothLines"];
[&](){uint32_t temp_GjNyuiD;[&](){temp_GjNyuiD=static_cast<uint32_t>(value_to<int>(stippledSmoothLines_json));}();member.stippledSmoothLines=(VkBool32)temp_GjNyuiD;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceLineRasterizationPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& lineSubPixelPrecisionBits_json=json["lineSubPixelPrecisionBits"];
[&](){lineSubPixelPrecisionBits_json=member.lineSubPixelPrecisionBits;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceLineRasterizationPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& lineSubPixelPrecisionBits_json=json["lineSubPixelPrecisionBits"];
[&](){member.lineSubPixelPrecisionBits=static_cast<uint32_t>(value_to<int>(lineSubPixelPrecisionBits_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRasterizationLineStateCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& lineRasterizationMode_json=json["lineRasterizationMode"];
[&](){[&](){[&](){lineRasterizationMode_json=member.lineRasterizationMode;}();}();}();
auto& stippledLineEnable_json=json["stippledLineEnable"];
[&](){[&](){stippledLineEnable_json=member.stippledLineEnable;}();}();
auto& lineStippleFactor_json=json["lineStippleFactor"];
[&](){lineStippleFactor_json=member.lineStippleFactor;}();
auto& lineStipplePattern_json=json["lineStipplePattern"];
[&](){lineStipplePattern_json=member.lineStipplePattern;}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRasterizationLineStateCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& lineRasterizationMode_json=json["lineRasterizationMode"];
[&](){[&](){int temp_dugfRIl;[&](){temp_dugfRIl=static_cast<int>(value_to<int>(lineRasterizationMode_json));}();member.lineRasterizationMode=(VkLineRasterizationModeEXT)temp_dugfRIl;}();}();
auto& stippledLineEnable_json=json["stippledLineEnable"];
[&](){uint32_t temp_mqKOMla;[&](){temp_mqKOMla=static_cast<uint32_t>(value_to<int>(stippledLineEnable_json));}();member.stippledLineEnable=(VkBool32)temp_mqKOMla;}();
auto& lineStippleFactor_json=json["lineStippleFactor"];
[&](){member.lineStippleFactor=static_cast<uint32_t>(value_to<int>(lineStippleFactor_json));}();
auto& lineStipplePattern_json=json["lineStipplePattern"];
[&](){member.lineStipplePattern=static_cast<uint16_t>(value_to<int>(lineStipplePattern_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePipelineCreationCacheControlFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineCreationCacheControl_json=json["pipelineCreationCacheControl"];
[&](){[&](){pipelineCreationCacheControl_json=member.pipelineCreationCacheControl;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePipelineCreationCacheControlFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pipelineCreationCacheControl_json=json["pipelineCreationCacheControl"];
[&](){uint32_t temp_pylGmuz;[&](){temp_pylGmuz=static_cast<uint32_t>(value_to<int>(pipelineCreationCacheControl_json));}();member.pipelineCreationCacheControl=(VkBool32)temp_pylGmuz;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVulkan11Features& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& storageBuffer16BitAccess_json=json["storageBuffer16BitAccess"];
[&](){[&](){storageBuffer16BitAccess_json=member.storageBuffer16BitAccess;}();}();
auto& uniformAndStorageBuffer16BitAccess_json=json["uniformAndStorageBuffer16BitAccess"];
[&](){[&](){uniformAndStorageBuffer16BitAccess_json=member.uniformAndStorageBuffer16BitAccess;}();}();
auto& storagePushConstant16_json=json["storagePushConstant16"];
[&](){[&](){storagePushConstant16_json=member.storagePushConstant16;}();}();
auto& storageInputOutput16_json=json["storageInputOutput16"];
[&](){[&](){storageInputOutput16_json=member.storageInputOutput16;}();}();
auto& multiview_json=json["multiview"];
[&](){[&](){multiview_json=member.multiview;}();}();
auto& multiviewGeometryShader_json=json["multiviewGeometryShader"];
[&](){[&](){multiviewGeometryShader_json=member.multiviewGeometryShader;}();}();
auto& multiviewTessellationShader_json=json["multiviewTessellationShader"];
[&](){[&](){multiviewTessellationShader_json=member.multiviewTessellationShader;}();}();
auto& variablePointersStorageBuffer_json=json["variablePointersStorageBuffer"];
[&](){[&](){variablePointersStorageBuffer_json=member.variablePointersStorageBuffer;}();}();
auto& variablePointers_json=json["variablePointers"];
[&](){[&](){variablePointers_json=member.variablePointers;}();}();
auto& protectedMemory_json=json["protectedMemory"];
[&](){[&](){protectedMemory_json=member.protectedMemory;}();}();
auto& samplerYcbcrConversion_json=json["samplerYcbcrConversion"];
[&](){[&](){samplerYcbcrConversion_json=member.samplerYcbcrConversion;}();}();
auto& shaderDrawParameters_json=json["shaderDrawParameters"];
[&](){[&](){shaderDrawParameters_json=member.shaderDrawParameters;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVulkan11Features& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& storageBuffer16BitAccess_json=json["storageBuffer16BitAccess"];
[&](){uint32_t temp_yIPuXaQ;[&](){temp_yIPuXaQ=static_cast<uint32_t>(value_to<int>(storageBuffer16BitAccess_json));}();member.storageBuffer16BitAccess=(VkBool32)temp_yIPuXaQ;}();
auto& uniformAndStorageBuffer16BitAccess_json=json["uniformAndStorageBuffer16BitAccess"];
[&](){uint32_t temp_QYvUxzG;[&](){temp_QYvUxzG=static_cast<uint32_t>(value_to<int>(uniformAndStorageBuffer16BitAccess_json));}();member.uniformAndStorageBuffer16BitAccess=(VkBool32)temp_QYvUxzG;}();
auto& storagePushConstant16_json=json["storagePushConstant16"];
[&](){uint32_t temp_CaAqFdq;[&](){temp_CaAqFdq=static_cast<uint32_t>(value_to<int>(storagePushConstant16_json));}();member.storagePushConstant16=(VkBool32)temp_CaAqFdq;}();
auto& storageInputOutput16_json=json["storageInputOutput16"];
[&](){uint32_t temp_YzwMlAd;[&](){temp_YzwMlAd=static_cast<uint32_t>(value_to<int>(storageInputOutput16_json));}();member.storageInputOutput16=(VkBool32)temp_YzwMlAd;}();
auto& multiview_json=json["multiview"];
[&](){uint32_t temp_EEzipVg;[&](){temp_EEzipVg=static_cast<uint32_t>(value_to<int>(multiview_json));}();member.multiview=(VkBool32)temp_EEzipVg;}();
auto& multiviewGeometryShader_json=json["multiviewGeometryShader"];
[&](){uint32_t temp_ZgXANng;[&](){temp_ZgXANng=static_cast<uint32_t>(value_to<int>(multiviewGeometryShader_json));}();member.multiviewGeometryShader=(VkBool32)temp_ZgXANng;}();
auto& multiviewTessellationShader_json=json["multiviewTessellationShader"];
[&](){uint32_t temp_kJVppEY;[&](){temp_kJVppEY=static_cast<uint32_t>(value_to<int>(multiviewTessellationShader_json));}();member.multiviewTessellationShader=(VkBool32)temp_kJVppEY;}();
auto& variablePointersStorageBuffer_json=json["variablePointersStorageBuffer"];
[&](){uint32_t temp_ZTlpmfq;[&](){temp_ZTlpmfq=static_cast<uint32_t>(value_to<int>(variablePointersStorageBuffer_json));}();member.variablePointersStorageBuffer=(VkBool32)temp_ZTlpmfq;}();
auto& variablePointers_json=json["variablePointers"];
[&](){uint32_t temp_DgiVyJz;[&](){temp_DgiVyJz=static_cast<uint32_t>(value_to<int>(variablePointers_json));}();member.variablePointers=(VkBool32)temp_DgiVyJz;}();
auto& protectedMemory_json=json["protectedMemory"];
[&](){uint32_t temp_GuKmYAX;[&](){temp_GuKmYAX=static_cast<uint32_t>(value_to<int>(protectedMemory_json));}();member.protectedMemory=(VkBool32)temp_GuKmYAX;}();
auto& samplerYcbcrConversion_json=json["samplerYcbcrConversion"];
[&](){uint32_t temp_FgETtiO;[&](){temp_FgETtiO=static_cast<uint32_t>(value_to<int>(samplerYcbcrConversion_json));}();member.samplerYcbcrConversion=(VkBool32)temp_FgETtiO;}();
auto& shaderDrawParameters_json=json["shaderDrawParameters"];
[&](){uint32_t temp_RrCBUNI;[&](){temp_RrCBUNI=static_cast<uint32_t>(value_to<int>(shaderDrawParameters_json));}();member.shaderDrawParameters=(VkBool32)temp_RrCBUNI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVulkan11Properties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceUUID_json=json["deviceUUID"];
[&](){deviceUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_FuHCgMt=deviceUUID_json.as_array();
        for(int ysVOqaa=0; ysVOqaa < VK_UUID_SIZE; ysVOqaa++){
            [&](){arr_FuHCgMt[ysVOqaa]=member.deviceUUID[ysVOqaa];}();
        }
        }();
auto& driverUUID_json=json["driverUUID"];
[&](){driverUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_YRnTzib=driverUUID_json.as_array();
        for(int mkRKwTt=0; mkRKwTt < VK_UUID_SIZE; mkRKwTt++){
            [&](){arr_YRnTzib[mkRKwTt]=member.driverUUID[mkRKwTt];}();
        }
        }();
auto& deviceLUID_json=json["deviceLUID"];
[&](){deviceLUID_json=boost::json::array(VK_LUID_SIZE);
        auto& arr_ZPJcGyp=deviceLUID_json.as_array();
        for(int LcxBcjU=0; LcxBcjU < VK_LUID_SIZE; LcxBcjU++){
            [&](){arr_ZPJcGyp[LcxBcjU]=member.deviceLUID[LcxBcjU];}();
        }
        }();
auto& deviceNodeMask_json=json["deviceNodeMask"];
[&](){deviceNodeMask_json=member.deviceNodeMask;}();
auto& deviceLUIDValid_json=json["deviceLUIDValid"];
[&](){[&](){deviceLUIDValid_json=member.deviceLUIDValid;}();}();
auto& subgroupSize_json=json["subgroupSize"];
[&](){subgroupSize_json=member.subgroupSize;}();
auto& subgroupSupportedStages_json=json["subgroupSupportedStages"];
[&](){[&](){[&](){subgroupSupportedStages_json=member.subgroupSupportedStages;}();}();}();
auto& subgroupSupportedOperations_json=json["subgroupSupportedOperations"];
[&](){[&](){[&](){subgroupSupportedOperations_json=member.subgroupSupportedOperations;}();}();}();
auto& subgroupQuadOperationsInAllStages_json=json["subgroupQuadOperationsInAllStages"];
[&](){[&](){subgroupQuadOperationsInAllStages_json=member.subgroupQuadOperationsInAllStages;}();}();
auto& pointClippingBehavior_json=json["pointClippingBehavior"];
[&](){[&](){[&](){pointClippingBehavior_json=member.pointClippingBehavior;}();}();}();
auto& maxMultiviewViewCount_json=json["maxMultiviewViewCount"];
[&](){maxMultiviewViewCount_json=member.maxMultiviewViewCount;}();
auto& maxMultiviewInstanceIndex_json=json["maxMultiviewInstanceIndex"];
[&](){maxMultiviewInstanceIndex_json=member.maxMultiviewInstanceIndex;}();
auto& protectedNoFault_json=json["protectedNoFault"];
[&](){[&](){protectedNoFault_json=member.protectedNoFault;}();}();
auto& maxPerSetDescriptors_json=json["maxPerSetDescriptors"];
[&](){maxPerSetDescriptors_json=member.maxPerSetDescriptors;}();
auto& maxMemoryAllocationSize_json=json["maxMemoryAllocationSize"];
[&](){[&](){maxMemoryAllocationSize_json=member.maxMemoryAllocationSize;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVulkan11Properties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& deviceUUID_json=json["deviceUUID"];
[&](){
        auto& arr_FuHCgMt=deviceUUID_json.as_array();
        for(int ysVOqaa=0; ysVOqaa < VK_UUID_SIZE; ysVOqaa++){
            [&](){member.deviceUUID[ysVOqaa]=static_cast<uint8_t>(value_to<int>(arr_FuHCgMt[ysVOqaa]));}();
        }
        }();
auto& driverUUID_json=json["driverUUID"];
[&](){
        auto& arr_YRnTzib=driverUUID_json.as_array();
        for(int mkRKwTt=0; mkRKwTt < VK_UUID_SIZE; mkRKwTt++){
            [&](){member.driverUUID[mkRKwTt]=static_cast<uint8_t>(value_to<int>(arr_YRnTzib[mkRKwTt]));}();
        }
        }();
auto& deviceLUID_json=json["deviceLUID"];
[&](){
        auto& arr_ZPJcGyp=deviceLUID_json.as_array();
        for(int LcxBcjU=0; LcxBcjU < VK_LUID_SIZE; LcxBcjU++){
            [&](){member.deviceLUID[LcxBcjU]=static_cast<uint8_t>(value_to<int>(arr_ZPJcGyp[LcxBcjU]));}();
        }
        }();
auto& deviceNodeMask_json=json["deviceNodeMask"];
[&](){member.deviceNodeMask=static_cast<uint32_t>(value_to<int>(deviceNodeMask_json));}();
auto& deviceLUIDValid_json=json["deviceLUIDValid"];
[&](){uint32_t temp_ZWIQNBq;[&](){temp_ZWIQNBq=static_cast<uint32_t>(value_to<int>(deviceLUIDValid_json));}();member.deviceLUIDValid=(VkBool32)temp_ZWIQNBq;}();
auto& subgroupSize_json=json["subgroupSize"];
[&](){member.subgroupSize=static_cast<uint32_t>(value_to<int>(subgroupSize_json));}();
auto& subgroupSupportedStages_json=json["subgroupSupportedStages"];
[&](){[&](){int temp_weEVsxW;[&](){temp_weEVsxW=static_cast<int>(value_to<int>(subgroupSupportedStages_json));}();member.subgroupSupportedStages=(VkShaderStageFlags)temp_weEVsxW;}();}();
auto& subgroupSupportedOperations_json=json["subgroupSupportedOperations"];
[&](){[&](){int temp_yqlZFQX;[&](){temp_yqlZFQX=static_cast<int>(value_to<int>(subgroupSupportedOperations_json));}();member.subgroupSupportedOperations=(VkSubgroupFeatureFlags)temp_yqlZFQX;}();}();
auto& subgroupQuadOperationsInAllStages_json=json["subgroupQuadOperationsInAllStages"];
[&](){uint32_t temp_YxxjamW;[&](){temp_YxxjamW=static_cast<uint32_t>(value_to<int>(subgroupQuadOperationsInAllStages_json));}();member.subgroupQuadOperationsInAllStages=(VkBool32)temp_YxxjamW;}();
auto& pointClippingBehavior_json=json["pointClippingBehavior"];
[&](){[&](){int temp_AuXEWUF;[&](){temp_AuXEWUF=static_cast<int>(value_to<int>(pointClippingBehavior_json));}();member.pointClippingBehavior=(VkPointClippingBehavior)temp_AuXEWUF;}();}();
auto& maxMultiviewViewCount_json=json["maxMultiviewViewCount"];
[&](){member.maxMultiviewViewCount=static_cast<uint32_t>(value_to<int>(maxMultiviewViewCount_json));}();
auto& maxMultiviewInstanceIndex_json=json["maxMultiviewInstanceIndex"];
[&](){member.maxMultiviewInstanceIndex=static_cast<uint32_t>(value_to<int>(maxMultiviewInstanceIndex_json));}();
auto& protectedNoFault_json=json["protectedNoFault"];
[&](){uint32_t temp_vnlcpsN;[&](){temp_vnlcpsN=static_cast<uint32_t>(value_to<int>(protectedNoFault_json));}();member.protectedNoFault=(VkBool32)temp_vnlcpsN;}();
auto& maxPerSetDescriptors_json=json["maxPerSetDescriptors"];
[&](){member.maxPerSetDescriptors=static_cast<uint32_t>(value_to<int>(maxPerSetDescriptors_json));}();
auto& maxMemoryAllocationSize_json=json["maxMemoryAllocationSize"];
[&](){uint64_t temp_mtnouHJ;[&](){temp_mtnouHJ=static_cast<uint64_t>(value_to<int>(maxMemoryAllocationSize_json));}();member.maxMemoryAllocationSize=(VkDeviceSize)temp_mtnouHJ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVulkan12Features& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& samplerMirrorClampToEdge_json=json["samplerMirrorClampToEdge"];
[&](){[&](){samplerMirrorClampToEdge_json=member.samplerMirrorClampToEdge;}();}();
auto& drawIndirectCount_json=json["drawIndirectCount"];
[&](){[&](){drawIndirectCount_json=member.drawIndirectCount;}();}();
auto& storageBuffer8BitAccess_json=json["storageBuffer8BitAccess"];
[&](){[&](){storageBuffer8BitAccess_json=member.storageBuffer8BitAccess;}();}();
auto& uniformAndStorageBuffer8BitAccess_json=json["uniformAndStorageBuffer8BitAccess"];
[&](){[&](){uniformAndStorageBuffer8BitAccess_json=member.uniformAndStorageBuffer8BitAccess;}();}();
auto& storagePushConstant8_json=json["storagePushConstant8"];
[&](){[&](){storagePushConstant8_json=member.storagePushConstant8;}();}();
auto& shaderBufferInt64Atomics_json=json["shaderBufferInt64Atomics"];
[&](){[&](){shaderBufferInt64Atomics_json=member.shaderBufferInt64Atomics;}();}();
auto& shaderSharedInt64Atomics_json=json["shaderSharedInt64Atomics"];
[&](){[&](){shaderSharedInt64Atomics_json=member.shaderSharedInt64Atomics;}();}();
auto& shaderFloat16_json=json["shaderFloat16"];
[&](){[&](){shaderFloat16_json=member.shaderFloat16;}();}();
auto& shaderInt8_json=json["shaderInt8"];
[&](){[&](){shaderInt8_json=member.shaderInt8;}();}();
auto& descriptorIndexing_json=json["descriptorIndexing"];
[&](){[&](){descriptorIndexing_json=member.descriptorIndexing;}();}();
auto& shaderInputAttachmentArrayDynamicIndexing_json=json["shaderInputAttachmentArrayDynamicIndexing"];
[&](){[&](){shaderInputAttachmentArrayDynamicIndexing_json=member.shaderInputAttachmentArrayDynamicIndexing;}();}();
auto& shaderUniformTexelBufferArrayDynamicIndexing_json=json["shaderUniformTexelBufferArrayDynamicIndexing"];
[&](){[&](){shaderUniformTexelBufferArrayDynamicIndexing_json=member.shaderUniformTexelBufferArrayDynamicIndexing;}();}();
auto& shaderStorageTexelBufferArrayDynamicIndexing_json=json["shaderStorageTexelBufferArrayDynamicIndexing"];
[&](){[&](){shaderStorageTexelBufferArrayDynamicIndexing_json=member.shaderStorageTexelBufferArrayDynamicIndexing;}();}();
auto& shaderUniformBufferArrayNonUniformIndexing_json=json["shaderUniformBufferArrayNonUniformIndexing"];
[&](){[&](){shaderUniformBufferArrayNonUniformIndexing_json=member.shaderUniformBufferArrayNonUniformIndexing;}();}();
auto& shaderSampledImageArrayNonUniformIndexing_json=json["shaderSampledImageArrayNonUniformIndexing"];
[&](){[&](){shaderSampledImageArrayNonUniformIndexing_json=member.shaderSampledImageArrayNonUniformIndexing;}();}();
auto& shaderStorageBufferArrayNonUniformIndexing_json=json["shaderStorageBufferArrayNonUniformIndexing"];
[&](){[&](){shaderStorageBufferArrayNonUniformIndexing_json=member.shaderStorageBufferArrayNonUniformIndexing;}();}();
auto& shaderStorageImageArrayNonUniformIndexing_json=json["shaderStorageImageArrayNonUniformIndexing"];
[&](){[&](){shaderStorageImageArrayNonUniformIndexing_json=member.shaderStorageImageArrayNonUniformIndexing;}();}();
auto& shaderInputAttachmentArrayNonUniformIndexing_json=json["shaderInputAttachmentArrayNonUniformIndexing"];
[&](){[&](){shaderInputAttachmentArrayNonUniformIndexing_json=member.shaderInputAttachmentArrayNonUniformIndexing;}();}();
auto& shaderUniformTexelBufferArrayNonUniformIndexing_json=json["shaderUniformTexelBufferArrayNonUniformIndexing"];
[&](){[&](){shaderUniformTexelBufferArrayNonUniformIndexing_json=member.shaderUniformTexelBufferArrayNonUniformIndexing;}();}();
auto& shaderStorageTexelBufferArrayNonUniformIndexing_json=json["shaderStorageTexelBufferArrayNonUniformIndexing"];
[&](){[&](){shaderStorageTexelBufferArrayNonUniformIndexing_json=member.shaderStorageTexelBufferArrayNonUniformIndexing;}();}();
auto& descriptorBindingUniformBufferUpdateAfterBind_json=json["descriptorBindingUniformBufferUpdateAfterBind"];
[&](){[&](){descriptorBindingUniformBufferUpdateAfterBind_json=member.descriptorBindingUniformBufferUpdateAfterBind;}();}();
auto& descriptorBindingSampledImageUpdateAfterBind_json=json["descriptorBindingSampledImageUpdateAfterBind"];
[&](){[&](){descriptorBindingSampledImageUpdateAfterBind_json=member.descriptorBindingSampledImageUpdateAfterBind;}();}();
auto& descriptorBindingStorageImageUpdateAfterBind_json=json["descriptorBindingStorageImageUpdateAfterBind"];
[&](){[&](){descriptorBindingStorageImageUpdateAfterBind_json=member.descriptorBindingStorageImageUpdateAfterBind;}();}();
auto& descriptorBindingStorageBufferUpdateAfterBind_json=json["descriptorBindingStorageBufferUpdateAfterBind"];
[&](){[&](){descriptorBindingStorageBufferUpdateAfterBind_json=member.descriptorBindingStorageBufferUpdateAfterBind;}();}();
auto& descriptorBindingUniformTexelBufferUpdateAfterBind_json=json["descriptorBindingUniformTexelBufferUpdateAfterBind"];
[&](){[&](){descriptorBindingUniformTexelBufferUpdateAfterBind_json=member.descriptorBindingUniformTexelBufferUpdateAfterBind;}();}();
auto& descriptorBindingStorageTexelBufferUpdateAfterBind_json=json["descriptorBindingStorageTexelBufferUpdateAfterBind"];
[&](){[&](){descriptorBindingStorageTexelBufferUpdateAfterBind_json=member.descriptorBindingStorageTexelBufferUpdateAfterBind;}();}();
auto& descriptorBindingUpdateUnusedWhilePending_json=json["descriptorBindingUpdateUnusedWhilePending"];
[&](){[&](){descriptorBindingUpdateUnusedWhilePending_json=member.descriptorBindingUpdateUnusedWhilePending;}();}();
auto& descriptorBindingPartiallyBound_json=json["descriptorBindingPartiallyBound"];
[&](){[&](){descriptorBindingPartiallyBound_json=member.descriptorBindingPartiallyBound;}();}();
auto& descriptorBindingVariableDescriptorCount_json=json["descriptorBindingVariableDescriptorCount"];
[&](){[&](){descriptorBindingVariableDescriptorCount_json=member.descriptorBindingVariableDescriptorCount;}();}();
auto& runtimeDescriptorArray_json=json["runtimeDescriptorArray"];
[&](){[&](){runtimeDescriptorArray_json=member.runtimeDescriptorArray;}();}();
auto& samplerFilterMinmax_json=json["samplerFilterMinmax"];
[&](){[&](){samplerFilterMinmax_json=member.samplerFilterMinmax;}();}();
auto& scalarBlockLayout_json=json["scalarBlockLayout"];
[&](){[&](){scalarBlockLayout_json=member.scalarBlockLayout;}();}();
auto& imagelessFramebuffer_json=json["imagelessFramebuffer"];
[&](){[&](){imagelessFramebuffer_json=member.imagelessFramebuffer;}();}();
auto& uniformBufferStandardLayout_json=json["uniformBufferStandardLayout"];
[&](){[&](){uniformBufferStandardLayout_json=member.uniformBufferStandardLayout;}();}();
auto& shaderSubgroupExtendedTypes_json=json["shaderSubgroupExtendedTypes"];
[&](){[&](){shaderSubgroupExtendedTypes_json=member.shaderSubgroupExtendedTypes;}();}();
auto& separateDepthStencilLayouts_json=json["separateDepthStencilLayouts"];
[&](){[&](){separateDepthStencilLayouts_json=member.separateDepthStencilLayouts;}();}();
auto& hostQueryReset_json=json["hostQueryReset"];
[&](){[&](){hostQueryReset_json=member.hostQueryReset;}();}();
auto& timelineSemaphore_json=json["timelineSemaphore"];
[&](){[&](){timelineSemaphore_json=member.timelineSemaphore;}();}();
auto& bufferDeviceAddress_json=json["bufferDeviceAddress"];
[&](){[&](){bufferDeviceAddress_json=member.bufferDeviceAddress;}();}();
auto& bufferDeviceAddressCaptureReplay_json=json["bufferDeviceAddressCaptureReplay"];
[&](){[&](){bufferDeviceAddressCaptureReplay_json=member.bufferDeviceAddressCaptureReplay;}();}();
auto& bufferDeviceAddressMultiDevice_json=json["bufferDeviceAddressMultiDevice"];
[&](){[&](){bufferDeviceAddressMultiDevice_json=member.bufferDeviceAddressMultiDevice;}();}();
auto& vulkanMemoryModel_json=json["vulkanMemoryModel"];
[&](){[&](){vulkanMemoryModel_json=member.vulkanMemoryModel;}();}();
auto& vulkanMemoryModelDeviceScope_json=json["vulkanMemoryModelDeviceScope"];
[&](){[&](){vulkanMemoryModelDeviceScope_json=member.vulkanMemoryModelDeviceScope;}();}();
auto& vulkanMemoryModelAvailabilityVisibilityChains_json=json["vulkanMemoryModelAvailabilityVisibilityChains"];
[&](){[&](){vulkanMemoryModelAvailabilityVisibilityChains_json=member.vulkanMemoryModelAvailabilityVisibilityChains;}();}();
auto& shaderOutputViewportIndex_json=json["shaderOutputViewportIndex"];
[&](){[&](){shaderOutputViewportIndex_json=member.shaderOutputViewportIndex;}();}();
auto& shaderOutputLayer_json=json["shaderOutputLayer"];
[&](){[&](){shaderOutputLayer_json=member.shaderOutputLayer;}();}();
auto& subgroupBroadcastDynamicId_json=json["subgroupBroadcastDynamicId"];
[&](){[&](){subgroupBroadcastDynamicId_json=member.subgroupBroadcastDynamicId;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVulkan12Features& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& samplerMirrorClampToEdge_json=json["samplerMirrorClampToEdge"];
[&](){uint32_t temp_saaELME;[&](){temp_saaELME=static_cast<uint32_t>(value_to<int>(samplerMirrorClampToEdge_json));}();member.samplerMirrorClampToEdge=(VkBool32)temp_saaELME;}();
auto& drawIndirectCount_json=json["drawIndirectCount"];
[&](){uint32_t temp_qnfgAGJ;[&](){temp_qnfgAGJ=static_cast<uint32_t>(value_to<int>(drawIndirectCount_json));}();member.drawIndirectCount=(VkBool32)temp_qnfgAGJ;}();
auto& storageBuffer8BitAccess_json=json["storageBuffer8BitAccess"];
[&](){uint32_t temp_FtJFtaE;[&](){temp_FtJFtaE=static_cast<uint32_t>(value_to<int>(storageBuffer8BitAccess_json));}();member.storageBuffer8BitAccess=(VkBool32)temp_FtJFtaE;}();
auto& uniformAndStorageBuffer8BitAccess_json=json["uniformAndStorageBuffer8BitAccess"];
[&](){uint32_t temp_lQfUyFR;[&](){temp_lQfUyFR=static_cast<uint32_t>(value_to<int>(uniformAndStorageBuffer8BitAccess_json));}();member.uniformAndStorageBuffer8BitAccess=(VkBool32)temp_lQfUyFR;}();
auto& storagePushConstant8_json=json["storagePushConstant8"];
[&](){uint32_t temp_WEvCwTd;[&](){temp_WEvCwTd=static_cast<uint32_t>(value_to<int>(storagePushConstant8_json));}();member.storagePushConstant8=(VkBool32)temp_WEvCwTd;}();
auto& shaderBufferInt64Atomics_json=json["shaderBufferInt64Atomics"];
[&](){uint32_t temp_yVOKFeL;[&](){temp_yVOKFeL=static_cast<uint32_t>(value_to<int>(shaderBufferInt64Atomics_json));}();member.shaderBufferInt64Atomics=(VkBool32)temp_yVOKFeL;}();
auto& shaderSharedInt64Atomics_json=json["shaderSharedInt64Atomics"];
[&](){uint32_t temp_eiWVlfp;[&](){temp_eiWVlfp=static_cast<uint32_t>(value_to<int>(shaderSharedInt64Atomics_json));}();member.shaderSharedInt64Atomics=(VkBool32)temp_eiWVlfp;}();
auto& shaderFloat16_json=json["shaderFloat16"];
[&](){uint32_t temp_HaJynSC;[&](){temp_HaJynSC=static_cast<uint32_t>(value_to<int>(shaderFloat16_json));}();member.shaderFloat16=(VkBool32)temp_HaJynSC;}();
auto& shaderInt8_json=json["shaderInt8"];
[&](){uint32_t temp_PUHXULH;[&](){temp_PUHXULH=static_cast<uint32_t>(value_to<int>(shaderInt8_json));}();member.shaderInt8=(VkBool32)temp_PUHXULH;}();
auto& descriptorIndexing_json=json["descriptorIndexing"];
[&](){uint32_t temp_GXmzYcb;[&](){temp_GXmzYcb=static_cast<uint32_t>(value_to<int>(descriptorIndexing_json));}();member.descriptorIndexing=(VkBool32)temp_GXmzYcb;}();
auto& shaderInputAttachmentArrayDynamicIndexing_json=json["shaderInputAttachmentArrayDynamicIndexing"];
[&](){uint32_t temp_fyJbpOD;[&](){temp_fyJbpOD=static_cast<uint32_t>(value_to<int>(shaderInputAttachmentArrayDynamicIndexing_json));}();member.shaderInputAttachmentArrayDynamicIndexing=(VkBool32)temp_fyJbpOD;}();
auto& shaderUniformTexelBufferArrayDynamicIndexing_json=json["shaderUniformTexelBufferArrayDynamicIndexing"];
[&](){uint32_t temp_MMQkhrI;[&](){temp_MMQkhrI=static_cast<uint32_t>(value_to<int>(shaderUniformTexelBufferArrayDynamicIndexing_json));}();member.shaderUniformTexelBufferArrayDynamicIndexing=(VkBool32)temp_MMQkhrI;}();
auto& shaderStorageTexelBufferArrayDynamicIndexing_json=json["shaderStorageTexelBufferArrayDynamicIndexing"];
[&](){uint32_t temp_dJdOALu;[&](){temp_dJdOALu=static_cast<uint32_t>(value_to<int>(shaderStorageTexelBufferArrayDynamicIndexing_json));}();member.shaderStorageTexelBufferArrayDynamicIndexing=(VkBool32)temp_dJdOALu;}();
auto& shaderUniformBufferArrayNonUniformIndexing_json=json["shaderUniformBufferArrayNonUniformIndexing"];
[&](){uint32_t temp_bpPwNfg;[&](){temp_bpPwNfg=static_cast<uint32_t>(value_to<int>(shaderUniformBufferArrayNonUniformIndexing_json));}();member.shaderUniformBufferArrayNonUniformIndexing=(VkBool32)temp_bpPwNfg;}();
auto& shaderSampledImageArrayNonUniformIndexing_json=json["shaderSampledImageArrayNonUniformIndexing"];
[&](){uint32_t temp_lVzKpVq;[&](){temp_lVzKpVq=static_cast<uint32_t>(value_to<int>(shaderSampledImageArrayNonUniformIndexing_json));}();member.shaderSampledImageArrayNonUniformIndexing=(VkBool32)temp_lVzKpVq;}();
auto& shaderStorageBufferArrayNonUniformIndexing_json=json["shaderStorageBufferArrayNonUniformIndexing"];
[&](){uint32_t temp_UtOakrN;[&](){temp_UtOakrN=static_cast<uint32_t>(value_to<int>(shaderStorageBufferArrayNonUniformIndexing_json));}();member.shaderStorageBufferArrayNonUniformIndexing=(VkBool32)temp_UtOakrN;}();
auto& shaderStorageImageArrayNonUniformIndexing_json=json["shaderStorageImageArrayNonUniformIndexing"];
[&](){uint32_t temp_mNnhHJv;[&](){temp_mNnhHJv=static_cast<uint32_t>(value_to<int>(shaderStorageImageArrayNonUniformIndexing_json));}();member.shaderStorageImageArrayNonUniformIndexing=(VkBool32)temp_mNnhHJv;}();
auto& shaderInputAttachmentArrayNonUniformIndexing_json=json["shaderInputAttachmentArrayNonUniformIndexing"];
[&](){uint32_t temp_iOZaHHL;[&](){temp_iOZaHHL=static_cast<uint32_t>(value_to<int>(shaderInputAttachmentArrayNonUniformIndexing_json));}();member.shaderInputAttachmentArrayNonUniformIndexing=(VkBool32)temp_iOZaHHL;}();
auto& shaderUniformTexelBufferArrayNonUniformIndexing_json=json["shaderUniformTexelBufferArrayNonUniformIndexing"];
[&](){uint32_t temp_cftOXUy;[&](){temp_cftOXUy=static_cast<uint32_t>(value_to<int>(shaderUniformTexelBufferArrayNonUniformIndexing_json));}();member.shaderUniformTexelBufferArrayNonUniformIndexing=(VkBool32)temp_cftOXUy;}();
auto& shaderStorageTexelBufferArrayNonUniformIndexing_json=json["shaderStorageTexelBufferArrayNonUniformIndexing"];
[&](){uint32_t temp_EPBIyHy;[&](){temp_EPBIyHy=static_cast<uint32_t>(value_to<int>(shaderStorageTexelBufferArrayNonUniformIndexing_json));}();member.shaderStorageTexelBufferArrayNonUniformIndexing=(VkBool32)temp_EPBIyHy;}();
auto& descriptorBindingUniformBufferUpdateAfterBind_json=json["descriptorBindingUniformBufferUpdateAfterBind"];
[&](){uint32_t temp_fUMytxk;[&](){temp_fUMytxk=static_cast<uint32_t>(value_to<int>(descriptorBindingUniformBufferUpdateAfterBind_json));}();member.descriptorBindingUniformBufferUpdateAfterBind=(VkBool32)temp_fUMytxk;}();
auto& descriptorBindingSampledImageUpdateAfterBind_json=json["descriptorBindingSampledImageUpdateAfterBind"];
[&](){uint32_t temp_xaqghGY;[&](){temp_xaqghGY=static_cast<uint32_t>(value_to<int>(descriptorBindingSampledImageUpdateAfterBind_json));}();member.descriptorBindingSampledImageUpdateAfterBind=(VkBool32)temp_xaqghGY;}();
auto& descriptorBindingStorageImageUpdateAfterBind_json=json["descriptorBindingStorageImageUpdateAfterBind"];
[&](){uint32_t temp_sFIjULV;[&](){temp_sFIjULV=static_cast<uint32_t>(value_to<int>(descriptorBindingStorageImageUpdateAfterBind_json));}();member.descriptorBindingStorageImageUpdateAfterBind=(VkBool32)temp_sFIjULV;}();
auto& descriptorBindingStorageBufferUpdateAfterBind_json=json["descriptorBindingStorageBufferUpdateAfterBind"];
[&](){uint32_t temp_IMOOVIt;[&](){temp_IMOOVIt=static_cast<uint32_t>(value_to<int>(descriptorBindingStorageBufferUpdateAfterBind_json));}();member.descriptorBindingStorageBufferUpdateAfterBind=(VkBool32)temp_IMOOVIt;}();
auto& descriptorBindingUniformTexelBufferUpdateAfterBind_json=json["descriptorBindingUniformTexelBufferUpdateAfterBind"];
[&](){uint32_t temp_FjRggwM;[&](){temp_FjRggwM=static_cast<uint32_t>(value_to<int>(descriptorBindingUniformTexelBufferUpdateAfterBind_json));}();member.descriptorBindingUniformTexelBufferUpdateAfterBind=(VkBool32)temp_FjRggwM;}();
auto& descriptorBindingStorageTexelBufferUpdateAfterBind_json=json["descriptorBindingStorageTexelBufferUpdateAfterBind"];
[&](){uint32_t temp_PYbExfI;[&](){temp_PYbExfI=static_cast<uint32_t>(value_to<int>(descriptorBindingStorageTexelBufferUpdateAfterBind_json));}();member.descriptorBindingStorageTexelBufferUpdateAfterBind=(VkBool32)temp_PYbExfI;}();
auto& descriptorBindingUpdateUnusedWhilePending_json=json["descriptorBindingUpdateUnusedWhilePending"];
[&](){uint32_t temp_znoAjAs;[&](){temp_znoAjAs=static_cast<uint32_t>(value_to<int>(descriptorBindingUpdateUnusedWhilePending_json));}();member.descriptorBindingUpdateUnusedWhilePending=(VkBool32)temp_znoAjAs;}();
auto& descriptorBindingPartiallyBound_json=json["descriptorBindingPartiallyBound"];
[&](){uint32_t temp_BCHGQDa;[&](){temp_BCHGQDa=static_cast<uint32_t>(value_to<int>(descriptorBindingPartiallyBound_json));}();member.descriptorBindingPartiallyBound=(VkBool32)temp_BCHGQDa;}();
auto& descriptorBindingVariableDescriptorCount_json=json["descriptorBindingVariableDescriptorCount"];
[&](){uint32_t temp_BHqFqTR;[&](){temp_BHqFqTR=static_cast<uint32_t>(value_to<int>(descriptorBindingVariableDescriptorCount_json));}();member.descriptorBindingVariableDescriptorCount=(VkBool32)temp_BHqFqTR;}();
auto& runtimeDescriptorArray_json=json["runtimeDescriptorArray"];
[&](){uint32_t temp_nSZVBTY;[&](){temp_nSZVBTY=static_cast<uint32_t>(value_to<int>(runtimeDescriptorArray_json));}();member.runtimeDescriptorArray=(VkBool32)temp_nSZVBTY;}();
auto& samplerFilterMinmax_json=json["samplerFilterMinmax"];
[&](){uint32_t temp_ZGGNZTo;[&](){temp_ZGGNZTo=static_cast<uint32_t>(value_to<int>(samplerFilterMinmax_json));}();member.samplerFilterMinmax=(VkBool32)temp_ZGGNZTo;}();
auto& scalarBlockLayout_json=json["scalarBlockLayout"];
[&](){uint32_t temp_CKSkRNT;[&](){temp_CKSkRNT=static_cast<uint32_t>(value_to<int>(scalarBlockLayout_json));}();member.scalarBlockLayout=(VkBool32)temp_CKSkRNT;}();
auto& imagelessFramebuffer_json=json["imagelessFramebuffer"];
[&](){uint32_t temp_eYtbOdU;[&](){temp_eYtbOdU=static_cast<uint32_t>(value_to<int>(imagelessFramebuffer_json));}();member.imagelessFramebuffer=(VkBool32)temp_eYtbOdU;}();
auto& uniformBufferStandardLayout_json=json["uniformBufferStandardLayout"];
[&](){uint32_t temp_BdhQgZA;[&](){temp_BdhQgZA=static_cast<uint32_t>(value_to<int>(uniformBufferStandardLayout_json));}();member.uniformBufferStandardLayout=(VkBool32)temp_BdhQgZA;}();
auto& shaderSubgroupExtendedTypes_json=json["shaderSubgroupExtendedTypes"];
[&](){uint32_t temp_ITZfDXI;[&](){temp_ITZfDXI=static_cast<uint32_t>(value_to<int>(shaderSubgroupExtendedTypes_json));}();member.shaderSubgroupExtendedTypes=(VkBool32)temp_ITZfDXI;}();
auto& separateDepthStencilLayouts_json=json["separateDepthStencilLayouts"];
[&](){uint32_t temp_XLmmIxV;[&](){temp_XLmmIxV=static_cast<uint32_t>(value_to<int>(separateDepthStencilLayouts_json));}();member.separateDepthStencilLayouts=(VkBool32)temp_XLmmIxV;}();
auto& hostQueryReset_json=json["hostQueryReset"];
[&](){uint32_t temp_xScjSSB;[&](){temp_xScjSSB=static_cast<uint32_t>(value_to<int>(hostQueryReset_json));}();member.hostQueryReset=(VkBool32)temp_xScjSSB;}();
auto& timelineSemaphore_json=json["timelineSemaphore"];
[&](){uint32_t temp_AMuaKRA;[&](){temp_AMuaKRA=static_cast<uint32_t>(value_to<int>(timelineSemaphore_json));}();member.timelineSemaphore=(VkBool32)temp_AMuaKRA;}();
auto& bufferDeviceAddress_json=json["bufferDeviceAddress"];
[&](){uint32_t temp_yVSfIxJ;[&](){temp_yVSfIxJ=static_cast<uint32_t>(value_to<int>(bufferDeviceAddress_json));}();member.bufferDeviceAddress=(VkBool32)temp_yVSfIxJ;}();
auto& bufferDeviceAddressCaptureReplay_json=json["bufferDeviceAddressCaptureReplay"];
[&](){uint32_t temp_ZdaRGga;[&](){temp_ZdaRGga=static_cast<uint32_t>(value_to<int>(bufferDeviceAddressCaptureReplay_json));}();member.bufferDeviceAddressCaptureReplay=(VkBool32)temp_ZdaRGga;}();
auto& bufferDeviceAddressMultiDevice_json=json["bufferDeviceAddressMultiDevice"];
[&](){uint32_t temp_XwIBhTJ;[&](){temp_XwIBhTJ=static_cast<uint32_t>(value_to<int>(bufferDeviceAddressMultiDevice_json));}();member.bufferDeviceAddressMultiDevice=(VkBool32)temp_XwIBhTJ;}();
auto& vulkanMemoryModel_json=json["vulkanMemoryModel"];
[&](){uint32_t temp_BSWUhSK;[&](){temp_BSWUhSK=static_cast<uint32_t>(value_to<int>(vulkanMemoryModel_json));}();member.vulkanMemoryModel=(VkBool32)temp_BSWUhSK;}();
auto& vulkanMemoryModelDeviceScope_json=json["vulkanMemoryModelDeviceScope"];
[&](){uint32_t temp_rZUhdCm;[&](){temp_rZUhdCm=static_cast<uint32_t>(value_to<int>(vulkanMemoryModelDeviceScope_json));}();member.vulkanMemoryModelDeviceScope=(VkBool32)temp_rZUhdCm;}();
auto& vulkanMemoryModelAvailabilityVisibilityChains_json=json["vulkanMemoryModelAvailabilityVisibilityChains"];
[&](){uint32_t temp_XZLJnrA;[&](){temp_XZLJnrA=static_cast<uint32_t>(value_to<int>(vulkanMemoryModelAvailabilityVisibilityChains_json));}();member.vulkanMemoryModelAvailabilityVisibilityChains=(VkBool32)temp_XZLJnrA;}();
auto& shaderOutputViewportIndex_json=json["shaderOutputViewportIndex"];
[&](){uint32_t temp_lryZZEk;[&](){temp_lryZZEk=static_cast<uint32_t>(value_to<int>(shaderOutputViewportIndex_json));}();member.shaderOutputViewportIndex=(VkBool32)temp_lryZZEk;}();
auto& shaderOutputLayer_json=json["shaderOutputLayer"];
[&](){uint32_t temp_cPFiKRe;[&](){temp_cPFiKRe=static_cast<uint32_t>(value_to<int>(shaderOutputLayer_json));}();member.shaderOutputLayer=(VkBool32)temp_cPFiKRe;}();
auto& subgroupBroadcastDynamicId_json=json["subgroupBroadcastDynamicId"];
[&](){uint32_t temp_yQzGkJD;[&](){temp_yQzGkJD=static_cast<uint32_t>(value_to<int>(subgroupBroadcastDynamicId_json));}();member.subgroupBroadcastDynamicId=(VkBool32)temp_yQzGkJD;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVulkan12Properties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& driverID_json=json["driverID"];
[&](){[&](){[&](){driverID_json=member.driverID;}();}();}();
auto& driverName_json=json["driverName"];
[&](){driverName_json=boost::json::array(VK_MAX_DRIVER_NAME_SIZE);
        auto& arr_SyXYXNX=driverName_json.as_array();
        for(int vSFArQc=0; vSFArQc < VK_MAX_DRIVER_NAME_SIZE; vSFArQc++){
            [&](){arr_SyXYXNX[vSFArQc]=member.driverName[vSFArQc];}();
        }
        }();
auto& driverInfo_json=json["driverInfo"];
[&](){driverInfo_json=boost::json::array(VK_MAX_DRIVER_INFO_SIZE);
        auto& arr_TFnmGhH=driverInfo_json.as_array();
        for(int ZmulTHh=0; ZmulTHh < VK_MAX_DRIVER_INFO_SIZE; ZmulTHh++){
            [&](){arr_TFnmGhH[ZmulTHh]=member.driverInfo[ZmulTHh];}();
        }
        }();
auto& conformanceVersion_json=json["conformanceVersion"];
[&](){
            auto& temp=conformanceVersion_json.emplace_object();
            return serialize_struct(temp, member.conformanceVersion);
            }();
auto& denormBehaviorIndependence_json=json["denormBehaviorIndependence"];
[&](){[&](){[&](){denormBehaviorIndependence_json=member.denormBehaviorIndependence;}();}();}();
auto& roundingModeIndependence_json=json["roundingModeIndependence"];
[&](){[&](){[&](){roundingModeIndependence_json=member.roundingModeIndependence;}();}();}();
auto& shaderSignedZeroInfNanPreserveFloat16_json=json["shaderSignedZeroInfNanPreserveFloat16"];
[&](){[&](){shaderSignedZeroInfNanPreserveFloat16_json=member.shaderSignedZeroInfNanPreserveFloat16;}();}();
auto& shaderSignedZeroInfNanPreserveFloat32_json=json["shaderSignedZeroInfNanPreserveFloat32"];
[&](){[&](){shaderSignedZeroInfNanPreserveFloat32_json=member.shaderSignedZeroInfNanPreserveFloat32;}();}();
auto& shaderSignedZeroInfNanPreserveFloat64_json=json["shaderSignedZeroInfNanPreserveFloat64"];
[&](){[&](){shaderSignedZeroInfNanPreserveFloat64_json=member.shaderSignedZeroInfNanPreserveFloat64;}();}();
auto& shaderDenormPreserveFloat16_json=json["shaderDenormPreserveFloat16"];
[&](){[&](){shaderDenormPreserveFloat16_json=member.shaderDenormPreserveFloat16;}();}();
auto& shaderDenormPreserveFloat32_json=json["shaderDenormPreserveFloat32"];
[&](){[&](){shaderDenormPreserveFloat32_json=member.shaderDenormPreserveFloat32;}();}();
auto& shaderDenormPreserveFloat64_json=json["shaderDenormPreserveFloat64"];
[&](){[&](){shaderDenormPreserveFloat64_json=member.shaderDenormPreserveFloat64;}();}();
auto& shaderDenormFlushToZeroFloat16_json=json["shaderDenormFlushToZeroFloat16"];
[&](){[&](){shaderDenormFlushToZeroFloat16_json=member.shaderDenormFlushToZeroFloat16;}();}();
auto& shaderDenormFlushToZeroFloat32_json=json["shaderDenormFlushToZeroFloat32"];
[&](){[&](){shaderDenormFlushToZeroFloat32_json=member.shaderDenormFlushToZeroFloat32;}();}();
auto& shaderDenormFlushToZeroFloat64_json=json["shaderDenormFlushToZeroFloat64"];
[&](){[&](){shaderDenormFlushToZeroFloat64_json=member.shaderDenormFlushToZeroFloat64;}();}();
auto& shaderRoundingModeRTEFloat16_json=json["shaderRoundingModeRTEFloat16"];
[&](){[&](){shaderRoundingModeRTEFloat16_json=member.shaderRoundingModeRTEFloat16;}();}();
auto& shaderRoundingModeRTEFloat32_json=json["shaderRoundingModeRTEFloat32"];
[&](){[&](){shaderRoundingModeRTEFloat32_json=member.shaderRoundingModeRTEFloat32;}();}();
auto& shaderRoundingModeRTEFloat64_json=json["shaderRoundingModeRTEFloat64"];
[&](){[&](){shaderRoundingModeRTEFloat64_json=member.shaderRoundingModeRTEFloat64;}();}();
auto& shaderRoundingModeRTZFloat16_json=json["shaderRoundingModeRTZFloat16"];
[&](){[&](){shaderRoundingModeRTZFloat16_json=member.shaderRoundingModeRTZFloat16;}();}();
auto& shaderRoundingModeRTZFloat32_json=json["shaderRoundingModeRTZFloat32"];
[&](){[&](){shaderRoundingModeRTZFloat32_json=member.shaderRoundingModeRTZFloat32;}();}();
auto& shaderRoundingModeRTZFloat64_json=json["shaderRoundingModeRTZFloat64"];
[&](){[&](){shaderRoundingModeRTZFloat64_json=member.shaderRoundingModeRTZFloat64;}();}();
auto& maxUpdateAfterBindDescriptorsInAllPools_json=json["maxUpdateAfterBindDescriptorsInAllPools"];
[&](){maxUpdateAfterBindDescriptorsInAllPools_json=member.maxUpdateAfterBindDescriptorsInAllPools;}();
auto& shaderUniformBufferArrayNonUniformIndexingNative_json=json["shaderUniformBufferArrayNonUniformIndexingNative"];
[&](){[&](){shaderUniformBufferArrayNonUniformIndexingNative_json=member.shaderUniformBufferArrayNonUniformIndexingNative;}();}();
auto& shaderSampledImageArrayNonUniformIndexingNative_json=json["shaderSampledImageArrayNonUniformIndexingNative"];
[&](){[&](){shaderSampledImageArrayNonUniformIndexingNative_json=member.shaderSampledImageArrayNonUniformIndexingNative;}();}();
auto& shaderStorageBufferArrayNonUniformIndexingNative_json=json["shaderStorageBufferArrayNonUniformIndexingNative"];
[&](){[&](){shaderStorageBufferArrayNonUniformIndexingNative_json=member.shaderStorageBufferArrayNonUniformIndexingNative;}();}();
auto& shaderStorageImageArrayNonUniformIndexingNative_json=json["shaderStorageImageArrayNonUniformIndexingNative"];
[&](){[&](){shaderStorageImageArrayNonUniformIndexingNative_json=member.shaderStorageImageArrayNonUniformIndexingNative;}();}();
auto& shaderInputAttachmentArrayNonUniformIndexingNative_json=json["shaderInputAttachmentArrayNonUniformIndexingNative"];
[&](){[&](){shaderInputAttachmentArrayNonUniformIndexingNative_json=member.shaderInputAttachmentArrayNonUniformIndexingNative;}();}();
auto& robustBufferAccessUpdateAfterBind_json=json["robustBufferAccessUpdateAfterBind"];
[&](){[&](){robustBufferAccessUpdateAfterBind_json=member.robustBufferAccessUpdateAfterBind;}();}();
auto& quadDivergentImplicitLod_json=json["quadDivergentImplicitLod"];
[&](){[&](){quadDivergentImplicitLod_json=member.quadDivergentImplicitLod;}();}();
auto& maxPerStageDescriptorUpdateAfterBindSamplers_json=json["maxPerStageDescriptorUpdateAfterBindSamplers"];
[&](){maxPerStageDescriptorUpdateAfterBindSamplers_json=member.maxPerStageDescriptorUpdateAfterBindSamplers;}();
auto& maxPerStageDescriptorUpdateAfterBindUniformBuffers_json=json["maxPerStageDescriptorUpdateAfterBindUniformBuffers"];
[&](){maxPerStageDescriptorUpdateAfterBindUniformBuffers_json=member.maxPerStageDescriptorUpdateAfterBindUniformBuffers;}();
auto& maxPerStageDescriptorUpdateAfterBindStorageBuffers_json=json["maxPerStageDescriptorUpdateAfterBindStorageBuffers"];
[&](){maxPerStageDescriptorUpdateAfterBindStorageBuffers_json=member.maxPerStageDescriptorUpdateAfterBindStorageBuffers;}();
auto& maxPerStageDescriptorUpdateAfterBindSampledImages_json=json["maxPerStageDescriptorUpdateAfterBindSampledImages"];
[&](){maxPerStageDescriptorUpdateAfterBindSampledImages_json=member.maxPerStageDescriptorUpdateAfterBindSampledImages;}();
auto& maxPerStageDescriptorUpdateAfterBindStorageImages_json=json["maxPerStageDescriptorUpdateAfterBindStorageImages"];
[&](){maxPerStageDescriptorUpdateAfterBindStorageImages_json=member.maxPerStageDescriptorUpdateAfterBindStorageImages;}();
auto& maxPerStageDescriptorUpdateAfterBindInputAttachments_json=json["maxPerStageDescriptorUpdateAfterBindInputAttachments"];
[&](){maxPerStageDescriptorUpdateAfterBindInputAttachments_json=member.maxPerStageDescriptorUpdateAfterBindInputAttachments;}();
auto& maxPerStageUpdateAfterBindResources_json=json["maxPerStageUpdateAfterBindResources"];
[&](){maxPerStageUpdateAfterBindResources_json=member.maxPerStageUpdateAfterBindResources;}();
auto& maxDescriptorSetUpdateAfterBindSamplers_json=json["maxDescriptorSetUpdateAfterBindSamplers"];
[&](){maxDescriptorSetUpdateAfterBindSamplers_json=member.maxDescriptorSetUpdateAfterBindSamplers;}();
auto& maxDescriptorSetUpdateAfterBindUniformBuffers_json=json["maxDescriptorSetUpdateAfterBindUniformBuffers"];
[&](){maxDescriptorSetUpdateAfterBindUniformBuffers_json=member.maxDescriptorSetUpdateAfterBindUniformBuffers;}();
auto& maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_json=json["maxDescriptorSetUpdateAfterBindUniformBuffersDynamic"];
[&](){maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_json=member.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;}();
auto& maxDescriptorSetUpdateAfterBindStorageBuffers_json=json["maxDescriptorSetUpdateAfterBindStorageBuffers"];
[&](){maxDescriptorSetUpdateAfterBindStorageBuffers_json=member.maxDescriptorSetUpdateAfterBindStorageBuffers;}();
auto& maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_json=json["maxDescriptorSetUpdateAfterBindStorageBuffersDynamic"];
[&](){maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_json=member.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;}();
auto& maxDescriptorSetUpdateAfterBindSampledImages_json=json["maxDescriptorSetUpdateAfterBindSampledImages"];
[&](){maxDescriptorSetUpdateAfterBindSampledImages_json=member.maxDescriptorSetUpdateAfterBindSampledImages;}();
auto& maxDescriptorSetUpdateAfterBindStorageImages_json=json["maxDescriptorSetUpdateAfterBindStorageImages"];
[&](){maxDescriptorSetUpdateAfterBindStorageImages_json=member.maxDescriptorSetUpdateAfterBindStorageImages;}();
auto& maxDescriptorSetUpdateAfterBindInputAttachments_json=json["maxDescriptorSetUpdateAfterBindInputAttachments"];
[&](){maxDescriptorSetUpdateAfterBindInputAttachments_json=member.maxDescriptorSetUpdateAfterBindInputAttachments;}();
auto& supportedDepthResolveModes_json=json["supportedDepthResolveModes"];
[&](){[&](){[&](){supportedDepthResolveModes_json=member.supportedDepthResolveModes;}();}();}();
auto& supportedStencilResolveModes_json=json["supportedStencilResolveModes"];
[&](){[&](){[&](){supportedStencilResolveModes_json=member.supportedStencilResolveModes;}();}();}();
auto& independentResolveNone_json=json["independentResolveNone"];
[&](){[&](){independentResolveNone_json=member.independentResolveNone;}();}();
auto& independentResolve_json=json["independentResolve"];
[&](){[&](){independentResolve_json=member.independentResolve;}();}();
auto& filterMinmaxSingleComponentFormats_json=json["filterMinmaxSingleComponentFormats"];
[&](){[&](){filterMinmaxSingleComponentFormats_json=member.filterMinmaxSingleComponentFormats;}();}();
auto& filterMinmaxImageComponentMapping_json=json["filterMinmaxImageComponentMapping"];
[&](){[&](){filterMinmaxImageComponentMapping_json=member.filterMinmaxImageComponentMapping;}();}();
auto& maxTimelineSemaphoreValueDifference_json=json["maxTimelineSemaphoreValueDifference"];
[&](){maxTimelineSemaphoreValueDifference_json=member.maxTimelineSemaphoreValueDifference;}();
auto& framebufferIntegerColorSampleCounts_json=json["framebufferIntegerColorSampleCounts"];
[&](){[&](){[&](){framebufferIntegerColorSampleCounts_json=member.framebufferIntegerColorSampleCounts;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVulkan12Properties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& driverID_json=json["driverID"];
[&](){[&](){int temp_vHrPzGx;[&](){temp_vHrPzGx=static_cast<int>(value_to<int>(driverID_json));}();member.driverID=(VkDriverId)temp_vHrPzGx;}();}();
auto& driverName_json=json["driverName"];
[&](){
        auto& arr_SyXYXNX=driverName_json.as_array();
        for(int vSFArQc=0; vSFArQc < VK_MAX_DRIVER_NAME_SIZE; vSFArQc++){
            [&](){member.driverName[vSFArQc]=static_cast<char>(value_to<int>(arr_SyXYXNX[vSFArQc]));}();
        }
        }();
auto& driverInfo_json=json["driverInfo"];
[&](){
        auto& arr_TFnmGhH=driverInfo_json.as_array();
        for(int ZmulTHh=0; ZmulTHh < VK_MAX_DRIVER_INFO_SIZE; ZmulTHh++){
            [&](){member.driverInfo[ZmulTHh]=static_cast<char>(value_to<int>(arr_TFnmGhH[ZmulTHh]));}();
        }
        }();
auto& conformanceVersion_json=json["conformanceVersion"];
[&](){
            auto& temp=conformanceVersion_json.as_object();
            deserialize_struct(temp,member.conformanceVersion);
            }();
auto& denormBehaviorIndependence_json=json["denormBehaviorIndependence"];
[&](){[&](){int temp_BLtKgXu;[&](){temp_BLtKgXu=static_cast<int>(value_to<int>(denormBehaviorIndependence_json));}();member.denormBehaviorIndependence=(VkShaderFloatControlsIndependence)temp_BLtKgXu;}();}();
auto& roundingModeIndependence_json=json["roundingModeIndependence"];
[&](){[&](){int temp_HJUeGxa;[&](){temp_HJUeGxa=static_cast<int>(value_to<int>(roundingModeIndependence_json));}();member.roundingModeIndependence=(VkShaderFloatControlsIndependence)temp_HJUeGxa;}();}();
auto& shaderSignedZeroInfNanPreserveFloat16_json=json["shaderSignedZeroInfNanPreserveFloat16"];
[&](){uint32_t temp_rWhIHaR;[&](){temp_rWhIHaR=static_cast<uint32_t>(value_to<int>(shaderSignedZeroInfNanPreserveFloat16_json));}();member.shaderSignedZeroInfNanPreserveFloat16=(VkBool32)temp_rWhIHaR;}();
auto& shaderSignedZeroInfNanPreserveFloat32_json=json["shaderSignedZeroInfNanPreserveFloat32"];
[&](){uint32_t temp_TvnMBEH;[&](){temp_TvnMBEH=static_cast<uint32_t>(value_to<int>(shaderSignedZeroInfNanPreserveFloat32_json));}();member.shaderSignedZeroInfNanPreserveFloat32=(VkBool32)temp_TvnMBEH;}();
auto& shaderSignedZeroInfNanPreserveFloat64_json=json["shaderSignedZeroInfNanPreserveFloat64"];
[&](){uint32_t temp_kwFSZOJ;[&](){temp_kwFSZOJ=static_cast<uint32_t>(value_to<int>(shaderSignedZeroInfNanPreserveFloat64_json));}();member.shaderSignedZeroInfNanPreserveFloat64=(VkBool32)temp_kwFSZOJ;}();
auto& shaderDenormPreserveFloat16_json=json["shaderDenormPreserveFloat16"];
[&](){uint32_t temp_ZYjrgpL;[&](){temp_ZYjrgpL=static_cast<uint32_t>(value_to<int>(shaderDenormPreserveFloat16_json));}();member.shaderDenormPreserveFloat16=(VkBool32)temp_ZYjrgpL;}();
auto& shaderDenormPreserveFloat32_json=json["shaderDenormPreserveFloat32"];
[&](){uint32_t temp_sfVRrPx;[&](){temp_sfVRrPx=static_cast<uint32_t>(value_to<int>(shaderDenormPreserveFloat32_json));}();member.shaderDenormPreserveFloat32=(VkBool32)temp_sfVRrPx;}();
auto& shaderDenormPreserveFloat64_json=json["shaderDenormPreserveFloat64"];
[&](){uint32_t temp_UPaBbGA;[&](){temp_UPaBbGA=static_cast<uint32_t>(value_to<int>(shaderDenormPreserveFloat64_json));}();member.shaderDenormPreserveFloat64=(VkBool32)temp_UPaBbGA;}();
auto& shaderDenormFlushToZeroFloat16_json=json["shaderDenormFlushToZeroFloat16"];
[&](){uint32_t temp_GmxfgYW;[&](){temp_GmxfgYW=static_cast<uint32_t>(value_to<int>(shaderDenormFlushToZeroFloat16_json));}();member.shaderDenormFlushToZeroFloat16=(VkBool32)temp_GmxfgYW;}();
auto& shaderDenormFlushToZeroFloat32_json=json["shaderDenormFlushToZeroFloat32"];
[&](){uint32_t temp_nWzegbQ;[&](){temp_nWzegbQ=static_cast<uint32_t>(value_to<int>(shaderDenormFlushToZeroFloat32_json));}();member.shaderDenormFlushToZeroFloat32=(VkBool32)temp_nWzegbQ;}();
auto& shaderDenormFlushToZeroFloat64_json=json["shaderDenormFlushToZeroFloat64"];
[&](){uint32_t temp_LCXslrc;[&](){temp_LCXslrc=static_cast<uint32_t>(value_to<int>(shaderDenormFlushToZeroFloat64_json));}();member.shaderDenormFlushToZeroFloat64=(VkBool32)temp_LCXslrc;}();
auto& shaderRoundingModeRTEFloat16_json=json["shaderRoundingModeRTEFloat16"];
[&](){uint32_t temp_OoWLdCy;[&](){temp_OoWLdCy=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTEFloat16_json));}();member.shaderRoundingModeRTEFloat16=(VkBool32)temp_OoWLdCy;}();
auto& shaderRoundingModeRTEFloat32_json=json["shaderRoundingModeRTEFloat32"];
[&](){uint32_t temp_WzAzxFg;[&](){temp_WzAzxFg=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTEFloat32_json));}();member.shaderRoundingModeRTEFloat32=(VkBool32)temp_WzAzxFg;}();
auto& shaderRoundingModeRTEFloat64_json=json["shaderRoundingModeRTEFloat64"];
[&](){uint32_t temp_OLqczsx;[&](){temp_OLqczsx=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTEFloat64_json));}();member.shaderRoundingModeRTEFloat64=(VkBool32)temp_OLqczsx;}();
auto& shaderRoundingModeRTZFloat16_json=json["shaderRoundingModeRTZFloat16"];
[&](){uint32_t temp_xlTjUUK;[&](){temp_xlTjUUK=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTZFloat16_json));}();member.shaderRoundingModeRTZFloat16=(VkBool32)temp_xlTjUUK;}();
auto& shaderRoundingModeRTZFloat32_json=json["shaderRoundingModeRTZFloat32"];
[&](){uint32_t temp_CVmsBXR;[&](){temp_CVmsBXR=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTZFloat32_json));}();member.shaderRoundingModeRTZFloat32=(VkBool32)temp_CVmsBXR;}();
auto& shaderRoundingModeRTZFloat64_json=json["shaderRoundingModeRTZFloat64"];
[&](){uint32_t temp_jLYPXAU;[&](){temp_jLYPXAU=static_cast<uint32_t>(value_to<int>(shaderRoundingModeRTZFloat64_json));}();member.shaderRoundingModeRTZFloat64=(VkBool32)temp_jLYPXAU;}();
auto& maxUpdateAfterBindDescriptorsInAllPools_json=json["maxUpdateAfterBindDescriptorsInAllPools"];
[&](){member.maxUpdateAfterBindDescriptorsInAllPools=static_cast<uint32_t>(value_to<int>(maxUpdateAfterBindDescriptorsInAllPools_json));}();
auto& shaderUniformBufferArrayNonUniformIndexingNative_json=json["shaderUniformBufferArrayNonUniformIndexingNative"];
[&](){uint32_t temp_cKfmDrI;[&](){temp_cKfmDrI=static_cast<uint32_t>(value_to<int>(shaderUniformBufferArrayNonUniformIndexingNative_json));}();member.shaderUniformBufferArrayNonUniformIndexingNative=(VkBool32)temp_cKfmDrI;}();
auto& shaderSampledImageArrayNonUniformIndexingNative_json=json["shaderSampledImageArrayNonUniformIndexingNative"];
[&](){uint32_t temp_myHZdDe;[&](){temp_myHZdDe=static_cast<uint32_t>(value_to<int>(shaderSampledImageArrayNonUniformIndexingNative_json));}();member.shaderSampledImageArrayNonUniformIndexingNative=(VkBool32)temp_myHZdDe;}();
auto& shaderStorageBufferArrayNonUniformIndexingNative_json=json["shaderStorageBufferArrayNonUniformIndexingNative"];
[&](){uint32_t temp_RezyGAK;[&](){temp_RezyGAK=static_cast<uint32_t>(value_to<int>(shaderStorageBufferArrayNonUniformIndexingNative_json));}();member.shaderStorageBufferArrayNonUniformIndexingNative=(VkBool32)temp_RezyGAK;}();
auto& shaderStorageImageArrayNonUniformIndexingNative_json=json["shaderStorageImageArrayNonUniformIndexingNative"];
[&](){uint32_t temp_FTqVGBQ;[&](){temp_FTqVGBQ=static_cast<uint32_t>(value_to<int>(shaderStorageImageArrayNonUniformIndexingNative_json));}();member.shaderStorageImageArrayNonUniformIndexingNative=(VkBool32)temp_FTqVGBQ;}();
auto& shaderInputAttachmentArrayNonUniformIndexingNative_json=json["shaderInputAttachmentArrayNonUniformIndexingNative"];
[&](){uint32_t temp_KqorXqH;[&](){temp_KqorXqH=static_cast<uint32_t>(value_to<int>(shaderInputAttachmentArrayNonUniformIndexingNative_json));}();member.shaderInputAttachmentArrayNonUniformIndexingNative=(VkBool32)temp_KqorXqH;}();
auto& robustBufferAccessUpdateAfterBind_json=json["robustBufferAccessUpdateAfterBind"];
[&](){uint32_t temp_LlZxjdH;[&](){temp_LlZxjdH=static_cast<uint32_t>(value_to<int>(robustBufferAccessUpdateAfterBind_json));}();member.robustBufferAccessUpdateAfterBind=(VkBool32)temp_LlZxjdH;}();
auto& quadDivergentImplicitLod_json=json["quadDivergentImplicitLod"];
[&](){uint32_t temp_gaWUOsp;[&](){temp_gaWUOsp=static_cast<uint32_t>(value_to<int>(quadDivergentImplicitLod_json));}();member.quadDivergentImplicitLod=(VkBool32)temp_gaWUOsp;}();
auto& maxPerStageDescriptorUpdateAfterBindSamplers_json=json["maxPerStageDescriptorUpdateAfterBindSamplers"];
[&](){member.maxPerStageDescriptorUpdateAfterBindSamplers=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindSamplers_json));}();
auto& maxPerStageDescriptorUpdateAfterBindUniformBuffers_json=json["maxPerStageDescriptorUpdateAfterBindUniformBuffers"];
[&](){member.maxPerStageDescriptorUpdateAfterBindUniformBuffers=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindUniformBuffers_json));}();
auto& maxPerStageDescriptorUpdateAfterBindStorageBuffers_json=json["maxPerStageDescriptorUpdateAfterBindStorageBuffers"];
[&](){member.maxPerStageDescriptorUpdateAfterBindStorageBuffers=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindStorageBuffers_json));}();
auto& maxPerStageDescriptorUpdateAfterBindSampledImages_json=json["maxPerStageDescriptorUpdateAfterBindSampledImages"];
[&](){member.maxPerStageDescriptorUpdateAfterBindSampledImages=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindSampledImages_json));}();
auto& maxPerStageDescriptorUpdateAfterBindStorageImages_json=json["maxPerStageDescriptorUpdateAfterBindStorageImages"];
[&](){member.maxPerStageDescriptorUpdateAfterBindStorageImages=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindStorageImages_json));}();
auto& maxPerStageDescriptorUpdateAfterBindInputAttachments_json=json["maxPerStageDescriptorUpdateAfterBindInputAttachments"];
[&](){member.maxPerStageDescriptorUpdateAfterBindInputAttachments=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindInputAttachments_json));}();
auto& maxPerStageUpdateAfterBindResources_json=json["maxPerStageUpdateAfterBindResources"];
[&](){member.maxPerStageUpdateAfterBindResources=static_cast<uint32_t>(value_to<int>(maxPerStageUpdateAfterBindResources_json));}();
auto& maxDescriptorSetUpdateAfterBindSamplers_json=json["maxDescriptorSetUpdateAfterBindSamplers"];
[&](){member.maxDescriptorSetUpdateAfterBindSamplers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindSamplers_json));}();
auto& maxDescriptorSetUpdateAfterBindUniformBuffers_json=json["maxDescriptorSetUpdateAfterBindUniformBuffers"];
[&](){member.maxDescriptorSetUpdateAfterBindUniformBuffers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindUniformBuffers_json));}();
auto& maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_json=json["maxDescriptorSetUpdateAfterBindUniformBuffersDynamic"];
[&](){member.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_json));}();
auto& maxDescriptorSetUpdateAfterBindStorageBuffers_json=json["maxDescriptorSetUpdateAfterBindStorageBuffers"];
[&](){member.maxDescriptorSetUpdateAfterBindStorageBuffers=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindStorageBuffers_json));}();
auto& maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_json=json["maxDescriptorSetUpdateAfterBindStorageBuffersDynamic"];
[&](){member.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_json));}();
auto& maxDescriptorSetUpdateAfterBindSampledImages_json=json["maxDescriptorSetUpdateAfterBindSampledImages"];
[&](){member.maxDescriptorSetUpdateAfterBindSampledImages=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindSampledImages_json));}();
auto& maxDescriptorSetUpdateAfterBindStorageImages_json=json["maxDescriptorSetUpdateAfterBindStorageImages"];
[&](){member.maxDescriptorSetUpdateAfterBindStorageImages=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindStorageImages_json));}();
auto& maxDescriptorSetUpdateAfterBindInputAttachments_json=json["maxDescriptorSetUpdateAfterBindInputAttachments"];
[&](){member.maxDescriptorSetUpdateAfterBindInputAttachments=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindInputAttachments_json));}();
auto& supportedDepthResolveModes_json=json["supportedDepthResolveModes"];
[&](){[&](){int temp_juBDFoI;[&](){temp_juBDFoI=static_cast<int>(value_to<int>(supportedDepthResolveModes_json));}();member.supportedDepthResolveModes=(VkResolveModeFlags)temp_juBDFoI;}();}();
auto& supportedStencilResolveModes_json=json["supportedStencilResolveModes"];
[&](){[&](){int temp_QFrMlAg;[&](){temp_QFrMlAg=static_cast<int>(value_to<int>(supportedStencilResolveModes_json));}();member.supportedStencilResolveModes=(VkResolveModeFlags)temp_QFrMlAg;}();}();
auto& independentResolveNone_json=json["independentResolveNone"];
[&](){uint32_t temp_AhFrMTv;[&](){temp_AhFrMTv=static_cast<uint32_t>(value_to<int>(independentResolveNone_json));}();member.independentResolveNone=(VkBool32)temp_AhFrMTv;}();
auto& independentResolve_json=json["independentResolve"];
[&](){uint32_t temp_anItncR;[&](){temp_anItncR=static_cast<uint32_t>(value_to<int>(independentResolve_json));}();member.independentResolve=(VkBool32)temp_anItncR;}();
auto& filterMinmaxSingleComponentFormats_json=json["filterMinmaxSingleComponentFormats"];
[&](){uint32_t temp_DdyYeOw;[&](){temp_DdyYeOw=static_cast<uint32_t>(value_to<int>(filterMinmaxSingleComponentFormats_json));}();member.filterMinmaxSingleComponentFormats=(VkBool32)temp_DdyYeOw;}();
auto& filterMinmaxImageComponentMapping_json=json["filterMinmaxImageComponentMapping"];
[&](){uint32_t temp_laYBitp;[&](){temp_laYBitp=static_cast<uint32_t>(value_to<int>(filterMinmaxImageComponentMapping_json));}();member.filterMinmaxImageComponentMapping=(VkBool32)temp_laYBitp;}();
auto& maxTimelineSemaphoreValueDifference_json=json["maxTimelineSemaphoreValueDifference"];
[&](){member.maxTimelineSemaphoreValueDifference=static_cast<uint64_t>(value_to<int>(maxTimelineSemaphoreValueDifference_json));}();
auto& framebufferIntegerColorSampleCounts_json=json["framebufferIntegerColorSampleCounts"];
[&](){[&](){int temp_UeWXZDg;[&](){temp_UeWXZDg=static_cast<int>(value_to<int>(framebufferIntegerColorSampleCounts_json));}();member.framebufferIntegerColorSampleCounts=(VkSampleCountFlags)temp_UeWXZDg;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVulkan13Features& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& robustImageAccess_json=json["robustImageAccess"];
[&](){[&](){robustImageAccess_json=member.robustImageAccess;}();}();
auto& inlineUniformBlock_json=json["inlineUniformBlock"];
[&](){[&](){inlineUniformBlock_json=member.inlineUniformBlock;}();}();
auto& descriptorBindingInlineUniformBlockUpdateAfterBind_json=json["descriptorBindingInlineUniformBlockUpdateAfterBind"];
[&](){[&](){descriptorBindingInlineUniformBlockUpdateAfterBind_json=member.descriptorBindingInlineUniformBlockUpdateAfterBind;}();}();
auto& pipelineCreationCacheControl_json=json["pipelineCreationCacheControl"];
[&](){[&](){pipelineCreationCacheControl_json=member.pipelineCreationCacheControl;}();}();
auto& privateData_json=json["privateData"];
[&](){[&](){privateData_json=member.privateData;}();}();
auto& shaderDemoteToHelperInvocation_json=json["shaderDemoteToHelperInvocation"];
[&](){[&](){shaderDemoteToHelperInvocation_json=member.shaderDemoteToHelperInvocation;}();}();
auto& shaderTerminateInvocation_json=json["shaderTerminateInvocation"];
[&](){[&](){shaderTerminateInvocation_json=member.shaderTerminateInvocation;}();}();
auto& subgroupSizeControl_json=json["subgroupSizeControl"];
[&](){[&](){subgroupSizeControl_json=member.subgroupSizeControl;}();}();
auto& computeFullSubgroups_json=json["computeFullSubgroups"];
[&](){[&](){computeFullSubgroups_json=member.computeFullSubgroups;}();}();
auto& synchronization2_json=json["synchronization2"];
[&](){[&](){synchronization2_json=member.synchronization2;}();}();
auto& textureCompressionASTC_HDR_json=json["textureCompressionASTC_HDR"];
[&](){[&](){textureCompressionASTC_HDR_json=member.textureCompressionASTC_HDR;}();}();
auto& shaderZeroInitializeWorkgroupMemory_json=json["shaderZeroInitializeWorkgroupMemory"];
[&](){[&](){shaderZeroInitializeWorkgroupMemory_json=member.shaderZeroInitializeWorkgroupMemory;}();}();
auto& dynamicRendering_json=json["dynamicRendering"];
[&](){[&](){dynamicRendering_json=member.dynamicRendering;}();}();
auto& shaderIntegerDotProduct_json=json["shaderIntegerDotProduct"];
[&](){[&](){shaderIntegerDotProduct_json=member.shaderIntegerDotProduct;}();}();
auto& maintenance4_json=json["maintenance4"];
[&](){[&](){maintenance4_json=member.maintenance4;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVulkan13Features& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& robustImageAccess_json=json["robustImageAccess"];
[&](){uint32_t temp_UzJnzpL;[&](){temp_UzJnzpL=static_cast<uint32_t>(value_to<int>(robustImageAccess_json));}();member.robustImageAccess=(VkBool32)temp_UzJnzpL;}();
auto& inlineUniformBlock_json=json["inlineUniformBlock"];
[&](){uint32_t temp_AHQNchS;[&](){temp_AHQNchS=static_cast<uint32_t>(value_to<int>(inlineUniformBlock_json));}();member.inlineUniformBlock=(VkBool32)temp_AHQNchS;}();
auto& descriptorBindingInlineUniformBlockUpdateAfterBind_json=json["descriptorBindingInlineUniformBlockUpdateAfterBind"];
[&](){uint32_t temp_HCUdNQI;[&](){temp_HCUdNQI=static_cast<uint32_t>(value_to<int>(descriptorBindingInlineUniformBlockUpdateAfterBind_json));}();member.descriptorBindingInlineUniformBlockUpdateAfterBind=(VkBool32)temp_HCUdNQI;}();
auto& pipelineCreationCacheControl_json=json["pipelineCreationCacheControl"];
[&](){uint32_t temp_pylGmuz;[&](){temp_pylGmuz=static_cast<uint32_t>(value_to<int>(pipelineCreationCacheControl_json));}();member.pipelineCreationCacheControl=(VkBool32)temp_pylGmuz;}();
auto& privateData_json=json["privateData"];
[&](){uint32_t temp_dlWhRic;[&](){temp_dlWhRic=static_cast<uint32_t>(value_to<int>(privateData_json));}();member.privateData=(VkBool32)temp_dlWhRic;}();
auto& shaderDemoteToHelperInvocation_json=json["shaderDemoteToHelperInvocation"];
[&](){uint32_t temp_VPshPOm;[&](){temp_VPshPOm=static_cast<uint32_t>(value_to<int>(shaderDemoteToHelperInvocation_json));}();member.shaderDemoteToHelperInvocation=(VkBool32)temp_VPshPOm;}();
auto& shaderTerminateInvocation_json=json["shaderTerminateInvocation"];
[&](){uint32_t temp_CsrLjgN;[&](){temp_CsrLjgN=static_cast<uint32_t>(value_to<int>(shaderTerminateInvocation_json));}();member.shaderTerminateInvocation=(VkBool32)temp_CsrLjgN;}();
auto& subgroupSizeControl_json=json["subgroupSizeControl"];
[&](){uint32_t temp_LqAuymN;[&](){temp_LqAuymN=static_cast<uint32_t>(value_to<int>(subgroupSizeControl_json));}();member.subgroupSizeControl=(VkBool32)temp_LqAuymN;}();
auto& computeFullSubgroups_json=json["computeFullSubgroups"];
[&](){uint32_t temp_niRFeFb;[&](){temp_niRFeFb=static_cast<uint32_t>(value_to<int>(computeFullSubgroups_json));}();member.computeFullSubgroups=(VkBool32)temp_niRFeFb;}();
auto& synchronization2_json=json["synchronization2"];
[&](){uint32_t temp_zHZoxeW;[&](){temp_zHZoxeW=static_cast<uint32_t>(value_to<int>(synchronization2_json));}();member.synchronization2=(VkBool32)temp_zHZoxeW;}();
auto& textureCompressionASTC_HDR_json=json["textureCompressionASTC_HDR"];
[&](){uint32_t temp_FUhDyOz;[&](){temp_FUhDyOz=static_cast<uint32_t>(value_to<int>(textureCompressionASTC_HDR_json));}();member.textureCompressionASTC_HDR=(VkBool32)temp_FUhDyOz;}();
auto& shaderZeroInitializeWorkgroupMemory_json=json["shaderZeroInitializeWorkgroupMemory"];
[&](){uint32_t temp_TYydgpp;[&](){temp_TYydgpp=static_cast<uint32_t>(value_to<int>(shaderZeroInitializeWorkgroupMemory_json));}();member.shaderZeroInitializeWorkgroupMemory=(VkBool32)temp_TYydgpp;}();
auto& dynamicRendering_json=json["dynamicRendering"];
[&](){uint32_t temp_sIAWlvy;[&](){temp_sIAWlvy=static_cast<uint32_t>(value_to<int>(dynamicRendering_json));}();member.dynamicRendering=(VkBool32)temp_sIAWlvy;}();
auto& shaderIntegerDotProduct_json=json["shaderIntegerDotProduct"];
[&](){uint32_t temp_eNUMtoL;[&](){temp_eNUMtoL=static_cast<uint32_t>(value_to<int>(shaderIntegerDotProduct_json));}();member.shaderIntegerDotProduct=(VkBool32)temp_eNUMtoL;}();
auto& maintenance4_json=json["maintenance4"];
[&](){uint32_t temp_nYvfKwI;[&](){temp_nYvfKwI=static_cast<uint32_t>(value_to<int>(maintenance4_json));}();member.maintenance4=(VkBool32)temp_nYvfKwI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVulkan13Properties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& minSubgroupSize_json=json["minSubgroupSize"];
[&](){minSubgroupSize_json=member.minSubgroupSize;}();
auto& maxSubgroupSize_json=json["maxSubgroupSize"];
[&](){maxSubgroupSize_json=member.maxSubgroupSize;}();
auto& maxComputeWorkgroupSubgroups_json=json["maxComputeWorkgroupSubgroups"];
[&](){maxComputeWorkgroupSubgroups_json=member.maxComputeWorkgroupSubgroups;}();
auto& requiredSubgroupSizeStages_json=json["requiredSubgroupSizeStages"];
[&](){[&](){[&](){requiredSubgroupSizeStages_json=member.requiredSubgroupSizeStages;}();}();}();
auto& maxInlineUniformBlockSize_json=json["maxInlineUniformBlockSize"];
[&](){maxInlineUniformBlockSize_json=member.maxInlineUniformBlockSize;}();
auto& maxPerStageDescriptorInlineUniformBlocks_json=json["maxPerStageDescriptorInlineUniformBlocks"];
[&](){maxPerStageDescriptorInlineUniformBlocks_json=member.maxPerStageDescriptorInlineUniformBlocks;}();
auto& maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_json=json["maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks"];
[&](){maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_json=member.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;}();
auto& maxDescriptorSetInlineUniformBlocks_json=json["maxDescriptorSetInlineUniformBlocks"];
[&](){maxDescriptorSetInlineUniformBlocks_json=member.maxDescriptorSetInlineUniformBlocks;}();
auto& maxDescriptorSetUpdateAfterBindInlineUniformBlocks_json=json["maxDescriptorSetUpdateAfterBindInlineUniformBlocks"];
[&](){maxDescriptorSetUpdateAfterBindInlineUniformBlocks_json=member.maxDescriptorSetUpdateAfterBindInlineUniformBlocks;}();
auto& maxInlineUniformTotalSize_json=json["maxInlineUniformTotalSize"];
[&](){maxInlineUniformTotalSize_json=member.maxInlineUniformTotalSize;}();
auto& integerDotProduct8BitUnsignedAccelerated_json=json["integerDotProduct8BitUnsignedAccelerated"];
[&](){[&](){integerDotProduct8BitUnsignedAccelerated_json=member.integerDotProduct8BitUnsignedAccelerated;}();}();
auto& integerDotProduct8BitSignedAccelerated_json=json["integerDotProduct8BitSignedAccelerated"];
[&](){[&](){integerDotProduct8BitSignedAccelerated_json=member.integerDotProduct8BitSignedAccelerated;}();}();
auto& integerDotProduct8BitMixedSignednessAccelerated_json=json["integerDotProduct8BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct8BitMixedSignednessAccelerated_json=member.integerDotProduct8BitMixedSignednessAccelerated;}();}();
auto& integerDotProduct4x8BitPackedUnsignedAccelerated_json=json["integerDotProduct4x8BitPackedUnsignedAccelerated"];
[&](){[&](){integerDotProduct4x8BitPackedUnsignedAccelerated_json=member.integerDotProduct4x8BitPackedUnsignedAccelerated;}();}();
auto& integerDotProduct4x8BitPackedSignedAccelerated_json=json["integerDotProduct4x8BitPackedSignedAccelerated"];
[&](){[&](){integerDotProduct4x8BitPackedSignedAccelerated_json=member.integerDotProduct4x8BitPackedSignedAccelerated;}();}();
auto& integerDotProduct4x8BitPackedMixedSignednessAccelerated_json=json["integerDotProduct4x8BitPackedMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct4x8BitPackedMixedSignednessAccelerated_json=member.integerDotProduct4x8BitPackedMixedSignednessAccelerated;}();}();
auto& integerDotProduct16BitUnsignedAccelerated_json=json["integerDotProduct16BitUnsignedAccelerated"];
[&](){[&](){integerDotProduct16BitUnsignedAccelerated_json=member.integerDotProduct16BitUnsignedAccelerated;}();}();
auto& integerDotProduct16BitSignedAccelerated_json=json["integerDotProduct16BitSignedAccelerated"];
[&](){[&](){integerDotProduct16BitSignedAccelerated_json=member.integerDotProduct16BitSignedAccelerated;}();}();
auto& integerDotProduct16BitMixedSignednessAccelerated_json=json["integerDotProduct16BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct16BitMixedSignednessAccelerated_json=member.integerDotProduct16BitMixedSignednessAccelerated;}();}();
auto& integerDotProduct32BitUnsignedAccelerated_json=json["integerDotProduct32BitUnsignedAccelerated"];
[&](){[&](){integerDotProduct32BitUnsignedAccelerated_json=member.integerDotProduct32BitUnsignedAccelerated;}();}();
auto& integerDotProduct32BitSignedAccelerated_json=json["integerDotProduct32BitSignedAccelerated"];
[&](){[&](){integerDotProduct32BitSignedAccelerated_json=member.integerDotProduct32BitSignedAccelerated;}();}();
auto& integerDotProduct32BitMixedSignednessAccelerated_json=json["integerDotProduct32BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct32BitMixedSignednessAccelerated_json=member.integerDotProduct32BitMixedSignednessAccelerated;}();}();
auto& integerDotProduct64BitUnsignedAccelerated_json=json["integerDotProduct64BitUnsignedAccelerated"];
[&](){[&](){integerDotProduct64BitUnsignedAccelerated_json=member.integerDotProduct64BitUnsignedAccelerated;}();}();
auto& integerDotProduct64BitSignedAccelerated_json=json["integerDotProduct64BitSignedAccelerated"];
[&](){[&](){integerDotProduct64BitSignedAccelerated_json=member.integerDotProduct64BitSignedAccelerated;}();}();
auto& integerDotProduct64BitMixedSignednessAccelerated_json=json["integerDotProduct64BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct64BitMixedSignednessAccelerated_json=member.integerDotProduct64BitMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating8BitUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating8BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating8BitSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating8BitSignedAccelerated_json=member.integerDotProductAccumulatingSaturating8BitSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_json=member.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating16BitUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating16BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating16BitSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating16BitSignedAccelerated_json=member.integerDotProductAccumulatingSaturating16BitSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating32BitUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating32BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating32BitSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating32BitSignedAccelerated_json=member.integerDotProductAccumulatingSaturating32BitSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating64BitUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating64BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating64BitSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating64BitSignedAccelerated_json=member.integerDotProductAccumulatingSaturating64BitSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;}();}();
auto& storageTexelBufferOffsetAlignmentBytes_json=json["storageTexelBufferOffsetAlignmentBytes"];
[&](){[&](){storageTexelBufferOffsetAlignmentBytes_json=member.storageTexelBufferOffsetAlignmentBytes;}();}();
auto& storageTexelBufferOffsetSingleTexelAlignment_json=json["storageTexelBufferOffsetSingleTexelAlignment"];
[&](){[&](){storageTexelBufferOffsetSingleTexelAlignment_json=member.storageTexelBufferOffsetSingleTexelAlignment;}();}();
auto& uniformTexelBufferOffsetAlignmentBytes_json=json["uniformTexelBufferOffsetAlignmentBytes"];
[&](){[&](){uniformTexelBufferOffsetAlignmentBytes_json=member.uniformTexelBufferOffsetAlignmentBytes;}();}();
auto& uniformTexelBufferOffsetSingleTexelAlignment_json=json["uniformTexelBufferOffsetSingleTexelAlignment"];
[&](){[&](){uniformTexelBufferOffsetSingleTexelAlignment_json=member.uniformTexelBufferOffsetSingleTexelAlignment;}();}();
auto& maxBufferSize_json=json["maxBufferSize"];
[&](){[&](){maxBufferSize_json=member.maxBufferSize;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVulkan13Properties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& minSubgroupSize_json=json["minSubgroupSize"];
[&](){member.minSubgroupSize=static_cast<uint32_t>(value_to<int>(minSubgroupSize_json));}();
auto& maxSubgroupSize_json=json["maxSubgroupSize"];
[&](){member.maxSubgroupSize=static_cast<uint32_t>(value_to<int>(maxSubgroupSize_json));}();
auto& maxComputeWorkgroupSubgroups_json=json["maxComputeWorkgroupSubgroups"];
[&](){member.maxComputeWorkgroupSubgroups=static_cast<uint32_t>(value_to<int>(maxComputeWorkgroupSubgroups_json));}();
auto& requiredSubgroupSizeStages_json=json["requiredSubgroupSizeStages"];
[&](){[&](){int temp_dasyLIM;[&](){temp_dasyLIM=static_cast<int>(value_to<int>(requiredSubgroupSizeStages_json));}();member.requiredSubgroupSizeStages=(VkShaderStageFlags)temp_dasyLIM;}();}();
auto& maxInlineUniformBlockSize_json=json["maxInlineUniformBlockSize"];
[&](){member.maxInlineUniformBlockSize=static_cast<uint32_t>(value_to<int>(maxInlineUniformBlockSize_json));}();
auto& maxPerStageDescriptorInlineUniformBlocks_json=json["maxPerStageDescriptorInlineUniformBlocks"];
[&](){member.maxPerStageDescriptorInlineUniformBlocks=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorInlineUniformBlocks_json));}();
auto& maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_json=json["maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks"];
[&](){member.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks=static_cast<uint32_t>(value_to<int>(maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_json));}();
auto& maxDescriptorSetInlineUniformBlocks_json=json["maxDescriptorSetInlineUniformBlocks"];
[&](){member.maxDescriptorSetInlineUniformBlocks=static_cast<uint32_t>(value_to<int>(maxDescriptorSetInlineUniformBlocks_json));}();
auto& maxDescriptorSetUpdateAfterBindInlineUniformBlocks_json=json["maxDescriptorSetUpdateAfterBindInlineUniformBlocks"];
[&](){member.maxDescriptorSetUpdateAfterBindInlineUniformBlocks=static_cast<uint32_t>(value_to<int>(maxDescriptorSetUpdateAfterBindInlineUniformBlocks_json));}();
auto& maxInlineUniformTotalSize_json=json["maxInlineUniformTotalSize"];
[&](){member.maxInlineUniformTotalSize=static_cast<uint32_t>(value_to<int>(maxInlineUniformTotalSize_json));}();
auto& integerDotProduct8BitUnsignedAccelerated_json=json["integerDotProduct8BitUnsignedAccelerated"];
[&](){uint32_t temp_fDqbRQt;[&](){temp_fDqbRQt=static_cast<uint32_t>(value_to<int>(integerDotProduct8BitUnsignedAccelerated_json));}();member.integerDotProduct8BitUnsignedAccelerated=(VkBool32)temp_fDqbRQt;}();
auto& integerDotProduct8BitSignedAccelerated_json=json["integerDotProduct8BitSignedAccelerated"];
[&](){uint32_t temp_OVVZAzm;[&](){temp_OVVZAzm=static_cast<uint32_t>(value_to<int>(integerDotProduct8BitSignedAccelerated_json));}();member.integerDotProduct8BitSignedAccelerated=(VkBool32)temp_OVVZAzm;}();
auto& integerDotProduct8BitMixedSignednessAccelerated_json=json["integerDotProduct8BitMixedSignednessAccelerated"];
[&](){uint32_t temp_ZPpCkIW;[&](){temp_ZPpCkIW=static_cast<uint32_t>(value_to<int>(integerDotProduct8BitMixedSignednessAccelerated_json));}();member.integerDotProduct8BitMixedSignednessAccelerated=(VkBool32)temp_ZPpCkIW;}();
auto& integerDotProduct4x8BitPackedUnsignedAccelerated_json=json["integerDotProduct4x8BitPackedUnsignedAccelerated"];
[&](){uint32_t temp_QQSXkLc;[&](){temp_QQSXkLc=static_cast<uint32_t>(value_to<int>(integerDotProduct4x8BitPackedUnsignedAccelerated_json));}();member.integerDotProduct4x8BitPackedUnsignedAccelerated=(VkBool32)temp_QQSXkLc;}();
auto& integerDotProduct4x8BitPackedSignedAccelerated_json=json["integerDotProduct4x8BitPackedSignedAccelerated"];
[&](){uint32_t temp_hjLzHHu;[&](){temp_hjLzHHu=static_cast<uint32_t>(value_to<int>(integerDotProduct4x8BitPackedSignedAccelerated_json));}();member.integerDotProduct4x8BitPackedSignedAccelerated=(VkBool32)temp_hjLzHHu;}();
auto& integerDotProduct4x8BitPackedMixedSignednessAccelerated_json=json["integerDotProduct4x8BitPackedMixedSignednessAccelerated"];
[&](){uint32_t temp_iTsrloW;[&](){temp_iTsrloW=static_cast<uint32_t>(value_to<int>(integerDotProduct4x8BitPackedMixedSignednessAccelerated_json));}();member.integerDotProduct4x8BitPackedMixedSignednessAccelerated=(VkBool32)temp_iTsrloW;}();
auto& integerDotProduct16BitUnsignedAccelerated_json=json["integerDotProduct16BitUnsignedAccelerated"];
[&](){uint32_t temp_RlYaNQJ;[&](){temp_RlYaNQJ=static_cast<uint32_t>(value_to<int>(integerDotProduct16BitUnsignedAccelerated_json));}();member.integerDotProduct16BitUnsignedAccelerated=(VkBool32)temp_RlYaNQJ;}();
auto& integerDotProduct16BitSignedAccelerated_json=json["integerDotProduct16BitSignedAccelerated"];
[&](){uint32_t temp_oazBVOM;[&](){temp_oazBVOM=static_cast<uint32_t>(value_to<int>(integerDotProduct16BitSignedAccelerated_json));}();member.integerDotProduct16BitSignedAccelerated=(VkBool32)temp_oazBVOM;}();
auto& integerDotProduct16BitMixedSignednessAccelerated_json=json["integerDotProduct16BitMixedSignednessAccelerated"];
[&](){uint32_t temp_VtDSaBh;[&](){temp_VtDSaBh=static_cast<uint32_t>(value_to<int>(integerDotProduct16BitMixedSignednessAccelerated_json));}();member.integerDotProduct16BitMixedSignednessAccelerated=(VkBool32)temp_VtDSaBh;}();
auto& integerDotProduct32BitUnsignedAccelerated_json=json["integerDotProduct32BitUnsignedAccelerated"];
[&](){uint32_t temp_mQdwEcH;[&](){temp_mQdwEcH=static_cast<uint32_t>(value_to<int>(integerDotProduct32BitUnsignedAccelerated_json));}();member.integerDotProduct32BitUnsignedAccelerated=(VkBool32)temp_mQdwEcH;}();
auto& integerDotProduct32BitSignedAccelerated_json=json["integerDotProduct32BitSignedAccelerated"];
[&](){uint32_t temp_fZyGLve;[&](){temp_fZyGLve=static_cast<uint32_t>(value_to<int>(integerDotProduct32BitSignedAccelerated_json));}();member.integerDotProduct32BitSignedAccelerated=(VkBool32)temp_fZyGLve;}();
auto& integerDotProduct32BitMixedSignednessAccelerated_json=json["integerDotProduct32BitMixedSignednessAccelerated"];
[&](){uint32_t temp_rOzQkzt;[&](){temp_rOzQkzt=static_cast<uint32_t>(value_to<int>(integerDotProduct32BitMixedSignednessAccelerated_json));}();member.integerDotProduct32BitMixedSignednessAccelerated=(VkBool32)temp_rOzQkzt;}();
auto& integerDotProduct64BitUnsignedAccelerated_json=json["integerDotProduct64BitUnsignedAccelerated"];
[&](){uint32_t temp_cibSbVP;[&](){temp_cibSbVP=static_cast<uint32_t>(value_to<int>(integerDotProduct64BitUnsignedAccelerated_json));}();member.integerDotProduct64BitUnsignedAccelerated=(VkBool32)temp_cibSbVP;}();
auto& integerDotProduct64BitSignedAccelerated_json=json["integerDotProduct64BitSignedAccelerated"];
[&](){uint32_t temp_wxUhdFT;[&](){temp_wxUhdFT=static_cast<uint32_t>(value_to<int>(integerDotProduct64BitSignedAccelerated_json));}();member.integerDotProduct64BitSignedAccelerated=(VkBool32)temp_wxUhdFT;}();
auto& integerDotProduct64BitMixedSignednessAccelerated_json=json["integerDotProduct64BitMixedSignednessAccelerated"];
[&](){uint32_t temp_gyfEcYC;[&](){temp_gyfEcYC=static_cast<uint32_t>(value_to<int>(integerDotProduct64BitMixedSignednessAccelerated_json));}();member.integerDotProduct64BitMixedSignednessAccelerated=(VkBool32)temp_gyfEcYC;}();
auto& integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating8BitUnsignedAccelerated"];
[&](){uint32_t temp_TMcyhrX;[&](){temp_TMcyhrX=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated=(VkBool32)temp_TMcyhrX;}();
auto& integerDotProductAccumulatingSaturating8BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating8BitSignedAccelerated"];
[&](){uint32_t temp_LeRvzBX;[&](){temp_LeRvzBX=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating8BitSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating8BitSignedAccelerated=(VkBool32)temp_LeRvzBX;}();
auto& integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated"];
[&](){uint32_t temp_jHhlRkW;[&](){temp_jHhlRkW=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated=(VkBool32)temp_jHhlRkW;}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated"];
[&](){uint32_t temp_FndoQSL;[&](){temp_FndoQSL=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated=(VkBool32)temp_FndoQSL;}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated"];
[&](){uint32_t temp_thuQCSE;[&](){temp_thuQCSE=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated=(VkBool32)temp_thuQCSE;}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated"];
[&](){uint32_t temp_VHhaQJU;[&](){temp_VHhaQJU=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated=(VkBool32)temp_VHhaQJU;}();
auto& integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating16BitUnsignedAccelerated"];
[&](){uint32_t temp_acIgfMM;[&](){temp_acIgfMM=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated=(VkBool32)temp_acIgfMM;}();
auto& integerDotProductAccumulatingSaturating16BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating16BitSignedAccelerated"];
[&](){uint32_t temp_HuYqlMi;[&](){temp_HuYqlMi=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating16BitSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating16BitSignedAccelerated=(VkBool32)temp_HuYqlMi;}();
auto& integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated"];
[&](){uint32_t temp_EWNFIGo;[&](){temp_EWNFIGo=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated=(VkBool32)temp_EWNFIGo;}();
auto& integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating32BitUnsignedAccelerated"];
[&](){uint32_t temp_eNRVwFh;[&](){temp_eNRVwFh=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated=(VkBool32)temp_eNRVwFh;}();
auto& integerDotProductAccumulatingSaturating32BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating32BitSignedAccelerated"];
[&](){uint32_t temp_GYmnmmW;[&](){temp_GYmnmmW=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating32BitSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating32BitSignedAccelerated=(VkBool32)temp_GYmnmmW;}();
auto& integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated"];
[&](){uint32_t temp_ejWvqPb;[&](){temp_ejWvqPb=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated=(VkBool32)temp_ejWvqPb;}();
auto& integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating64BitUnsignedAccelerated"];
[&](){uint32_t temp_KxIXIXe;[&](){temp_KxIXIXe=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated=(VkBool32)temp_KxIXIXe;}();
auto& integerDotProductAccumulatingSaturating64BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating64BitSignedAccelerated"];
[&](){uint32_t temp_gmviEte;[&](){temp_gmviEte=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating64BitSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating64BitSignedAccelerated=(VkBool32)temp_gmviEte;}();
auto& integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated"];
[&](){uint32_t temp_fOGFkYs;[&](){temp_fOGFkYs=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated=(VkBool32)temp_fOGFkYs;}();
auto& storageTexelBufferOffsetAlignmentBytes_json=json["storageTexelBufferOffsetAlignmentBytes"];
[&](){uint64_t temp_qnaGqom;[&](){temp_qnaGqom=static_cast<uint64_t>(value_to<int>(storageTexelBufferOffsetAlignmentBytes_json));}();member.storageTexelBufferOffsetAlignmentBytes=(VkDeviceSize)temp_qnaGqom;}();
auto& storageTexelBufferOffsetSingleTexelAlignment_json=json["storageTexelBufferOffsetSingleTexelAlignment"];
[&](){uint32_t temp_CiMJyMm;[&](){temp_CiMJyMm=static_cast<uint32_t>(value_to<int>(storageTexelBufferOffsetSingleTexelAlignment_json));}();member.storageTexelBufferOffsetSingleTexelAlignment=(VkBool32)temp_CiMJyMm;}();
auto& uniformTexelBufferOffsetAlignmentBytes_json=json["uniformTexelBufferOffsetAlignmentBytes"];
[&](){uint64_t temp_RIQPxor;[&](){temp_RIQPxor=static_cast<uint64_t>(value_to<int>(uniformTexelBufferOffsetAlignmentBytes_json));}();member.uniformTexelBufferOffsetAlignmentBytes=(VkDeviceSize)temp_RIQPxor;}();
auto& uniformTexelBufferOffsetSingleTexelAlignment_json=json["uniformTexelBufferOffsetSingleTexelAlignment"];
[&](){uint32_t temp_QXNrRGs;[&](){temp_QXNrRGs=static_cast<uint32_t>(value_to<int>(uniformTexelBufferOffsetSingleTexelAlignment_json));}();member.uniformTexelBufferOffsetSingleTexelAlignment=(VkBool32)temp_QXNrRGs;}();
auto& maxBufferSize_json=json["maxBufferSize"];
[&](){uint64_t temp_tgfIjmh;[&](){temp_tgfIjmh=static_cast<uint64_t>(value_to<int>(maxBufferSize_json));}();member.maxBufferSize=(VkDeviceSize)temp_tgfIjmh;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineCompilerControlCreateInfoAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& compilerControlFlags_json=json["compilerControlFlags"];
[&](){[&](){[&](){compilerControlFlags_json=member.compilerControlFlags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineCompilerControlCreateInfoAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& compilerControlFlags_json=json["compilerControlFlags"];
[&](){[&](){int temp_dhWOqJS;[&](){temp_dhWOqJS=static_cast<int>(value_to<int>(compilerControlFlags_json));}();member.compilerControlFlags=(VkPipelineCompilerControlFlagsAMD)temp_dhWOqJS;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCoherentMemoryFeaturesAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceCoherentMemory_json=json["deviceCoherentMemory"];
[&](){[&](){deviceCoherentMemory_json=member.deviceCoherentMemory;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCoherentMemoryFeaturesAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& deviceCoherentMemory_json=json["deviceCoherentMemory"];
[&](){uint32_t temp_MQtBUmH;[&](){temp_MQtBUmH=static_cast<uint32_t>(value_to<int>(deviceCoherentMemory_json));}();member.deviceCoherentMemory=(VkBool32)temp_MQtBUmH;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceToolProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& name_json=json["name"];
[&](){name_json=boost::json::array(VK_MAX_EXTENSION_NAME_SIZE);
        auto& arr_WlDeXhg=name_json.as_array();
        for(int hUQppgo=0; hUQppgo < VK_MAX_EXTENSION_NAME_SIZE; hUQppgo++){
            [&](){arr_WlDeXhg[hUQppgo]=member.name[hUQppgo];}();
        }
        }();
auto& version_json=json["version"];
[&](){version_json=boost::json::array(VK_MAX_EXTENSION_NAME_SIZE);
        auto& arr_EmluaLG=version_json.as_array();
        for(int rISQyWZ=0; rISQyWZ < VK_MAX_EXTENSION_NAME_SIZE; rISQyWZ++){
            [&](){arr_EmluaLG[rISQyWZ]=member.version[rISQyWZ];}();
        }
        }();
auto& purposes_json=json["purposes"];
[&](){[&](){[&](){purposes_json=member.purposes;}();}();}();
auto& description_json=json["description"];
[&](){description_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){arr_XKStCoi[xOHuflK]=member.description[xOHuflK];}();
        }
        }();
auto& layer_json=json["layer"];
[&](){layer_json=boost::json::array(VK_MAX_EXTENSION_NAME_SIZE);
        auto& arr_fbztMan=layer_json.as_array();
        for(int tFkeCEi=0; tFkeCEi < VK_MAX_EXTENSION_NAME_SIZE; tFkeCEi++){
            [&](){arr_fbztMan[tFkeCEi]=member.layer[tFkeCEi];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceToolProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& name_json=json["name"];
[&](){
        auto& arr_WlDeXhg=name_json.as_array();
        for(int hUQppgo=0; hUQppgo < VK_MAX_EXTENSION_NAME_SIZE; hUQppgo++){
            [&](){member.name[hUQppgo]=static_cast<char>(value_to<int>(arr_WlDeXhg[hUQppgo]));}();
        }
        }();
auto& version_json=json["version"];
[&](){
        auto& arr_EmluaLG=version_json.as_array();
        for(int rISQyWZ=0; rISQyWZ < VK_MAX_EXTENSION_NAME_SIZE; rISQyWZ++){
            [&](){member.version[rISQyWZ]=static_cast<char>(value_to<int>(arr_EmluaLG[rISQyWZ]));}();
        }
        }();
auto& purposes_json=json["purposes"];
[&](){[&](){int temp_PyLuvfX;[&](){temp_PyLuvfX=static_cast<int>(value_to<int>(purposes_json));}();member.purposes=(VkToolPurposeFlags)temp_PyLuvfX;}();}();
auto& description_json=json["description"];
[&](){
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){member.description[xOHuflK]=static_cast<char>(value_to<int>(arr_XKStCoi[xOHuflK]));}();
        }
        }();
auto& layer_json=json["layer"];
[&](){
        auto& arr_fbztMan=layer_json.as_array();
        for(int tFkeCEi=0; tFkeCEi < VK_MAX_EXTENSION_NAME_SIZE; tFkeCEi++){
            [&](){member.layer[tFkeCEi]=static_cast<char>(value_to<int>(arr_fbztMan[tFkeCEi]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkSamplerCustomBorderColorCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& customBorderColor_json=json["customBorderColor"];
[&](){
            auto& temp=customBorderColor_json.emplace_object();
            return serialize_struct(temp, member.customBorderColor);
            }();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSamplerCustomBorderColorCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& customBorderColor_json=json["customBorderColor"];
[&](){
            auto& temp=customBorderColor_json.as_object();
            deserialize_struct(temp,member.customBorderColor);
            }();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCustomBorderColorPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxCustomBorderColorSamplers_json=json["maxCustomBorderColorSamplers"];
[&](){maxCustomBorderColorSamplers_json=member.maxCustomBorderColorSamplers;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCustomBorderColorPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxCustomBorderColorSamplers_json=json["maxCustomBorderColorSamplers"];
[&](){member.maxCustomBorderColorSamplers=static_cast<uint32_t>(value_to<int>(maxCustomBorderColorSamplers_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCustomBorderColorFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& customBorderColors_json=json["customBorderColors"];
[&](){[&](){customBorderColors_json=member.customBorderColors;}();}();
auto& customBorderColorWithoutFormat_json=json["customBorderColorWithoutFormat"];
[&](){[&](){customBorderColorWithoutFormat_json=member.customBorderColorWithoutFormat;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCustomBorderColorFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& customBorderColors_json=json["customBorderColors"];
[&](){uint32_t temp_LJwYLem;[&](){temp_LJwYLem=static_cast<uint32_t>(value_to<int>(customBorderColors_json));}();member.customBorderColors=(VkBool32)temp_LJwYLem;}();
auto& customBorderColorWithoutFormat_json=json["customBorderColorWithoutFormat"];
[&](){uint32_t temp_eKYambW;[&](){temp_eKYambW=static_cast<uint32_t>(value_to<int>(customBorderColorWithoutFormat_json));}();member.customBorderColorWithoutFormat=(VkBool32)temp_eKYambW;}();
}

    void serialize_struct(boost::json::object& json, const VkSamplerBorderColorComponentMappingCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& components_json=json["components"];
[&](){
            auto& temp=components_json.emplace_object();
            return serialize_struct(temp, member.components);
            }();
auto& srgb_json=json["srgb"];
[&](){[&](){srgb_json=member.srgb;}();}();
}
void deserialize_struct(boost::json::object& json, VkSamplerBorderColorComponentMappingCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& components_json=json["components"];
[&](){
            auto& temp=components_json.as_object();
            deserialize_struct(temp,member.components);
            }();
auto& srgb_json=json["srgb"];
[&](){uint32_t temp_TRZTkLS;[&](){temp_TRZTkLS=static_cast<uint32_t>(value_to<int>(srgb_json));}();member.srgb=(VkBool32)temp_TRZTkLS;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& borderColorSwizzle_json=json["borderColorSwizzle"];
[&](){[&](){borderColorSwizzle_json=member.borderColorSwizzle;}();}();
auto& borderColorSwizzleFromImage_json=json["borderColorSwizzleFromImage"];
[&](){[&](){borderColorSwizzleFromImage_json=member.borderColorSwizzleFromImage;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& borderColorSwizzle_json=json["borderColorSwizzle"];
[&](){uint32_t temp_UczNKVY;[&](){temp_UczNKVY=static_cast<uint32_t>(value_to<int>(borderColorSwizzle_json));}();member.borderColorSwizzle=(VkBool32)temp_UczNKVY;}();
auto& borderColorSwizzleFromImage_json=json["borderColorSwizzleFromImage"];
[&](){uint32_t temp_DNXUaST;[&](){temp_DNXUaST=static_cast<uint32_t>(value_to<int>(borderColorSwizzleFromImage_json));}();member.borderColorSwizzleFromImage=(VkBool32)temp_DNXUaST;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceOrHostAddressKHR& member){
        
    
auto& deviceAddress_json=json["deviceAddress"];
[&](){[&](){deviceAddress_json=member.deviceAddress;}();}();
auto& hostAddress_json=json["hostAddress"];
[&](){
            if (member.hostAddress==NULL){
                hostAddress_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.hostAddress))==NULL){
                hostAddress_json=boost::json::array();
            return; }hostAddress_json=boost::json::array(strlen(((char*)(member.hostAddress)))+1);
        auto& arr_vecfklo=hostAddress_json.as_array();
        for(int rebBrIs=0; rebBrIs < strlen(((char*)(member.hostAddress)))+1; rebBrIs++){
            [&](){arr_vecfklo[rebBrIs]=((char*)(member.hostAddress))[rebBrIs];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceOrHostAddressKHR& member){
auto& deviceAddress_json=json["deviceAddress"];
[&](){uint64_t temp_JcebElc;[&](){temp_JcebElc=static_cast<uint64_t>(value_to<int>(deviceAddress_json));}();member.deviceAddress=(VkDeviceAddress)temp_JcebElc;}();
auto& hostAddress_json=json["hostAddress"];
[&](){
            if (hostAddress_json.as_array().size()==0){
                member.hostAddress=NULL;
            return; }char* temp_fiKuQcW;[&](){
            if (hostAddress_json.as_array().size()==0){
                temp_fiKuQcW=NULL;
            return; }temp_fiKuQcW=(char*)malloc(hostAddress_json.as_array().size()*sizeof(char));
        auto& arr_vecfklo=hostAddress_json.as_array();
        for(int rebBrIs=0; rebBrIs < hostAddress_json.as_array().size(); rebBrIs++){
            [&](){temp_fiKuQcW[rebBrIs]=static_cast<char>(value_to<int>(arr_vecfklo[rebBrIs]));}();
        }
        }();member.hostAddress=temp_fiKuQcW;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceOrHostAddressConstKHR& member){
        
    
auto& deviceAddress_json=json["deviceAddress"];
[&](){[&](){deviceAddress_json=member.deviceAddress;}();}();
auto& hostAddress_json=json["hostAddress"];
[&](){
            if (member.hostAddress==NULL){
                hostAddress_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.hostAddress))==NULL){
                hostAddress_json=boost::json::array();
            return; }hostAddress_json=boost::json::array(strlen(((char*)(member.hostAddress)))+1);
        auto& arr_FsCizYU=hostAddress_json.as_array();
        for(int hLpIlSM=0; hLpIlSM < strlen(((char*)(member.hostAddress)))+1; hLpIlSM++){
            [&](){arr_FsCizYU[hLpIlSM]=((char*)(member.hostAddress))[hLpIlSM];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceOrHostAddressConstKHR& member){
auto& deviceAddress_json=json["deviceAddress"];
[&](){uint64_t temp_JcebElc;[&](){temp_JcebElc=static_cast<uint64_t>(value_to<int>(deviceAddress_json));}();member.deviceAddress=(VkDeviceAddress)temp_JcebElc;}();
auto& hostAddress_json=json["hostAddress"];
[&](){ void* temp_sYgHmJE;;[&](){
            if (hostAddress_json.as_array().size()==0){
                temp_sYgHmJE=NULL;
            return; }char* temp_tyXPSns;[&](){
            if (hostAddress_json.as_array().size()==0){
                temp_tyXPSns=NULL;
            return; }temp_tyXPSns=(char*)malloc(hostAddress_json.as_array().size()*sizeof(char));
        auto& arr_EdreUCK=hostAddress_json.as_array();
        for(int txdGZNV=0; txdGZNV < hostAddress_json.as_array().size(); txdGZNV++){
            [&](){temp_tyXPSns[txdGZNV]=static_cast<char>(value_to<int>(arr_EdreUCK[txdGZNV]));}();
        }
        }();temp_sYgHmJE=temp_tyXPSns;}();member.hostAddress=temp_sYgHmJE;}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureGeometryTrianglesDataKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& vertexFormat_json=json["vertexFormat"];
[&](){[&](){[&](){vertexFormat_json=member.vertexFormat;}();}();}();
auto& vertexData_json=json["vertexData"];
[&](){
            auto& temp=vertexData_json.emplace_object();
            return serialize_struct(temp, member.vertexData);
            }();
auto& vertexStride_json=json["vertexStride"];
[&](){[&](){vertexStride_json=member.vertexStride;}();}();
auto& maxVertex_json=json["maxVertex"];
[&](){maxVertex_json=member.maxVertex;}();
auto& indexType_json=json["indexType"];
[&](){[&](){[&](){indexType_json=member.indexType;}();}();}();
auto& indexData_json=json["indexData"];
[&](){
            auto& temp=indexData_json.emplace_object();
            return serialize_struct(temp, member.indexData);
            }();
auto& transformData_json=json["transformData"];
[&](){
            auto& temp=transformData_json.emplace_object();
            return serialize_struct(temp, member.transformData);
            }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureGeometryTrianglesDataKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& vertexFormat_json=json["vertexFormat"];
[&](){[&](){int temp_kPQLYRr;[&](){temp_kPQLYRr=static_cast<int>(value_to<int>(vertexFormat_json));}();member.vertexFormat=(VkFormat)temp_kPQLYRr;}();}();
auto& vertexData_json=json["vertexData"];
[&](){
            auto& temp=vertexData_json.as_object();
            deserialize_struct(temp,member.vertexData);
            }();
auto& vertexStride_json=json["vertexStride"];
[&](){uint64_t temp_NJLcxGv;[&](){temp_NJLcxGv=static_cast<uint64_t>(value_to<int>(vertexStride_json));}();member.vertexStride=(VkDeviceSize)temp_NJLcxGv;}();
auto& maxVertex_json=json["maxVertex"];
[&](){member.maxVertex=static_cast<uint32_t>(value_to<int>(maxVertex_json));}();
auto& indexType_json=json["indexType"];
[&](){[&](){int temp_sCUtzFY;[&](){temp_sCUtzFY=static_cast<int>(value_to<int>(indexType_json));}();member.indexType=(VkIndexType)temp_sCUtzFY;}();}();
auto& indexData_json=json["indexData"];
[&](){
            auto& temp=indexData_json.as_object();
            deserialize_struct(temp,member.indexData);
            }();
auto& transformData_json=json["transformData"];
[&](){
            auto& temp=transformData_json.as_object();
            deserialize_struct(temp,member.transformData);
            }();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureGeometryAabbsDataKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.emplace_object();
            return serialize_struct(temp, member.data);
            }();
auto& stride_json=json["stride"];
[&](){[&](){stride_json=member.stride;}();}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureGeometryAabbsDataKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.as_object();
            deserialize_struct(temp,member.data);
            }();
auto& stride_json=json["stride"];
[&](){uint64_t temp_TOKWKUv;[&](){temp_TOKWKUv=static_cast<uint64_t>(value_to<int>(stride_json));}();member.stride=(VkDeviceSize)temp_TOKWKUv;}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureGeometryInstancesDataKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& arrayOfPointers_json=json["arrayOfPointers"];
[&](){[&](){arrayOfPointers_json=member.arrayOfPointers;}();}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.emplace_object();
            return serialize_struct(temp, member.data);
            }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureGeometryInstancesDataKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& arrayOfPointers_json=json["arrayOfPointers"];
[&](){uint32_t temp_oUULrpA;[&](){temp_oUULrpA=static_cast<uint32_t>(value_to<int>(arrayOfPointers_json));}();member.arrayOfPointers=(VkBool32)temp_oUULrpA;}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.as_object();
            deserialize_struct(temp,member.data);
            }();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureGeometryDataKHR& member){
        
    
auto& triangles_json=json["triangles"];
[&](){
            auto& temp=triangles_json.emplace_object();
            return serialize_struct(temp, member.triangles);
            }();
auto& aabbs_json=json["aabbs"];
[&](){
            auto& temp=aabbs_json.emplace_object();
            return serialize_struct(temp, member.aabbs);
            }();
auto& instances_json=json["instances"];
[&](){
            auto& temp=instances_json.emplace_object();
            return serialize_struct(temp, member.instances);
            }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureGeometryDataKHR& member){
auto& triangles_json=json["triangles"];
[&](){
            auto& temp=triangles_json.as_object();
            deserialize_struct(temp,member.triangles);
            }();
auto& aabbs_json=json["aabbs"];
[&](){
            auto& temp=aabbs_json.as_object();
            deserialize_struct(temp,member.aabbs);
            }();
auto& instances_json=json["instances"];
[&](){
            auto& temp=instances_json.as_object();
            deserialize_struct(temp,member.instances);
            }();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureGeometryKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& geometryType_json=json["geometryType"];
[&](){[&](){[&](){geometryType_json=member.geometryType;}();}();}();
auto& geometry_json=json["geometry"];
[&](){
            auto& temp=geometry_json.emplace_object();
            return serialize_struct(temp, member.geometry);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureGeometryKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& geometryType_json=json["geometryType"];
[&](){[&](){int temp_fDjxHTD;[&](){temp_fDjxHTD=static_cast<int>(value_to<int>(geometryType_json));}();member.geometryType=(VkGeometryTypeKHR)temp_fDjxHTD;}();}();
auto& geometry_json=json["geometry"];
[&](){
            auto& temp=geometry_json.as_object();
            deserialize_struct(temp,member.geometry);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_qsfLWQJ;[&](){temp_qsfLWQJ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkGeometryFlagsKHR)temp_qsfLWQJ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureBuildGeometryInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
auto& srcAccelerationStructure_json=json["srcAccelerationStructure"];
[&](){serialize_VkAccelerationStructureKHR(srcAccelerationStructure_json,member.srcAccelerationStructure);}();
auto& dstAccelerationStructure_json=json["dstAccelerationStructure"];
[&](){serialize_VkAccelerationStructureKHR(dstAccelerationStructure_json,member.dstAccelerationStructure);}();
auto& geometryCount_json=json["geometryCount"];
[&](){geometryCount_json=member.geometryCount;}();
auto& pGeometries_json=json["pGeometries"];
[&](){
            if (member.pGeometries==NULL){
                pGeometries_json=boost::json::array();
            return; }pGeometries_json=boost::json::array(member.geometryCount);
        auto& arr_vwbQOKz=pGeometries_json.as_array();
        for(int zAgFHZV=0; zAgFHZV < member.geometryCount; zAgFHZV++){
            [&](){
            auto& temp=arr_vwbQOKz[zAgFHZV].emplace_object();
            return serialize_struct(temp, member.pGeometries[zAgFHZV]);
            }();
        }
        }();
auto& ppGeometries_json=json["ppGeometries"];
[&](){
            if (member.ppGeometries==NULL){
                ppGeometries_json=boost::json::array();
            return; }ppGeometries_json=boost::json::array(member.geometryCount);
        auto& arr_rkrDVjE=ppGeometries_json.as_array();
        for(int uKdXAxa=0; uKdXAxa < member.geometryCount; uKdXAxa++){
            [&](){
            if (member.ppGeometries[uKdXAxa]==NULL){
                arr_rkrDVjE[uKdXAxa]=boost::json::array();
            return; }arr_rkrDVjE[uKdXAxa]=boost::json::array(1);
        auto& arr_xCWURfT=arr_rkrDVjE[uKdXAxa].as_array();
        for(int BbpFYeD=0; BbpFYeD < 1; BbpFYeD++){
            [&](){
            auto& temp=arr_xCWURfT[BbpFYeD].emplace_object();
            return serialize_struct(temp, member.ppGeometries[uKdXAxa][BbpFYeD]);
            }();
        }
        }();
        }
        }();
auto& scratchData_json=json["scratchData"];
[&](){
            auto& temp=scratchData_json.emplace_object();
            return serialize_struct(temp, member.scratchData);
            }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureBuildGeometryInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& type_json=json["type"];
[&](){[&](){int temp_WOjqhht;[&](){temp_WOjqhht=static_cast<int>(value_to<int>(type_json));}();member.type=(VkAccelerationStructureTypeKHR)temp_WOjqhht;}();}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_yjbUcho;[&](){temp_yjbUcho=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkBuildAccelerationStructureFlagsKHR)temp_yjbUcho;}();}();
auto& mode_json=json["mode"];
[&](){[&](){int temp_exQzWzk;[&](){temp_exQzWzk=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkBuildAccelerationStructureModeKHR)temp_exQzWzk;}();}();
auto& srcAccelerationStructure_json=json["srcAccelerationStructure"];
[&](){deserialize_VkAccelerationStructureKHR(srcAccelerationStructure_json, member.srcAccelerationStructure);}();
auto& dstAccelerationStructure_json=json["dstAccelerationStructure"];
[&](){deserialize_VkAccelerationStructureKHR(dstAccelerationStructure_json, member.dstAccelerationStructure);}();
auto& geometryCount_json=json["geometryCount"];
[&](){member.geometryCount=static_cast<uint32_t>(value_to<int>(geometryCount_json));}();
auto& pGeometries_json=json["pGeometries"];
[&](){ VkAccelerationStructureGeometryKHR* temp_giFZxid;;[&](){
            if (pGeometries_json.as_array().size()==0){
                temp_giFZxid=NULL;
            return; }temp_giFZxid=(VkAccelerationStructureGeometryKHR*)malloc(member.geometryCount*sizeof(VkAccelerationStructureGeometryKHR));
        auto& arr_gaIhRXr=pGeometries_json.as_array();
        for(int NqcOOyG=0; NqcOOyG < member.geometryCount; NqcOOyG++){
            [&](){
            auto& temp=arr_gaIhRXr[NqcOOyG].as_object();
            deserialize_struct(temp,temp_giFZxid[NqcOOyG]);
            }();
        }
        }();member.pGeometries=temp_giFZxid;}();
auto& ppGeometries_json=json["ppGeometries"];
[&](){ VkAccelerationStructureGeometryKHR* * temp_mHuubqP;;[&](){
            if (ppGeometries_json.as_array().size()==0){
                temp_mHuubqP=NULL;
            return; }temp_mHuubqP=(VkAccelerationStructureGeometryKHR**)malloc(member.geometryCount*sizeof(VkAccelerationStructureGeometryKHR*));
        auto& arr_uEsDOMb=ppGeometries_json.as_array();
        for(int lBmTwOQ=0; lBmTwOQ < member.geometryCount; lBmTwOQ++){
            [&](){
            if (arr_uEsDOMb[lBmTwOQ].as_array().size()==0){
                temp_mHuubqP[lBmTwOQ]=NULL;
            return; }temp_mHuubqP[lBmTwOQ]=(VkAccelerationStructureGeometryKHR*)malloc(1*sizeof(VkAccelerationStructureGeometryKHR));
        auto& arr_fKNvNgX=arr_uEsDOMb[lBmTwOQ].as_array();
        for(int SWgyiSY=0; SWgyiSY < 1; SWgyiSY++){
            [&](){
            auto& temp=arr_fKNvNgX[SWgyiSY].as_object();
            deserialize_struct(temp,temp_mHuubqP[lBmTwOQ][SWgyiSY]);
            }();
        }
        }();
        }
        }();member.ppGeometries=temp_mHuubqP;}();
auto& scratchData_json=json["scratchData"];
[&](){
            auto& temp=scratchData_json.as_object();
            deserialize_struct(temp,member.scratchData);
            }();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureBuildRangeInfoKHR& member){
        
    
auto& primitiveCount_json=json["primitiveCount"];
[&](){primitiveCount_json=member.primitiveCount;}();
auto& primitiveOffset_json=json["primitiveOffset"];
[&](){primitiveOffset_json=member.primitiveOffset;}();
auto& firstVertex_json=json["firstVertex"];
[&](){firstVertex_json=member.firstVertex;}();
auto& transformOffset_json=json["transformOffset"];
[&](){transformOffset_json=member.transformOffset;}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureBuildRangeInfoKHR& member){
auto& primitiveCount_json=json["primitiveCount"];
[&](){member.primitiveCount=static_cast<uint32_t>(value_to<int>(primitiveCount_json));}();
auto& primitiveOffset_json=json["primitiveOffset"];
[&](){member.primitiveOffset=static_cast<uint32_t>(value_to<int>(primitiveOffset_json));}();
auto& firstVertex_json=json["firstVertex"];
[&](){member.firstVertex=static_cast<uint32_t>(value_to<int>(firstVertex_json));}();
auto& transformOffset_json=json["transformOffset"];
[&](){member.transformOffset=static_cast<uint32_t>(value_to<int>(transformOffset_json));}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& createFlags_json=json["createFlags"];
[&](){[&](){[&](){createFlags_json=member.createFlags;}();}();}();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& deviceAddress_json=json["deviceAddress"];
[&](){[&](){deviceAddress_json=member.deviceAddress;}();}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& createFlags_json=json["createFlags"];
[&](){[&](){int temp_AjmNulm;[&](){temp_AjmNulm=static_cast<int>(value_to<int>(createFlags_json));}();member.createFlags=(VkAccelerationStructureCreateFlagsKHR)temp_AjmNulm;}();}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& type_json=json["type"];
[&](){[&](){int temp_WOjqhht;[&](){temp_WOjqhht=static_cast<int>(value_to<int>(type_json));}();member.type=(VkAccelerationStructureTypeKHR)temp_WOjqhht;}();}();
auto& deviceAddress_json=json["deviceAddress"];
[&](){uint64_t temp_JcebElc;[&](){temp_JcebElc=static_cast<uint64_t>(value_to<int>(deviceAddress_json));}();member.deviceAddress=(VkDeviceAddress)temp_JcebElc;}();
}

    void serialize_struct(boost::json::object& json, const VkAabbPositionsKHR& member){
        
    
auto& minX_json=json["minX"];
[&](){minX_json=member.minX;}();
auto& minY_json=json["minY"];
[&](){minY_json=member.minY;}();
auto& minZ_json=json["minZ"];
[&](){minZ_json=member.minZ;}();
auto& maxX_json=json["maxX"];
[&](){maxX_json=member.maxX;}();
auto& maxY_json=json["maxY"];
[&](){maxY_json=member.maxY;}();
auto& maxZ_json=json["maxZ"];
[&](){maxZ_json=member.maxZ;}();
}
void deserialize_struct(boost::json::object& json, VkAabbPositionsKHR& member){
auto& minX_json=json["minX"];
[&](){member.minX=static_cast<float>(value_to<int>(minX_json));}();
auto& minY_json=json["minY"];
[&](){member.minY=static_cast<float>(value_to<int>(minY_json));}();
auto& minZ_json=json["minZ"];
[&](){member.minZ=static_cast<float>(value_to<int>(minZ_json));}();
auto& maxX_json=json["maxX"];
[&](){member.maxX=static_cast<float>(value_to<int>(maxX_json));}();
auto& maxY_json=json["maxY"];
[&](){member.maxY=static_cast<float>(value_to<int>(maxY_json));}();
auto& maxZ_json=json["maxZ"];
[&](){member.maxZ=static_cast<float>(value_to<int>(maxZ_json));}();
}

    void serialize_struct(boost::json::object& json, const VkTransformMatrixKHR& member){
        
    
auto& matrix_json=json["matrix"];
[&](){matrix_json=boost::json::array(3);
        auto& arr_JPThYox=matrix_json.as_array();
        for(int vApbGbg=0; vApbGbg < 3; vApbGbg++){
            [&](){arr_JPThYox[vApbGbg]=boost::json::array(4);
        auto& arr_sBwgNeF=arr_JPThYox[vApbGbg].as_array();
        for(int fHPyluH=0; fHPyluH < 4; fHPyluH++){
            [&](){arr_sBwgNeF[fHPyluH]=member.matrix[vApbGbg][fHPyluH];}();
        }
        }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkTransformMatrixKHR& member){
auto& matrix_json=json["matrix"];
[&](){
        auto& arr_JPThYox=matrix_json.as_array();
        for(int vApbGbg=0; vApbGbg < 3; vApbGbg++){
            [&](){
        auto& arr_sBwgNeF=arr_JPThYox[vApbGbg].as_array();
        for(int fHPyluH=0; fHPyluH < 4; fHPyluH++){
            [&](){member.matrix[vApbGbg][fHPyluH]=static_cast<float>(value_to<int>(arr_sBwgNeF[fHPyluH]));}();
        }
        }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureInstanceKHR& member){
        
    
auto& transform_json=json["transform"];
[&](){
            auto& temp=transform_json.emplace_object();
            return serialize_struct(temp, member.transform);
            }();
auto& instanceCustomIndex_json=json["instanceCustomIndex"];
[&](){instanceCustomIndex_json=member.instanceCustomIndex;}();
auto& mask_json=json["mask"];
[&](){mask_json=member.mask;}();
auto& instanceShaderBindingTableRecordOffset_json=json["instanceShaderBindingTableRecordOffset"];
[&](){instanceShaderBindingTableRecordOffset_json=member.instanceShaderBindingTableRecordOffset;}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& accelerationStructureReference_json=json["accelerationStructureReference"];
[&](){accelerationStructureReference_json=member.accelerationStructureReference;}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureInstanceKHR& member){
auto& transform_json=json["transform"];
[&](){
            auto& temp=transform_json.as_object();
            deserialize_struct(temp,member.transform);
            }();
auto& instanceCustomIndex_json=json["instanceCustomIndex"];
[&](){member.instanceCustomIndex=static_cast<uint32_t>(value_to<int>(instanceCustomIndex_json));}();
auto& mask_json=json["mask"];
[&](){member.mask=static_cast<uint32_t>(value_to<int>(mask_json));}();
auto& instanceShaderBindingTableRecordOffset_json=json["instanceShaderBindingTableRecordOffset"];
[&](){member.instanceShaderBindingTableRecordOffset=static_cast<uint32_t>(value_to<int>(instanceShaderBindingTableRecordOffset_json));}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_PyNGaXN;[&](){temp_PyNGaXN=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkGeometryInstanceFlagsKHR)temp_PyNGaXN;}();}();
auto& accelerationStructureReference_json=json["accelerationStructureReference"];
[&](){member.accelerationStructureReference=static_cast<uint64_t>(value_to<int>(accelerationStructureReference_json));}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureDeviceAddressInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){serialize_VkAccelerationStructureKHR(accelerationStructure_json,member.accelerationStructure);}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureDeviceAddressInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){deserialize_VkAccelerationStructureKHR(accelerationStructure_json, member.accelerationStructure);}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureVersionInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pVersionData_json=json["pVersionData"];
[&](){
            if (member.pVersionData==NULL){
                pVersionData_json=boost::json::array();
            return; }pVersionData_json=boost::json::array(2*VK_UUID_SIZE);
        auto& arr_RuHqWQz=pVersionData_json.as_array();
        for(int EDvhmfD=0; EDvhmfD < 2*VK_UUID_SIZE; EDvhmfD++){
            [&](){arr_RuHqWQz[EDvhmfD]=member.pVersionData[EDvhmfD];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureVersionInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pVersionData_json=json["pVersionData"];
[&](){ uint8_t* temp_djnalGl;;[&](){
            if (pVersionData_json.as_array().size()==0){
                temp_djnalGl=NULL;
            return; }temp_djnalGl=(uint8_t*)malloc(2*VK_UUID_SIZE*sizeof(uint8_t));
        auto& arr_LkXRmLG=pVersionData_json.as_array();
        for(int NHzWVtx=0; NHzWVtx < 2*VK_UUID_SIZE; NHzWVtx++){
            [&](){temp_djnalGl[NHzWVtx]=static_cast<uint8_t>(value_to<int>(arr_LkXRmLG[NHzWVtx]));}();
        }
        }();member.pVersionData=temp_djnalGl;}();
}

    void serialize_struct(boost::json::object& json, const VkCopyAccelerationStructureInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& src_json=json["src"];
[&](){serialize_VkAccelerationStructureKHR(src_json,member.src);}();
auto& dst_json=json["dst"];
[&](){serialize_VkAccelerationStructureKHR(dst_json,member.dst);}();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCopyAccelerationStructureInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& src_json=json["src"];
[&](){deserialize_VkAccelerationStructureKHR(src_json, member.src);}();
auto& dst_json=json["dst"];
[&](){deserialize_VkAccelerationStructureKHR(dst_json, member.dst);}();
auto& mode_json=json["mode"];
[&](){[&](){int temp_JSylVIF;[&](){temp_JSylVIF=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkCopyAccelerationStructureModeKHR)temp_JSylVIF;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCopyAccelerationStructureToMemoryInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& src_json=json["src"];
[&](){serialize_VkAccelerationStructureKHR(src_json,member.src);}();
auto& dst_json=json["dst"];
[&](){
            auto& temp=dst_json.emplace_object();
            return serialize_struct(temp, member.dst);
            }();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCopyAccelerationStructureToMemoryInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& src_json=json["src"];
[&](){deserialize_VkAccelerationStructureKHR(src_json, member.src);}();
auto& dst_json=json["dst"];
[&](){
            auto& temp=dst_json.as_object();
            deserialize_struct(temp,member.dst);
            }();
auto& mode_json=json["mode"];
[&](){[&](){int temp_JSylVIF;[&](){temp_JSylVIF=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkCopyAccelerationStructureModeKHR)temp_JSylVIF;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCopyMemoryToAccelerationStructureInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& src_json=json["src"];
[&](){
            auto& temp=src_json.emplace_object();
            return serialize_struct(temp, member.src);
            }();
auto& dst_json=json["dst"];
[&](){serialize_VkAccelerationStructureKHR(dst_json,member.dst);}();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCopyMemoryToAccelerationStructureInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& src_json=json["src"];
[&](){
            auto& temp=src_json.as_object();
            deserialize_struct(temp,member.src);
            }();
auto& dst_json=json["dst"];
[&](){deserialize_VkAccelerationStructureKHR(dst_json, member.dst);}();
auto& mode_json=json["mode"];
[&](){[&](){int temp_JSylVIF;[&](){temp_JSylVIF=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkCopyAccelerationStructureModeKHR)temp_JSylVIF;}();}();
}

    void serialize_struct(boost::json::object& json, const VkRayTracingPipelineInterfaceCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxPipelineRayPayloadSize_json=json["maxPipelineRayPayloadSize"];
[&](){maxPipelineRayPayloadSize_json=member.maxPipelineRayPayloadSize;}();
auto& maxPipelineRayHitAttributeSize_json=json["maxPipelineRayHitAttributeSize"];
[&](){maxPipelineRayHitAttributeSize_json=member.maxPipelineRayHitAttributeSize;}();
}
void deserialize_struct(boost::json::object& json, VkRayTracingPipelineInterfaceCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& maxPipelineRayPayloadSize_json=json["maxPipelineRayPayloadSize"];
[&](){member.maxPipelineRayPayloadSize=static_cast<uint32_t>(value_to<int>(maxPipelineRayPayloadSize_json));}();
auto& maxPipelineRayHitAttributeSize_json=json["maxPipelineRayHitAttributeSize"];
[&](){member.maxPipelineRayHitAttributeSize=static_cast<uint32_t>(value_to<int>(maxPipelineRayHitAttributeSize_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineLibraryCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& libraryCount_json=json["libraryCount"];
[&](){libraryCount_json=member.libraryCount;}();
auto& pLibraries_json=json["pLibraries"];
[&](){
            if (member.pLibraries==NULL){
                pLibraries_json=boost::json::array();
            return; }pLibraries_json=boost::json::array(member.libraryCount);
        auto& arr_zRxHbYX=pLibraries_json.as_array();
        for(int WJsvUCn=0; WJsvUCn < member.libraryCount; WJsvUCn++){
            [&](){serialize_VkPipeline(arr_zRxHbYX[WJsvUCn],member.pLibraries[WJsvUCn]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineLibraryCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& libraryCount_json=json["libraryCount"];
[&](){member.libraryCount=static_cast<uint32_t>(value_to<int>(libraryCount_json));}();
auto& pLibraries_json=json["pLibraries"];
[&](){ VkPipeline* temp_HzoMuYL;;[&](){
            if (pLibraries_json.as_array().size()==0){
                temp_HzoMuYL=NULL;
            return; }temp_HzoMuYL=(VkPipeline*)malloc(member.libraryCount*sizeof(VkPipeline));
        auto& arr_LgIjhBH=pLibraries_json.as_array();
        for(int odvorVV=0; odvorVV < member.libraryCount; odvorVV++){
            [&](){deserialize_VkPipeline(arr_LgIjhBH[odvorVV], temp_HzoMuYL[odvorVV]);}();
        }
        }();member.pLibraries=temp_HzoMuYL;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& extendedDynamicState_json=json["extendedDynamicState"];
[&](){[&](){extendedDynamicState_json=member.extendedDynamicState;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& extendedDynamicState_json=json["extendedDynamicState"];
[&](){uint32_t temp_bUnUNCr;[&](){temp_bUnUNCr=static_cast<uint32_t>(value_to<int>(extendedDynamicState_json));}();member.extendedDynamicState=(VkBool32)temp_bUnUNCr;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& extendedDynamicState2_json=json["extendedDynamicState2"];
[&](){[&](){extendedDynamicState2_json=member.extendedDynamicState2;}();}();
auto& extendedDynamicState2LogicOp_json=json["extendedDynamicState2LogicOp"];
[&](){[&](){extendedDynamicState2LogicOp_json=member.extendedDynamicState2LogicOp;}();}();
auto& extendedDynamicState2PatchControlPoints_json=json["extendedDynamicState2PatchControlPoints"];
[&](){[&](){extendedDynamicState2PatchControlPoints_json=member.extendedDynamicState2PatchControlPoints;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& extendedDynamicState2_json=json["extendedDynamicState2"];
[&](){uint32_t temp_pUlDviO;[&](){temp_pUlDviO=static_cast<uint32_t>(value_to<int>(extendedDynamicState2_json));}();member.extendedDynamicState2=(VkBool32)temp_pUlDviO;}();
auto& extendedDynamicState2LogicOp_json=json["extendedDynamicState2LogicOp"];
[&](){uint32_t temp_IeeEfaa;[&](){temp_IeeEfaa=static_cast<uint32_t>(value_to<int>(extendedDynamicState2LogicOp_json));}();member.extendedDynamicState2LogicOp=(VkBool32)temp_IeeEfaa;}();
auto& extendedDynamicState2PatchControlPoints_json=json["extendedDynamicState2PatchControlPoints"];
[&](){uint32_t temp_gdqcCsy;[&](){temp_gdqcCsy=static_cast<uint32_t>(value_to<int>(extendedDynamicState2PatchControlPoints_json));}();member.extendedDynamicState2PatchControlPoints=(VkBool32)temp_gdqcCsy;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& extendedDynamicState3TessellationDomainOrigin_json=json["extendedDynamicState3TessellationDomainOrigin"];
[&](){[&](){extendedDynamicState3TessellationDomainOrigin_json=member.extendedDynamicState3TessellationDomainOrigin;}();}();
auto& extendedDynamicState3DepthClampEnable_json=json["extendedDynamicState3DepthClampEnable"];
[&](){[&](){extendedDynamicState3DepthClampEnable_json=member.extendedDynamicState3DepthClampEnable;}();}();
auto& extendedDynamicState3PolygonMode_json=json["extendedDynamicState3PolygonMode"];
[&](){[&](){extendedDynamicState3PolygonMode_json=member.extendedDynamicState3PolygonMode;}();}();
auto& extendedDynamicState3RasterizationSamples_json=json["extendedDynamicState3RasterizationSamples"];
[&](){[&](){extendedDynamicState3RasterizationSamples_json=member.extendedDynamicState3RasterizationSamples;}();}();
auto& extendedDynamicState3SampleMask_json=json["extendedDynamicState3SampleMask"];
[&](){[&](){extendedDynamicState3SampleMask_json=member.extendedDynamicState3SampleMask;}();}();
auto& extendedDynamicState3AlphaToCoverageEnable_json=json["extendedDynamicState3AlphaToCoverageEnable"];
[&](){[&](){extendedDynamicState3AlphaToCoverageEnable_json=member.extendedDynamicState3AlphaToCoverageEnable;}();}();
auto& extendedDynamicState3AlphaToOneEnable_json=json["extendedDynamicState3AlphaToOneEnable"];
[&](){[&](){extendedDynamicState3AlphaToOneEnable_json=member.extendedDynamicState3AlphaToOneEnable;}();}();
auto& extendedDynamicState3LogicOpEnable_json=json["extendedDynamicState3LogicOpEnable"];
[&](){[&](){extendedDynamicState3LogicOpEnable_json=member.extendedDynamicState3LogicOpEnable;}();}();
auto& extendedDynamicState3ColorBlendEnable_json=json["extendedDynamicState3ColorBlendEnable"];
[&](){[&](){extendedDynamicState3ColorBlendEnable_json=member.extendedDynamicState3ColorBlendEnable;}();}();
auto& extendedDynamicState3ColorBlendEquation_json=json["extendedDynamicState3ColorBlendEquation"];
[&](){[&](){extendedDynamicState3ColorBlendEquation_json=member.extendedDynamicState3ColorBlendEquation;}();}();
auto& extendedDynamicState3ColorWriteMask_json=json["extendedDynamicState3ColorWriteMask"];
[&](){[&](){extendedDynamicState3ColorWriteMask_json=member.extendedDynamicState3ColorWriteMask;}();}();
auto& extendedDynamicState3RasterizationStream_json=json["extendedDynamicState3RasterizationStream"];
[&](){[&](){extendedDynamicState3RasterizationStream_json=member.extendedDynamicState3RasterizationStream;}();}();
auto& extendedDynamicState3ConservativeRasterizationMode_json=json["extendedDynamicState3ConservativeRasterizationMode"];
[&](){[&](){extendedDynamicState3ConservativeRasterizationMode_json=member.extendedDynamicState3ConservativeRasterizationMode;}();}();
auto& extendedDynamicState3ExtraPrimitiveOverestimationSize_json=json["extendedDynamicState3ExtraPrimitiveOverestimationSize"];
[&](){[&](){extendedDynamicState3ExtraPrimitiveOverestimationSize_json=member.extendedDynamicState3ExtraPrimitiveOverestimationSize;}();}();
auto& extendedDynamicState3DepthClipEnable_json=json["extendedDynamicState3DepthClipEnable"];
[&](){[&](){extendedDynamicState3DepthClipEnable_json=member.extendedDynamicState3DepthClipEnable;}();}();
auto& extendedDynamicState3SampleLocationsEnable_json=json["extendedDynamicState3SampleLocationsEnable"];
[&](){[&](){extendedDynamicState3SampleLocationsEnable_json=member.extendedDynamicState3SampleLocationsEnable;}();}();
auto& extendedDynamicState3ColorBlendAdvanced_json=json["extendedDynamicState3ColorBlendAdvanced"];
[&](){[&](){extendedDynamicState3ColorBlendAdvanced_json=member.extendedDynamicState3ColorBlendAdvanced;}();}();
auto& extendedDynamicState3ProvokingVertexMode_json=json["extendedDynamicState3ProvokingVertexMode"];
[&](){[&](){extendedDynamicState3ProvokingVertexMode_json=member.extendedDynamicState3ProvokingVertexMode;}();}();
auto& extendedDynamicState3LineRasterizationMode_json=json["extendedDynamicState3LineRasterizationMode"];
[&](){[&](){extendedDynamicState3LineRasterizationMode_json=member.extendedDynamicState3LineRasterizationMode;}();}();
auto& extendedDynamicState3LineStippleEnable_json=json["extendedDynamicState3LineStippleEnable"];
[&](){[&](){extendedDynamicState3LineStippleEnable_json=member.extendedDynamicState3LineStippleEnable;}();}();
auto& extendedDynamicState3DepthClipNegativeOneToOne_json=json["extendedDynamicState3DepthClipNegativeOneToOne"];
[&](){[&](){extendedDynamicState3DepthClipNegativeOneToOne_json=member.extendedDynamicState3DepthClipNegativeOneToOne;}();}();
auto& extendedDynamicState3ViewportWScalingEnable_json=json["extendedDynamicState3ViewportWScalingEnable"];
[&](){[&](){extendedDynamicState3ViewportWScalingEnable_json=member.extendedDynamicState3ViewportWScalingEnable;}();}();
auto& extendedDynamicState3ViewportSwizzle_json=json["extendedDynamicState3ViewportSwizzle"];
[&](){[&](){extendedDynamicState3ViewportSwizzle_json=member.extendedDynamicState3ViewportSwizzle;}();}();
auto& extendedDynamicState3CoverageToColorEnable_json=json["extendedDynamicState3CoverageToColorEnable"];
[&](){[&](){extendedDynamicState3CoverageToColorEnable_json=member.extendedDynamicState3CoverageToColorEnable;}();}();
auto& extendedDynamicState3CoverageToColorLocation_json=json["extendedDynamicState3CoverageToColorLocation"];
[&](){[&](){extendedDynamicState3CoverageToColorLocation_json=member.extendedDynamicState3CoverageToColorLocation;}();}();
auto& extendedDynamicState3CoverageModulationMode_json=json["extendedDynamicState3CoverageModulationMode"];
[&](){[&](){extendedDynamicState3CoverageModulationMode_json=member.extendedDynamicState3CoverageModulationMode;}();}();
auto& extendedDynamicState3CoverageModulationTableEnable_json=json["extendedDynamicState3CoverageModulationTableEnable"];
[&](){[&](){extendedDynamicState3CoverageModulationTableEnable_json=member.extendedDynamicState3CoverageModulationTableEnable;}();}();
auto& extendedDynamicState3CoverageModulationTable_json=json["extendedDynamicState3CoverageModulationTable"];
[&](){[&](){extendedDynamicState3CoverageModulationTable_json=member.extendedDynamicState3CoverageModulationTable;}();}();
auto& extendedDynamicState3CoverageReductionMode_json=json["extendedDynamicState3CoverageReductionMode"];
[&](){[&](){extendedDynamicState3CoverageReductionMode_json=member.extendedDynamicState3CoverageReductionMode;}();}();
auto& extendedDynamicState3RepresentativeFragmentTestEnable_json=json["extendedDynamicState3RepresentativeFragmentTestEnable"];
[&](){[&](){extendedDynamicState3RepresentativeFragmentTestEnable_json=member.extendedDynamicState3RepresentativeFragmentTestEnable;}();}();
auto& extendedDynamicState3ShadingRateImageEnable_json=json["extendedDynamicState3ShadingRateImageEnable"];
[&](){[&](){extendedDynamicState3ShadingRateImageEnable_json=member.extendedDynamicState3ShadingRateImageEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& extendedDynamicState3TessellationDomainOrigin_json=json["extendedDynamicState3TessellationDomainOrigin"];
[&](){uint32_t temp_TgAeKyO;[&](){temp_TgAeKyO=static_cast<uint32_t>(value_to<int>(extendedDynamicState3TessellationDomainOrigin_json));}();member.extendedDynamicState3TessellationDomainOrigin=(VkBool32)temp_TgAeKyO;}();
auto& extendedDynamicState3DepthClampEnable_json=json["extendedDynamicState3DepthClampEnable"];
[&](){uint32_t temp_iGDPSNQ;[&](){temp_iGDPSNQ=static_cast<uint32_t>(value_to<int>(extendedDynamicState3DepthClampEnable_json));}();member.extendedDynamicState3DepthClampEnable=(VkBool32)temp_iGDPSNQ;}();
auto& extendedDynamicState3PolygonMode_json=json["extendedDynamicState3PolygonMode"];
[&](){uint32_t temp_wKPMVyr;[&](){temp_wKPMVyr=static_cast<uint32_t>(value_to<int>(extendedDynamicState3PolygonMode_json));}();member.extendedDynamicState3PolygonMode=(VkBool32)temp_wKPMVyr;}();
auto& extendedDynamicState3RasterizationSamples_json=json["extendedDynamicState3RasterizationSamples"];
[&](){uint32_t temp_MztIvAA;[&](){temp_MztIvAA=static_cast<uint32_t>(value_to<int>(extendedDynamicState3RasterizationSamples_json));}();member.extendedDynamicState3RasterizationSamples=(VkBool32)temp_MztIvAA;}();
auto& extendedDynamicState3SampleMask_json=json["extendedDynamicState3SampleMask"];
[&](){uint32_t temp_stMvEmV;[&](){temp_stMvEmV=static_cast<uint32_t>(value_to<int>(extendedDynamicState3SampleMask_json));}();member.extendedDynamicState3SampleMask=(VkBool32)temp_stMvEmV;}();
auto& extendedDynamicState3AlphaToCoverageEnable_json=json["extendedDynamicState3AlphaToCoverageEnable"];
[&](){uint32_t temp_IyURedS;[&](){temp_IyURedS=static_cast<uint32_t>(value_to<int>(extendedDynamicState3AlphaToCoverageEnable_json));}();member.extendedDynamicState3AlphaToCoverageEnable=(VkBool32)temp_IyURedS;}();
auto& extendedDynamicState3AlphaToOneEnable_json=json["extendedDynamicState3AlphaToOneEnable"];
[&](){uint32_t temp_VuqPVdg;[&](){temp_VuqPVdg=static_cast<uint32_t>(value_to<int>(extendedDynamicState3AlphaToOneEnable_json));}();member.extendedDynamicState3AlphaToOneEnable=(VkBool32)temp_VuqPVdg;}();
auto& extendedDynamicState3LogicOpEnable_json=json["extendedDynamicState3LogicOpEnable"];
[&](){uint32_t temp_OGLGily;[&](){temp_OGLGily=static_cast<uint32_t>(value_to<int>(extendedDynamicState3LogicOpEnable_json));}();member.extendedDynamicState3LogicOpEnable=(VkBool32)temp_OGLGily;}();
auto& extendedDynamicState3ColorBlendEnable_json=json["extendedDynamicState3ColorBlendEnable"];
[&](){uint32_t temp_xDIQmOE;[&](){temp_xDIQmOE=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ColorBlendEnable_json));}();member.extendedDynamicState3ColorBlendEnable=(VkBool32)temp_xDIQmOE;}();
auto& extendedDynamicState3ColorBlendEquation_json=json["extendedDynamicState3ColorBlendEquation"];
[&](){uint32_t temp_vLJayNp;[&](){temp_vLJayNp=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ColorBlendEquation_json));}();member.extendedDynamicState3ColorBlendEquation=(VkBool32)temp_vLJayNp;}();
auto& extendedDynamicState3ColorWriteMask_json=json["extendedDynamicState3ColorWriteMask"];
[&](){uint32_t temp_IbljDCw;[&](){temp_IbljDCw=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ColorWriteMask_json));}();member.extendedDynamicState3ColorWriteMask=(VkBool32)temp_IbljDCw;}();
auto& extendedDynamicState3RasterizationStream_json=json["extendedDynamicState3RasterizationStream"];
[&](){uint32_t temp_LrilIuW;[&](){temp_LrilIuW=static_cast<uint32_t>(value_to<int>(extendedDynamicState3RasterizationStream_json));}();member.extendedDynamicState3RasterizationStream=(VkBool32)temp_LrilIuW;}();
auto& extendedDynamicState3ConservativeRasterizationMode_json=json["extendedDynamicState3ConservativeRasterizationMode"];
[&](){uint32_t temp_TSLBFCb;[&](){temp_TSLBFCb=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ConservativeRasterizationMode_json));}();member.extendedDynamicState3ConservativeRasterizationMode=(VkBool32)temp_TSLBFCb;}();
auto& extendedDynamicState3ExtraPrimitiveOverestimationSize_json=json["extendedDynamicState3ExtraPrimitiveOverestimationSize"];
[&](){uint32_t temp_qwYUhwo;[&](){temp_qwYUhwo=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ExtraPrimitiveOverestimationSize_json));}();member.extendedDynamicState3ExtraPrimitiveOverestimationSize=(VkBool32)temp_qwYUhwo;}();
auto& extendedDynamicState3DepthClipEnable_json=json["extendedDynamicState3DepthClipEnable"];
[&](){uint32_t temp_astKued;[&](){temp_astKued=static_cast<uint32_t>(value_to<int>(extendedDynamicState3DepthClipEnable_json));}();member.extendedDynamicState3DepthClipEnable=(VkBool32)temp_astKued;}();
auto& extendedDynamicState3SampleLocationsEnable_json=json["extendedDynamicState3SampleLocationsEnable"];
[&](){uint32_t temp_lTDYQPY;[&](){temp_lTDYQPY=static_cast<uint32_t>(value_to<int>(extendedDynamicState3SampleLocationsEnable_json));}();member.extendedDynamicState3SampleLocationsEnable=(VkBool32)temp_lTDYQPY;}();
auto& extendedDynamicState3ColorBlendAdvanced_json=json["extendedDynamicState3ColorBlendAdvanced"];
[&](){uint32_t temp_XoSHeXY;[&](){temp_XoSHeXY=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ColorBlendAdvanced_json));}();member.extendedDynamicState3ColorBlendAdvanced=(VkBool32)temp_XoSHeXY;}();
auto& extendedDynamicState3ProvokingVertexMode_json=json["extendedDynamicState3ProvokingVertexMode"];
[&](){uint32_t temp_RynZVVb;[&](){temp_RynZVVb=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ProvokingVertexMode_json));}();member.extendedDynamicState3ProvokingVertexMode=(VkBool32)temp_RynZVVb;}();
auto& extendedDynamicState3LineRasterizationMode_json=json["extendedDynamicState3LineRasterizationMode"];
[&](){uint32_t temp_OuNbGFH;[&](){temp_OuNbGFH=static_cast<uint32_t>(value_to<int>(extendedDynamicState3LineRasterizationMode_json));}();member.extendedDynamicState3LineRasterizationMode=(VkBool32)temp_OuNbGFH;}();
auto& extendedDynamicState3LineStippleEnable_json=json["extendedDynamicState3LineStippleEnable"];
[&](){uint32_t temp_CUwzMYp;[&](){temp_CUwzMYp=static_cast<uint32_t>(value_to<int>(extendedDynamicState3LineStippleEnable_json));}();member.extendedDynamicState3LineStippleEnable=(VkBool32)temp_CUwzMYp;}();
auto& extendedDynamicState3DepthClipNegativeOneToOne_json=json["extendedDynamicState3DepthClipNegativeOneToOne"];
[&](){uint32_t temp_khhsOMg;[&](){temp_khhsOMg=static_cast<uint32_t>(value_to<int>(extendedDynamicState3DepthClipNegativeOneToOne_json));}();member.extendedDynamicState3DepthClipNegativeOneToOne=(VkBool32)temp_khhsOMg;}();
auto& extendedDynamicState3ViewportWScalingEnable_json=json["extendedDynamicState3ViewportWScalingEnable"];
[&](){uint32_t temp_RHnLpqF;[&](){temp_RHnLpqF=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ViewportWScalingEnable_json));}();member.extendedDynamicState3ViewportWScalingEnable=(VkBool32)temp_RHnLpqF;}();
auto& extendedDynamicState3ViewportSwizzle_json=json["extendedDynamicState3ViewportSwizzle"];
[&](){uint32_t temp_oSJUyBU;[&](){temp_oSJUyBU=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ViewportSwizzle_json));}();member.extendedDynamicState3ViewportSwizzle=(VkBool32)temp_oSJUyBU;}();
auto& extendedDynamicState3CoverageToColorEnable_json=json["extendedDynamicState3CoverageToColorEnable"];
[&](){uint32_t temp_BzBMOon;[&](){temp_BzBMOon=static_cast<uint32_t>(value_to<int>(extendedDynamicState3CoverageToColorEnable_json));}();member.extendedDynamicState3CoverageToColorEnable=(VkBool32)temp_BzBMOon;}();
auto& extendedDynamicState3CoverageToColorLocation_json=json["extendedDynamicState3CoverageToColorLocation"];
[&](){uint32_t temp_obQIYKe;[&](){temp_obQIYKe=static_cast<uint32_t>(value_to<int>(extendedDynamicState3CoverageToColorLocation_json));}();member.extendedDynamicState3CoverageToColorLocation=(VkBool32)temp_obQIYKe;}();
auto& extendedDynamicState3CoverageModulationMode_json=json["extendedDynamicState3CoverageModulationMode"];
[&](){uint32_t temp_IDjHgMp;[&](){temp_IDjHgMp=static_cast<uint32_t>(value_to<int>(extendedDynamicState3CoverageModulationMode_json));}();member.extendedDynamicState3CoverageModulationMode=(VkBool32)temp_IDjHgMp;}();
auto& extendedDynamicState3CoverageModulationTableEnable_json=json["extendedDynamicState3CoverageModulationTableEnable"];
[&](){uint32_t temp_rPdOeWj;[&](){temp_rPdOeWj=static_cast<uint32_t>(value_to<int>(extendedDynamicState3CoverageModulationTableEnable_json));}();member.extendedDynamicState3CoverageModulationTableEnable=(VkBool32)temp_rPdOeWj;}();
auto& extendedDynamicState3CoverageModulationTable_json=json["extendedDynamicState3CoverageModulationTable"];
[&](){uint32_t temp_RBZNVMZ;[&](){temp_RBZNVMZ=static_cast<uint32_t>(value_to<int>(extendedDynamicState3CoverageModulationTable_json));}();member.extendedDynamicState3CoverageModulationTable=(VkBool32)temp_RBZNVMZ;}();
auto& extendedDynamicState3CoverageReductionMode_json=json["extendedDynamicState3CoverageReductionMode"];
[&](){uint32_t temp_dGABKdX;[&](){temp_dGABKdX=static_cast<uint32_t>(value_to<int>(extendedDynamicState3CoverageReductionMode_json));}();member.extendedDynamicState3CoverageReductionMode=(VkBool32)temp_dGABKdX;}();
auto& extendedDynamicState3RepresentativeFragmentTestEnable_json=json["extendedDynamicState3RepresentativeFragmentTestEnable"];
[&](){uint32_t temp_JwkuWUC;[&](){temp_JwkuWUC=static_cast<uint32_t>(value_to<int>(extendedDynamicState3RepresentativeFragmentTestEnable_json));}();member.extendedDynamicState3RepresentativeFragmentTestEnable=(VkBool32)temp_JwkuWUC;}();
auto& extendedDynamicState3ShadingRateImageEnable_json=json["extendedDynamicState3ShadingRateImageEnable"];
[&](){uint32_t temp_kzRfSfh;[&](){temp_kzRfSfh=static_cast<uint32_t>(value_to<int>(extendedDynamicState3ShadingRateImageEnable_json));}();member.extendedDynamicState3ShadingRateImageEnable=(VkBool32)temp_kzRfSfh;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dynamicPrimitiveTopologyUnrestricted_json=json["dynamicPrimitiveTopologyUnrestricted"];
[&](){[&](){dynamicPrimitiveTopologyUnrestricted_json=member.dynamicPrimitiveTopologyUnrestricted;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& dynamicPrimitiveTopologyUnrestricted_json=json["dynamicPrimitiveTopologyUnrestricted"];
[&](){uint32_t temp_dXGeXWL;[&](){temp_dXGeXWL=static_cast<uint32_t>(value_to<int>(dynamicPrimitiveTopologyUnrestricted_json));}();member.dynamicPrimitiveTopologyUnrestricted=(VkBool32)temp_dXGeXWL;}();
}

    void serialize_struct(boost::json::object& json, const VkColorBlendEquationEXT& member){
        
    
auto& srcColorBlendFactor_json=json["srcColorBlendFactor"];
[&](){[&](){[&](){srcColorBlendFactor_json=member.srcColorBlendFactor;}();}();}();
auto& dstColorBlendFactor_json=json["dstColorBlendFactor"];
[&](){[&](){[&](){dstColorBlendFactor_json=member.dstColorBlendFactor;}();}();}();
auto& colorBlendOp_json=json["colorBlendOp"];
[&](){[&](){[&](){colorBlendOp_json=member.colorBlendOp;}();}();}();
auto& srcAlphaBlendFactor_json=json["srcAlphaBlendFactor"];
[&](){[&](){[&](){srcAlphaBlendFactor_json=member.srcAlphaBlendFactor;}();}();}();
auto& dstAlphaBlendFactor_json=json["dstAlphaBlendFactor"];
[&](){[&](){[&](){dstAlphaBlendFactor_json=member.dstAlphaBlendFactor;}();}();}();
auto& alphaBlendOp_json=json["alphaBlendOp"];
[&](){[&](){[&](){alphaBlendOp_json=member.alphaBlendOp;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkColorBlendEquationEXT& member){
auto& srcColorBlendFactor_json=json["srcColorBlendFactor"];
[&](){[&](){int temp_itBZrfJ;[&](){temp_itBZrfJ=static_cast<int>(value_to<int>(srcColorBlendFactor_json));}();member.srcColorBlendFactor=(VkBlendFactor)temp_itBZrfJ;}();}();
auto& dstColorBlendFactor_json=json["dstColorBlendFactor"];
[&](){[&](){int temp_OJUMGlm;[&](){temp_OJUMGlm=static_cast<int>(value_to<int>(dstColorBlendFactor_json));}();member.dstColorBlendFactor=(VkBlendFactor)temp_OJUMGlm;}();}();
auto& colorBlendOp_json=json["colorBlendOp"];
[&](){[&](){int temp_dhbtuka;[&](){temp_dhbtuka=static_cast<int>(value_to<int>(colorBlendOp_json));}();member.colorBlendOp=(VkBlendOp)temp_dhbtuka;}();}();
auto& srcAlphaBlendFactor_json=json["srcAlphaBlendFactor"];
[&](){[&](){int temp_LxHDiTT;[&](){temp_LxHDiTT=static_cast<int>(value_to<int>(srcAlphaBlendFactor_json));}();member.srcAlphaBlendFactor=(VkBlendFactor)temp_LxHDiTT;}();}();
auto& dstAlphaBlendFactor_json=json["dstAlphaBlendFactor"];
[&](){[&](){int temp_VXLWFSC;[&](){temp_VXLWFSC=static_cast<int>(value_to<int>(dstAlphaBlendFactor_json));}();member.dstAlphaBlendFactor=(VkBlendFactor)temp_VXLWFSC;}();}();
auto& alphaBlendOp_json=json["alphaBlendOp"];
[&](){[&](){int temp_obeoNAe;[&](){temp_obeoNAe=static_cast<int>(value_to<int>(alphaBlendOp_json));}();member.alphaBlendOp=(VkBlendOp)temp_obeoNAe;}();}();
}

    void serialize_struct(boost::json::object& json, const VkColorBlendAdvancedEXT& member){
        
    
auto& advancedBlendOp_json=json["advancedBlendOp"];
[&](){[&](){[&](){advancedBlendOp_json=member.advancedBlendOp;}();}();}();
auto& srcPremultiplied_json=json["srcPremultiplied"];
[&](){[&](){srcPremultiplied_json=member.srcPremultiplied;}();}();
auto& dstPremultiplied_json=json["dstPremultiplied"];
[&](){[&](){dstPremultiplied_json=member.dstPremultiplied;}();}();
auto& blendOverlap_json=json["blendOverlap"];
[&](){[&](){[&](){blendOverlap_json=member.blendOverlap;}();}();}();
auto& clampResults_json=json["clampResults"];
[&](){[&](){clampResults_json=member.clampResults;}();}();
}
void deserialize_struct(boost::json::object& json, VkColorBlendAdvancedEXT& member){
auto& advancedBlendOp_json=json["advancedBlendOp"];
[&](){[&](){int temp_jzxfdyA;[&](){temp_jzxfdyA=static_cast<int>(value_to<int>(advancedBlendOp_json));}();member.advancedBlendOp=(VkBlendOp)temp_jzxfdyA;}();}();
auto& srcPremultiplied_json=json["srcPremultiplied"];
[&](){uint32_t temp_INMFoxF;[&](){temp_INMFoxF=static_cast<uint32_t>(value_to<int>(srcPremultiplied_json));}();member.srcPremultiplied=(VkBool32)temp_INMFoxF;}();
auto& dstPremultiplied_json=json["dstPremultiplied"];
[&](){uint32_t temp_IepqSXd;[&](){temp_IepqSXd=static_cast<uint32_t>(value_to<int>(dstPremultiplied_json));}();member.dstPremultiplied=(VkBool32)temp_IepqSXd;}();
auto& blendOverlap_json=json["blendOverlap"];
[&](){[&](){int temp_mSHDMhO;[&](){temp_mSHDMhO=static_cast<int>(value_to<int>(blendOverlap_json));}();member.blendOverlap=(VkBlendOverlapEXT)temp_mSHDMhO;}();}();
auto& clampResults_json=json["clampResults"];
[&](){uint32_t temp_WBrxRdO;[&](){temp_WBrxRdO=static_cast<uint32_t>(value_to<int>(clampResults_json));}();member.clampResults=(VkBool32)temp_WBrxRdO;}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassTransformBeginInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& transform_json=json["transform"];
[&](){[&](){[&](){transform_json=member.transform;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkRenderPassTransformBeginInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& transform_json=json["transform"];
[&](){[&](){int temp_docqSjH;[&](){temp_docqSjH=static_cast<int>(value_to<int>(transform_json));}();member.transform=(VkSurfaceTransformFlagBitsKHR)temp_docqSjH;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCopyCommandTransformInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& transform_json=json["transform"];
[&](){[&](){[&](){transform_json=member.transform;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCopyCommandTransformInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& transform_json=json["transform"];
[&](){[&](){int temp_docqSjH;[&](){temp_docqSjH=static_cast<int>(value_to<int>(transform_json));}();member.transform=(VkSurfaceTransformFlagBitsKHR)temp_docqSjH;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCommandBufferInheritanceRenderPassTransformInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& transform_json=json["transform"];
[&](){[&](){[&](){transform_json=member.transform;}();}();}();
auto& renderArea_json=json["renderArea"];
[&](){
            auto& temp=renderArea_json.emplace_object();
            return serialize_struct(temp, member.renderArea);
            }();
}
void deserialize_struct(boost::json::object& json, VkCommandBufferInheritanceRenderPassTransformInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& transform_json=json["transform"];
[&](){[&](){int temp_docqSjH;[&](){temp_docqSjH=static_cast<int>(value_to<int>(transform_json));}();member.transform=(VkSurfaceTransformFlagBitsKHR)temp_docqSjH;}();}();
auto& renderArea_json=json["renderArea"];
[&](){
            auto& temp=renderArea_json.as_object();
            deserialize_struct(temp,member.renderArea);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDiagnosticsConfigFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& diagnosticsConfig_json=json["diagnosticsConfig"];
[&](){[&](){diagnosticsConfig_json=member.diagnosticsConfig;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDiagnosticsConfigFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& diagnosticsConfig_json=json["diagnosticsConfig"];
[&](){uint32_t temp_ALsFOKp;[&](){temp_ALsFOKp=static_cast<uint32_t>(value_to<int>(diagnosticsConfig_json));}();member.diagnosticsConfig=(VkBool32)temp_ALsFOKp;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceDiagnosticsConfigCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceDiagnosticsConfigCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_pUgfmYv;[&](){temp_pUgfmYv=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDeviceDiagnosticsConfigFlagsNV)temp_pUgfmYv;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderZeroInitializeWorkgroupMemory_json=json["shaderZeroInitializeWorkgroupMemory"];
[&](){[&](){shaderZeroInitializeWorkgroupMemory_json=member.shaderZeroInitializeWorkgroupMemory;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderZeroInitializeWorkgroupMemory_json=json["shaderZeroInitializeWorkgroupMemory"];
[&](){uint32_t temp_TYydgpp;[&](){temp_TYydgpp=static_cast<uint32_t>(value_to<int>(shaderZeroInitializeWorkgroupMemory_json));}();member.shaderZeroInitializeWorkgroupMemory=(VkBool32)temp_TYydgpp;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderSubgroupUniformControlFlow_json=json["shaderSubgroupUniformControlFlow"];
[&](){[&](){shaderSubgroupUniformControlFlow_json=member.shaderSubgroupUniformControlFlow;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderSubgroupUniformControlFlow_json=json["shaderSubgroupUniformControlFlow"];
[&](){uint32_t temp_ERicIbS;[&](){temp_ERicIbS=static_cast<uint32_t>(value_to<int>(shaderSubgroupUniformControlFlow_json));}();member.shaderSubgroupUniformControlFlow=(VkBool32)temp_ERicIbS;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRobustness2FeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& robustBufferAccess2_json=json["robustBufferAccess2"];
[&](){[&](){robustBufferAccess2_json=member.robustBufferAccess2;}();}();
auto& robustImageAccess2_json=json["robustImageAccess2"];
[&](){[&](){robustImageAccess2_json=member.robustImageAccess2;}();}();
auto& nullDescriptor_json=json["nullDescriptor"];
[&](){[&](){nullDescriptor_json=member.nullDescriptor;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRobustness2FeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& robustBufferAccess2_json=json["robustBufferAccess2"];
[&](){uint32_t temp_gmWuWnR;[&](){temp_gmWuWnR=static_cast<uint32_t>(value_to<int>(robustBufferAccess2_json));}();member.robustBufferAccess2=(VkBool32)temp_gmWuWnR;}();
auto& robustImageAccess2_json=json["robustImageAccess2"];
[&](){uint32_t temp_CNOUlOc;[&](){temp_CNOUlOc=static_cast<uint32_t>(value_to<int>(robustImageAccess2_json));}();member.robustImageAccess2=(VkBool32)temp_CNOUlOc;}();
auto& nullDescriptor_json=json["nullDescriptor"];
[&](){uint32_t temp_GgYlLyO;[&](){temp_GgYlLyO=static_cast<uint32_t>(value_to<int>(nullDescriptor_json));}();member.nullDescriptor=(VkBool32)temp_GgYlLyO;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRobustness2PropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& robustStorageBufferAccessSizeAlignment_json=json["robustStorageBufferAccessSizeAlignment"];
[&](){[&](){robustStorageBufferAccessSizeAlignment_json=member.robustStorageBufferAccessSizeAlignment;}();}();
auto& robustUniformBufferAccessSizeAlignment_json=json["robustUniformBufferAccessSizeAlignment"];
[&](){[&](){robustUniformBufferAccessSizeAlignment_json=member.robustUniformBufferAccessSizeAlignment;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRobustness2PropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& robustStorageBufferAccessSizeAlignment_json=json["robustStorageBufferAccessSizeAlignment"];
[&](){uint64_t temp_KGGNDie;[&](){temp_KGGNDie=static_cast<uint64_t>(value_to<int>(robustStorageBufferAccessSizeAlignment_json));}();member.robustStorageBufferAccessSizeAlignment=(VkDeviceSize)temp_KGGNDie;}();
auto& robustUniformBufferAccessSizeAlignment_json=json["robustUniformBufferAccessSizeAlignment"];
[&](){uint64_t temp_oRngSzT;[&](){temp_oRngSzT=static_cast<uint64_t>(value_to<int>(robustUniformBufferAccessSizeAlignment_json));}();member.robustUniformBufferAccessSizeAlignment=(VkDeviceSize)temp_oRngSzT;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageRobustnessFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& robustImageAccess_json=json["robustImageAccess"];
[&](){[&](){robustImageAccess_json=member.robustImageAccess;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageRobustnessFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& robustImageAccess_json=json["robustImageAccess"];
[&](){uint32_t temp_UzJnzpL;[&](){temp_UzJnzpL=static_cast<uint32_t>(value_to<int>(robustImageAccess_json));}();member.robustImageAccess=(VkBool32)temp_UzJnzpL;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& workgroupMemoryExplicitLayout_json=json["workgroupMemoryExplicitLayout"];
[&](){[&](){workgroupMemoryExplicitLayout_json=member.workgroupMemoryExplicitLayout;}();}();
auto& workgroupMemoryExplicitLayoutScalarBlockLayout_json=json["workgroupMemoryExplicitLayoutScalarBlockLayout"];
[&](){[&](){workgroupMemoryExplicitLayoutScalarBlockLayout_json=member.workgroupMemoryExplicitLayoutScalarBlockLayout;}();}();
auto& workgroupMemoryExplicitLayout8BitAccess_json=json["workgroupMemoryExplicitLayout8BitAccess"];
[&](){[&](){workgroupMemoryExplicitLayout8BitAccess_json=member.workgroupMemoryExplicitLayout8BitAccess;}();}();
auto& workgroupMemoryExplicitLayout16BitAccess_json=json["workgroupMemoryExplicitLayout16BitAccess"];
[&](){[&](){workgroupMemoryExplicitLayout16BitAccess_json=member.workgroupMemoryExplicitLayout16BitAccess;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& workgroupMemoryExplicitLayout_json=json["workgroupMemoryExplicitLayout"];
[&](){uint32_t temp_locgXCq;[&](){temp_locgXCq=static_cast<uint32_t>(value_to<int>(workgroupMemoryExplicitLayout_json));}();member.workgroupMemoryExplicitLayout=(VkBool32)temp_locgXCq;}();
auto& workgroupMemoryExplicitLayoutScalarBlockLayout_json=json["workgroupMemoryExplicitLayoutScalarBlockLayout"];
[&](){uint32_t temp_mQtjZRi;[&](){temp_mQtjZRi=static_cast<uint32_t>(value_to<int>(workgroupMemoryExplicitLayoutScalarBlockLayout_json));}();member.workgroupMemoryExplicitLayoutScalarBlockLayout=(VkBool32)temp_mQtjZRi;}();
auto& workgroupMemoryExplicitLayout8BitAccess_json=json["workgroupMemoryExplicitLayout8BitAccess"];
[&](){uint32_t temp_RYCYcuD;[&](){temp_RYCYcuD=static_cast<uint32_t>(value_to<int>(workgroupMemoryExplicitLayout8BitAccess_json));}();member.workgroupMemoryExplicitLayout8BitAccess=(VkBool32)temp_RYCYcuD;}();
auto& workgroupMemoryExplicitLayout16BitAccess_json=json["workgroupMemoryExplicitLayout16BitAccess"];
[&](){uint32_t temp_skufySw;[&](){temp_skufySw=static_cast<uint32_t>(value_to<int>(workgroupMemoryExplicitLayout16BitAccess_json));}();member.workgroupMemoryExplicitLayout16BitAccess=(VkBool32)temp_skufySw;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevice4444FormatsFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& formatA4R4G4B4_json=json["formatA4R4G4B4"];
[&](){[&](){formatA4R4G4B4_json=member.formatA4R4G4B4;}();}();
auto& formatA4B4G4R4_json=json["formatA4B4G4R4"];
[&](){[&](){formatA4B4G4R4_json=member.formatA4B4G4R4;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevice4444FormatsFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& formatA4R4G4B4_json=json["formatA4R4G4B4"];
[&](){uint32_t temp_iEUviNj;[&](){temp_iEUviNj=static_cast<uint32_t>(value_to<int>(formatA4R4G4B4_json));}();member.formatA4R4G4B4=(VkBool32)temp_iEUviNj;}();
auto& formatA4B4G4R4_json=json["formatA4B4G4R4"];
[&](){uint32_t temp_msaEfFd;[&](){temp_msaEfFd=static_cast<uint32_t>(value_to<int>(formatA4B4G4R4_json));}();member.formatA4B4G4R4=(VkBool32)temp_msaEfFd;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& subpassShading_json=json["subpassShading"];
[&](){[&](){subpassShading_json=member.subpassShading;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& subpassShading_json=json["subpassShading"];
[&](){uint32_t temp_ejxhhHD;[&](){temp_ejxhhHD=static_cast<uint32_t>(value_to<int>(subpassShading_json));}();member.subpassShading=(VkBool32)temp_ejxhhHD;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& clustercullingShader_json=json["clustercullingShader"];
[&](){[&](){clustercullingShader_json=member.clustercullingShader;}();}();
auto& multiviewClusterCullingShader_json=json["multiviewClusterCullingShader"];
[&](){[&](){multiviewClusterCullingShader_json=member.multiviewClusterCullingShader;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& clustercullingShader_json=json["clustercullingShader"];
[&](){uint32_t temp_eZTtzKo;[&](){temp_eZTtzKo=static_cast<uint32_t>(value_to<int>(clustercullingShader_json));}();member.clustercullingShader=(VkBool32)temp_eZTtzKo;}();
auto& multiviewClusterCullingShader_json=json["multiviewClusterCullingShader"];
[&](){uint32_t temp_eSfADMJ;[&](){temp_eSfADMJ=static_cast<uint32_t>(value_to<int>(multiviewClusterCullingShader_json));}();member.multiviewClusterCullingShader=(VkBool32)temp_eSfADMJ;}();
}

    void serialize_struct(boost::json::object& json, const VkBufferCopy2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcOffset_json=json["srcOffset"];
[&](){[&](){srcOffset_json=member.srcOffset;}();}();
auto& dstOffset_json=json["dstOffset"];
[&](){[&](){dstOffset_json=member.dstOffset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkBufferCopy2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcOffset_json=json["srcOffset"];
[&](){uint64_t temp_jpKCFAb;[&](){temp_jpKCFAb=static_cast<uint64_t>(value_to<int>(srcOffset_json));}();member.srcOffset=(VkDeviceSize)temp_jpKCFAb;}();
auto& dstOffset_json=json["dstOffset"];
[&](){uint64_t temp_krGwneR;[&](){temp_krGwneR=static_cast<uint64_t>(value_to<int>(dstOffset_json));}();member.dstOffset=(VkDeviceSize)temp_krGwneR;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkImageCopy2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.emplace_object();
            return serialize_struct(temp, member.srcSubresource);
            }();
auto& srcOffset_json=json["srcOffset"];
[&](){
            auto& temp=srcOffset_json.emplace_object();
            return serialize_struct(temp, member.srcOffset);
            }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.emplace_object();
            return serialize_struct(temp, member.dstSubresource);
            }();
auto& dstOffset_json=json["dstOffset"];
[&](){
            auto& temp=dstOffset_json.emplace_object();
            return serialize_struct(temp, member.dstOffset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.emplace_object();
            return serialize_struct(temp, member.extent);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageCopy2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.as_object();
            deserialize_struct(temp,member.srcSubresource);
            }();
auto& srcOffset_json=json["srcOffset"];
[&](){
            auto& temp=srcOffset_json.as_object();
            deserialize_struct(temp,member.srcOffset);
            }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.as_object();
            deserialize_struct(temp,member.dstSubresource);
            }();
auto& dstOffset_json=json["dstOffset"];
[&](){
            auto& temp=dstOffset_json.as_object();
            deserialize_struct(temp,member.dstOffset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.as_object();
            deserialize_struct(temp,member.extent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkImageBlit2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.emplace_object();
            return serialize_struct(temp, member.srcSubresource);
            }();
auto& srcOffsets_json=json["srcOffsets"];
[&](){srcOffsets_json=boost::json::array(2);
        auto& arr_HKFUgIx=srcOffsets_json.as_array();
        for(int cffHdsm=0; cffHdsm < 2; cffHdsm++){
            [&](){
            auto& temp=arr_HKFUgIx[cffHdsm].emplace_object();
            return serialize_struct(temp, member.srcOffsets[cffHdsm]);
            }();
        }
        }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.emplace_object();
            return serialize_struct(temp, member.dstSubresource);
            }();
auto& dstOffsets_json=json["dstOffsets"];
[&](){dstOffsets_json=boost::json::array(2);
        auto& arr_EYgKCdH=dstOffsets_json.as_array();
        for(int YmWWFoI=0; YmWWFoI < 2; YmWWFoI++){
            [&](){
            auto& temp=arr_EYgKCdH[YmWWFoI].emplace_object();
            return serialize_struct(temp, member.dstOffsets[YmWWFoI]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkImageBlit2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.as_object();
            deserialize_struct(temp,member.srcSubresource);
            }();
auto& srcOffsets_json=json["srcOffsets"];
[&](){
        auto& arr_HKFUgIx=srcOffsets_json.as_array();
        for(int cffHdsm=0; cffHdsm < 2; cffHdsm++){
            [&](){
            auto& temp=arr_HKFUgIx[cffHdsm].as_object();
            deserialize_struct(temp,member.srcOffsets[cffHdsm]);
            }();
        }
        }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.as_object();
            deserialize_struct(temp,member.dstSubresource);
            }();
auto& dstOffsets_json=json["dstOffsets"];
[&](){
        auto& arr_EYgKCdH=dstOffsets_json.as_array();
        for(int YmWWFoI=0; YmWWFoI < 2; YmWWFoI++){
            [&](){
            auto& temp=arr_EYgKCdH[YmWWFoI].as_object();
            deserialize_struct(temp,member.dstOffsets[YmWWFoI]);
            }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkBufferImageCopy2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& bufferOffset_json=json["bufferOffset"];
[&](){[&](){bufferOffset_json=member.bufferOffset;}();}();
auto& bufferRowLength_json=json["bufferRowLength"];
[&](){bufferRowLength_json=member.bufferRowLength;}();
auto& bufferImageHeight_json=json["bufferImageHeight"];
[&](){bufferImageHeight_json=member.bufferImageHeight;}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.emplace_object();
            return serialize_struct(temp, member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.emplace_object();
            return serialize_struct(temp, member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.emplace_object();
            return serialize_struct(temp, member.imageExtent);
            }();
}
void deserialize_struct(boost::json::object& json, VkBufferImageCopy2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& bufferOffset_json=json["bufferOffset"];
[&](){uint64_t temp_VmlvOye;[&](){temp_VmlvOye=static_cast<uint64_t>(value_to<int>(bufferOffset_json));}();member.bufferOffset=(VkDeviceSize)temp_VmlvOye;}();
auto& bufferRowLength_json=json["bufferRowLength"];
[&](){member.bufferRowLength=static_cast<uint32_t>(value_to<int>(bufferRowLength_json));}();
auto& bufferImageHeight_json=json["bufferImageHeight"];
[&](){member.bufferImageHeight=static_cast<uint32_t>(value_to<int>(bufferImageHeight_json));}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.as_object();
            deserialize_struct(temp,member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.as_object();
            deserialize_struct(temp,member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.as_object();
            deserialize_struct(temp,member.imageExtent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkImageResolve2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.emplace_object();
            return serialize_struct(temp, member.srcSubresource);
            }();
auto& srcOffset_json=json["srcOffset"];
[&](){
            auto& temp=srcOffset_json.emplace_object();
            return serialize_struct(temp, member.srcOffset);
            }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.emplace_object();
            return serialize_struct(temp, member.dstSubresource);
            }();
auto& dstOffset_json=json["dstOffset"];
[&](){
            auto& temp=dstOffset_json.emplace_object();
            return serialize_struct(temp, member.dstOffset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.emplace_object();
            return serialize_struct(temp, member.extent);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageResolve2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcSubresource_json=json["srcSubresource"];
[&](){
            auto& temp=srcSubresource_json.as_object();
            deserialize_struct(temp,member.srcSubresource);
            }();
auto& srcOffset_json=json["srcOffset"];
[&](){
            auto& temp=srcOffset_json.as_object();
            deserialize_struct(temp,member.srcOffset);
            }();
auto& dstSubresource_json=json["dstSubresource"];
[&](){
            auto& temp=dstSubresource_json.as_object();
            deserialize_struct(temp,member.dstSubresource);
            }();
auto& dstOffset_json=json["dstOffset"];
[&](){
            auto& temp=dstOffset_json.as_object();
            deserialize_struct(temp,member.dstOffset);
            }();
auto& extent_json=json["extent"];
[&](){
            auto& temp=extent_json.as_object();
            deserialize_struct(temp,member.extent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkCopyBufferInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcBuffer_json=json["srcBuffer"];
[&](){serialize_VkBuffer(srcBuffer_json,member.srcBuffer);}();
auto& dstBuffer_json=json["dstBuffer"];
[&](){serialize_VkBuffer(dstBuffer_json,member.dstBuffer);}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_VOOmlwa=pRegions_json.as_array();
        for(int PyHvXgN=0; PyHvXgN < member.regionCount; PyHvXgN++){
            [&](){
            auto& temp=arr_VOOmlwa[PyHvXgN].emplace_object();
            return serialize_struct(temp, member.pRegions[PyHvXgN]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCopyBufferInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcBuffer_json=json["srcBuffer"];
[&](){deserialize_VkBuffer(srcBuffer_json, member.srcBuffer);}();
auto& dstBuffer_json=json["dstBuffer"];
[&](){deserialize_VkBuffer(dstBuffer_json, member.dstBuffer);}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkBufferCopy2* temp_zrPiZnj;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_zrPiZnj=NULL;
            return; }temp_zrPiZnj=(VkBufferCopy2*)malloc(member.regionCount*sizeof(VkBufferCopy2));
        auto& arr_qpOEBXN=pRegions_json.as_array();
        for(int dBYygoN=0; dBYygoN < member.regionCount; dBYygoN++){
            [&](){
            auto& temp=arr_qpOEBXN[dBYygoN].as_object();
            deserialize_struct(temp,temp_zrPiZnj[dBYygoN]);
            }();
        }
        }();member.pRegions=temp_zrPiZnj;}();
}

    void serialize_struct(boost::json::object& json, const VkCopyImageInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcImage_json=json["srcImage"];
[&](){serialize_VkImage(srcImage_json,member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){[&](){srcImageLayout_json=member.srcImageLayout;}();}();}();
auto& dstImage_json=json["dstImage"];
[&](){serialize_VkImage(dstImage_json,member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){[&](){dstImageLayout_json=member.dstImageLayout;}();}();}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_eEkCrMz=pRegions_json.as_array();
        for(int ldqasfX=0; ldqasfX < member.regionCount; ldqasfX++){
            [&](){
            auto& temp=arr_eEkCrMz[ldqasfX].emplace_object();
            return serialize_struct(temp, member.pRegions[ldqasfX]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCopyImageInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcImage_json=json["srcImage"];
[&](){deserialize_VkImage(srcImage_json, member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){int temp_OvXTzZQ;[&](){temp_OvXTzZQ=static_cast<int>(value_to<int>(srcImageLayout_json));}();member.srcImageLayout=(VkImageLayout)temp_OvXTzZQ;}();}();
auto& dstImage_json=json["dstImage"];
[&](){deserialize_VkImage(dstImage_json, member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){int temp_PpCpPSr;[&](){temp_PpCpPSr=static_cast<int>(value_to<int>(dstImageLayout_json));}();member.dstImageLayout=(VkImageLayout)temp_PpCpPSr;}();}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkImageCopy2* temp_oEdYZas;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_oEdYZas=NULL;
            return; }temp_oEdYZas=(VkImageCopy2*)malloc(member.regionCount*sizeof(VkImageCopy2));
        auto& arr_uCCYJNU=pRegions_json.as_array();
        for(int dqHsbqL=0; dqHsbqL < member.regionCount; dqHsbqL++){
            [&](){
            auto& temp=arr_uCCYJNU[dqHsbqL].as_object();
            deserialize_struct(temp,temp_oEdYZas[dqHsbqL]);
            }();
        }
        }();member.pRegions=temp_oEdYZas;}();
}

    void serialize_struct(boost::json::object& json, const VkBlitImageInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcImage_json=json["srcImage"];
[&](){serialize_VkImage(srcImage_json,member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){[&](){srcImageLayout_json=member.srcImageLayout;}();}();}();
auto& dstImage_json=json["dstImage"];
[&](){serialize_VkImage(dstImage_json,member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){[&](){dstImageLayout_json=member.dstImageLayout;}();}();}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_bLXCajV=pRegions_json.as_array();
        for(int vKsiEIA=0; vKsiEIA < member.regionCount; vKsiEIA++){
            [&](){
            auto& temp=arr_bLXCajV[vKsiEIA].emplace_object();
            return serialize_struct(temp, member.pRegions[vKsiEIA]);
            }();
        }
        }();
auto& filter_json=json["filter"];
[&](){[&](){[&](){filter_json=member.filter;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkBlitImageInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcImage_json=json["srcImage"];
[&](){deserialize_VkImage(srcImage_json, member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){int temp_OvXTzZQ;[&](){temp_OvXTzZQ=static_cast<int>(value_to<int>(srcImageLayout_json));}();member.srcImageLayout=(VkImageLayout)temp_OvXTzZQ;}();}();
auto& dstImage_json=json["dstImage"];
[&](){deserialize_VkImage(dstImage_json, member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){int temp_PpCpPSr;[&](){temp_PpCpPSr=static_cast<int>(value_to<int>(dstImageLayout_json));}();member.dstImageLayout=(VkImageLayout)temp_PpCpPSr;}();}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkImageBlit2* temp_YUyJGVO;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_YUyJGVO=NULL;
            return; }temp_YUyJGVO=(VkImageBlit2*)malloc(member.regionCount*sizeof(VkImageBlit2));
        auto& arr_QZNwrCx=pRegions_json.as_array();
        for(int GEBuyUw=0; GEBuyUw < member.regionCount; GEBuyUw++){
            [&](){
            auto& temp=arr_QZNwrCx[GEBuyUw].as_object();
            deserialize_struct(temp,temp_YUyJGVO[GEBuyUw]);
            }();
        }
        }();member.pRegions=temp_YUyJGVO;}();
auto& filter_json=json["filter"];
[&](){[&](){int temp_bDXEaKV;[&](){temp_bDXEaKV=static_cast<int>(value_to<int>(filter_json));}();member.filter=(VkFilter)temp_bDXEaKV;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCopyBufferToImageInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcBuffer_json=json["srcBuffer"];
[&](){serialize_VkBuffer(srcBuffer_json,member.srcBuffer);}();
auto& dstImage_json=json["dstImage"];
[&](){serialize_VkImage(dstImage_json,member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){[&](){dstImageLayout_json=member.dstImageLayout;}();}();}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_BFqlBiQ=pRegions_json.as_array();
        for(int mhPmJjS=0; mhPmJjS < member.regionCount; mhPmJjS++){
            [&](){
            auto& temp=arr_BFqlBiQ[mhPmJjS].emplace_object();
            return serialize_struct(temp, member.pRegions[mhPmJjS]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCopyBufferToImageInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcBuffer_json=json["srcBuffer"];
[&](){deserialize_VkBuffer(srcBuffer_json, member.srcBuffer);}();
auto& dstImage_json=json["dstImage"];
[&](){deserialize_VkImage(dstImage_json, member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){int temp_PpCpPSr;[&](){temp_PpCpPSr=static_cast<int>(value_to<int>(dstImageLayout_json));}();member.dstImageLayout=(VkImageLayout)temp_PpCpPSr;}();}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkBufferImageCopy2* temp_vSWbOmF;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_vSWbOmF=NULL;
            return; }temp_vSWbOmF=(VkBufferImageCopy2*)malloc(member.regionCount*sizeof(VkBufferImageCopy2));
        auto& arr_CxFwyRm=pRegions_json.as_array();
        for(int JoFKlzg=0; JoFKlzg < member.regionCount; JoFKlzg++){
            [&](){
            auto& temp=arr_CxFwyRm[JoFKlzg].as_object();
            deserialize_struct(temp,temp_vSWbOmF[JoFKlzg]);
            }();
        }
        }();member.pRegions=temp_vSWbOmF;}();
}

    void serialize_struct(boost::json::object& json, const VkCopyImageToBufferInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcImage_json=json["srcImage"];
[&](){serialize_VkImage(srcImage_json,member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){[&](){srcImageLayout_json=member.srcImageLayout;}();}();}();
auto& dstBuffer_json=json["dstBuffer"];
[&](){serialize_VkBuffer(dstBuffer_json,member.dstBuffer);}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_BFqlBiQ=pRegions_json.as_array();
        for(int mhPmJjS=0; mhPmJjS < member.regionCount; mhPmJjS++){
            [&](){
            auto& temp=arr_BFqlBiQ[mhPmJjS].emplace_object();
            return serialize_struct(temp, member.pRegions[mhPmJjS]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCopyImageToBufferInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcImage_json=json["srcImage"];
[&](){deserialize_VkImage(srcImage_json, member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){int temp_OvXTzZQ;[&](){temp_OvXTzZQ=static_cast<int>(value_to<int>(srcImageLayout_json));}();member.srcImageLayout=(VkImageLayout)temp_OvXTzZQ;}();}();
auto& dstBuffer_json=json["dstBuffer"];
[&](){deserialize_VkBuffer(dstBuffer_json, member.dstBuffer);}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkBufferImageCopy2* temp_vSWbOmF;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_vSWbOmF=NULL;
            return; }temp_vSWbOmF=(VkBufferImageCopy2*)malloc(member.regionCount*sizeof(VkBufferImageCopy2));
        auto& arr_CxFwyRm=pRegions_json.as_array();
        for(int JoFKlzg=0; JoFKlzg < member.regionCount; JoFKlzg++){
            [&](){
            auto& temp=arr_CxFwyRm[JoFKlzg].as_object();
            deserialize_struct(temp,temp_vSWbOmF[JoFKlzg]);
            }();
        }
        }();member.pRegions=temp_vSWbOmF;}();
}

    void serialize_struct(boost::json::object& json, const VkResolveImageInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcImage_json=json["srcImage"];
[&](){serialize_VkImage(srcImage_json,member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){[&](){srcImageLayout_json=member.srcImageLayout;}();}();}();
auto& dstImage_json=json["dstImage"];
[&](){serialize_VkImage(dstImage_json,member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){[&](){dstImageLayout_json=member.dstImageLayout;}();}();}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_sJBzdaX=pRegions_json.as_array();
        for(int gYVnlSs=0; gYVnlSs < member.regionCount; gYVnlSs++){
            [&](){
            auto& temp=arr_sJBzdaX[gYVnlSs].emplace_object();
            return serialize_struct(temp, member.pRegions[gYVnlSs]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkResolveImageInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcImage_json=json["srcImage"];
[&](){deserialize_VkImage(srcImage_json, member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){int temp_OvXTzZQ;[&](){temp_OvXTzZQ=static_cast<int>(value_to<int>(srcImageLayout_json));}();member.srcImageLayout=(VkImageLayout)temp_OvXTzZQ;}();}();
auto& dstImage_json=json["dstImage"];
[&](){deserialize_VkImage(dstImage_json, member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){int temp_PpCpPSr;[&](){temp_PpCpPSr=static_cast<int>(value_to<int>(dstImageLayout_json));}();member.dstImageLayout=(VkImageLayout)temp_PpCpPSr;}();}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkImageResolve2* temp_lfYdkxM;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_lfYdkxM=NULL;
            return; }temp_lfYdkxM=(VkImageResolve2*)malloc(member.regionCount*sizeof(VkImageResolve2));
        auto& arr_UkgYDDG=pRegions_json.as_array();
        for(int XMXckUx=0; XMXckUx < member.regionCount; XMXckUx++){
            [&](){
            auto& temp=arr_UkgYDDG[XMXckUx].as_object();
            deserialize_struct(temp,temp_lfYdkxM[XMXckUx]);
            }();
        }
        }();member.pRegions=temp_lfYdkxM;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderImageInt64Atomics_json=json["shaderImageInt64Atomics"];
[&](){[&](){shaderImageInt64Atomics_json=member.shaderImageInt64Atomics;}();}();
auto& sparseImageInt64Atomics_json=json["sparseImageInt64Atomics"];
[&](){[&](){sparseImageInt64Atomics_json=member.sparseImageInt64Atomics;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderImageInt64Atomics_json=json["shaderImageInt64Atomics"];
[&](){uint32_t temp_QUCeHdF;[&](){temp_QUCeHdF=static_cast<uint32_t>(value_to<int>(shaderImageInt64Atomics_json));}();member.shaderImageInt64Atomics=(VkBool32)temp_QUCeHdF;}();
auto& sparseImageInt64Atomics_json=json["sparseImageInt64Atomics"];
[&](){uint32_t temp_Ycsrmea;[&](){temp_Ycsrmea=static_cast<uint32_t>(value_to<int>(sparseImageInt64Atomics_json));}();member.sparseImageInt64Atomics=(VkBool32)temp_Ycsrmea;}();
}

    void serialize_struct(boost::json::object& json, const VkFragmentShadingRateAttachmentInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pFragmentShadingRateAttachment_json=json["pFragmentShadingRateAttachment"];
[&](){
            if (member.pFragmentShadingRateAttachment==NULL){
                pFragmentShadingRateAttachment_json=boost::json::array();
            return; }pFragmentShadingRateAttachment_json=boost::json::array(1);
        auto& arr_srAaFCv=pFragmentShadingRateAttachment_json.as_array();
        for(int EhVdyFn=0; EhVdyFn < 1; EhVdyFn++){
            [&](){
            auto& temp=arr_srAaFCv[EhVdyFn].emplace_object();
            return serialize_struct(temp, member.pFragmentShadingRateAttachment[EhVdyFn]);
            }();
        }
        }();
auto& shadingRateAttachmentTexelSize_json=json["shadingRateAttachmentTexelSize"];
[&](){
            auto& temp=shadingRateAttachmentTexelSize_json.emplace_object();
            return serialize_struct(temp, member.shadingRateAttachmentTexelSize);
            }();
}
void deserialize_struct(boost::json::object& json, VkFragmentShadingRateAttachmentInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pFragmentShadingRateAttachment_json=json["pFragmentShadingRateAttachment"];
[&](){ VkAttachmentReference2* temp_ZZGkbZU;;[&](){
            if (pFragmentShadingRateAttachment_json.as_array().size()==0){
                temp_ZZGkbZU=NULL;
            return; }temp_ZZGkbZU=(VkAttachmentReference2*)malloc(1*sizeof(VkAttachmentReference2));
        auto& arr_PhTPBjm=pFragmentShadingRateAttachment_json.as_array();
        for(int zTNIyTJ=0; zTNIyTJ < 1; zTNIyTJ++){
            [&](){
            auto& temp=arr_PhTPBjm[zTNIyTJ].as_object();
            deserialize_struct(temp,temp_ZZGkbZU[zTNIyTJ]);
            }();
        }
        }();member.pFragmentShadingRateAttachment=temp_ZZGkbZU;}();
auto& shadingRateAttachmentTexelSize_json=json["shadingRateAttachmentTexelSize"];
[&](){
            auto& temp=shadingRateAttachmentTexelSize_json.as_object();
            deserialize_struct(temp,member.shadingRateAttachmentTexelSize);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPipelineFragmentShadingRateStateCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentSize_json=json["fragmentSize"];
[&](){
            auto& temp=fragmentSize_json.emplace_object();
            return serialize_struct(temp, member.fragmentSize);
            }();
auto& combinerOps_json=json["combinerOps"];
[&](){combinerOps_json=boost::json::array(2);
        auto& arr_XZmmBZZ=combinerOps_json.as_array();
        for(int oRFNtpI=0; oRFNtpI < 2; oRFNtpI++){
            [&](){[&](){[&](){arr_XZmmBZZ[oRFNtpI]=member.combinerOps[oRFNtpI];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineFragmentShadingRateStateCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& fragmentSize_json=json["fragmentSize"];
[&](){
            auto& temp=fragmentSize_json.as_object();
            deserialize_struct(temp,member.fragmentSize);
            }();
auto& combinerOps_json=json["combinerOps"];
[&](){
        auto& arr_XZmmBZZ=combinerOps_json.as_array();
        for(int oRFNtpI=0; oRFNtpI < 2; oRFNtpI++){
            [&](){[&](){int temp_HyVITSp;[&](){temp_HyVITSp=static_cast<int>(value_to<int>(arr_XZmmBZZ[oRFNtpI]));}();member.combinerOps[oRFNtpI]=(VkFragmentShadingRateCombinerOpKHR)temp_HyVITSp;}();}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentShadingRateFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineFragmentShadingRate_json=json["pipelineFragmentShadingRate"];
[&](){[&](){pipelineFragmentShadingRate_json=member.pipelineFragmentShadingRate;}();}();
auto& primitiveFragmentShadingRate_json=json["primitiveFragmentShadingRate"];
[&](){[&](){primitiveFragmentShadingRate_json=member.primitiveFragmentShadingRate;}();}();
auto& attachmentFragmentShadingRate_json=json["attachmentFragmentShadingRate"];
[&](){[&](){attachmentFragmentShadingRate_json=member.attachmentFragmentShadingRate;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentShadingRateFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pipelineFragmentShadingRate_json=json["pipelineFragmentShadingRate"];
[&](){uint32_t temp_NWWSmTh;[&](){temp_NWWSmTh=static_cast<uint32_t>(value_to<int>(pipelineFragmentShadingRate_json));}();member.pipelineFragmentShadingRate=(VkBool32)temp_NWWSmTh;}();
auto& primitiveFragmentShadingRate_json=json["primitiveFragmentShadingRate"];
[&](){uint32_t temp_cRqrmYU;[&](){temp_cRqrmYU=static_cast<uint32_t>(value_to<int>(primitiveFragmentShadingRate_json));}();member.primitiveFragmentShadingRate=(VkBool32)temp_cRqrmYU;}();
auto& attachmentFragmentShadingRate_json=json["attachmentFragmentShadingRate"];
[&](){uint32_t temp_SlmEUoa;[&](){temp_SlmEUoa=static_cast<uint32_t>(value_to<int>(attachmentFragmentShadingRate_json));}();member.attachmentFragmentShadingRate=(VkBool32)temp_SlmEUoa;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentShadingRatePropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& minFragmentShadingRateAttachmentTexelSize_json=json["minFragmentShadingRateAttachmentTexelSize"];
[&](){
            auto& temp=minFragmentShadingRateAttachmentTexelSize_json.emplace_object();
            return serialize_struct(temp, member.minFragmentShadingRateAttachmentTexelSize);
            }();
auto& maxFragmentShadingRateAttachmentTexelSize_json=json["maxFragmentShadingRateAttachmentTexelSize"];
[&](){
            auto& temp=maxFragmentShadingRateAttachmentTexelSize_json.emplace_object();
            return serialize_struct(temp, member.maxFragmentShadingRateAttachmentTexelSize);
            }();
auto& maxFragmentShadingRateAttachmentTexelSizeAspectRatio_json=json["maxFragmentShadingRateAttachmentTexelSizeAspectRatio"];
[&](){maxFragmentShadingRateAttachmentTexelSizeAspectRatio_json=member.maxFragmentShadingRateAttachmentTexelSizeAspectRatio;}();
auto& primitiveFragmentShadingRateWithMultipleViewports_json=json["primitiveFragmentShadingRateWithMultipleViewports"];
[&](){[&](){primitiveFragmentShadingRateWithMultipleViewports_json=member.primitiveFragmentShadingRateWithMultipleViewports;}();}();
auto& layeredShadingRateAttachments_json=json["layeredShadingRateAttachments"];
[&](){[&](){layeredShadingRateAttachments_json=member.layeredShadingRateAttachments;}();}();
auto& fragmentShadingRateNonTrivialCombinerOps_json=json["fragmentShadingRateNonTrivialCombinerOps"];
[&](){[&](){fragmentShadingRateNonTrivialCombinerOps_json=member.fragmentShadingRateNonTrivialCombinerOps;}();}();
auto& maxFragmentSize_json=json["maxFragmentSize"];
[&](){
            auto& temp=maxFragmentSize_json.emplace_object();
            return serialize_struct(temp, member.maxFragmentSize);
            }();
auto& maxFragmentSizeAspectRatio_json=json["maxFragmentSizeAspectRatio"];
[&](){maxFragmentSizeAspectRatio_json=member.maxFragmentSizeAspectRatio;}();
auto& maxFragmentShadingRateCoverageSamples_json=json["maxFragmentShadingRateCoverageSamples"];
[&](){maxFragmentShadingRateCoverageSamples_json=member.maxFragmentShadingRateCoverageSamples;}();
auto& maxFragmentShadingRateRasterizationSamples_json=json["maxFragmentShadingRateRasterizationSamples"];
[&](){[&](){[&](){maxFragmentShadingRateRasterizationSamples_json=member.maxFragmentShadingRateRasterizationSamples;}();}();}();
auto& fragmentShadingRateWithShaderDepthStencilWrites_json=json["fragmentShadingRateWithShaderDepthStencilWrites"];
[&](){[&](){fragmentShadingRateWithShaderDepthStencilWrites_json=member.fragmentShadingRateWithShaderDepthStencilWrites;}();}();
auto& fragmentShadingRateWithSampleMask_json=json["fragmentShadingRateWithSampleMask"];
[&](){[&](){fragmentShadingRateWithSampleMask_json=member.fragmentShadingRateWithSampleMask;}();}();
auto& fragmentShadingRateWithShaderSampleMask_json=json["fragmentShadingRateWithShaderSampleMask"];
[&](){[&](){fragmentShadingRateWithShaderSampleMask_json=member.fragmentShadingRateWithShaderSampleMask;}();}();
auto& fragmentShadingRateWithConservativeRasterization_json=json["fragmentShadingRateWithConservativeRasterization"];
[&](){[&](){fragmentShadingRateWithConservativeRasterization_json=member.fragmentShadingRateWithConservativeRasterization;}();}();
auto& fragmentShadingRateWithFragmentShaderInterlock_json=json["fragmentShadingRateWithFragmentShaderInterlock"];
[&](){[&](){fragmentShadingRateWithFragmentShaderInterlock_json=member.fragmentShadingRateWithFragmentShaderInterlock;}();}();
auto& fragmentShadingRateWithCustomSampleLocations_json=json["fragmentShadingRateWithCustomSampleLocations"];
[&](){[&](){fragmentShadingRateWithCustomSampleLocations_json=member.fragmentShadingRateWithCustomSampleLocations;}();}();
auto& fragmentShadingRateStrictMultiplyCombiner_json=json["fragmentShadingRateStrictMultiplyCombiner"];
[&](){[&](){fragmentShadingRateStrictMultiplyCombiner_json=member.fragmentShadingRateStrictMultiplyCombiner;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentShadingRatePropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& minFragmentShadingRateAttachmentTexelSize_json=json["minFragmentShadingRateAttachmentTexelSize"];
[&](){
            auto& temp=minFragmentShadingRateAttachmentTexelSize_json.as_object();
            deserialize_struct(temp,member.minFragmentShadingRateAttachmentTexelSize);
            }();
auto& maxFragmentShadingRateAttachmentTexelSize_json=json["maxFragmentShadingRateAttachmentTexelSize"];
[&](){
            auto& temp=maxFragmentShadingRateAttachmentTexelSize_json.as_object();
            deserialize_struct(temp,member.maxFragmentShadingRateAttachmentTexelSize);
            }();
auto& maxFragmentShadingRateAttachmentTexelSizeAspectRatio_json=json["maxFragmentShadingRateAttachmentTexelSizeAspectRatio"];
[&](){member.maxFragmentShadingRateAttachmentTexelSizeAspectRatio=static_cast<uint32_t>(value_to<int>(maxFragmentShadingRateAttachmentTexelSizeAspectRatio_json));}();
auto& primitiveFragmentShadingRateWithMultipleViewports_json=json["primitiveFragmentShadingRateWithMultipleViewports"];
[&](){uint32_t temp_fxaKccS;[&](){temp_fxaKccS=static_cast<uint32_t>(value_to<int>(primitiveFragmentShadingRateWithMultipleViewports_json));}();member.primitiveFragmentShadingRateWithMultipleViewports=(VkBool32)temp_fxaKccS;}();
auto& layeredShadingRateAttachments_json=json["layeredShadingRateAttachments"];
[&](){uint32_t temp_RMbpytV;[&](){temp_RMbpytV=static_cast<uint32_t>(value_to<int>(layeredShadingRateAttachments_json));}();member.layeredShadingRateAttachments=(VkBool32)temp_RMbpytV;}();
auto& fragmentShadingRateNonTrivialCombinerOps_json=json["fragmentShadingRateNonTrivialCombinerOps"];
[&](){uint32_t temp_uImZyFq;[&](){temp_uImZyFq=static_cast<uint32_t>(value_to<int>(fragmentShadingRateNonTrivialCombinerOps_json));}();member.fragmentShadingRateNonTrivialCombinerOps=(VkBool32)temp_uImZyFq;}();
auto& maxFragmentSize_json=json["maxFragmentSize"];
[&](){
            auto& temp=maxFragmentSize_json.as_object();
            deserialize_struct(temp,member.maxFragmentSize);
            }();
auto& maxFragmentSizeAspectRatio_json=json["maxFragmentSizeAspectRatio"];
[&](){member.maxFragmentSizeAspectRatio=static_cast<uint32_t>(value_to<int>(maxFragmentSizeAspectRatio_json));}();
auto& maxFragmentShadingRateCoverageSamples_json=json["maxFragmentShadingRateCoverageSamples"];
[&](){member.maxFragmentShadingRateCoverageSamples=static_cast<uint32_t>(value_to<int>(maxFragmentShadingRateCoverageSamples_json));}();
auto& maxFragmentShadingRateRasterizationSamples_json=json["maxFragmentShadingRateRasterizationSamples"];
[&](){[&](){int temp_CVwLqfj;[&](){temp_CVwLqfj=static_cast<int>(value_to<int>(maxFragmentShadingRateRasterizationSamples_json));}();member.maxFragmentShadingRateRasterizationSamples=(VkSampleCountFlagBits)temp_CVwLqfj;}();}();
auto& fragmentShadingRateWithShaderDepthStencilWrites_json=json["fragmentShadingRateWithShaderDepthStencilWrites"];
[&](){uint32_t temp_UVRlgGU;[&](){temp_UVRlgGU=static_cast<uint32_t>(value_to<int>(fragmentShadingRateWithShaderDepthStencilWrites_json));}();member.fragmentShadingRateWithShaderDepthStencilWrites=(VkBool32)temp_UVRlgGU;}();
auto& fragmentShadingRateWithSampleMask_json=json["fragmentShadingRateWithSampleMask"];
[&](){uint32_t temp_hTLFhPM;[&](){temp_hTLFhPM=static_cast<uint32_t>(value_to<int>(fragmentShadingRateWithSampleMask_json));}();member.fragmentShadingRateWithSampleMask=(VkBool32)temp_hTLFhPM;}();
auto& fragmentShadingRateWithShaderSampleMask_json=json["fragmentShadingRateWithShaderSampleMask"];
[&](){uint32_t temp_NqaZxJD;[&](){temp_NqaZxJD=static_cast<uint32_t>(value_to<int>(fragmentShadingRateWithShaderSampleMask_json));}();member.fragmentShadingRateWithShaderSampleMask=(VkBool32)temp_NqaZxJD;}();
auto& fragmentShadingRateWithConservativeRasterization_json=json["fragmentShadingRateWithConservativeRasterization"];
[&](){uint32_t temp_zYeuxhm;[&](){temp_zYeuxhm=static_cast<uint32_t>(value_to<int>(fragmentShadingRateWithConservativeRasterization_json));}();member.fragmentShadingRateWithConservativeRasterization=(VkBool32)temp_zYeuxhm;}();
auto& fragmentShadingRateWithFragmentShaderInterlock_json=json["fragmentShadingRateWithFragmentShaderInterlock"];
[&](){uint32_t temp_IHdRaAM;[&](){temp_IHdRaAM=static_cast<uint32_t>(value_to<int>(fragmentShadingRateWithFragmentShaderInterlock_json));}();member.fragmentShadingRateWithFragmentShaderInterlock=(VkBool32)temp_IHdRaAM;}();
auto& fragmentShadingRateWithCustomSampleLocations_json=json["fragmentShadingRateWithCustomSampleLocations"];
[&](){uint32_t temp_cXDcPbZ;[&](){temp_cXDcPbZ=static_cast<uint32_t>(value_to<int>(fragmentShadingRateWithCustomSampleLocations_json));}();member.fragmentShadingRateWithCustomSampleLocations=(VkBool32)temp_cXDcPbZ;}();
auto& fragmentShadingRateStrictMultiplyCombiner_json=json["fragmentShadingRateStrictMultiplyCombiner"];
[&](){uint32_t temp_ebvJOdb;[&](){temp_ebvJOdb=static_cast<uint32_t>(value_to<int>(fragmentShadingRateStrictMultiplyCombiner_json));}();member.fragmentShadingRateStrictMultiplyCombiner=(VkBool32)temp_ebvJOdb;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentShadingRateKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& sampleCounts_json=json["sampleCounts"];
[&](){[&](){[&](){sampleCounts_json=member.sampleCounts;}();}();}();
auto& fragmentSize_json=json["fragmentSize"];
[&](){
            auto& temp=fragmentSize_json.emplace_object();
            return serialize_struct(temp, member.fragmentSize);
            }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentShadingRateKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& sampleCounts_json=json["sampleCounts"];
[&](){[&](){int temp_LcBJWgU;[&](){temp_LcBJWgU=static_cast<int>(value_to<int>(sampleCounts_json));}();member.sampleCounts=(VkSampleCountFlags)temp_LcBJWgU;}();}();
auto& fragmentSize_json=json["fragmentSize"];
[&](){
            auto& temp=fragmentSize_json.as_object();
            deserialize_struct(temp,member.fragmentSize);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderTerminateInvocationFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderTerminateInvocation_json=json["shaderTerminateInvocation"];
[&](){[&](){shaderTerminateInvocation_json=member.shaderTerminateInvocation;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderTerminateInvocationFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderTerminateInvocation_json=json["shaderTerminateInvocation"];
[&](){uint32_t temp_CsrLjgN;[&](){temp_CsrLjgN=static_cast<uint32_t>(value_to<int>(shaderTerminateInvocation_json));}();member.shaderTerminateInvocation=(VkBool32)temp_CsrLjgN;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentShadingRateEnums_json=json["fragmentShadingRateEnums"];
[&](){[&](){fragmentShadingRateEnums_json=member.fragmentShadingRateEnums;}();}();
auto& supersampleFragmentShadingRates_json=json["supersampleFragmentShadingRates"];
[&](){[&](){supersampleFragmentShadingRates_json=member.supersampleFragmentShadingRates;}();}();
auto& noInvocationFragmentShadingRates_json=json["noInvocationFragmentShadingRates"];
[&](){[&](){noInvocationFragmentShadingRates_json=member.noInvocationFragmentShadingRates;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& fragmentShadingRateEnums_json=json["fragmentShadingRateEnums"];
[&](){uint32_t temp_eSutHns;[&](){temp_eSutHns=static_cast<uint32_t>(value_to<int>(fragmentShadingRateEnums_json));}();member.fragmentShadingRateEnums=(VkBool32)temp_eSutHns;}();
auto& supersampleFragmentShadingRates_json=json["supersampleFragmentShadingRates"];
[&](){uint32_t temp_RYUhkhp;[&](){temp_RYUhkhp=static_cast<uint32_t>(value_to<int>(supersampleFragmentShadingRates_json));}();member.supersampleFragmentShadingRates=(VkBool32)temp_RYUhkhp;}();
auto& noInvocationFragmentShadingRates_json=json["noInvocationFragmentShadingRates"];
[&](){uint32_t temp_uWNAJJW;[&](){temp_uWNAJJW=static_cast<uint32_t>(value_to<int>(noInvocationFragmentShadingRates_json));}();member.noInvocationFragmentShadingRates=(VkBool32)temp_uWNAJJW;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxFragmentShadingRateInvocationCount_json=json["maxFragmentShadingRateInvocationCount"];
[&](){[&](){[&](){maxFragmentShadingRateInvocationCount_json=member.maxFragmentShadingRateInvocationCount;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxFragmentShadingRateInvocationCount_json=json["maxFragmentShadingRateInvocationCount"];
[&](){[&](){int temp_Twykcqd;[&](){temp_Twykcqd=static_cast<int>(value_to<int>(maxFragmentShadingRateInvocationCount_json));}();member.maxFragmentShadingRateInvocationCount=(VkSampleCountFlagBits)temp_Twykcqd;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineFragmentShadingRateEnumStateCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shadingRateType_json=json["shadingRateType"];
[&](){[&](){[&](){shadingRateType_json=member.shadingRateType;}();}();}();
auto& shadingRate_json=json["shadingRate"];
[&](){[&](){[&](){shadingRate_json=member.shadingRate;}();}();}();
auto& combinerOps_json=json["combinerOps"];
[&](){combinerOps_json=boost::json::array(2);
        auto& arr_XZmmBZZ=combinerOps_json.as_array();
        for(int oRFNtpI=0; oRFNtpI < 2; oRFNtpI++){
            [&](){[&](){[&](){arr_XZmmBZZ[oRFNtpI]=member.combinerOps[oRFNtpI];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineFragmentShadingRateEnumStateCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& shadingRateType_json=json["shadingRateType"];
[&](){[&](){int temp_ifNgjNF;[&](){temp_ifNgjNF=static_cast<int>(value_to<int>(shadingRateType_json));}();member.shadingRateType=(VkFragmentShadingRateTypeNV)temp_ifNgjNF;}();}();
auto& shadingRate_json=json["shadingRate"];
[&](){[&](){int temp_ZKwTAsp;[&](){temp_ZKwTAsp=static_cast<int>(value_to<int>(shadingRate_json));}();member.shadingRate=(VkFragmentShadingRateNV)temp_ZKwTAsp;}();}();
auto& combinerOps_json=json["combinerOps"];
[&](){
        auto& arr_XZmmBZZ=combinerOps_json.as_array();
        for(int oRFNtpI=0; oRFNtpI < 2; oRFNtpI++){
            [&](){[&](){int temp_HyVITSp;[&](){temp_HyVITSp=static_cast<int>(value_to<int>(arr_XZmmBZZ[oRFNtpI]));}();member.combinerOps[oRFNtpI]=(VkFragmentShadingRateCombinerOpKHR)temp_HyVITSp;}();}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureBuildSizesInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& accelerationStructureSize_json=json["accelerationStructureSize"];
[&](){[&](){accelerationStructureSize_json=member.accelerationStructureSize;}();}();
auto& updateScratchSize_json=json["updateScratchSize"];
[&](){[&](){updateScratchSize_json=member.updateScratchSize;}();}();
auto& buildScratchSize_json=json["buildScratchSize"];
[&](){[&](){buildScratchSize_json=member.buildScratchSize;}();}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureBuildSizesInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& accelerationStructureSize_json=json["accelerationStructureSize"];
[&](){uint64_t temp_ItDUZcN;[&](){temp_ItDUZcN=static_cast<uint64_t>(value_to<int>(accelerationStructureSize_json));}();member.accelerationStructureSize=(VkDeviceSize)temp_ItDUZcN;}();
auto& updateScratchSize_json=json["updateScratchSize"];
[&](){uint64_t temp_CwnTZyf;[&](){temp_CwnTZyf=static_cast<uint64_t>(value_to<int>(updateScratchSize_json));}();member.updateScratchSize=(VkDeviceSize)temp_CwnTZyf;}();
auto& buildScratchSize_json=json["buildScratchSize"];
[&](){uint64_t temp_MMSKrnN;[&](){temp_MMSKrnN=static_cast<uint64_t>(value_to<int>(buildScratchSize_json));}();member.buildScratchSize=(VkDeviceSize)temp_MMSKrnN;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& image2DViewOf3D_json=json["image2DViewOf3D"];
[&](){[&](){image2DViewOf3D_json=member.image2DViewOf3D;}();}();
auto& sampler2DViewOf3D_json=json["sampler2DViewOf3D"];
[&](){[&](){sampler2DViewOf3D_json=member.sampler2DViewOf3D;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& image2DViewOf3D_json=json["image2DViewOf3D"];
[&](){uint32_t temp_eRQxbir;[&](){temp_eRQxbir=static_cast<uint32_t>(value_to<int>(image2DViewOf3D_json));}();member.image2DViewOf3D=(VkBool32)temp_eRQxbir;}();
auto& sampler2DViewOf3D_json=json["sampler2DViewOf3D"];
[&](){uint32_t temp_HEfUrXR;[&](){temp_HEfUrXR=static_cast<uint32_t>(value_to<int>(sampler2DViewOf3D_json));}();member.sampler2DViewOf3D=(VkBool32)temp_HEfUrXR;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageSlicedViewOf3D_json=json["imageSlicedViewOf3D"];
[&](){[&](){imageSlicedViewOf3D_json=member.imageSlicedViewOf3D;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& imageSlicedViewOf3D_json=json["imageSlicedViewOf3D"];
[&](){uint32_t temp_PZftQZa;[&](){temp_PZftQZa=static_cast<uint32_t>(value_to<int>(imageSlicedViewOf3D_json));}();member.imageSlicedViewOf3D=(VkBool32)temp_PZftQZa;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& attachmentFeedbackLoopDynamicState_json=json["attachmentFeedbackLoopDynamicState"];
[&](){[&](){attachmentFeedbackLoopDynamicState_json=member.attachmentFeedbackLoopDynamicState;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& attachmentFeedbackLoopDynamicState_json=json["attachmentFeedbackLoopDynamicState"];
[&](){uint32_t temp_HuoFEQt;[&](){temp_HuoFEQt=static_cast<uint32_t>(value_to<int>(attachmentFeedbackLoopDynamicState_json));}();member.attachmentFeedbackLoopDynamicState=(VkBool32)temp_HuoFEQt;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& mutableDescriptorType_json=json["mutableDescriptorType"];
[&](){[&](){mutableDescriptorType_json=member.mutableDescriptorType;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& mutableDescriptorType_json=json["mutableDescriptorType"];
[&](){uint32_t temp_TrqCPiU;[&](){temp_TrqCPiU=static_cast<uint32_t>(value_to<int>(mutableDescriptorType_json));}();member.mutableDescriptorType=(VkBool32)temp_TrqCPiU;}();
}

    void serialize_struct(boost::json::object& json, const VkMutableDescriptorTypeListEXT& member){
        
    
auto& descriptorTypeCount_json=json["descriptorTypeCount"];
[&](){descriptorTypeCount_json=member.descriptorTypeCount;}();
auto& pDescriptorTypes_json=json["pDescriptorTypes"];
[&](){
            if (member.pDescriptorTypes==NULL){
                pDescriptorTypes_json=boost::json::array();
            return; }pDescriptorTypes_json=boost::json::array(member.descriptorTypeCount);
        auto& arr_MqlUYrq=pDescriptorTypes_json.as_array();
        for(int nsUPqrI=0; nsUPqrI < member.descriptorTypeCount; nsUPqrI++){
            [&](){[&](){[&](){arr_MqlUYrq[nsUPqrI]=member.pDescriptorTypes[nsUPqrI];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkMutableDescriptorTypeListEXT& member){
auto& descriptorTypeCount_json=json["descriptorTypeCount"];
[&](){member.descriptorTypeCount=static_cast<uint32_t>(value_to<int>(descriptorTypeCount_json));}();
auto& pDescriptorTypes_json=json["pDescriptorTypes"];
[&](){ VkDescriptorType* temp_DXHzrHk;;[&](){
            if (pDescriptorTypes_json.as_array().size()==0){
                temp_DXHzrHk=NULL;
            return; }temp_DXHzrHk=(VkDescriptorType*)malloc(member.descriptorTypeCount*sizeof(VkDescriptorType));
        auto& arr_wcZQLgN=pDescriptorTypes_json.as_array();
        for(int nElHLly=0; nElHLly < member.descriptorTypeCount; nElHLly++){
            [&](){[&](){int temp_dPanhJb;[&](){temp_dPanhJb=static_cast<int>(value_to<int>(arr_wcZQLgN[nElHLly]));}();temp_DXHzrHk[nElHLly]=(VkDescriptorType)temp_dPanhJb;}();}();
        }
        }();member.pDescriptorTypes=temp_DXHzrHk;}();
}

    void serialize_struct(boost::json::object& json, const VkMutableDescriptorTypeCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& mutableDescriptorTypeListCount_json=json["mutableDescriptorTypeListCount"];
[&](){mutableDescriptorTypeListCount_json=member.mutableDescriptorTypeListCount;}();
auto& pMutableDescriptorTypeLists_json=json["pMutableDescriptorTypeLists"];
[&](){
            if (member.pMutableDescriptorTypeLists==NULL){
                pMutableDescriptorTypeLists_json=boost::json::array();
            return; }pMutableDescriptorTypeLists_json=boost::json::array(member.mutableDescriptorTypeListCount);
        auto& arr_oiOuQBO=pMutableDescriptorTypeLists_json.as_array();
        for(int oOYbFEO=0; oOYbFEO < member.mutableDescriptorTypeListCount; oOYbFEO++){
            [&](){
            auto& temp=arr_oiOuQBO[oOYbFEO].emplace_object();
            return serialize_struct(temp, member.pMutableDescriptorTypeLists[oOYbFEO]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkMutableDescriptorTypeCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& mutableDescriptorTypeListCount_json=json["mutableDescriptorTypeListCount"];
[&](){member.mutableDescriptorTypeListCount=static_cast<uint32_t>(value_to<int>(mutableDescriptorTypeListCount_json));}();
auto& pMutableDescriptorTypeLists_json=json["pMutableDescriptorTypeLists"];
[&](){ VkMutableDescriptorTypeListEXT* temp_AHOkPgY;;[&](){
            if (pMutableDescriptorTypeLists_json.as_array().size()==0){
                temp_AHOkPgY=NULL;
            return; }temp_AHOkPgY=(VkMutableDescriptorTypeListEXT*)malloc(member.mutableDescriptorTypeListCount*sizeof(VkMutableDescriptorTypeListEXT));
        auto& arr_iZvfgle=pMutableDescriptorTypeLists_json.as_array();
        for(int lEFmilH=0; lEFmilH < member.mutableDescriptorTypeListCount; lEFmilH++){
            [&](){
            auto& temp=arr_iZvfgle[lEFmilH].as_object();
            deserialize_struct(temp,temp_AHOkPgY[lEFmilH]);
            }();
        }
        }();member.pMutableDescriptorTypeLists=temp_AHOkPgY;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDepthClipControlFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& depthClipControl_json=json["depthClipControl"];
[&](){[&](){depthClipControl_json=member.depthClipControl;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDepthClipControlFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& depthClipControl_json=json["depthClipControl"];
[&](){uint32_t temp_byeMHez;[&](){temp_byeMHez=static_cast<uint32_t>(value_to<int>(depthClipControl_json));}();member.depthClipControl=(VkBool32)temp_byeMHez;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineViewportDepthClipControlCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& negativeOneToOne_json=json["negativeOneToOne"];
[&](){[&](){negativeOneToOne_json=member.negativeOneToOne;}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineViewportDepthClipControlCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& negativeOneToOne_json=json["negativeOneToOne"];
[&](){uint32_t temp_TYsLuog;[&](){temp_TYsLuog=static_cast<uint32_t>(value_to<int>(negativeOneToOne_json));}();member.negativeOneToOne=(VkBool32)temp_TYsLuog;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& vertexInputDynamicState_json=json["vertexInputDynamicState"];
[&](){[&](){vertexInputDynamicState_json=member.vertexInputDynamicState;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& vertexInputDynamicState_json=json["vertexInputDynamicState"];
[&](){uint32_t temp_PSIcVOX;[&](){temp_PSIcVOX=static_cast<uint32_t>(value_to<int>(vertexInputDynamicState_json));}();member.vertexInputDynamicState=(VkBool32)temp_PSIcVOX;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& externalMemoryRDMA_json=json["externalMemoryRDMA"];
[&](){[&](){externalMemoryRDMA_json=member.externalMemoryRDMA;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceExternalMemoryRDMAFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& externalMemoryRDMA_json=json["externalMemoryRDMA"];
[&](){uint32_t temp_uIwTdIW;[&](){temp_uIwTdIW=static_cast<uint32_t>(value_to<int>(externalMemoryRDMA_json));}();member.externalMemoryRDMA=(VkBool32)temp_uIwTdIW;}();
}

    void serialize_struct(boost::json::object& json, const VkVertexInputBindingDescription2EXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& binding_json=json["binding"];
[&](){binding_json=member.binding;}();
auto& stride_json=json["stride"];
[&](){stride_json=member.stride;}();
auto& inputRate_json=json["inputRate"];
[&](){[&](){[&](){inputRate_json=member.inputRate;}();}();}();
auto& divisor_json=json["divisor"];
[&](){divisor_json=member.divisor;}();
}
void deserialize_struct(boost::json::object& json, VkVertexInputBindingDescription2EXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& binding_json=json["binding"];
[&](){member.binding=static_cast<uint32_t>(value_to<int>(binding_json));}();
auto& stride_json=json["stride"];
[&](){member.stride=static_cast<uint32_t>(value_to<int>(stride_json));}();
auto& inputRate_json=json["inputRate"];
[&](){[&](){int temp_fqvaWJZ;[&](){temp_fqvaWJZ=static_cast<int>(value_to<int>(inputRate_json));}();member.inputRate=(VkVertexInputRate)temp_fqvaWJZ;}();}();
auto& divisor_json=json["divisor"];
[&](){member.divisor=static_cast<uint32_t>(value_to<int>(divisor_json));}();
}

    void serialize_struct(boost::json::object& json, const VkVertexInputAttributeDescription2EXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& location_json=json["location"];
[&](){location_json=member.location;}();
auto& binding_json=json["binding"];
[&](){binding_json=member.binding;}();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& offset_json=json["offset"];
[&](){offset_json=member.offset;}();
}
void deserialize_struct(boost::json::object& json, VkVertexInputAttributeDescription2EXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& location_json=json["location"];
[&](){member.location=static_cast<uint32_t>(value_to<int>(location_json));}();
auto& binding_json=json["binding"];
[&](){member.binding=static_cast<uint32_t>(value_to<int>(binding_json));}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& offset_json=json["offset"];
[&](){member.offset=static_cast<uint32_t>(value_to<int>(offset_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceColorWriteEnableFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& colorWriteEnable_json=json["colorWriteEnable"];
[&](){[&](){colorWriteEnable_json=member.colorWriteEnable;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceColorWriteEnableFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& colorWriteEnable_json=json["colorWriteEnable"];
[&](){uint32_t temp_SVYofeJ;[&](){temp_SVYofeJ=static_cast<uint32_t>(value_to<int>(colorWriteEnable_json));}();member.colorWriteEnable=(VkBool32)temp_SVYofeJ;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineColorWriteCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& attachmentCount_json=json["attachmentCount"];
[&](){attachmentCount_json=member.attachmentCount;}();
auto& pColorWriteEnables_json=json["pColorWriteEnables"];
[&](){
            if (member.pColorWriteEnables==NULL){
                pColorWriteEnables_json=boost::json::array();
            return; }pColorWriteEnables_json=boost::json::array(member.attachmentCount);
        auto& arr_FSxsZtL=pColorWriteEnables_json.as_array();
        for(int aDpiKGH=0; aDpiKGH < member.attachmentCount; aDpiKGH++){
            [&](){[&](){arr_FSxsZtL[aDpiKGH]=member.pColorWriteEnables[aDpiKGH];}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineColorWriteCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& attachmentCount_json=json["attachmentCount"];
[&](){member.attachmentCount=static_cast<uint32_t>(value_to<int>(attachmentCount_json));}();
auto& pColorWriteEnables_json=json["pColorWriteEnables"];
[&](){ VkBool32* temp_eYyjieh;;[&](){
            if (pColorWriteEnables_json.as_array().size()==0){
                temp_eYyjieh=NULL;
            return; }temp_eYyjieh=(VkBool32*)malloc(member.attachmentCount*sizeof(VkBool32));
        auto& arr_UuNkBWN=pColorWriteEnables_json.as_array();
        for(int otJUDfS=0; otJUDfS < member.attachmentCount; otJUDfS++){
            [&](){uint32_t temp_UuNkBWN;[&](){temp_UuNkBWN=static_cast<uint32_t>(value_to<int>(arr_UuNkBWN[otJUDfS]));}();temp_eYyjieh[otJUDfS]=(VkBool32)temp_UuNkBWN;}();
        }
        }();member.pColorWriteEnables=temp_eYyjieh;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryBarrier2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){[&](){srcStageMask_json=member.srcStageMask;}();}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){[&](){srcAccessMask_json=member.srcAccessMask;}();}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){[&](){dstStageMask_json=member.dstStageMask;}();}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){[&](){dstAccessMask_json=member.dstAccessMask;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkMemoryBarrier2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){int temp_dSSxTDX;[&](){temp_dSSxTDX=static_cast<int>(value_to<int>(srcStageMask_json));}();member.srcStageMask=(VkPipelineStageFlags2)temp_dSSxTDX;}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){int temp_wSKCBXj;[&](){temp_wSKCBXj=static_cast<int>(value_to<int>(srcAccessMask_json));}();member.srcAccessMask=(VkAccessFlags2)temp_wSKCBXj;}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){int temp_fLoCVLh;[&](){temp_fLoCVLh=static_cast<int>(value_to<int>(dstStageMask_json));}();member.dstStageMask=(VkPipelineStageFlags2)temp_fLoCVLh;}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){int temp_XipjHkT;[&](){temp_XipjHkT=static_cast<int>(value_to<int>(dstAccessMask_json));}();member.dstAccessMask=(VkAccessFlags2)temp_XipjHkT;}();}();
}

    void serialize_struct(boost::json::object& json, const VkImageMemoryBarrier2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){[&](){srcStageMask_json=member.srcStageMask;}();}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){[&](){srcAccessMask_json=member.srcAccessMask;}();}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){[&](){dstStageMask_json=member.dstStageMask;}();}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){[&](){dstAccessMask_json=member.dstAccessMask;}();}();}();
auto& oldLayout_json=json["oldLayout"];
[&](){[&](){[&](){oldLayout_json=member.oldLayout;}();}();}();
auto& newLayout_json=json["newLayout"];
[&](){[&](){[&](){newLayout_json=member.newLayout;}();}();}();
auto& srcQueueFamilyIndex_json=json["srcQueueFamilyIndex"];
[&](){srcQueueFamilyIndex_json=member.srcQueueFamilyIndex;}();
auto& dstQueueFamilyIndex_json=json["dstQueueFamilyIndex"];
[&](){dstQueueFamilyIndex_json=member.dstQueueFamilyIndex;}();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
auto& subresourceRange_json=json["subresourceRange"];
[&](){
            auto& temp=subresourceRange_json.emplace_object();
            return serialize_struct(temp, member.subresourceRange);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageMemoryBarrier2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){int temp_dSSxTDX;[&](){temp_dSSxTDX=static_cast<int>(value_to<int>(srcStageMask_json));}();member.srcStageMask=(VkPipelineStageFlags2)temp_dSSxTDX;}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){int temp_wSKCBXj;[&](){temp_wSKCBXj=static_cast<int>(value_to<int>(srcAccessMask_json));}();member.srcAccessMask=(VkAccessFlags2)temp_wSKCBXj;}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){int temp_fLoCVLh;[&](){temp_fLoCVLh=static_cast<int>(value_to<int>(dstStageMask_json));}();member.dstStageMask=(VkPipelineStageFlags2)temp_fLoCVLh;}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){int temp_XipjHkT;[&](){temp_XipjHkT=static_cast<int>(value_to<int>(dstAccessMask_json));}();member.dstAccessMask=(VkAccessFlags2)temp_XipjHkT;}();}();
auto& oldLayout_json=json["oldLayout"];
[&](){[&](){int temp_IxSclWO;[&](){temp_IxSclWO=static_cast<int>(value_to<int>(oldLayout_json));}();member.oldLayout=(VkImageLayout)temp_IxSclWO;}();}();
auto& newLayout_json=json["newLayout"];
[&](){[&](){int temp_oJsXEmm;[&](){temp_oJsXEmm=static_cast<int>(value_to<int>(newLayout_json));}();member.newLayout=(VkImageLayout)temp_oJsXEmm;}();}();
auto& srcQueueFamilyIndex_json=json["srcQueueFamilyIndex"];
[&](){member.srcQueueFamilyIndex=static_cast<uint32_t>(value_to<int>(srcQueueFamilyIndex_json));}();
auto& dstQueueFamilyIndex_json=json["dstQueueFamilyIndex"];
[&](){member.dstQueueFamilyIndex=static_cast<uint32_t>(value_to<int>(dstQueueFamilyIndex_json));}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
auto& subresourceRange_json=json["subresourceRange"];
[&](){
            auto& temp=subresourceRange_json.as_object();
            deserialize_struct(temp,member.subresourceRange);
            }();
}

    void serialize_struct(boost::json::object& json, const VkBufferMemoryBarrier2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){[&](){srcStageMask_json=member.srcStageMask;}();}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){[&](){srcAccessMask_json=member.srcAccessMask;}();}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){[&](){dstStageMask_json=member.dstStageMask;}();}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){[&](){dstAccessMask_json=member.dstAccessMask;}();}();}();
auto& srcQueueFamilyIndex_json=json["srcQueueFamilyIndex"];
[&](){srcQueueFamilyIndex_json=member.srcQueueFamilyIndex;}();
auto& dstQueueFamilyIndex_json=json["dstQueueFamilyIndex"];
[&](){dstQueueFamilyIndex_json=member.dstQueueFamilyIndex;}();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkBufferMemoryBarrier2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& srcStageMask_json=json["srcStageMask"];
[&](){[&](){int temp_dSSxTDX;[&](){temp_dSSxTDX=static_cast<int>(value_to<int>(srcStageMask_json));}();member.srcStageMask=(VkPipelineStageFlags2)temp_dSSxTDX;}();}();
auto& srcAccessMask_json=json["srcAccessMask"];
[&](){[&](){int temp_wSKCBXj;[&](){temp_wSKCBXj=static_cast<int>(value_to<int>(srcAccessMask_json));}();member.srcAccessMask=(VkAccessFlags2)temp_wSKCBXj;}();}();
auto& dstStageMask_json=json["dstStageMask"];
[&](){[&](){int temp_fLoCVLh;[&](){temp_fLoCVLh=static_cast<int>(value_to<int>(dstStageMask_json));}();member.dstStageMask=(VkPipelineStageFlags2)temp_fLoCVLh;}();}();
auto& dstAccessMask_json=json["dstAccessMask"];
[&](){[&](){int temp_XipjHkT;[&](){temp_XipjHkT=static_cast<int>(value_to<int>(dstAccessMask_json));}();member.dstAccessMask=(VkAccessFlags2)temp_XipjHkT;}();}();
auto& srcQueueFamilyIndex_json=json["srcQueueFamilyIndex"];
[&](){member.srcQueueFamilyIndex=static_cast<uint32_t>(value_to<int>(srcQueueFamilyIndex_json));}();
auto& dstQueueFamilyIndex_json=json["dstQueueFamilyIndex"];
[&](){member.dstQueueFamilyIndex=static_cast<uint32_t>(value_to<int>(dstQueueFamilyIndex_json));}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkDependencyInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dependencyFlags_json=json["dependencyFlags"];
[&](){[&](){[&](){dependencyFlags_json=member.dependencyFlags;}();}();}();
auto& memoryBarrierCount_json=json["memoryBarrierCount"];
[&](){memoryBarrierCount_json=member.memoryBarrierCount;}();
auto& pMemoryBarriers_json=json["pMemoryBarriers"];
[&](){
            if (member.pMemoryBarriers==NULL){
                pMemoryBarriers_json=boost::json::array();
            return; }pMemoryBarriers_json=boost::json::array(member.memoryBarrierCount);
        auto& arr_uYqXDjV=pMemoryBarriers_json.as_array();
        for(int EtCwghm=0; EtCwghm < member.memoryBarrierCount; EtCwghm++){
            [&](){
            auto& temp=arr_uYqXDjV[EtCwghm].emplace_object();
            return serialize_struct(temp, member.pMemoryBarriers[EtCwghm]);
            }();
        }
        }();
auto& bufferMemoryBarrierCount_json=json["bufferMemoryBarrierCount"];
[&](){bufferMemoryBarrierCount_json=member.bufferMemoryBarrierCount;}();
auto& pBufferMemoryBarriers_json=json["pBufferMemoryBarriers"];
[&](){
            if (member.pBufferMemoryBarriers==NULL){
                pBufferMemoryBarriers_json=boost::json::array();
            return; }pBufferMemoryBarriers_json=boost::json::array(member.bufferMemoryBarrierCount);
        auto& arr_lZorhiU=pBufferMemoryBarriers_json.as_array();
        for(int PpUXYmj=0; PpUXYmj < member.bufferMemoryBarrierCount; PpUXYmj++){
            [&](){
            auto& temp=arr_lZorhiU[PpUXYmj].emplace_object();
            return serialize_struct(temp, member.pBufferMemoryBarriers[PpUXYmj]);
            }();
        }
        }();
auto& imageMemoryBarrierCount_json=json["imageMemoryBarrierCount"];
[&](){imageMemoryBarrierCount_json=member.imageMemoryBarrierCount;}();
auto& pImageMemoryBarriers_json=json["pImageMemoryBarriers"];
[&](){
            if (member.pImageMemoryBarriers==NULL){
                pImageMemoryBarriers_json=boost::json::array();
            return; }pImageMemoryBarriers_json=boost::json::array(member.imageMemoryBarrierCount);
        auto& arr_ELVGTei=pImageMemoryBarriers_json.as_array();
        for(int jZqCPSq=0; jZqCPSq < member.imageMemoryBarrierCount; jZqCPSq++){
            [&](){
            auto& temp=arr_ELVGTei[jZqCPSq].emplace_object();
            return serialize_struct(temp, member.pImageMemoryBarriers[jZqCPSq]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDependencyInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& dependencyFlags_json=json["dependencyFlags"];
[&](){[&](){int temp_BaltLwx;[&](){temp_BaltLwx=static_cast<int>(value_to<int>(dependencyFlags_json));}();member.dependencyFlags=(VkDependencyFlags)temp_BaltLwx;}();}();
auto& memoryBarrierCount_json=json["memoryBarrierCount"];
[&](){member.memoryBarrierCount=static_cast<uint32_t>(value_to<int>(memoryBarrierCount_json));}();
auto& pMemoryBarriers_json=json["pMemoryBarriers"];
[&](){ VkMemoryBarrier2* temp_RnoJYiN;;[&](){
            if (pMemoryBarriers_json.as_array().size()==0){
                temp_RnoJYiN=NULL;
            return; }temp_RnoJYiN=(VkMemoryBarrier2*)malloc(member.memoryBarrierCount*sizeof(VkMemoryBarrier2));
        auto& arr_IqcWIhI=pMemoryBarriers_json.as_array();
        for(int pEQCjNY=0; pEQCjNY < member.memoryBarrierCount; pEQCjNY++){
            [&](){
            auto& temp=arr_IqcWIhI[pEQCjNY].as_object();
            deserialize_struct(temp,temp_RnoJYiN[pEQCjNY]);
            }();
        }
        }();member.pMemoryBarriers=temp_RnoJYiN;}();
auto& bufferMemoryBarrierCount_json=json["bufferMemoryBarrierCount"];
[&](){member.bufferMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(bufferMemoryBarrierCount_json));}();
auto& pBufferMemoryBarriers_json=json["pBufferMemoryBarriers"];
[&](){ VkBufferMemoryBarrier2* temp_DQVVaQn;;[&](){
            if (pBufferMemoryBarriers_json.as_array().size()==0){
                temp_DQVVaQn=NULL;
            return; }temp_DQVVaQn=(VkBufferMemoryBarrier2*)malloc(member.bufferMemoryBarrierCount*sizeof(VkBufferMemoryBarrier2));
        auto& arr_yZfXpmL=pBufferMemoryBarriers_json.as_array();
        for(int nGqZpSC=0; nGqZpSC < member.bufferMemoryBarrierCount; nGqZpSC++){
            [&](){
            auto& temp=arr_yZfXpmL[nGqZpSC].as_object();
            deserialize_struct(temp,temp_DQVVaQn[nGqZpSC]);
            }();
        }
        }();member.pBufferMemoryBarriers=temp_DQVVaQn;}();
auto& imageMemoryBarrierCount_json=json["imageMemoryBarrierCount"];
[&](){member.imageMemoryBarrierCount=static_cast<uint32_t>(value_to<int>(imageMemoryBarrierCount_json));}();
auto& pImageMemoryBarriers_json=json["pImageMemoryBarriers"];
[&](){ VkImageMemoryBarrier2* temp_xMmRWhg;;[&](){
            if (pImageMemoryBarriers_json.as_array().size()==0){
                temp_xMmRWhg=NULL;
            return; }temp_xMmRWhg=(VkImageMemoryBarrier2*)malloc(member.imageMemoryBarrierCount*sizeof(VkImageMemoryBarrier2));
        auto& arr_pKDZnHs=pImageMemoryBarriers_json.as_array();
        for(int qViCZNC=0; qViCZNC < member.imageMemoryBarrierCount; qViCZNC++){
            [&](){
            auto& temp=arr_pKDZnHs[qViCZNC].as_object();
            deserialize_struct(temp,temp_xMmRWhg[qViCZNC]);
            }();
        }
        }();member.pImageMemoryBarriers=temp_xMmRWhg;}();
}

    void serialize_struct(boost::json::object& json, const VkSemaphoreSubmitInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& semaphore_json=json["semaphore"];
[&](){serialize_VkSemaphore(semaphore_json,member.semaphore);}();
auto& value_json=json["value"];
[&](){value_json=member.value;}();
auto& stageMask_json=json["stageMask"];
[&](){[&](){[&](){stageMask_json=member.stageMask;}();}();}();
auto& deviceIndex_json=json["deviceIndex"];
[&](){deviceIndex_json=member.deviceIndex;}();
}
void deserialize_struct(boost::json::object& json, VkSemaphoreSubmitInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& semaphore_json=json["semaphore"];
[&](){deserialize_VkSemaphore(semaphore_json, member.semaphore);}();
auto& value_json=json["value"];
[&](){member.value=static_cast<uint64_t>(value_to<int>(value_json));}();
auto& stageMask_json=json["stageMask"];
[&](){[&](){int temp_UQPTMYx;[&](){temp_UQPTMYx=static_cast<int>(value_to<int>(stageMask_json));}();member.stageMask=(VkPipelineStageFlags2)temp_UQPTMYx;}();}();
auto& deviceIndex_json=json["deviceIndex"];
[&](){member.deviceIndex=static_cast<uint32_t>(value_to<int>(deviceIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkCommandBufferSubmitInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& commandBuffer_json=json["commandBuffer"];
[&](){serialize_VkCommandBuffer(commandBuffer_json,member.commandBuffer);}();
auto& deviceMask_json=json["deviceMask"];
[&](){deviceMask_json=member.deviceMask;}();
}
void deserialize_struct(boost::json::object& json, VkCommandBufferSubmitInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& commandBuffer_json=json["commandBuffer"];
[&](){deserialize_VkCommandBuffer(commandBuffer_json, member.commandBuffer);}();
auto& deviceMask_json=json["deviceMask"];
[&](){member.deviceMask=static_cast<uint32_t>(value_to<int>(deviceMask_json));}();
}

    void serialize_struct(boost::json::object& json, const VkSubmitInfo2& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& waitSemaphoreInfoCount_json=json["waitSemaphoreInfoCount"];
[&](){waitSemaphoreInfoCount_json=member.waitSemaphoreInfoCount;}();
auto& pWaitSemaphoreInfos_json=json["pWaitSemaphoreInfos"];
[&](){
            if (member.pWaitSemaphoreInfos==NULL){
                pWaitSemaphoreInfos_json=boost::json::array();
            return; }pWaitSemaphoreInfos_json=boost::json::array(member.waitSemaphoreInfoCount);
        auto& arr_GVgDjlB=pWaitSemaphoreInfos_json.as_array();
        for(int LVzoqvo=0; LVzoqvo < member.waitSemaphoreInfoCount; LVzoqvo++){
            [&](){
            auto& temp=arr_GVgDjlB[LVzoqvo].emplace_object();
            return serialize_struct(temp, member.pWaitSemaphoreInfos[LVzoqvo]);
            }();
        }
        }();
auto& commandBufferInfoCount_json=json["commandBufferInfoCount"];
[&](){commandBufferInfoCount_json=member.commandBufferInfoCount;}();
auto& pCommandBufferInfos_json=json["pCommandBufferInfos"];
[&](){
            if (member.pCommandBufferInfos==NULL){
                pCommandBufferInfos_json=boost::json::array();
            return; }pCommandBufferInfos_json=boost::json::array(member.commandBufferInfoCount);
        auto& arr_fhIgJVd=pCommandBufferInfos_json.as_array();
        for(int prIDUIM=0; prIDUIM < member.commandBufferInfoCount; prIDUIM++){
            [&](){
            auto& temp=arr_fhIgJVd[prIDUIM].emplace_object();
            return serialize_struct(temp, member.pCommandBufferInfos[prIDUIM]);
            }();
        }
        }();
auto& signalSemaphoreInfoCount_json=json["signalSemaphoreInfoCount"];
[&](){signalSemaphoreInfoCount_json=member.signalSemaphoreInfoCount;}();
auto& pSignalSemaphoreInfos_json=json["pSignalSemaphoreInfos"];
[&](){
            if (member.pSignalSemaphoreInfos==NULL){
                pSignalSemaphoreInfos_json=boost::json::array();
            return; }pSignalSemaphoreInfos_json=boost::json::array(member.signalSemaphoreInfoCount);
        auto& arr_WqkNqnQ=pSignalSemaphoreInfos_json.as_array();
        for(int UBaqqLs=0; UBaqqLs < member.signalSemaphoreInfoCount; UBaqqLs++){
            [&](){
            auto& temp=arr_WqkNqnQ[UBaqqLs].emplace_object();
            return serialize_struct(temp, member.pSignalSemaphoreInfos[UBaqqLs]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSubmitInfo2& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_wDSTUYe;[&](){temp_wDSTUYe=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkSubmitFlags)temp_wDSTUYe;}();}();
auto& waitSemaphoreInfoCount_json=json["waitSemaphoreInfoCount"];
[&](){member.waitSemaphoreInfoCount=static_cast<uint32_t>(value_to<int>(waitSemaphoreInfoCount_json));}();
auto& pWaitSemaphoreInfos_json=json["pWaitSemaphoreInfos"];
[&](){ VkSemaphoreSubmitInfo* temp_QtXweUd;;[&](){
            if (pWaitSemaphoreInfos_json.as_array().size()==0){
                temp_QtXweUd=NULL;
            return; }temp_QtXweUd=(VkSemaphoreSubmitInfo*)malloc(member.waitSemaphoreInfoCount*sizeof(VkSemaphoreSubmitInfo));
        auto& arr_DdsFBJx=pWaitSemaphoreInfos_json.as_array();
        for(int oRIYeCQ=0; oRIYeCQ < member.waitSemaphoreInfoCount; oRIYeCQ++){
            [&](){
            auto& temp=arr_DdsFBJx[oRIYeCQ].as_object();
            deserialize_struct(temp,temp_QtXweUd[oRIYeCQ]);
            }();
        }
        }();member.pWaitSemaphoreInfos=temp_QtXweUd;}();
auto& commandBufferInfoCount_json=json["commandBufferInfoCount"];
[&](){member.commandBufferInfoCount=static_cast<uint32_t>(value_to<int>(commandBufferInfoCount_json));}();
auto& pCommandBufferInfos_json=json["pCommandBufferInfos"];
[&](){ VkCommandBufferSubmitInfo* temp_fUKqNTT;;[&](){
            if (pCommandBufferInfos_json.as_array().size()==0){
                temp_fUKqNTT=NULL;
            return; }temp_fUKqNTT=(VkCommandBufferSubmitInfo*)malloc(member.commandBufferInfoCount*sizeof(VkCommandBufferSubmitInfo));
        auto& arr_FPlgGOY=pCommandBufferInfos_json.as_array();
        for(int voSxkwU=0; voSxkwU < member.commandBufferInfoCount; voSxkwU++){
            [&](){
            auto& temp=arr_FPlgGOY[voSxkwU].as_object();
            deserialize_struct(temp,temp_fUKqNTT[voSxkwU]);
            }();
        }
        }();member.pCommandBufferInfos=temp_fUKqNTT;}();
auto& signalSemaphoreInfoCount_json=json["signalSemaphoreInfoCount"];
[&](){member.signalSemaphoreInfoCount=static_cast<uint32_t>(value_to<int>(signalSemaphoreInfoCount_json));}();
auto& pSignalSemaphoreInfos_json=json["pSignalSemaphoreInfos"];
[&](){ VkSemaphoreSubmitInfo* temp_jUwmpLy;;[&](){
            if (pSignalSemaphoreInfos_json.as_array().size()==0){
                temp_jUwmpLy=NULL;
            return; }temp_jUwmpLy=(VkSemaphoreSubmitInfo*)malloc(member.signalSemaphoreInfoCount*sizeof(VkSemaphoreSubmitInfo));
        auto& arr_cPjEKmF=pSignalSemaphoreInfos_json.as_array();
        for(int EOcUUOu=0; EOcUUOu < member.signalSemaphoreInfoCount; EOcUUOu++){
            [&](){
            auto& temp=arr_cPjEKmF[EOcUUOu].as_object();
            deserialize_struct(temp,temp_jUwmpLy[EOcUUOu]);
            }();
        }
        }();member.pSignalSemaphoreInfos=temp_jUwmpLy;}();
}

    void serialize_struct(boost::json::object& json, const VkQueueFamilyCheckpointProperties2NV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& checkpointExecutionStageMask_json=json["checkpointExecutionStageMask"];
[&](){[&](){[&](){checkpointExecutionStageMask_json=member.checkpointExecutionStageMask;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkQueueFamilyCheckpointProperties2NV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& checkpointExecutionStageMask_json=json["checkpointExecutionStageMask"];
[&](){[&](){int temp_SFpXYYD;[&](){temp_SFpXYYD=static_cast<int>(value_to<int>(checkpointExecutionStageMask_json));}();member.checkpointExecutionStageMask=(VkPipelineStageFlags2)temp_SFpXYYD;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCheckpointData2NV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stage_json=json["stage"];
[&](){[&](){[&](){stage_json=member.stage;}();}();}();
auto& pCheckpointMarker_json=json["pCheckpointMarker"];
[&](){
            if (member.pCheckpointMarker==NULL){
                pCheckpointMarker_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pCheckpointMarker))==NULL){
                pCheckpointMarker_json=boost::json::array();
            return; }pCheckpointMarker_json=boost::json::array(strlen(((char*)(member.pCheckpointMarker)))+1);
        auto& arr_camgBwN=pCheckpointMarker_json.as_array();
        for(int RrhLchW=0; RrhLchW < strlen(((char*)(member.pCheckpointMarker)))+1; RrhLchW++){
            [&](){arr_camgBwN[RrhLchW]=((char*)(member.pCheckpointMarker))[RrhLchW];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkCheckpointData2NV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& stage_json=json["stage"];
[&](){[&](){int temp_CuhegcX;[&](){temp_CuhegcX=static_cast<int>(value_to<int>(stage_json));}();member.stage=(VkPipelineStageFlags2)temp_CuhegcX;}();}();
auto& pCheckpointMarker_json=json["pCheckpointMarker"];
[&](){
            if (pCheckpointMarker_json.as_array().size()==0){
                member.pCheckpointMarker=NULL;
            return; }char* temp_YQxDhdf;[&](){
            if (pCheckpointMarker_json.as_array().size()==0){
                temp_YQxDhdf=NULL;
            return; }temp_YQxDhdf=(char*)malloc(pCheckpointMarker_json.as_array().size()*sizeof(char));
        auto& arr_camgBwN=pCheckpointMarker_json.as_array();
        for(int RrhLchW=0; RrhLchW < pCheckpointMarker_json.as_array().size(); RrhLchW++){
            [&](){temp_YQxDhdf[RrhLchW]=static_cast<char>(value_to<int>(arr_camgBwN[RrhLchW]));}();
        }
        }();member.pCheckpointMarker=temp_YQxDhdf;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSynchronization2Features& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& synchronization2_json=json["synchronization2"];
[&](){[&](){synchronization2_json=member.synchronization2;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSynchronization2Features& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& synchronization2_json=json["synchronization2"];
[&](){uint32_t temp_zHZoxeW;[&](){temp_zHZoxeW=static_cast<uint32_t>(value_to<int>(synchronization2_json));}();member.synchronization2=(VkBool32)temp_zHZoxeW;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceHostImageCopyFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& hostImageCopy_json=json["hostImageCopy"];
[&](){[&](){hostImageCopy_json=member.hostImageCopy;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceHostImageCopyFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& hostImageCopy_json=json["hostImageCopy"];
[&](){uint32_t temp_IXWdHce;[&](){temp_IXWdHce=static_cast<uint32_t>(value_to<int>(hostImageCopy_json));}();member.hostImageCopy=(VkBool32)temp_IXWdHce;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceHostImageCopyPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& copySrcLayoutCount_json=json["copySrcLayoutCount"];
[&](){copySrcLayoutCount_json=member.copySrcLayoutCount;}();
auto& pCopySrcLayouts_json=json["pCopySrcLayouts"];
[&](){
            if (member.pCopySrcLayouts==NULL){
                pCopySrcLayouts_json=boost::json::array();
            return; }pCopySrcLayouts_json=boost::json::array(member.copySrcLayoutCount);
        auto& arr_gKSOpvu=pCopySrcLayouts_json.as_array();
        for(int sAVlRAU=0; sAVlRAU < member.copySrcLayoutCount; sAVlRAU++){
            [&](){[&](){[&](){arr_gKSOpvu[sAVlRAU]=member.pCopySrcLayouts[sAVlRAU];}();}();}();
        }
        }();
auto& copyDstLayoutCount_json=json["copyDstLayoutCount"];
[&](){copyDstLayoutCount_json=member.copyDstLayoutCount;}();
auto& pCopyDstLayouts_json=json["pCopyDstLayouts"];
[&](){
            if (member.pCopyDstLayouts==NULL){
                pCopyDstLayouts_json=boost::json::array();
            return; }pCopyDstLayouts_json=boost::json::array(member.copyDstLayoutCount);
        auto& arr_dMkwjru=pCopyDstLayouts_json.as_array();
        for(int ugeATbs=0; ugeATbs < member.copyDstLayoutCount; ugeATbs++){
            [&](){[&](){[&](){arr_dMkwjru[ugeATbs]=member.pCopyDstLayouts[ugeATbs];}();}();}();
        }
        }();
auto& optimalTilingLayoutUUID_json=json["optimalTilingLayoutUUID"];
[&](){optimalTilingLayoutUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_TgNNyMA=optimalTilingLayoutUUID_json.as_array();
        for(int uzTazor=0; uzTazor < VK_UUID_SIZE; uzTazor++){
            [&](){arr_TgNNyMA[uzTazor]=member.optimalTilingLayoutUUID[uzTazor];}();
        }
        }();
auto& identicalMemoryTypeRequirements_json=json["identicalMemoryTypeRequirements"];
[&](){[&](){identicalMemoryTypeRequirements_json=member.identicalMemoryTypeRequirements;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceHostImageCopyPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& copySrcLayoutCount_json=json["copySrcLayoutCount"];
[&](){member.copySrcLayoutCount=static_cast<uint32_t>(value_to<int>(copySrcLayoutCount_json));}();
auto& pCopySrcLayouts_json=json["pCopySrcLayouts"];
[&](){
            if (pCopySrcLayouts_json.as_array().size()==0){
                member.pCopySrcLayouts=NULL;
            return; }member.pCopySrcLayouts=(VkImageLayout*)malloc(member.copySrcLayoutCount*sizeof(VkImageLayout));
        auto& arr_gKSOpvu=pCopySrcLayouts_json.as_array();
        for(int sAVlRAU=0; sAVlRAU < member.copySrcLayoutCount; sAVlRAU++){
            [&](){[&](){int temp_cSKQuLP;[&](){temp_cSKQuLP=static_cast<int>(value_to<int>(arr_gKSOpvu[sAVlRAU]));}();member.pCopySrcLayouts[sAVlRAU]=(VkImageLayout)temp_cSKQuLP;}();}();
        }
        }();
auto& copyDstLayoutCount_json=json["copyDstLayoutCount"];
[&](){member.copyDstLayoutCount=static_cast<uint32_t>(value_to<int>(copyDstLayoutCount_json));}();
auto& pCopyDstLayouts_json=json["pCopyDstLayouts"];
[&](){
            if (pCopyDstLayouts_json.as_array().size()==0){
                member.pCopyDstLayouts=NULL;
            return; }member.pCopyDstLayouts=(VkImageLayout*)malloc(member.copyDstLayoutCount*sizeof(VkImageLayout));
        auto& arr_dMkwjru=pCopyDstLayouts_json.as_array();
        for(int ugeATbs=0; ugeATbs < member.copyDstLayoutCount; ugeATbs++){
            [&](){[&](){int temp_XVMlmFS;[&](){temp_XVMlmFS=static_cast<int>(value_to<int>(arr_dMkwjru[ugeATbs]));}();member.pCopyDstLayouts[ugeATbs]=(VkImageLayout)temp_XVMlmFS;}();}();
        }
        }();
auto& optimalTilingLayoutUUID_json=json["optimalTilingLayoutUUID"];
[&](){
        auto& arr_TgNNyMA=optimalTilingLayoutUUID_json.as_array();
        for(int uzTazor=0; uzTazor < VK_UUID_SIZE; uzTazor++){
            [&](){member.optimalTilingLayoutUUID[uzTazor]=static_cast<uint8_t>(value_to<int>(arr_TgNNyMA[uzTazor]));}();
        }
        }();
auto& identicalMemoryTypeRequirements_json=json["identicalMemoryTypeRequirements"];
[&](){uint32_t temp_fMEcoRZ;[&](){temp_fMEcoRZ=static_cast<uint32_t>(value_to<int>(identicalMemoryTypeRequirements_json));}();member.identicalMemoryTypeRequirements=(VkBool32)temp_fMEcoRZ;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryToImageCopyEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pHostPointer_json=json["pHostPointer"];
[&](){
            if (member.pHostPointer==NULL){
                pHostPointer_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pHostPointer))==NULL){
                pHostPointer_json=boost::json::array();
            return; }pHostPointer_json=boost::json::array(strlen(((char*)(member.pHostPointer)))+1);
        auto& arr_kKQnyNo=pHostPointer_json.as_array();
        for(int HbGymWe=0; HbGymWe < strlen(((char*)(member.pHostPointer)))+1; HbGymWe++){
            [&](){arr_kKQnyNo[HbGymWe]=((char*)(member.pHostPointer))[HbGymWe];}();
        }
        }();}();
auto& memoryRowLength_json=json["memoryRowLength"];
[&](){memoryRowLength_json=member.memoryRowLength;}();
auto& memoryImageHeight_json=json["memoryImageHeight"];
[&](){memoryImageHeight_json=member.memoryImageHeight;}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.emplace_object();
            return serialize_struct(temp, member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.emplace_object();
            return serialize_struct(temp, member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.emplace_object();
            return serialize_struct(temp, member.imageExtent);
            }();
}
void deserialize_struct(boost::json::object& json, VkMemoryToImageCopyEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pHostPointer_json=json["pHostPointer"];
[&](){ void* temp_SgjnWPf;;[&](){
            if (pHostPointer_json.as_array().size()==0){
                temp_SgjnWPf=NULL;
            return; }char* temp_oxrKMdu;[&](){
            if (pHostPointer_json.as_array().size()==0){
                temp_oxrKMdu=NULL;
            return; }temp_oxrKMdu=(char*)malloc(pHostPointer_json.as_array().size()*sizeof(char));
        auto& arr_jtlRKsJ=pHostPointer_json.as_array();
        for(int EpJrNfa=0; EpJrNfa < pHostPointer_json.as_array().size(); EpJrNfa++){
            [&](){temp_oxrKMdu[EpJrNfa]=static_cast<char>(value_to<int>(arr_jtlRKsJ[EpJrNfa]));}();
        }
        }();temp_SgjnWPf=temp_oxrKMdu;}();member.pHostPointer=temp_SgjnWPf;}();
auto& memoryRowLength_json=json["memoryRowLength"];
[&](){member.memoryRowLength=static_cast<uint32_t>(value_to<int>(memoryRowLength_json));}();
auto& memoryImageHeight_json=json["memoryImageHeight"];
[&](){member.memoryImageHeight=static_cast<uint32_t>(value_to<int>(memoryImageHeight_json));}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.as_object();
            deserialize_struct(temp,member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.as_object();
            deserialize_struct(temp,member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.as_object();
            deserialize_struct(temp,member.imageExtent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkImageToMemoryCopyEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pHostPointer_json=json["pHostPointer"];
[&](){
            if (member.pHostPointer==NULL){
                pHostPointer_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pHostPointer))==NULL){
                pHostPointer_json=boost::json::array();
            return; }pHostPointer_json=boost::json::array(100000);
        auto& arr_BrxoFPy=pHostPointer_json.as_array();
        for(int ZYyfYiy=0; ZYyfYiy < 100000; ZYyfYiy++){
            [&](){arr_BrxoFPy[ZYyfYiy]=((char*)(member.pHostPointer))[ZYyfYiy];}();
        }
        }();}();
auto& memoryRowLength_json=json["memoryRowLength"];
[&](){memoryRowLength_json=member.memoryRowLength;}();
auto& memoryImageHeight_json=json["memoryImageHeight"];
[&](){memoryImageHeight_json=member.memoryImageHeight;}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.emplace_object();
            return serialize_struct(temp, member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.emplace_object();
            return serialize_struct(temp, member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.emplace_object();
            return serialize_struct(temp, member.imageExtent);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageToMemoryCopyEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pHostPointer_json=json["pHostPointer"];
[&](){
            if (pHostPointer_json.as_array().size()==0){
                member.pHostPointer=NULL;
            return; }char* temp_LWTmyZj;[&](){
            if (pHostPointer_json.as_array().size()==0){
                temp_LWTmyZj=NULL;
            return; }temp_LWTmyZj=(char*)malloc(100000*sizeof(char));
        auto& arr_BrxoFPy=pHostPointer_json.as_array();
        for(int ZYyfYiy=0; ZYyfYiy < 100000; ZYyfYiy++){
            [&](){temp_LWTmyZj[ZYyfYiy]=static_cast<char>(value_to<int>(arr_BrxoFPy[ZYyfYiy]));}();
        }
        }();member.pHostPointer=temp_LWTmyZj;}();
auto& memoryRowLength_json=json["memoryRowLength"];
[&](){member.memoryRowLength=static_cast<uint32_t>(value_to<int>(memoryRowLength_json));}();
auto& memoryImageHeight_json=json["memoryImageHeight"];
[&](){member.memoryImageHeight=static_cast<uint32_t>(value_to<int>(memoryImageHeight_json));}();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.as_object();
            deserialize_struct(temp,member.imageSubresource);
            }();
auto& imageOffset_json=json["imageOffset"];
[&](){
            auto& temp=imageOffset_json.as_object();
            deserialize_struct(temp,member.imageOffset);
            }();
auto& imageExtent_json=json["imageExtent"];
[&](){
            auto& temp=imageExtent_json.as_object();
            deserialize_struct(temp,member.imageExtent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkCopyMemoryToImageInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& dstImage_json=json["dstImage"];
[&](){serialize_VkImage(dstImage_json,member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){[&](){dstImageLayout_json=member.dstImageLayout;}();}();}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_TpKEHMr=pRegions_json.as_array();
        for(int yOYELJC=0; yOYELJC < member.regionCount; yOYELJC++){
            [&](){
            auto& temp=arr_TpKEHMr[yOYELJC].emplace_object();
            return serialize_struct(temp, member.pRegions[yOYELJC]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCopyMemoryToImageInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_QEUVDKw;[&](){temp_QEUVDKw=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkHostImageCopyFlagsEXT)temp_QEUVDKw;}();}();
auto& dstImage_json=json["dstImage"];
[&](){deserialize_VkImage(dstImage_json, member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){int temp_PpCpPSr;[&](){temp_PpCpPSr=static_cast<int>(value_to<int>(dstImageLayout_json));}();member.dstImageLayout=(VkImageLayout)temp_PpCpPSr;}();}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkMemoryToImageCopyEXT* temp_DdzLswa;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_DdzLswa=NULL;
            return; }temp_DdzLswa=(VkMemoryToImageCopyEXT*)malloc(member.regionCount*sizeof(VkMemoryToImageCopyEXT));
        auto& arr_nLmDELu=pRegions_json.as_array();
        for(int PEkQQYO=0; PEkQQYO < member.regionCount; PEkQQYO++){
            [&](){
            auto& temp=arr_nLmDELu[PEkQQYO].as_object();
            deserialize_struct(temp,temp_DdzLswa[PEkQQYO]);
            }();
        }
        }();member.pRegions=temp_DdzLswa;}();
}

    void serialize_struct(boost::json::object& json, const VkCopyImageToMemoryInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& srcImage_json=json["srcImage"];
[&](){serialize_VkImage(srcImage_json,member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){[&](){srcImageLayout_json=member.srcImageLayout;}();}();}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_JnLERzC=pRegions_json.as_array();
        for(int RazZKkE=0; RazZKkE < member.regionCount; RazZKkE++){
            [&](){
            auto& temp=arr_JnLERzC[RazZKkE].emplace_object();
            return serialize_struct(temp, member.pRegions[RazZKkE]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCopyImageToMemoryInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_QEUVDKw;[&](){temp_QEUVDKw=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkHostImageCopyFlagsEXT)temp_QEUVDKw;}();}();
auto& srcImage_json=json["srcImage"];
[&](){deserialize_VkImage(srcImage_json, member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){int temp_OvXTzZQ;[&](){temp_OvXTzZQ=static_cast<int>(value_to<int>(srcImageLayout_json));}();member.srcImageLayout=(VkImageLayout)temp_OvXTzZQ;}();}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkImageToMemoryCopyEXT* temp_HOvyPGP;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_HOvyPGP=NULL;
            return; }temp_HOvyPGP=(VkImageToMemoryCopyEXT*)malloc(member.regionCount*sizeof(VkImageToMemoryCopyEXT));
        auto& arr_OJEycAV=pRegions_json.as_array();
        for(int ryuCzSY=0; ryuCzSY < member.regionCount; ryuCzSY++){
            [&](){
            auto& temp=arr_OJEycAV[ryuCzSY].as_object();
            deserialize_struct(temp,temp_HOvyPGP[ryuCzSY]);
            }();
        }
        }();member.pRegions=temp_HOvyPGP;}();
}

    void serialize_struct(boost::json::object& json, const VkCopyImageToImageInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& srcImage_json=json["srcImage"];
[&](){serialize_VkImage(srcImage_json,member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){[&](){srcImageLayout_json=member.srcImageLayout;}();}();}();
auto& dstImage_json=json["dstImage"];
[&](){serialize_VkImage(dstImage_json,member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){[&](){dstImageLayout_json=member.dstImageLayout;}();}();}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_eEkCrMz=pRegions_json.as_array();
        for(int ldqasfX=0; ldqasfX < member.regionCount; ldqasfX++){
            [&](){
            auto& temp=arr_eEkCrMz[ldqasfX].emplace_object();
            return serialize_struct(temp, member.pRegions[ldqasfX]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCopyImageToImageInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_QEUVDKw;[&](){temp_QEUVDKw=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkHostImageCopyFlagsEXT)temp_QEUVDKw;}();}();
auto& srcImage_json=json["srcImage"];
[&](){deserialize_VkImage(srcImage_json, member.srcImage);}();
auto& srcImageLayout_json=json["srcImageLayout"];
[&](){[&](){int temp_OvXTzZQ;[&](){temp_OvXTzZQ=static_cast<int>(value_to<int>(srcImageLayout_json));}();member.srcImageLayout=(VkImageLayout)temp_OvXTzZQ;}();}();
auto& dstImage_json=json["dstImage"];
[&](){deserialize_VkImage(dstImage_json, member.dstImage);}();
auto& dstImageLayout_json=json["dstImageLayout"];
[&](){[&](){int temp_PpCpPSr;[&](){temp_PpCpPSr=static_cast<int>(value_to<int>(dstImageLayout_json));}();member.dstImageLayout=(VkImageLayout)temp_PpCpPSr;}();}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkImageCopy2* temp_oEdYZas;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_oEdYZas=NULL;
            return; }temp_oEdYZas=(VkImageCopy2*)malloc(member.regionCount*sizeof(VkImageCopy2));
        auto& arr_uCCYJNU=pRegions_json.as_array();
        for(int dqHsbqL=0; dqHsbqL < member.regionCount; dqHsbqL++){
            [&](){
            auto& temp=arr_uCCYJNU[dqHsbqL].as_object();
            deserialize_struct(temp,temp_oEdYZas[dqHsbqL]);
            }();
        }
        }();member.pRegions=temp_oEdYZas;}();
}

    void serialize_struct(boost::json::object& json, const VkHostImageLayoutTransitionInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
auto& oldLayout_json=json["oldLayout"];
[&](){[&](){[&](){oldLayout_json=member.oldLayout;}();}();}();
auto& newLayout_json=json["newLayout"];
[&](){[&](){[&](){newLayout_json=member.newLayout;}();}();}();
auto& subresourceRange_json=json["subresourceRange"];
[&](){
            auto& temp=subresourceRange_json.emplace_object();
            return serialize_struct(temp, member.subresourceRange);
            }();
}
void deserialize_struct(boost::json::object& json, VkHostImageLayoutTransitionInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
auto& oldLayout_json=json["oldLayout"];
[&](){[&](){int temp_IxSclWO;[&](){temp_IxSclWO=static_cast<int>(value_to<int>(oldLayout_json));}();member.oldLayout=(VkImageLayout)temp_IxSclWO;}();}();
auto& newLayout_json=json["newLayout"];
[&](){[&](){int temp_oJsXEmm;[&](){temp_oJsXEmm=static_cast<int>(value_to<int>(newLayout_json));}();member.newLayout=(VkImageLayout)temp_oJsXEmm;}();}();
auto& subresourceRange_json=json["subresourceRange"];
[&](){
            auto& temp=subresourceRange_json.as_object();
            deserialize_struct(temp,member.subresourceRange);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSubresourceHostMemcpySizeEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkSubresourceHostMemcpySizeEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkHostImageCopyDevicePerformanceQueryEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& optimalDeviceAccess_json=json["optimalDeviceAccess"];
[&](){[&](){optimalDeviceAccess_json=member.optimalDeviceAccess;}();}();
auto& identicalMemoryLayout_json=json["identicalMemoryLayout"];
[&](){[&](){identicalMemoryLayout_json=member.identicalMemoryLayout;}();}();
}
void deserialize_struct(boost::json::object& json, VkHostImageCopyDevicePerformanceQueryEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& optimalDeviceAccess_json=json["optimalDeviceAccess"];
[&](){uint32_t temp_wrmDMyN;[&](){temp_wrmDMyN=static_cast<uint32_t>(value_to<int>(optimalDeviceAccess_json));}();member.optimalDeviceAccess=(VkBool32)temp_wrmDMyN;}();
auto& identicalMemoryLayout_json=json["identicalMemoryLayout"];
[&](){uint32_t temp_cbfJemv;[&](){temp_cbfJemv=static_cast<uint32_t>(value_to<int>(identicalMemoryLayout_json));}();member.identicalMemoryLayout=(VkBool32)temp_cbfJemv;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& primitivesGeneratedQuery_json=json["primitivesGeneratedQuery"];
[&](){[&](){primitivesGeneratedQuery_json=member.primitivesGeneratedQuery;}();}();
auto& primitivesGeneratedQueryWithRasterizerDiscard_json=json["primitivesGeneratedQueryWithRasterizerDiscard"];
[&](){[&](){primitivesGeneratedQueryWithRasterizerDiscard_json=member.primitivesGeneratedQueryWithRasterizerDiscard;}();}();
auto& primitivesGeneratedQueryWithNonZeroStreams_json=json["primitivesGeneratedQueryWithNonZeroStreams"];
[&](){[&](){primitivesGeneratedQueryWithNonZeroStreams_json=member.primitivesGeneratedQueryWithNonZeroStreams;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& primitivesGeneratedQuery_json=json["primitivesGeneratedQuery"];
[&](){uint32_t temp_svJXGJw;[&](){temp_svJXGJw=static_cast<uint32_t>(value_to<int>(primitivesGeneratedQuery_json));}();member.primitivesGeneratedQuery=(VkBool32)temp_svJXGJw;}();
auto& primitivesGeneratedQueryWithRasterizerDiscard_json=json["primitivesGeneratedQueryWithRasterizerDiscard"];
[&](){uint32_t temp_phirgPR;[&](){temp_phirgPR=static_cast<uint32_t>(value_to<int>(primitivesGeneratedQueryWithRasterizerDiscard_json));}();member.primitivesGeneratedQueryWithRasterizerDiscard=(VkBool32)temp_phirgPR;}();
auto& primitivesGeneratedQueryWithNonZeroStreams_json=json["primitivesGeneratedQueryWithNonZeroStreams"];
[&](){uint32_t temp_eBIVvRS;[&](){temp_eBIVvRS=static_cast<uint32_t>(value_to<int>(primitivesGeneratedQueryWithNonZeroStreams_json));}();member.primitivesGeneratedQueryWithNonZeroStreams=(VkBool32)temp_eBIVvRS;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceLegacyDitheringFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& legacyDithering_json=json["legacyDithering"];
[&](){[&](){legacyDithering_json=member.legacyDithering;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceLegacyDitheringFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& legacyDithering_json=json["legacyDithering"];
[&](){uint32_t temp_AWwmjLa;[&](){temp_AWwmjLa=static_cast<uint32_t>(value_to<int>(legacyDithering_json));}();member.legacyDithering=(VkBool32)temp_AWwmjLa;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& multisampledRenderToSingleSampled_json=json["multisampledRenderToSingleSampled"];
[&](){[&](){multisampledRenderToSingleSampled_json=member.multisampledRenderToSingleSampled;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& multisampledRenderToSingleSampled_json=json["multisampledRenderToSingleSampled"];
[&](){uint32_t temp_pKKiBNG;[&](){temp_pKKiBNG=static_cast<uint32_t>(value_to<int>(multisampledRenderToSingleSampled_json));}();member.multisampledRenderToSingleSampled=(VkBool32)temp_pKKiBNG;}();
}

    void serialize_struct(boost::json::object& json, const VkSubpassResolvePerformanceQueryEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& optimal_json=json["optimal"];
[&](){[&](){optimal_json=member.optimal;}();}();
}
void deserialize_struct(boost::json::object& json, VkSubpassResolvePerformanceQueryEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& optimal_json=json["optimal"];
[&](){uint32_t temp_gOyLYRA;[&](){temp_gOyLYRA=static_cast<uint32_t>(value_to<int>(optimal_json));}();member.optimal=(VkBool32)temp_gOyLYRA;}();
}

    void serialize_struct(boost::json::object& json, const VkMultisampledRenderToSingleSampledInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& multisampledRenderToSingleSampledEnable_json=json["multisampledRenderToSingleSampledEnable"];
[&](){[&](){multisampledRenderToSingleSampledEnable_json=member.multisampledRenderToSingleSampledEnable;}();}();
auto& rasterizationSamples_json=json["rasterizationSamples"];
[&](){[&](){[&](){rasterizationSamples_json=member.rasterizationSamples;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkMultisampledRenderToSingleSampledInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& multisampledRenderToSingleSampledEnable_json=json["multisampledRenderToSingleSampledEnable"];
[&](){uint32_t temp_UCmSyeF;[&](){temp_UCmSyeF=static_cast<uint32_t>(value_to<int>(multisampledRenderToSingleSampledEnable_json));}();member.multisampledRenderToSingleSampledEnable=(VkBool32)temp_UCmSyeF;}();
auto& rasterizationSamples_json=json["rasterizationSamples"];
[&](){[&](){int temp_cDVWodo;[&](){temp_cDVWodo=static_cast<int>(value_to<int>(rasterizationSamples_json));}();member.rasterizationSamples=(VkSampleCountFlagBits)temp_cDVWodo;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineProtectedAccess_json=json["pipelineProtectedAccess"];
[&](){[&](){pipelineProtectedAccess_json=member.pipelineProtectedAccess;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePipelineProtectedAccessFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pipelineProtectedAccess_json=json["pipelineProtectedAccess"];
[&](){uint32_t temp_iWXmnYm;[&](){temp_iWXmnYm=static_cast<uint32_t>(value_to<int>(pipelineProtectedAccess_json));}();member.pipelineProtectedAccess=(VkBool32)temp_iWXmnYm;}();
}

    void serialize_struct(boost::json::object& json, const VkQueueFamilyVideoPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& videoCodecOperations_json=json["videoCodecOperations"];
[&](){[&](){[&](){videoCodecOperations_json=member.videoCodecOperations;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkQueueFamilyVideoPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& videoCodecOperations_json=json["videoCodecOperations"];
[&](){[&](){int temp_DXAVWVQ;[&](){temp_DXAVWVQ=static_cast<int>(value_to<int>(videoCodecOperations_json));}();member.videoCodecOperations=(VkVideoCodecOperationFlagsKHR)temp_DXAVWVQ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkQueueFamilyQueryResultStatusPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& queryResultStatusSupport_json=json["queryResultStatusSupport"];
[&](){[&](){queryResultStatusSupport_json=member.queryResultStatusSupport;}();}();
}
void deserialize_struct(boost::json::object& json, VkQueueFamilyQueryResultStatusPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& queryResultStatusSupport_json=json["queryResultStatusSupport"];
[&](){uint32_t temp_ALgkmLR;[&](){temp_ALgkmLR=static_cast<uint32_t>(value_to<int>(queryResultStatusSupport_json));}();member.queryResultStatusSupport=(VkBool32)temp_ALgkmLR;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoProfileListInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& profileCount_json=json["profileCount"];
[&](){profileCount_json=member.profileCount;}();
auto& pProfiles_json=json["pProfiles"];
[&](){
            if (member.pProfiles==NULL){
                pProfiles_json=boost::json::array();
            return; }pProfiles_json=boost::json::array(member.profileCount);
        auto& arr_ZBtGgqD=pProfiles_json.as_array();
        for(int qLsWZEU=0; qLsWZEU < member.profileCount; qLsWZEU++){
            [&](){
            auto& temp=arr_ZBtGgqD[qLsWZEU].emplace_object();
            return serialize_struct(temp, member.pProfiles[qLsWZEU]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkVideoProfileListInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& profileCount_json=json["profileCount"];
[&](){member.profileCount=static_cast<uint32_t>(value_to<int>(profileCount_json));}();
auto& pProfiles_json=json["pProfiles"];
[&](){ VkVideoProfileInfoKHR* temp_GfaUqcv;;[&](){
            if (pProfiles_json.as_array().size()==0){
                temp_GfaUqcv=NULL;
            return; }temp_GfaUqcv=(VkVideoProfileInfoKHR*)malloc(member.profileCount*sizeof(VkVideoProfileInfoKHR));
        auto& arr_zZMXblM=pProfiles_json.as_array();
        for(int wxDhulq=0; wxDhulq < member.profileCount; wxDhulq++){
            [&](){
            auto& temp=arr_zZMXblM[wxDhulq].as_object();
            deserialize_struct(temp,temp_GfaUqcv[wxDhulq]);
            }();
        }
        }();member.pProfiles=temp_GfaUqcv;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceVideoFormatInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageUsage_json=json["imageUsage"];
[&](){[&](){[&](){imageUsage_json=member.imageUsage;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceVideoFormatInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& imageUsage_json=json["imageUsage"];
[&](){[&](){int temp_UnfmVYD;[&](){temp_UnfmVYD=static_cast<int>(value_to<int>(imageUsage_json));}();member.imageUsage=(VkImageUsageFlags)temp_UnfmVYD;}();}();
}

    void serialize_struct(boost::json::object& json, const VkVideoFormatPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
auto& componentMapping_json=json["componentMapping"];
[&](){
            auto& temp=componentMapping_json.emplace_object();
            return serialize_struct(temp, member.componentMapping);
            }();
auto& imageCreateFlags_json=json["imageCreateFlags"];
[&](){[&](){[&](){imageCreateFlags_json=member.imageCreateFlags;}();}();}();
auto& imageType_json=json["imageType"];
[&](){[&](){[&](){imageType_json=member.imageType;}();}();}();
auto& imageTiling_json=json["imageTiling"];
[&](){[&](){[&](){imageTiling_json=member.imageTiling;}();}();}();
auto& imageUsageFlags_json=json["imageUsageFlags"];
[&](){[&](){[&](){imageUsageFlags_json=member.imageUsageFlags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkVideoFormatPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
auto& componentMapping_json=json["componentMapping"];
[&](){
            auto& temp=componentMapping_json.as_object();
            deserialize_struct(temp,member.componentMapping);
            }();
auto& imageCreateFlags_json=json["imageCreateFlags"];
[&](){[&](){int temp_tbNLXJc;[&](){temp_tbNLXJc=static_cast<int>(value_to<int>(imageCreateFlags_json));}();member.imageCreateFlags=(VkImageCreateFlags)temp_tbNLXJc;}();}();
auto& imageType_json=json["imageType"];
[&](){[&](){int temp_ORiRUzB;[&](){temp_ORiRUzB=static_cast<int>(value_to<int>(imageType_json));}();member.imageType=(VkImageType)temp_ORiRUzB;}();}();
auto& imageTiling_json=json["imageTiling"];
[&](){[&](){int temp_qLpxOef;[&](){temp_qLpxOef=static_cast<int>(value_to<int>(imageTiling_json));}();member.imageTiling=(VkImageTiling)temp_qLpxOef;}();}();
auto& imageUsageFlags_json=json["imageUsageFlags"];
[&](){[&](){int temp_xMKKDUD;[&](){temp_xMKKDUD=static_cast<int>(value_to<int>(imageUsageFlags_json));}();member.imageUsageFlags=(VkImageUsageFlags)temp_xMKKDUD;}();}();
}

    void serialize_struct(boost::json::object& json, const VkVideoProfileInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& videoCodecOperation_json=json["videoCodecOperation"];
[&](){[&](){[&](){videoCodecOperation_json=member.videoCodecOperation;}();}();}();
auto& chromaSubsampling_json=json["chromaSubsampling"];
[&](){[&](){[&](){chromaSubsampling_json=member.chromaSubsampling;}();}();}();
auto& lumaBitDepth_json=json["lumaBitDepth"];
[&](){[&](){[&](){lumaBitDepth_json=member.lumaBitDepth;}();}();}();
auto& chromaBitDepth_json=json["chromaBitDepth"];
[&](){[&](){[&](){chromaBitDepth_json=member.chromaBitDepth;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkVideoProfileInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& videoCodecOperation_json=json["videoCodecOperation"];
[&](){[&](){int temp_repcpcN;[&](){temp_repcpcN=static_cast<int>(value_to<int>(videoCodecOperation_json));}();member.videoCodecOperation=(VkVideoCodecOperationFlagBitsKHR)temp_repcpcN;}();}();
auto& chromaSubsampling_json=json["chromaSubsampling"];
[&](){[&](){int temp_taMZQyT;[&](){temp_taMZQyT=static_cast<int>(value_to<int>(chromaSubsampling_json));}();member.chromaSubsampling=(VkVideoChromaSubsamplingFlagsKHR)temp_taMZQyT;}();}();
auto& lumaBitDepth_json=json["lumaBitDepth"];
[&](){[&](){int temp_IVzYMDo;[&](){temp_IVzYMDo=static_cast<int>(value_to<int>(lumaBitDepth_json));}();member.lumaBitDepth=(VkVideoComponentBitDepthFlagsKHR)temp_IVzYMDo;}();}();
auto& chromaBitDepth_json=json["chromaBitDepth"];
[&](){[&](){int temp_rFsFDKx;[&](){temp_rFsFDKx=static_cast<int>(value_to<int>(chromaBitDepth_json));}();member.chromaBitDepth=(VkVideoComponentBitDepthFlagsKHR)temp_rFsFDKx;}();}();
}

    void serialize_struct(boost::json::object& json, const VkVideoCapabilitiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& minBitstreamBufferOffsetAlignment_json=json["minBitstreamBufferOffsetAlignment"];
[&](){[&](){minBitstreamBufferOffsetAlignment_json=member.minBitstreamBufferOffsetAlignment;}();}();
auto& minBitstreamBufferSizeAlignment_json=json["minBitstreamBufferSizeAlignment"];
[&](){[&](){minBitstreamBufferSizeAlignment_json=member.minBitstreamBufferSizeAlignment;}();}();
auto& pictureAccessGranularity_json=json["pictureAccessGranularity"];
[&](){
            auto& temp=pictureAccessGranularity_json.emplace_object();
            return serialize_struct(temp, member.pictureAccessGranularity);
            }();
auto& minCodedExtent_json=json["minCodedExtent"];
[&](){
            auto& temp=minCodedExtent_json.emplace_object();
            return serialize_struct(temp, member.minCodedExtent);
            }();
auto& maxCodedExtent_json=json["maxCodedExtent"];
[&](){
            auto& temp=maxCodedExtent_json.emplace_object();
            return serialize_struct(temp, member.maxCodedExtent);
            }();
auto& maxDpbSlots_json=json["maxDpbSlots"];
[&](){maxDpbSlots_json=member.maxDpbSlots;}();
auto& maxActiveReferencePictures_json=json["maxActiveReferencePictures"];
[&](){maxActiveReferencePictures_json=member.maxActiveReferencePictures;}();
auto& stdHeaderVersion_json=json["stdHeaderVersion"];
[&](){
            auto& temp=stdHeaderVersion_json.emplace_object();
            return serialize_struct(temp, member.stdHeaderVersion);
            }();
}
void deserialize_struct(boost::json::object& json, VkVideoCapabilitiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_jTekBTA;[&](){temp_jTekBTA=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkVideoCapabilityFlagsKHR)temp_jTekBTA;}();}();
auto& minBitstreamBufferOffsetAlignment_json=json["minBitstreamBufferOffsetAlignment"];
[&](){uint64_t temp_NbyCeUP;[&](){temp_NbyCeUP=static_cast<uint64_t>(value_to<int>(minBitstreamBufferOffsetAlignment_json));}();member.minBitstreamBufferOffsetAlignment=(VkDeviceSize)temp_NbyCeUP;}();
auto& minBitstreamBufferSizeAlignment_json=json["minBitstreamBufferSizeAlignment"];
[&](){uint64_t temp_mjQORCt;[&](){temp_mjQORCt=static_cast<uint64_t>(value_to<int>(minBitstreamBufferSizeAlignment_json));}();member.minBitstreamBufferSizeAlignment=(VkDeviceSize)temp_mjQORCt;}();
auto& pictureAccessGranularity_json=json["pictureAccessGranularity"];
[&](){
            auto& temp=pictureAccessGranularity_json.as_object();
            deserialize_struct(temp,member.pictureAccessGranularity);
            }();
auto& minCodedExtent_json=json["minCodedExtent"];
[&](){
            auto& temp=minCodedExtent_json.as_object();
            deserialize_struct(temp,member.minCodedExtent);
            }();
auto& maxCodedExtent_json=json["maxCodedExtent"];
[&](){
            auto& temp=maxCodedExtent_json.as_object();
            deserialize_struct(temp,member.maxCodedExtent);
            }();
auto& maxDpbSlots_json=json["maxDpbSlots"];
[&](){member.maxDpbSlots=static_cast<uint32_t>(value_to<int>(maxDpbSlots_json));}();
auto& maxActiveReferencePictures_json=json["maxActiveReferencePictures"];
[&](){member.maxActiveReferencePictures=static_cast<uint32_t>(value_to<int>(maxActiveReferencePictures_json));}();
auto& stdHeaderVersion_json=json["stdHeaderVersion"];
[&](){
            auto& temp=stdHeaderVersion_json.as_object();
            deserialize_struct(temp,member.stdHeaderVersion);
            }();
}

    void serialize_struct(boost::json::object& json, const VkVideoSessionMemoryRequirementsKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memoryBindIndex_json=json["memoryBindIndex"];
[&](){memoryBindIndex_json=member.memoryBindIndex;}();
auto& memoryRequirements_json=json["memoryRequirements"];
[&](){
            auto& temp=memoryRequirements_json.emplace_object();
            return serialize_struct(temp, member.memoryRequirements);
            }();
}
void deserialize_struct(boost::json::object& json, VkVideoSessionMemoryRequirementsKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& memoryBindIndex_json=json["memoryBindIndex"];
[&](){member.memoryBindIndex=static_cast<uint32_t>(value_to<int>(memoryBindIndex_json));}();
auto& memoryRequirements_json=json["memoryRequirements"];
[&](){
            auto& temp=memoryRequirements_json.as_object();
            deserialize_struct(temp,member.memoryRequirements);
            }();
}

    void serialize_struct(boost::json::object& json, const VkBindVideoSessionMemoryInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memoryBindIndex_json=json["memoryBindIndex"];
[&](){memoryBindIndex_json=member.memoryBindIndex;}();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){[&](){memoryOffset_json=member.memoryOffset;}();}();
auto& memorySize_json=json["memorySize"];
[&](){[&](){memorySize_json=member.memorySize;}();}();
}
void deserialize_struct(boost::json::object& json, VkBindVideoSessionMemoryInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& memoryBindIndex_json=json["memoryBindIndex"];
[&](){member.memoryBindIndex=static_cast<uint32_t>(value_to<int>(memoryBindIndex_json));}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& memoryOffset_json=json["memoryOffset"];
[&](){uint64_t temp_VWSGqtD;[&](){temp_VWSGqtD=static_cast<uint64_t>(value_to<int>(memoryOffset_json));}();member.memoryOffset=(VkDeviceSize)temp_VWSGqtD;}();
auto& memorySize_json=json["memorySize"];
[&](){uint64_t temp_WvfUAdo;[&](){temp_WvfUAdo=static_cast<uint64_t>(value_to<int>(memorySize_json));}();member.memorySize=(VkDeviceSize)temp_WvfUAdo;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoPictureResourceInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& codedOffset_json=json["codedOffset"];
[&](){
            auto& temp=codedOffset_json.emplace_object();
            return serialize_struct(temp, member.codedOffset);
            }();
auto& codedExtent_json=json["codedExtent"];
[&](){
            auto& temp=codedExtent_json.emplace_object();
            return serialize_struct(temp, member.codedExtent);
            }();
auto& baseArrayLayer_json=json["baseArrayLayer"];
[&](){baseArrayLayer_json=member.baseArrayLayer;}();
auto& imageViewBinding_json=json["imageViewBinding"];
[&](){serialize_VkImageView(imageViewBinding_json,member.imageViewBinding);}();
}
void deserialize_struct(boost::json::object& json, VkVideoPictureResourceInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& codedOffset_json=json["codedOffset"];
[&](){
            auto& temp=codedOffset_json.as_object();
            deserialize_struct(temp,member.codedOffset);
            }();
auto& codedExtent_json=json["codedExtent"];
[&](){
            auto& temp=codedExtent_json.as_object();
            deserialize_struct(temp,member.codedExtent);
            }();
auto& baseArrayLayer_json=json["baseArrayLayer"];
[&](){member.baseArrayLayer=static_cast<uint32_t>(value_to<int>(baseArrayLayer_json));}();
auto& imageViewBinding_json=json["imageViewBinding"];
[&](){deserialize_VkImageView(imageViewBinding_json, member.imageViewBinding);}();
}

    void serialize_struct(boost::json::object& json, const VkVideoReferenceSlotInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& slotIndex_json=json["slotIndex"];
[&](){slotIndex_json=member.slotIndex;}();
auto& pPictureResource_json=json["pPictureResource"];
[&](){
            if (member.pPictureResource==NULL){
                pPictureResource_json=boost::json::array();
            return; }pPictureResource_json=boost::json::array(1);
        auto& arr_djEoQBi=pPictureResource_json.as_array();
        for(int fEARCkB=0; fEARCkB < 1; fEARCkB++){
            [&](){
            auto& temp=arr_djEoQBi[fEARCkB].emplace_object();
            return serialize_struct(temp, member.pPictureResource[fEARCkB]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkVideoReferenceSlotInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& slotIndex_json=json["slotIndex"];
[&](){member.slotIndex=static_cast<int32_t>(value_to<int>(slotIndex_json));}();
auto& pPictureResource_json=json["pPictureResource"];
[&](){ VkVideoPictureResourceInfoKHR* temp_oJYnbkA;;[&](){
            if (pPictureResource_json.as_array().size()==0){
                temp_oJYnbkA=NULL;
            return; }temp_oJYnbkA=(VkVideoPictureResourceInfoKHR*)malloc(1*sizeof(VkVideoPictureResourceInfoKHR));
        auto& arr_JTuntNy=pPictureResource_json.as_array();
        for(int BpdBtqk=0; BpdBtqk < 1; BpdBtqk++){
            [&](){
            auto& temp=arr_JTuntNy[BpdBtqk].as_object();
            deserialize_struct(temp,temp_oJYnbkA[BpdBtqk]);
            }();
        }
        }();member.pPictureResource=temp_oJYnbkA;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeCapabilitiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeCapabilitiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_MunZVdw;[&](){temp_MunZVdw=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkVideoDecodeCapabilityFlagsKHR)temp_MunZVdw;}();}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeUsageInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& videoUsageHints_json=json["videoUsageHints"];
[&](){[&](){[&](){videoUsageHints_json=member.videoUsageHints;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeUsageInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& videoUsageHints_json=json["videoUsageHints"];
[&](){[&](){int temp_dAdDkrp;[&](){temp_dAdDkrp=static_cast<int>(value_to<int>(videoUsageHints_json));}();member.videoUsageHints=(VkVideoDecodeUsageFlagsKHR)temp_dAdDkrp;}();}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& srcBuffer_json=json["srcBuffer"];
[&](){serialize_VkBuffer(srcBuffer_json,member.srcBuffer);}();
auto& srcBufferOffset_json=json["srcBufferOffset"];
[&](){[&](){srcBufferOffset_json=member.srcBufferOffset;}();}();
auto& srcBufferRange_json=json["srcBufferRange"];
[&](){[&](){srcBufferRange_json=member.srcBufferRange;}();}();
auto& dstPictureResource_json=json["dstPictureResource"];
[&](){
            auto& temp=dstPictureResource_json.emplace_object();
            return serialize_struct(temp, member.dstPictureResource);
            }();
auto& pSetupReferenceSlot_json=json["pSetupReferenceSlot"];
[&](){
            if (member.pSetupReferenceSlot==NULL){
                pSetupReferenceSlot_json=boost::json::array();
            return; }pSetupReferenceSlot_json=boost::json::array(1);
        auto& arr_uwnCvBq=pSetupReferenceSlot_json.as_array();
        for(int ISkkOBc=0; ISkkOBc < 1; ISkkOBc++){
            [&](){
            auto& temp=arr_uwnCvBq[ISkkOBc].emplace_object();
            return serialize_struct(temp, member.pSetupReferenceSlot[ISkkOBc]);
            }();
        }
        }();
auto& referenceSlotCount_json=json["referenceSlotCount"];
[&](){referenceSlotCount_json=member.referenceSlotCount;}();
auto& pReferenceSlots_json=json["pReferenceSlots"];
[&](){
            if (member.pReferenceSlots==NULL){
                pReferenceSlots_json=boost::json::array();
            return; }pReferenceSlots_json=boost::json::array(member.referenceSlotCount);
        auto& arr_hNUTaci=pReferenceSlots_json.as_array();
        for(int EWeFaQj=0; EWeFaQj < member.referenceSlotCount; EWeFaQj++){
            [&](){
            auto& temp=arr_hNUTaci[EWeFaQj].emplace_object();
            return serialize_struct(temp, member.pReferenceSlots[EWeFaQj]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_NDeiDYD;[&](){temp_NDeiDYD=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkVideoDecodeFlagsKHR)temp_NDeiDYD;}();}();
auto& srcBuffer_json=json["srcBuffer"];
[&](){deserialize_VkBuffer(srcBuffer_json, member.srcBuffer);}();
auto& srcBufferOffset_json=json["srcBufferOffset"];
[&](){uint64_t temp_CsWZYki;[&](){temp_CsWZYki=static_cast<uint64_t>(value_to<int>(srcBufferOffset_json));}();member.srcBufferOffset=(VkDeviceSize)temp_CsWZYki;}();
auto& srcBufferRange_json=json["srcBufferRange"];
[&](){uint64_t temp_FQnIRZt;[&](){temp_FQnIRZt=static_cast<uint64_t>(value_to<int>(srcBufferRange_json));}();member.srcBufferRange=(VkDeviceSize)temp_FQnIRZt;}();
auto& dstPictureResource_json=json["dstPictureResource"];
[&](){
            auto& temp=dstPictureResource_json.as_object();
            deserialize_struct(temp,member.dstPictureResource);
            }();
auto& pSetupReferenceSlot_json=json["pSetupReferenceSlot"];
[&](){ VkVideoReferenceSlotInfoKHR* temp_hTBYsGa;;[&](){
            if (pSetupReferenceSlot_json.as_array().size()==0){
                temp_hTBYsGa=NULL;
            return; }temp_hTBYsGa=(VkVideoReferenceSlotInfoKHR*)malloc(1*sizeof(VkVideoReferenceSlotInfoKHR));
        auto& arr_nwgoaHU=pSetupReferenceSlot_json.as_array();
        for(int eJAqqwt=0; eJAqqwt < 1; eJAqqwt++){
            [&](){
            auto& temp=arr_nwgoaHU[eJAqqwt].as_object();
            deserialize_struct(temp,temp_hTBYsGa[eJAqqwt]);
            }();
        }
        }();member.pSetupReferenceSlot=temp_hTBYsGa;}();
auto& referenceSlotCount_json=json["referenceSlotCount"];
[&](){member.referenceSlotCount=static_cast<uint32_t>(value_to<int>(referenceSlotCount_json));}();
auto& pReferenceSlots_json=json["pReferenceSlots"];
[&](){ VkVideoReferenceSlotInfoKHR* temp_totdJRb;;[&](){
            if (pReferenceSlots_json.as_array().size()==0){
                temp_totdJRb=NULL;
            return; }temp_totdJRb=(VkVideoReferenceSlotInfoKHR*)malloc(member.referenceSlotCount*sizeof(VkVideoReferenceSlotInfoKHR));
        auto& arr_aGUxLTO=pReferenceSlots_json.as_array();
        for(int WOGyaJR=0; WOGyaJR < member.referenceSlotCount; WOGyaJR++){
            [&](){
            auto& temp=arr_aGUxLTO[WOGyaJR].as_object();
            deserialize_struct(temp,temp_totdJRb[WOGyaJR]);
            }();
        }
        }();member.pReferenceSlots=temp_totdJRb;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH264ProfileInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stdProfileIdc_json=json["stdProfileIdc"];
[&](){stdProfileIdc_json=(uintptr_t)member.stdProfileIdc;}();
auto& pictureLayout_json=json["pictureLayout"];
[&](){[&](){[&](){pictureLayout_json=member.pictureLayout;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH264ProfileInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& stdProfileIdc_json=json["stdProfileIdc"];
[&](){member.stdProfileIdc=(StdVideoH264ProfileIdc )(value_to<uintptr_t>(stdProfileIdc_json));}();
auto& pictureLayout_json=json["pictureLayout"];
[&](){[&](){int temp_DULMdrW;[&](){temp_DULMdrW=static_cast<int>(value_to<int>(pictureLayout_json));}();member.pictureLayout=(VkVideoDecodeH264PictureLayoutFlagBitsKHR)temp_DULMdrW;}();}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH264CapabilitiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxLevelIdc_json=json["maxLevelIdc"];
[&](){maxLevelIdc_json=(uintptr_t)member.maxLevelIdc;}();
auto& fieldOffsetGranularity_json=json["fieldOffsetGranularity"];
[&](){
            auto& temp=fieldOffsetGranularity_json.emplace_object();
            return serialize_struct(temp, member.fieldOffsetGranularity);
            }();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH264CapabilitiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxLevelIdc_json=json["maxLevelIdc"];
[&](){member.maxLevelIdc=(StdVideoH264LevelIdc )(value_to<uintptr_t>(maxLevelIdc_json));}();
auto& fieldOffsetGranularity_json=json["fieldOffsetGranularity"];
[&](){
            auto& temp=fieldOffsetGranularity_json.as_object();
            deserialize_struct(temp,member.fieldOffsetGranularity);
            }();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH264SessionParametersAddInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stdSPSCount_json=json["stdSPSCount"];
[&](){stdSPSCount_json=member.stdSPSCount;}();
auto& pStdSPSs_json=json["pStdSPSs"];
[&](){
            if (member.pStdSPSs==NULL){
                pStdSPSs_json=boost::json::array();
            return; }pStdSPSs_json=(uintptr_t)member.pStdSPSs;}();
auto& stdPPSCount_json=json["stdPPSCount"];
[&](){stdPPSCount_json=member.stdPPSCount;}();
auto& pStdPPSs_json=json["pStdPPSs"];
[&](){
            if (member.pStdPPSs==NULL){
                pStdPPSs_json=boost::json::array();
            return; }pStdPPSs_json=(uintptr_t)member.pStdPPSs;}();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH264SessionParametersAddInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& stdSPSCount_json=json["stdSPSCount"];
[&](){member.stdSPSCount=static_cast<uint32_t>(value_to<int>(stdSPSCount_json));}();
auto& pStdSPSs_json=json["pStdSPSs"];
[&](){ StdVideoH264SequenceParameterSet* temp_eRdqEOz;;[&](){
            if (pStdSPSs_json.as_array().size()==0){
                temp_eRdqEOz=NULL;
            return; }temp_eRdqEOz=( StdVideoH264SequenceParameterSet* )(value_to<uintptr_t>(pStdSPSs_json));}();member.pStdSPSs=temp_eRdqEOz;}();
auto& stdPPSCount_json=json["stdPPSCount"];
[&](){member.stdPPSCount=static_cast<uint32_t>(value_to<int>(stdPPSCount_json));}();
auto& pStdPPSs_json=json["pStdPPSs"];
[&](){ StdVideoH264PictureParameterSet* temp_NuINmNu;;[&](){
            if (pStdPPSs_json.as_array().size()==0){
                temp_NuINmNu=NULL;
            return; }temp_NuINmNu=( StdVideoH264PictureParameterSet* )(value_to<uintptr_t>(pStdPPSs_json));}();member.pStdPPSs=temp_NuINmNu;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH264SessionParametersCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxStdSPSCount_json=json["maxStdSPSCount"];
[&](){maxStdSPSCount_json=member.maxStdSPSCount;}();
auto& maxStdPPSCount_json=json["maxStdPPSCount"];
[&](){maxStdPPSCount_json=member.maxStdPPSCount;}();
auto& pParametersAddInfo_json=json["pParametersAddInfo"];
[&](){
            if (member.pParametersAddInfo==NULL){
                pParametersAddInfo_json=boost::json::array();
            return; }pParametersAddInfo_json=boost::json::array(1);
        auto& arr_xlxjnfg=pParametersAddInfo_json.as_array();
        for(int wbcEpkz=0; wbcEpkz < 1; wbcEpkz++){
            [&](){
            auto& temp=arr_xlxjnfg[wbcEpkz].emplace_object();
            return serialize_struct(temp, member.pParametersAddInfo[wbcEpkz]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH264SessionParametersCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& maxStdSPSCount_json=json["maxStdSPSCount"];
[&](){member.maxStdSPSCount=static_cast<uint32_t>(value_to<int>(maxStdSPSCount_json));}();
auto& maxStdPPSCount_json=json["maxStdPPSCount"];
[&](){member.maxStdPPSCount=static_cast<uint32_t>(value_to<int>(maxStdPPSCount_json));}();
auto& pParametersAddInfo_json=json["pParametersAddInfo"];
[&](){ VkVideoDecodeH264SessionParametersAddInfoKHR* temp_lrighDr;;[&](){
            if (pParametersAddInfo_json.as_array().size()==0){
                temp_lrighDr=NULL;
            return; }temp_lrighDr=(VkVideoDecodeH264SessionParametersAddInfoKHR*)malloc(1*sizeof(VkVideoDecodeH264SessionParametersAddInfoKHR));
        auto& arr_pVWbPxw=pParametersAddInfo_json.as_array();
        for(int SYpGtsC=0; SYpGtsC < 1; SYpGtsC++){
            [&](){
            auto& temp=arr_pVWbPxw[SYpGtsC].as_object();
            deserialize_struct(temp,temp_lrighDr[SYpGtsC]);
            }();
        }
        }();member.pParametersAddInfo=temp_lrighDr;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH264PictureInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pStdPictureInfo_json=json["pStdPictureInfo"];
[&](){
            if (member.pStdPictureInfo==NULL){
                pStdPictureInfo_json=boost::json::array();
            return; }pStdPictureInfo_json=(uintptr_t)member.pStdPictureInfo;}();
auto& sliceCount_json=json["sliceCount"];
[&](){sliceCount_json=member.sliceCount;}();
auto& pSliceOffsets_json=json["pSliceOffsets"];
[&](){
            if (member.pSliceOffsets==NULL){
                pSliceOffsets_json=boost::json::array();
            return; }pSliceOffsets_json=boost::json::array(member.sliceCount);
        auto& arr_xKJUFEi=pSliceOffsets_json.as_array();
        for(int qqvmrqA=0; qqvmrqA < member.sliceCount; qqvmrqA++){
            [&](){arr_xKJUFEi[qqvmrqA]=member.pSliceOffsets[qqvmrqA];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH264PictureInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pStdPictureInfo_json=json["pStdPictureInfo"];
[&](){ StdVideoDecodeH264PictureInfo* temp_IUCOJGe;;[&](){
            if (pStdPictureInfo_json.as_array().size()==0){
                temp_IUCOJGe=NULL;
            return; }temp_IUCOJGe=( StdVideoDecodeH264PictureInfo* )(value_to<uintptr_t>(pStdPictureInfo_json));}();member.pStdPictureInfo=temp_IUCOJGe;}();
auto& sliceCount_json=json["sliceCount"];
[&](){member.sliceCount=static_cast<uint32_t>(value_to<int>(sliceCount_json));}();
auto& pSliceOffsets_json=json["pSliceOffsets"];
[&](){ uint32_t* temp_fYiTbSh;;[&](){
            if (pSliceOffsets_json.as_array().size()==0){
                temp_fYiTbSh=NULL;
            return; }temp_fYiTbSh=(uint32_t*)malloc(member.sliceCount*sizeof(uint32_t));
        auto& arr_YYfqFzf=pSliceOffsets_json.as_array();
        for(int KZpGXuY=0; KZpGXuY < member.sliceCount; KZpGXuY++){
            [&](){temp_fYiTbSh[KZpGXuY]=static_cast<uint32_t>(value_to<int>(arr_YYfqFzf[KZpGXuY]));}();
        }
        }();member.pSliceOffsets=temp_fYiTbSh;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH264DpbSlotInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pStdReferenceInfo_json=json["pStdReferenceInfo"];
[&](){
            if (member.pStdReferenceInfo==NULL){
                pStdReferenceInfo_json=boost::json::array();
            return; }pStdReferenceInfo_json=(uintptr_t)member.pStdReferenceInfo;}();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH264DpbSlotInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pStdReferenceInfo_json=json["pStdReferenceInfo"];
[&](){ StdVideoDecodeH264ReferenceInfo* temp_nHXWlzc;;[&](){
            if (pStdReferenceInfo_json.as_array().size()==0){
                temp_nHXWlzc=NULL;
            return; }temp_nHXWlzc=( StdVideoDecodeH264ReferenceInfo* )(value_to<uintptr_t>(pStdReferenceInfo_json));}();member.pStdReferenceInfo=temp_nHXWlzc;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH265ProfileInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stdProfileIdc_json=json["stdProfileIdc"];
[&](){stdProfileIdc_json=(uintptr_t)member.stdProfileIdc;}();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH265ProfileInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& stdProfileIdc_json=json["stdProfileIdc"];
[&](){member.stdProfileIdc=(StdVideoH265ProfileIdc )(value_to<uintptr_t>(stdProfileIdc_json));}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH265CapabilitiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxLevelIdc_json=json["maxLevelIdc"];
[&](){maxLevelIdc_json=(uintptr_t)member.maxLevelIdc;}();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH265CapabilitiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxLevelIdc_json=json["maxLevelIdc"];
[&](){member.maxLevelIdc=(StdVideoH265LevelIdc )(value_to<uintptr_t>(maxLevelIdc_json));}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH265SessionParametersAddInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& stdVPSCount_json=json["stdVPSCount"];
[&](){stdVPSCount_json=member.stdVPSCount;}();
auto& pStdVPSs_json=json["pStdVPSs"];
[&](){
            if (member.pStdVPSs==NULL){
                pStdVPSs_json=boost::json::array();
            return; }pStdVPSs_json=(uintptr_t)member.pStdVPSs;}();
auto& stdSPSCount_json=json["stdSPSCount"];
[&](){stdSPSCount_json=member.stdSPSCount;}();
auto& pStdSPSs_json=json["pStdSPSs"];
[&](){
            if (member.pStdSPSs==NULL){
                pStdSPSs_json=boost::json::array();
            return; }pStdSPSs_json=(uintptr_t)member.pStdSPSs;}();
auto& stdPPSCount_json=json["stdPPSCount"];
[&](){stdPPSCount_json=member.stdPPSCount;}();
auto& pStdPPSs_json=json["pStdPPSs"];
[&](){
            if (member.pStdPPSs==NULL){
                pStdPPSs_json=boost::json::array();
            return; }pStdPPSs_json=(uintptr_t)member.pStdPPSs;}();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH265SessionParametersAddInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& stdVPSCount_json=json["stdVPSCount"];
[&](){member.stdVPSCount=static_cast<uint32_t>(value_to<int>(stdVPSCount_json));}();
auto& pStdVPSs_json=json["pStdVPSs"];
[&](){ StdVideoH265VideoParameterSet* temp_GONujJs;;[&](){
            if (pStdVPSs_json.as_array().size()==0){
                temp_GONujJs=NULL;
            return; }temp_GONujJs=( StdVideoH265VideoParameterSet* )(value_to<uintptr_t>(pStdVPSs_json));}();member.pStdVPSs=temp_GONujJs;}();
auto& stdSPSCount_json=json["stdSPSCount"];
[&](){member.stdSPSCount=static_cast<uint32_t>(value_to<int>(stdSPSCount_json));}();
auto& pStdSPSs_json=json["pStdSPSs"];
[&](){ StdVideoH265SequenceParameterSet* temp_MLUVlPd;;[&](){
            if (pStdSPSs_json.as_array().size()==0){
                temp_MLUVlPd=NULL;
            return; }temp_MLUVlPd=( StdVideoH265SequenceParameterSet* )(value_to<uintptr_t>(pStdSPSs_json));}();member.pStdSPSs=temp_MLUVlPd;}();
auto& stdPPSCount_json=json["stdPPSCount"];
[&](){member.stdPPSCount=static_cast<uint32_t>(value_to<int>(stdPPSCount_json));}();
auto& pStdPPSs_json=json["pStdPPSs"];
[&](){ StdVideoH265PictureParameterSet* temp_rJdRWdG;;[&](){
            if (pStdPPSs_json.as_array().size()==0){
                temp_rJdRWdG=NULL;
            return; }temp_rJdRWdG=( StdVideoH265PictureParameterSet* )(value_to<uintptr_t>(pStdPPSs_json));}();member.pStdPPSs=temp_rJdRWdG;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH265SessionParametersCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxStdVPSCount_json=json["maxStdVPSCount"];
[&](){maxStdVPSCount_json=member.maxStdVPSCount;}();
auto& maxStdSPSCount_json=json["maxStdSPSCount"];
[&](){maxStdSPSCount_json=member.maxStdSPSCount;}();
auto& maxStdPPSCount_json=json["maxStdPPSCount"];
[&](){maxStdPPSCount_json=member.maxStdPPSCount;}();
auto& pParametersAddInfo_json=json["pParametersAddInfo"];
[&](){
            if (member.pParametersAddInfo==NULL){
                pParametersAddInfo_json=boost::json::array();
            return; }pParametersAddInfo_json=boost::json::array(1);
        auto& arr_HwLlplh=pParametersAddInfo_json.as_array();
        for(int xyeBndZ=0; xyeBndZ < 1; xyeBndZ++){
            [&](){
            auto& temp=arr_HwLlplh[xyeBndZ].emplace_object();
            return serialize_struct(temp, member.pParametersAddInfo[xyeBndZ]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH265SessionParametersCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& maxStdVPSCount_json=json["maxStdVPSCount"];
[&](){member.maxStdVPSCount=static_cast<uint32_t>(value_to<int>(maxStdVPSCount_json));}();
auto& maxStdSPSCount_json=json["maxStdSPSCount"];
[&](){member.maxStdSPSCount=static_cast<uint32_t>(value_to<int>(maxStdSPSCount_json));}();
auto& maxStdPPSCount_json=json["maxStdPPSCount"];
[&](){member.maxStdPPSCount=static_cast<uint32_t>(value_to<int>(maxStdPPSCount_json));}();
auto& pParametersAddInfo_json=json["pParametersAddInfo"];
[&](){ VkVideoDecodeH265SessionParametersAddInfoKHR* temp_hAtCOsG;;[&](){
            if (pParametersAddInfo_json.as_array().size()==0){
                temp_hAtCOsG=NULL;
            return; }temp_hAtCOsG=(VkVideoDecodeH265SessionParametersAddInfoKHR*)malloc(1*sizeof(VkVideoDecodeH265SessionParametersAddInfoKHR));
        auto& arr_WzCAUKJ=pParametersAddInfo_json.as_array();
        for(int QOhFNQQ=0; QOhFNQQ < 1; QOhFNQQ++){
            [&](){
            auto& temp=arr_WzCAUKJ[QOhFNQQ].as_object();
            deserialize_struct(temp,temp_hAtCOsG[QOhFNQQ]);
            }();
        }
        }();member.pParametersAddInfo=temp_hAtCOsG;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH265PictureInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pStdPictureInfo_json=json["pStdPictureInfo"];
[&](){
            if (member.pStdPictureInfo==NULL){
                pStdPictureInfo_json=boost::json::array();
            return; }pStdPictureInfo_json=(uintptr_t)member.pStdPictureInfo;}();
auto& sliceSegmentCount_json=json["sliceSegmentCount"];
[&](){sliceSegmentCount_json=member.sliceSegmentCount;}();
auto& pSliceSegmentOffsets_json=json["pSliceSegmentOffsets"];
[&](){
            if (member.pSliceSegmentOffsets==NULL){
                pSliceSegmentOffsets_json=boost::json::array();
            return; }pSliceSegmentOffsets_json=boost::json::array(member.sliceSegmentCount);
        auto& arr_shxlmUq=pSliceSegmentOffsets_json.as_array();
        for(int bKjPBJN=0; bKjPBJN < member.sliceSegmentCount; bKjPBJN++){
            [&](){arr_shxlmUq[bKjPBJN]=member.pSliceSegmentOffsets[bKjPBJN];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH265PictureInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pStdPictureInfo_json=json["pStdPictureInfo"];
[&](){ StdVideoDecodeH265PictureInfo* temp_ipDHcVo;;[&](){
            if (pStdPictureInfo_json.as_array().size()==0){
                temp_ipDHcVo=NULL;
            return; }temp_ipDHcVo=( StdVideoDecodeH265PictureInfo* )(value_to<uintptr_t>(pStdPictureInfo_json));}();member.pStdPictureInfo=temp_ipDHcVo;}();
auto& sliceSegmentCount_json=json["sliceSegmentCount"];
[&](){member.sliceSegmentCount=static_cast<uint32_t>(value_to<int>(sliceSegmentCount_json));}();
auto& pSliceSegmentOffsets_json=json["pSliceSegmentOffsets"];
[&](){ uint32_t* temp_txFFMrU;;[&](){
            if (pSliceSegmentOffsets_json.as_array().size()==0){
                temp_txFFMrU=NULL;
            return; }temp_txFFMrU=(uint32_t*)malloc(member.sliceSegmentCount*sizeof(uint32_t));
        auto& arr_qknUlmQ=pSliceSegmentOffsets_json.as_array();
        for(int XfnlixP=0; XfnlixP < member.sliceSegmentCount; XfnlixP++){
            [&](){temp_txFFMrU[XfnlixP]=static_cast<uint32_t>(value_to<int>(arr_qknUlmQ[XfnlixP]));}();
        }
        }();member.pSliceSegmentOffsets=temp_txFFMrU;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoDecodeH265DpbSlotInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pStdReferenceInfo_json=json["pStdReferenceInfo"];
[&](){
            if (member.pStdReferenceInfo==NULL){
                pStdReferenceInfo_json=boost::json::array();
            return; }pStdReferenceInfo_json=(uintptr_t)member.pStdReferenceInfo;}();
}
void deserialize_struct(boost::json::object& json, VkVideoDecodeH265DpbSlotInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pStdReferenceInfo_json=json["pStdReferenceInfo"];
[&](){ StdVideoDecodeH265ReferenceInfo* temp_uDpLClD;;[&](){
            if (pStdReferenceInfo_json.as_array().size()==0){
                temp_uDpLClD=NULL;
            return; }temp_uDpLClD=( StdVideoDecodeH265ReferenceInfo* )(value_to<uintptr_t>(pStdReferenceInfo_json));}();member.pStdReferenceInfo=temp_uDpLClD;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoSessionCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){queueFamilyIndex_json=member.queueFamilyIndex;}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pVideoProfile_json=json["pVideoProfile"];
[&](){
            if (member.pVideoProfile==NULL){
                pVideoProfile_json=boost::json::array();
            return; }pVideoProfile_json=boost::json::array(1);
        auto& arr_cYUybNt=pVideoProfile_json.as_array();
        for(int HIFOwAq=0; HIFOwAq < 1; HIFOwAq++){
            [&](){
            auto& temp=arr_cYUybNt[HIFOwAq].emplace_object();
            return serialize_struct(temp, member.pVideoProfile[HIFOwAq]);
            }();
        }
        }();
auto& pictureFormat_json=json["pictureFormat"];
[&](){[&](){[&](){pictureFormat_json=member.pictureFormat;}();}();}();
auto& maxCodedExtent_json=json["maxCodedExtent"];
[&](){
            auto& temp=maxCodedExtent_json.emplace_object();
            return serialize_struct(temp, member.maxCodedExtent);
            }();
auto& referencePictureFormat_json=json["referencePictureFormat"];
[&](){[&](){[&](){referencePictureFormat_json=member.referencePictureFormat;}();}();}();
auto& maxDpbSlots_json=json["maxDpbSlots"];
[&](){maxDpbSlots_json=member.maxDpbSlots;}();
auto& maxActiveReferencePictures_json=json["maxActiveReferencePictures"];
[&](){maxActiveReferencePictures_json=member.maxActiveReferencePictures;}();
auto& pStdHeaderVersion_json=json["pStdHeaderVersion"];
[&](){
            if (member.pStdHeaderVersion==NULL){
                pStdHeaderVersion_json=boost::json::array();
            return; }pStdHeaderVersion_json=boost::json::array(1);
        auto& arr_UhuMWfc=pStdHeaderVersion_json.as_array();
        for(int aRJLlXo=0; aRJLlXo < 1; aRJLlXo++){
            [&](){
            auto& temp=arr_UhuMWfc[aRJLlXo].emplace_object();
            return serialize_struct(temp, member.pStdHeaderVersion[aRJLlXo]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkVideoSessionCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& queueFamilyIndex_json=json["queueFamilyIndex"];
[&](){member.queueFamilyIndex=static_cast<uint32_t>(value_to<int>(queueFamilyIndex_json));}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_ziMXJDg;[&](){temp_ziMXJDg=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkVideoSessionCreateFlagsKHR)temp_ziMXJDg;}();}();
auto& pVideoProfile_json=json["pVideoProfile"];
[&](){ VkVideoProfileInfoKHR* temp_pRvyKYn;;[&](){
            if (pVideoProfile_json.as_array().size()==0){
                temp_pRvyKYn=NULL;
            return; }temp_pRvyKYn=(VkVideoProfileInfoKHR*)malloc(1*sizeof(VkVideoProfileInfoKHR));
        auto& arr_HWDSivq=pVideoProfile_json.as_array();
        for(int vDsFylw=0; vDsFylw < 1; vDsFylw++){
            [&](){
            auto& temp=arr_HWDSivq[vDsFylw].as_object();
            deserialize_struct(temp,temp_pRvyKYn[vDsFylw]);
            }();
        }
        }();member.pVideoProfile=temp_pRvyKYn;}();
auto& pictureFormat_json=json["pictureFormat"];
[&](){[&](){int temp_iEWDbAV;[&](){temp_iEWDbAV=static_cast<int>(value_to<int>(pictureFormat_json));}();member.pictureFormat=(VkFormat)temp_iEWDbAV;}();}();
auto& maxCodedExtent_json=json["maxCodedExtent"];
[&](){
            auto& temp=maxCodedExtent_json.as_object();
            deserialize_struct(temp,member.maxCodedExtent);
            }();
auto& referencePictureFormat_json=json["referencePictureFormat"];
[&](){[&](){int temp_XntMaZN;[&](){temp_XntMaZN=static_cast<int>(value_to<int>(referencePictureFormat_json));}();member.referencePictureFormat=(VkFormat)temp_XntMaZN;}();}();
auto& maxDpbSlots_json=json["maxDpbSlots"];
[&](){member.maxDpbSlots=static_cast<uint32_t>(value_to<int>(maxDpbSlots_json));}();
auto& maxActiveReferencePictures_json=json["maxActiveReferencePictures"];
[&](){member.maxActiveReferencePictures=static_cast<uint32_t>(value_to<int>(maxActiveReferencePictures_json));}();
auto& pStdHeaderVersion_json=json["pStdHeaderVersion"];
[&](){ VkExtensionProperties* temp_axOXQXD;;[&](){
            if (pStdHeaderVersion_json.as_array().size()==0){
                temp_axOXQXD=NULL;
            return; }temp_axOXQXD=(VkExtensionProperties*)malloc(1*sizeof(VkExtensionProperties));
        auto& arr_IuRrwIL=pStdHeaderVersion_json.as_array();
        for(int yjIEPfw=0; yjIEPfw < 1; yjIEPfw++){
            [&](){
            auto& temp=arr_IuRrwIL[yjIEPfw].as_object();
            deserialize_struct(temp,temp_axOXQXD[yjIEPfw]);
            }();
        }
        }();member.pStdHeaderVersion=temp_axOXQXD;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoSessionParametersCreateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& videoSessionParametersTemplate_json=json["videoSessionParametersTemplate"];
[&](){serialize_VkVideoSessionParametersKHR(videoSessionParametersTemplate_json,member.videoSessionParametersTemplate);}();
auto& videoSession_json=json["videoSession"];
[&](){serialize_VkVideoSessionKHR(videoSession_json,member.videoSession);}();
}
void deserialize_struct(boost::json::object& json, VkVideoSessionParametersCreateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_BNfGxzR;[&](){temp_BNfGxzR=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkVideoSessionParametersCreateFlagsKHR)temp_BNfGxzR;}();}();
auto& videoSessionParametersTemplate_json=json["videoSessionParametersTemplate"];
[&](){deserialize_VkVideoSessionParametersKHR(videoSessionParametersTemplate_json, member.videoSessionParametersTemplate);}();
auto& videoSession_json=json["videoSession"];
[&](){deserialize_VkVideoSessionKHR(videoSession_json, member.videoSession);}();
}

    void serialize_struct(boost::json::object& json, const VkVideoSessionParametersUpdateInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& updateSequenceCount_json=json["updateSequenceCount"];
[&](){updateSequenceCount_json=member.updateSequenceCount;}();
}
void deserialize_struct(boost::json::object& json, VkVideoSessionParametersUpdateInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& updateSequenceCount_json=json["updateSequenceCount"];
[&](){member.updateSequenceCount=static_cast<uint32_t>(value_to<int>(updateSequenceCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkVideoBeginCodingInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& videoSession_json=json["videoSession"];
[&](){serialize_VkVideoSessionKHR(videoSession_json,member.videoSession);}();
auto& videoSessionParameters_json=json["videoSessionParameters"];
[&](){serialize_VkVideoSessionParametersKHR(videoSessionParameters_json,member.videoSessionParameters);}();
auto& referenceSlotCount_json=json["referenceSlotCount"];
[&](){referenceSlotCount_json=member.referenceSlotCount;}();
auto& pReferenceSlots_json=json["pReferenceSlots"];
[&](){
            if (member.pReferenceSlots==NULL){
                pReferenceSlots_json=boost::json::array();
            return; }pReferenceSlots_json=boost::json::array(member.referenceSlotCount);
        auto& arr_hNUTaci=pReferenceSlots_json.as_array();
        for(int EWeFaQj=0; EWeFaQj < member.referenceSlotCount; EWeFaQj++){
            [&](){
            auto& temp=arr_hNUTaci[EWeFaQj].emplace_object();
            return serialize_struct(temp, member.pReferenceSlots[EWeFaQj]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkVideoBeginCodingInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_yINEoGZ;[&](){temp_yINEoGZ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkVideoBeginCodingFlagsKHR)temp_yINEoGZ;}();}();
auto& videoSession_json=json["videoSession"];
[&](){deserialize_VkVideoSessionKHR(videoSession_json, member.videoSession);}();
auto& videoSessionParameters_json=json["videoSessionParameters"];
[&](){deserialize_VkVideoSessionParametersKHR(videoSessionParameters_json, member.videoSessionParameters);}();
auto& referenceSlotCount_json=json["referenceSlotCount"];
[&](){member.referenceSlotCount=static_cast<uint32_t>(value_to<int>(referenceSlotCount_json));}();
auto& pReferenceSlots_json=json["pReferenceSlots"];
[&](){ VkVideoReferenceSlotInfoKHR* temp_totdJRb;;[&](){
            if (pReferenceSlots_json.as_array().size()==0){
                temp_totdJRb=NULL;
            return; }temp_totdJRb=(VkVideoReferenceSlotInfoKHR*)malloc(member.referenceSlotCount*sizeof(VkVideoReferenceSlotInfoKHR));
        auto& arr_aGUxLTO=pReferenceSlots_json.as_array();
        for(int WOGyaJR=0; WOGyaJR < member.referenceSlotCount; WOGyaJR++){
            [&](){
            auto& temp=arr_aGUxLTO[WOGyaJR].as_object();
            deserialize_struct(temp,temp_totdJRb[WOGyaJR]);
            }();
        }
        }();member.pReferenceSlots=temp_totdJRb;}();
}

    void serialize_struct(boost::json::object& json, const VkVideoEndCodingInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkVideoEndCodingInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_daZapiR;[&](){temp_daZapiR=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkVideoEndCodingFlagsKHR)temp_daZapiR;}();}();
}

    void serialize_struct(boost::json::object& json, const VkVideoCodingControlInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkVideoCodingControlInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_uqWwcVK;[&](){temp_uqWwcVK=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkVideoCodingControlFlagsKHR)temp_uqWwcVK;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceInheritedViewportScissorFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& inheritedViewportScissor2D_json=json["inheritedViewportScissor2D"];
[&](){[&](){inheritedViewportScissor2D_json=member.inheritedViewportScissor2D;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceInheritedViewportScissorFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& inheritedViewportScissor2D_json=json["inheritedViewportScissor2D"];
[&](){uint32_t temp_vIKRHnm;[&](){temp_vIKRHnm=static_cast<uint32_t>(value_to<int>(inheritedViewportScissor2D_json));}();member.inheritedViewportScissor2D=(VkBool32)temp_vIKRHnm;}();
}

    void serialize_struct(boost::json::object& json, const VkCommandBufferInheritanceViewportScissorInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& viewportScissor2D_json=json["viewportScissor2D"];
[&](){[&](){viewportScissor2D_json=member.viewportScissor2D;}();}();
auto& viewportDepthCount_json=json["viewportDepthCount"];
[&](){viewportDepthCount_json=member.viewportDepthCount;}();
auto& pViewportDepths_json=json["pViewportDepths"];
[&](){
            if (member.pViewportDepths==NULL){
                pViewportDepths_json=boost::json::array();
            return; }pViewportDepths_json=boost::json::array(1);
        auto& arr_aQtsLfD=pViewportDepths_json.as_array();
        for(int choYOAw=0; choYOAw < 1; choYOAw++){
            [&](){
            auto& temp=arr_aQtsLfD[choYOAw].emplace_object();
            return serialize_struct(temp, member.pViewportDepths[choYOAw]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCommandBufferInheritanceViewportScissorInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& viewportScissor2D_json=json["viewportScissor2D"];
[&](){uint32_t temp_qoufcNr;[&](){temp_qoufcNr=static_cast<uint32_t>(value_to<int>(viewportScissor2D_json));}();member.viewportScissor2D=(VkBool32)temp_qoufcNr;}();
auto& viewportDepthCount_json=json["viewportDepthCount"];
[&](){member.viewportDepthCount=static_cast<uint32_t>(value_to<int>(viewportDepthCount_json));}();
auto& pViewportDepths_json=json["pViewportDepths"];
[&](){ VkViewport* temp_HUtdrCn;;[&](){
            if (pViewportDepths_json.as_array().size()==0){
                temp_HUtdrCn=NULL;
            return; }temp_HUtdrCn=(VkViewport*)malloc(1*sizeof(VkViewport));
        auto& arr_kVFeTvD=pViewportDepths_json.as_array();
        for(int PVrqLRw=0; PVrqLRw < 1; PVrqLRw++){
            [&](){
            auto& temp=arr_kVFeTvD[PVrqLRw].as_object();
            deserialize_struct(temp,temp_HUtdrCn[PVrqLRw]);
            }();
        }
        }();member.pViewportDepths=temp_HUtdrCn;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& ycbcr2plane444Formats_json=json["ycbcr2plane444Formats"];
[&](){[&](){ycbcr2plane444Formats_json=member.ycbcr2plane444Formats;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& ycbcr2plane444Formats_json=json["ycbcr2plane444Formats"];
[&](){uint32_t temp_najyMRy;[&](){temp_najyMRy=static_cast<uint32_t>(value_to<int>(ycbcr2plane444Formats_json));}();member.ycbcr2plane444Formats=(VkBool32)temp_najyMRy;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceProvokingVertexFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& provokingVertexLast_json=json["provokingVertexLast"];
[&](){[&](){provokingVertexLast_json=member.provokingVertexLast;}();}();
auto& transformFeedbackPreservesProvokingVertex_json=json["transformFeedbackPreservesProvokingVertex"];
[&](){[&](){transformFeedbackPreservesProvokingVertex_json=member.transformFeedbackPreservesProvokingVertex;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceProvokingVertexFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& provokingVertexLast_json=json["provokingVertexLast"];
[&](){uint32_t temp_NCZGCcF;[&](){temp_NCZGCcF=static_cast<uint32_t>(value_to<int>(provokingVertexLast_json));}();member.provokingVertexLast=(VkBool32)temp_NCZGCcF;}();
auto& transformFeedbackPreservesProvokingVertex_json=json["transformFeedbackPreservesProvokingVertex"];
[&](){uint32_t temp_MSWVYaG;[&](){temp_MSWVYaG=static_cast<uint32_t>(value_to<int>(transformFeedbackPreservesProvokingVertex_json));}();member.transformFeedbackPreservesProvokingVertex=(VkBool32)temp_MSWVYaG;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceProvokingVertexPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& provokingVertexModePerPipeline_json=json["provokingVertexModePerPipeline"];
[&](){[&](){provokingVertexModePerPipeline_json=member.provokingVertexModePerPipeline;}();}();
auto& transformFeedbackPreservesTriangleFanProvokingVertex_json=json["transformFeedbackPreservesTriangleFanProvokingVertex"];
[&](){[&](){transformFeedbackPreservesTriangleFanProvokingVertex_json=member.transformFeedbackPreservesTriangleFanProvokingVertex;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceProvokingVertexPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& provokingVertexModePerPipeline_json=json["provokingVertexModePerPipeline"];
[&](){uint32_t temp_SrcwGUN;[&](){temp_SrcwGUN=static_cast<uint32_t>(value_to<int>(provokingVertexModePerPipeline_json));}();member.provokingVertexModePerPipeline=(VkBool32)temp_SrcwGUN;}();
auto& transformFeedbackPreservesTriangleFanProvokingVertex_json=json["transformFeedbackPreservesTriangleFanProvokingVertex"];
[&](){uint32_t temp_KDoyxsO;[&](){temp_KDoyxsO=static_cast<uint32_t>(value_to<int>(transformFeedbackPreservesTriangleFanProvokingVertex_json));}();member.transformFeedbackPreservesTriangleFanProvokingVertex=(VkBool32)temp_KDoyxsO;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& provokingVertexMode_json=json["provokingVertexMode"];
[&](){[&](){[&](){provokingVertexMode_json=member.provokingVertexMode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& provokingVertexMode_json=json["provokingVertexMode"];
[&](){[&](){int temp_EpaVLog;[&](){temp_EpaVLog=static_cast<int>(value_to<int>(provokingVertexMode_json));}();member.provokingVertexMode=(VkProvokingVertexModeEXT)temp_EpaVLog;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCuModuleCreateInfoNVX& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dataSize_json=json["dataSize"];
[&](){dataSize_json=member.dataSize;}();
auto& pData_json=json["pData"];
[&](){
            if (member.pData==NULL){
                pData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pData))==NULL){
                pData_json=boost::json::array();
            return; }pData_json=boost::json::array(member.dataSize);
        auto& arr_cukaPTa=pData_json.as_array();
        for(int UqwNSOA=0; UqwNSOA < member.dataSize; UqwNSOA++){
            [&](){arr_cukaPTa[UqwNSOA]=((char*)(member.pData))[UqwNSOA];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkCuModuleCreateInfoNVX& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& dataSize_json=json["dataSize"];
[&](){member.dataSize=static_cast<size_t>(value_to<int>(dataSize_json));}();
auto& pData_json=json["pData"];
[&](){ void* temp_rZvPbwc;;[&](){
            if (pData_json.as_array().size()==0){
                temp_rZvPbwc=NULL;
            return; }char* temp_qtCaFHh;[&](){
            if (pData_json.as_array().size()==0){
                temp_qtCaFHh=NULL;
            return; }temp_qtCaFHh=(char*)malloc(member.dataSize*sizeof(char));
        auto& arr_XpObFOU=pData_json.as_array();
        for(int tUplioR=0; tUplioR < member.dataSize; tUplioR++){
            [&](){temp_qtCaFHh[tUplioR]=static_cast<char>(value_to<int>(arr_XpObFOU[tUplioR]));}();
        }
        }();temp_rZvPbwc=temp_qtCaFHh;}();member.pData=temp_rZvPbwc;}();
}

    void serialize_struct(boost::json::object& json, const VkCuFunctionCreateInfoNVX& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& module_json=json["module"];
[&](){serialize_VkCuModuleNVX(module_json,member.module);}();
auto& pName_json=json["pName"];
[&](){
            if (member.pName==NULL){
                pName_json=boost::json::array();
            return; }pName_json=boost::json::array(strlen(member.pName)+1);
        auto& arr_RNtEgHa=pName_json.as_array();
        for(int JRJzPhN=0; JRJzPhN < strlen(member.pName)+1; JRJzPhN++){
            [&](){arr_RNtEgHa[JRJzPhN]=member.pName[JRJzPhN];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCuFunctionCreateInfoNVX& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& module_json=json["module"];
[&](){deserialize_VkCuModuleNVX(module_json, member.module);}();
auto& pName_json=json["pName"];
[&](){ char* temp_AzKgJNk;;[&](){
            if (pName_json.as_array().size()==0){
                temp_AzKgJNk=NULL;
            return; }temp_AzKgJNk=(char*)malloc(pName_json.as_array().size()*sizeof(char));
        auto& arr_SFTpFTT=pName_json.as_array();
        for(int zYvyZlQ=0; zYvyZlQ < pName_json.as_array().size(); zYvyZlQ++){
            [&](){temp_AzKgJNk[zYvyZlQ]=static_cast<char>(value_to<int>(arr_SFTpFTT[zYvyZlQ]));}();
        }
        }();member.pName=temp_AzKgJNk;}();
}

    void serialize_struct(boost::json::object& json, const VkCuLaunchInfoNVX& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& function_json=json["function"];
[&](){serialize_VkCuFunctionNVX(function_json,member.function);}();
auto& gridDimX_json=json["gridDimX"];
[&](){gridDimX_json=member.gridDimX;}();
auto& gridDimY_json=json["gridDimY"];
[&](){gridDimY_json=member.gridDimY;}();
auto& gridDimZ_json=json["gridDimZ"];
[&](){gridDimZ_json=member.gridDimZ;}();
auto& blockDimX_json=json["blockDimX"];
[&](){blockDimX_json=member.blockDimX;}();
auto& blockDimY_json=json["blockDimY"];
[&](){blockDimY_json=member.blockDimY;}();
auto& blockDimZ_json=json["blockDimZ"];
[&](){blockDimZ_json=member.blockDimZ;}();
auto& sharedMemBytes_json=json["sharedMemBytes"];
[&](){sharedMemBytes_json=member.sharedMemBytes;}();
auto& paramCount_json=json["paramCount"];
[&](){paramCount_json=member.paramCount;}();
auto& pParams_json=json["pParams"];
[&](){
            if (member.pParams==NULL){
                pParams_json=boost::json::array();
            return; }pParams_json=boost::json::array(1);
        auto& arr_UKdddHW=pParams_json.as_array();
        for(int lwGCeVE=0; lwGCeVE < 1; lwGCeVE++){
            [&](){
            if (member.pParams[lwGCeVE]==NULL){
                arr_UKdddHW[lwGCeVE]=boost::json::array();
            return; }[&](){
            if (((char*)(member.pParams[lwGCeVE]))==NULL){
                arr_UKdddHW[lwGCeVE]=boost::json::array();
            return; }arr_UKdddHW[lwGCeVE]=boost::json::array(member.paramCount);
        auto& arr_ZeylACs=arr_UKdddHW[lwGCeVE].as_array();
        for(int sXfeKcP=0; sXfeKcP < member.paramCount; sXfeKcP++){
            [&](){arr_ZeylACs[sXfeKcP]=((char*)(member.pParams[lwGCeVE]))[sXfeKcP];}();
        }
        }();}();
        }
        }();
auto& extraCount_json=json["extraCount"];
[&](){extraCount_json=member.extraCount;}();
auto& pExtras_json=json["pExtras"];
[&](){
            if (member.pExtras==NULL){
                pExtras_json=boost::json::array();
            return; }pExtras_json=boost::json::array(1);
        auto& arr_JybOQtK=pExtras_json.as_array();
        for(int TjXAhjK=0; TjXAhjK < 1; TjXAhjK++){
            [&](){
            if (member.pExtras[TjXAhjK]==NULL){
                arr_JybOQtK[TjXAhjK]=boost::json::array();
            return; }[&](){
            if (((char*)(member.pExtras[TjXAhjK]))==NULL){
                arr_JybOQtK[TjXAhjK]=boost::json::array();
            return; }arr_JybOQtK[TjXAhjK]=boost::json::array(member.extraCount);
        auto& arr_VUsnEbF=arr_JybOQtK[TjXAhjK].as_array();
        for(int QaQDEqf=0; QaQDEqf < member.extraCount; QaQDEqf++){
            [&](){arr_VUsnEbF[QaQDEqf]=((char*)(member.pExtras[TjXAhjK]))[QaQDEqf];}();
        }
        }();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkCuLaunchInfoNVX& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& function_json=json["function"];
[&](){deserialize_VkCuFunctionNVX(function_json, member.function);}();
auto& gridDimX_json=json["gridDimX"];
[&](){member.gridDimX=static_cast<uint32_t>(value_to<int>(gridDimX_json));}();
auto& gridDimY_json=json["gridDimY"];
[&](){member.gridDimY=static_cast<uint32_t>(value_to<int>(gridDimY_json));}();
auto& gridDimZ_json=json["gridDimZ"];
[&](){member.gridDimZ=static_cast<uint32_t>(value_to<int>(gridDimZ_json));}();
auto& blockDimX_json=json["blockDimX"];
[&](){member.blockDimX=static_cast<uint32_t>(value_to<int>(blockDimX_json));}();
auto& blockDimY_json=json["blockDimY"];
[&](){member.blockDimY=static_cast<uint32_t>(value_to<int>(blockDimY_json));}();
auto& blockDimZ_json=json["blockDimZ"];
[&](){member.blockDimZ=static_cast<uint32_t>(value_to<int>(blockDimZ_json));}();
auto& sharedMemBytes_json=json["sharedMemBytes"];
[&](){member.sharedMemBytes=static_cast<uint32_t>(value_to<int>(sharedMemBytes_json));}();
auto& paramCount_json=json["paramCount"];
[&](){member.paramCount=static_cast<size_t>(value_to<int>(paramCount_json));}();
auto& pParams_json=json["pParams"];
[&](){ void*  * temp_ISnBMiO;;[&](){
            if (pParams_json.as_array().size()==0){
                temp_ISnBMiO=NULL;
            return; }temp_ISnBMiO=(void**)malloc(1*sizeof(void*));
        auto& arr_yGQtRYX=pParams_json.as_array();
        for(int nElQNmD=0; nElQNmD < 1; nElQNmD++){
            [&](){
            if (arr_yGQtRYX[nElQNmD].as_array().size()==0){
                temp_ISnBMiO[nElQNmD]=NULL;
            return; }char* temp_yGQtRYX;[&](){
            if (arr_yGQtRYX[nElQNmD].as_array().size()==0){
                temp_yGQtRYX=NULL;
            return; }temp_yGQtRYX=(char*)malloc(member.paramCount*sizeof(char));
        auto& arr_WjHuHAJ=arr_yGQtRYX[nElQNmD].as_array();
        for(int bqNaAvH=0; bqNaAvH < member.paramCount; bqNaAvH++){
            [&](){temp_yGQtRYX[bqNaAvH]=static_cast<char>(value_to<int>(arr_WjHuHAJ[bqNaAvH]));}();
        }
        }();temp_ISnBMiO[nElQNmD]=temp_yGQtRYX;}();
        }
        }();member.pParams=temp_ISnBMiO;}();
auto& extraCount_json=json["extraCount"];
[&](){member.extraCount=static_cast<size_t>(value_to<int>(extraCount_json));}();
auto& pExtras_json=json["pExtras"];
[&](){ void*  * temp_FUVwtsd;;[&](){
            if (pExtras_json.as_array().size()==0){
                temp_FUVwtsd=NULL;
            return; }temp_FUVwtsd=(void**)malloc(1*sizeof(void*));
        auto& arr_MnVTqgJ=pExtras_json.as_array();
        for(int kzGewvh=0; kzGewvh < 1; kzGewvh++){
            [&](){
            if (arr_MnVTqgJ[kzGewvh].as_array().size()==0){
                temp_FUVwtsd[kzGewvh]=NULL;
            return; }char* temp_MnVTqgJ;[&](){
            if (arr_MnVTqgJ[kzGewvh].as_array().size()==0){
                temp_MnVTqgJ=NULL;
            return; }temp_MnVTqgJ=(char*)malloc(member.extraCount*sizeof(char));
        auto& arr_ndLULUm=arr_MnVTqgJ[kzGewvh].as_array();
        for(int gCJMSyN=0; gCJMSyN < member.extraCount; gCJMSyN++){
            [&](){temp_MnVTqgJ[gCJMSyN]=static_cast<char>(value_to<int>(arr_ndLULUm[gCJMSyN]));}();
        }
        }();temp_FUVwtsd[kzGewvh]=temp_MnVTqgJ;}();
        }
        }();member.pExtras=temp_FUVwtsd;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDescriptorBufferFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& descriptorBuffer_json=json["descriptorBuffer"];
[&](){[&](){descriptorBuffer_json=member.descriptorBuffer;}();}();
auto& descriptorBufferCaptureReplay_json=json["descriptorBufferCaptureReplay"];
[&](){[&](){descriptorBufferCaptureReplay_json=member.descriptorBufferCaptureReplay;}();}();
auto& descriptorBufferImageLayoutIgnored_json=json["descriptorBufferImageLayoutIgnored"];
[&](){[&](){descriptorBufferImageLayoutIgnored_json=member.descriptorBufferImageLayoutIgnored;}();}();
auto& descriptorBufferPushDescriptors_json=json["descriptorBufferPushDescriptors"];
[&](){[&](){descriptorBufferPushDescriptors_json=member.descriptorBufferPushDescriptors;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDescriptorBufferFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& descriptorBuffer_json=json["descriptorBuffer"];
[&](){uint32_t temp_IIEycqV;[&](){temp_IIEycqV=static_cast<uint32_t>(value_to<int>(descriptorBuffer_json));}();member.descriptorBuffer=(VkBool32)temp_IIEycqV;}();
auto& descriptorBufferCaptureReplay_json=json["descriptorBufferCaptureReplay"];
[&](){uint32_t temp_dddbcJB;[&](){temp_dddbcJB=static_cast<uint32_t>(value_to<int>(descriptorBufferCaptureReplay_json));}();member.descriptorBufferCaptureReplay=(VkBool32)temp_dddbcJB;}();
auto& descriptorBufferImageLayoutIgnored_json=json["descriptorBufferImageLayoutIgnored"];
[&](){uint32_t temp_oxObyfw;[&](){temp_oxObyfw=static_cast<uint32_t>(value_to<int>(descriptorBufferImageLayoutIgnored_json));}();member.descriptorBufferImageLayoutIgnored=(VkBool32)temp_oxObyfw;}();
auto& descriptorBufferPushDescriptors_json=json["descriptorBufferPushDescriptors"];
[&](){uint32_t temp_pqYzqEO;[&](){temp_pqYzqEO=static_cast<uint32_t>(value_to<int>(descriptorBufferPushDescriptors_json));}();member.descriptorBufferPushDescriptors=(VkBool32)temp_pqYzqEO;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDescriptorBufferPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& combinedImageSamplerDescriptorSingleArray_json=json["combinedImageSamplerDescriptorSingleArray"];
[&](){[&](){combinedImageSamplerDescriptorSingleArray_json=member.combinedImageSamplerDescriptorSingleArray;}();}();
auto& bufferlessPushDescriptors_json=json["bufferlessPushDescriptors"];
[&](){[&](){bufferlessPushDescriptors_json=member.bufferlessPushDescriptors;}();}();
auto& allowSamplerImageViewPostSubmitCreation_json=json["allowSamplerImageViewPostSubmitCreation"];
[&](){[&](){allowSamplerImageViewPostSubmitCreation_json=member.allowSamplerImageViewPostSubmitCreation;}();}();
auto& descriptorBufferOffsetAlignment_json=json["descriptorBufferOffsetAlignment"];
[&](){[&](){descriptorBufferOffsetAlignment_json=member.descriptorBufferOffsetAlignment;}();}();
auto& maxDescriptorBufferBindings_json=json["maxDescriptorBufferBindings"];
[&](){maxDescriptorBufferBindings_json=member.maxDescriptorBufferBindings;}();
auto& maxResourceDescriptorBufferBindings_json=json["maxResourceDescriptorBufferBindings"];
[&](){maxResourceDescriptorBufferBindings_json=member.maxResourceDescriptorBufferBindings;}();
auto& maxSamplerDescriptorBufferBindings_json=json["maxSamplerDescriptorBufferBindings"];
[&](){maxSamplerDescriptorBufferBindings_json=member.maxSamplerDescriptorBufferBindings;}();
auto& maxEmbeddedImmutableSamplerBindings_json=json["maxEmbeddedImmutableSamplerBindings"];
[&](){maxEmbeddedImmutableSamplerBindings_json=member.maxEmbeddedImmutableSamplerBindings;}();
auto& maxEmbeddedImmutableSamplers_json=json["maxEmbeddedImmutableSamplers"];
[&](){maxEmbeddedImmutableSamplers_json=member.maxEmbeddedImmutableSamplers;}();
auto& bufferCaptureReplayDescriptorDataSize_json=json["bufferCaptureReplayDescriptorDataSize"];
[&](){bufferCaptureReplayDescriptorDataSize_json=member.bufferCaptureReplayDescriptorDataSize;}();
auto& imageCaptureReplayDescriptorDataSize_json=json["imageCaptureReplayDescriptorDataSize"];
[&](){imageCaptureReplayDescriptorDataSize_json=member.imageCaptureReplayDescriptorDataSize;}();
auto& imageViewCaptureReplayDescriptorDataSize_json=json["imageViewCaptureReplayDescriptorDataSize"];
[&](){imageViewCaptureReplayDescriptorDataSize_json=member.imageViewCaptureReplayDescriptorDataSize;}();
auto& samplerCaptureReplayDescriptorDataSize_json=json["samplerCaptureReplayDescriptorDataSize"];
[&](){samplerCaptureReplayDescriptorDataSize_json=member.samplerCaptureReplayDescriptorDataSize;}();
auto& accelerationStructureCaptureReplayDescriptorDataSize_json=json["accelerationStructureCaptureReplayDescriptorDataSize"];
[&](){accelerationStructureCaptureReplayDescriptorDataSize_json=member.accelerationStructureCaptureReplayDescriptorDataSize;}();
auto& samplerDescriptorSize_json=json["samplerDescriptorSize"];
[&](){samplerDescriptorSize_json=member.samplerDescriptorSize;}();
auto& combinedImageSamplerDescriptorSize_json=json["combinedImageSamplerDescriptorSize"];
[&](){combinedImageSamplerDescriptorSize_json=member.combinedImageSamplerDescriptorSize;}();
auto& sampledImageDescriptorSize_json=json["sampledImageDescriptorSize"];
[&](){sampledImageDescriptorSize_json=member.sampledImageDescriptorSize;}();
auto& storageImageDescriptorSize_json=json["storageImageDescriptorSize"];
[&](){storageImageDescriptorSize_json=member.storageImageDescriptorSize;}();
auto& uniformTexelBufferDescriptorSize_json=json["uniformTexelBufferDescriptorSize"];
[&](){uniformTexelBufferDescriptorSize_json=member.uniformTexelBufferDescriptorSize;}();
auto& robustUniformTexelBufferDescriptorSize_json=json["robustUniformTexelBufferDescriptorSize"];
[&](){robustUniformTexelBufferDescriptorSize_json=member.robustUniformTexelBufferDescriptorSize;}();
auto& storageTexelBufferDescriptorSize_json=json["storageTexelBufferDescriptorSize"];
[&](){storageTexelBufferDescriptorSize_json=member.storageTexelBufferDescriptorSize;}();
auto& robustStorageTexelBufferDescriptorSize_json=json["robustStorageTexelBufferDescriptorSize"];
[&](){robustStorageTexelBufferDescriptorSize_json=member.robustStorageTexelBufferDescriptorSize;}();
auto& uniformBufferDescriptorSize_json=json["uniformBufferDescriptorSize"];
[&](){uniformBufferDescriptorSize_json=member.uniformBufferDescriptorSize;}();
auto& robustUniformBufferDescriptorSize_json=json["robustUniformBufferDescriptorSize"];
[&](){robustUniformBufferDescriptorSize_json=member.robustUniformBufferDescriptorSize;}();
auto& storageBufferDescriptorSize_json=json["storageBufferDescriptorSize"];
[&](){storageBufferDescriptorSize_json=member.storageBufferDescriptorSize;}();
auto& robustStorageBufferDescriptorSize_json=json["robustStorageBufferDescriptorSize"];
[&](){robustStorageBufferDescriptorSize_json=member.robustStorageBufferDescriptorSize;}();
auto& inputAttachmentDescriptorSize_json=json["inputAttachmentDescriptorSize"];
[&](){inputAttachmentDescriptorSize_json=member.inputAttachmentDescriptorSize;}();
auto& accelerationStructureDescriptorSize_json=json["accelerationStructureDescriptorSize"];
[&](){accelerationStructureDescriptorSize_json=member.accelerationStructureDescriptorSize;}();
auto& maxSamplerDescriptorBufferRange_json=json["maxSamplerDescriptorBufferRange"];
[&](){[&](){maxSamplerDescriptorBufferRange_json=member.maxSamplerDescriptorBufferRange;}();}();
auto& maxResourceDescriptorBufferRange_json=json["maxResourceDescriptorBufferRange"];
[&](){[&](){maxResourceDescriptorBufferRange_json=member.maxResourceDescriptorBufferRange;}();}();
auto& samplerDescriptorBufferAddressSpaceSize_json=json["samplerDescriptorBufferAddressSpaceSize"];
[&](){[&](){samplerDescriptorBufferAddressSpaceSize_json=member.samplerDescriptorBufferAddressSpaceSize;}();}();
auto& resourceDescriptorBufferAddressSpaceSize_json=json["resourceDescriptorBufferAddressSpaceSize"];
[&](){[&](){resourceDescriptorBufferAddressSpaceSize_json=member.resourceDescriptorBufferAddressSpaceSize;}();}();
auto& descriptorBufferAddressSpaceSize_json=json["descriptorBufferAddressSpaceSize"];
[&](){[&](){descriptorBufferAddressSpaceSize_json=member.descriptorBufferAddressSpaceSize;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDescriptorBufferPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& combinedImageSamplerDescriptorSingleArray_json=json["combinedImageSamplerDescriptorSingleArray"];
[&](){uint32_t temp_zHSZNCW;[&](){temp_zHSZNCW=static_cast<uint32_t>(value_to<int>(combinedImageSamplerDescriptorSingleArray_json));}();member.combinedImageSamplerDescriptorSingleArray=(VkBool32)temp_zHSZNCW;}();
auto& bufferlessPushDescriptors_json=json["bufferlessPushDescriptors"];
[&](){uint32_t temp_OXyQIYl;[&](){temp_OXyQIYl=static_cast<uint32_t>(value_to<int>(bufferlessPushDescriptors_json));}();member.bufferlessPushDescriptors=(VkBool32)temp_OXyQIYl;}();
auto& allowSamplerImageViewPostSubmitCreation_json=json["allowSamplerImageViewPostSubmitCreation"];
[&](){uint32_t temp_XgtBXdG;[&](){temp_XgtBXdG=static_cast<uint32_t>(value_to<int>(allowSamplerImageViewPostSubmitCreation_json));}();member.allowSamplerImageViewPostSubmitCreation=(VkBool32)temp_XgtBXdG;}();
auto& descriptorBufferOffsetAlignment_json=json["descriptorBufferOffsetAlignment"];
[&](){uint64_t temp_Bwkfqfj;[&](){temp_Bwkfqfj=static_cast<uint64_t>(value_to<int>(descriptorBufferOffsetAlignment_json));}();member.descriptorBufferOffsetAlignment=(VkDeviceSize)temp_Bwkfqfj;}();
auto& maxDescriptorBufferBindings_json=json["maxDescriptorBufferBindings"];
[&](){member.maxDescriptorBufferBindings=static_cast<uint32_t>(value_to<int>(maxDescriptorBufferBindings_json));}();
auto& maxResourceDescriptorBufferBindings_json=json["maxResourceDescriptorBufferBindings"];
[&](){member.maxResourceDescriptorBufferBindings=static_cast<uint32_t>(value_to<int>(maxResourceDescriptorBufferBindings_json));}();
auto& maxSamplerDescriptorBufferBindings_json=json["maxSamplerDescriptorBufferBindings"];
[&](){member.maxSamplerDescriptorBufferBindings=static_cast<uint32_t>(value_to<int>(maxSamplerDescriptorBufferBindings_json));}();
auto& maxEmbeddedImmutableSamplerBindings_json=json["maxEmbeddedImmutableSamplerBindings"];
[&](){member.maxEmbeddedImmutableSamplerBindings=static_cast<uint32_t>(value_to<int>(maxEmbeddedImmutableSamplerBindings_json));}();
auto& maxEmbeddedImmutableSamplers_json=json["maxEmbeddedImmutableSamplers"];
[&](){member.maxEmbeddedImmutableSamplers=static_cast<uint32_t>(value_to<int>(maxEmbeddedImmutableSamplers_json));}();
auto& bufferCaptureReplayDescriptorDataSize_json=json["bufferCaptureReplayDescriptorDataSize"];
[&](){member.bufferCaptureReplayDescriptorDataSize=static_cast<size_t>(value_to<int>(bufferCaptureReplayDescriptorDataSize_json));}();
auto& imageCaptureReplayDescriptorDataSize_json=json["imageCaptureReplayDescriptorDataSize"];
[&](){member.imageCaptureReplayDescriptorDataSize=static_cast<size_t>(value_to<int>(imageCaptureReplayDescriptorDataSize_json));}();
auto& imageViewCaptureReplayDescriptorDataSize_json=json["imageViewCaptureReplayDescriptorDataSize"];
[&](){member.imageViewCaptureReplayDescriptorDataSize=static_cast<size_t>(value_to<int>(imageViewCaptureReplayDescriptorDataSize_json));}();
auto& samplerCaptureReplayDescriptorDataSize_json=json["samplerCaptureReplayDescriptorDataSize"];
[&](){member.samplerCaptureReplayDescriptorDataSize=static_cast<size_t>(value_to<int>(samplerCaptureReplayDescriptorDataSize_json));}();
auto& accelerationStructureCaptureReplayDescriptorDataSize_json=json["accelerationStructureCaptureReplayDescriptorDataSize"];
[&](){member.accelerationStructureCaptureReplayDescriptorDataSize=static_cast<size_t>(value_to<int>(accelerationStructureCaptureReplayDescriptorDataSize_json));}();
auto& samplerDescriptorSize_json=json["samplerDescriptorSize"];
[&](){member.samplerDescriptorSize=static_cast<size_t>(value_to<int>(samplerDescriptorSize_json));}();
auto& combinedImageSamplerDescriptorSize_json=json["combinedImageSamplerDescriptorSize"];
[&](){member.combinedImageSamplerDescriptorSize=static_cast<size_t>(value_to<int>(combinedImageSamplerDescriptorSize_json));}();
auto& sampledImageDescriptorSize_json=json["sampledImageDescriptorSize"];
[&](){member.sampledImageDescriptorSize=static_cast<size_t>(value_to<int>(sampledImageDescriptorSize_json));}();
auto& storageImageDescriptorSize_json=json["storageImageDescriptorSize"];
[&](){member.storageImageDescriptorSize=static_cast<size_t>(value_to<int>(storageImageDescriptorSize_json));}();
auto& uniformTexelBufferDescriptorSize_json=json["uniformTexelBufferDescriptorSize"];
[&](){member.uniformTexelBufferDescriptorSize=static_cast<size_t>(value_to<int>(uniformTexelBufferDescriptorSize_json));}();
auto& robustUniformTexelBufferDescriptorSize_json=json["robustUniformTexelBufferDescriptorSize"];
[&](){member.robustUniformTexelBufferDescriptorSize=static_cast<size_t>(value_to<int>(robustUniformTexelBufferDescriptorSize_json));}();
auto& storageTexelBufferDescriptorSize_json=json["storageTexelBufferDescriptorSize"];
[&](){member.storageTexelBufferDescriptorSize=static_cast<size_t>(value_to<int>(storageTexelBufferDescriptorSize_json));}();
auto& robustStorageTexelBufferDescriptorSize_json=json["robustStorageTexelBufferDescriptorSize"];
[&](){member.robustStorageTexelBufferDescriptorSize=static_cast<size_t>(value_to<int>(robustStorageTexelBufferDescriptorSize_json));}();
auto& uniformBufferDescriptorSize_json=json["uniformBufferDescriptorSize"];
[&](){member.uniformBufferDescriptorSize=static_cast<size_t>(value_to<int>(uniformBufferDescriptorSize_json));}();
auto& robustUniformBufferDescriptorSize_json=json["robustUniformBufferDescriptorSize"];
[&](){member.robustUniformBufferDescriptorSize=static_cast<size_t>(value_to<int>(robustUniformBufferDescriptorSize_json));}();
auto& storageBufferDescriptorSize_json=json["storageBufferDescriptorSize"];
[&](){member.storageBufferDescriptorSize=static_cast<size_t>(value_to<int>(storageBufferDescriptorSize_json));}();
auto& robustStorageBufferDescriptorSize_json=json["robustStorageBufferDescriptorSize"];
[&](){member.robustStorageBufferDescriptorSize=static_cast<size_t>(value_to<int>(robustStorageBufferDescriptorSize_json));}();
auto& inputAttachmentDescriptorSize_json=json["inputAttachmentDescriptorSize"];
[&](){member.inputAttachmentDescriptorSize=static_cast<size_t>(value_to<int>(inputAttachmentDescriptorSize_json));}();
auto& accelerationStructureDescriptorSize_json=json["accelerationStructureDescriptorSize"];
[&](){member.accelerationStructureDescriptorSize=static_cast<size_t>(value_to<int>(accelerationStructureDescriptorSize_json));}();
auto& maxSamplerDescriptorBufferRange_json=json["maxSamplerDescriptorBufferRange"];
[&](){uint64_t temp_gDRDtcX;[&](){temp_gDRDtcX=static_cast<uint64_t>(value_to<int>(maxSamplerDescriptorBufferRange_json));}();member.maxSamplerDescriptorBufferRange=(VkDeviceSize)temp_gDRDtcX;}();
auto& maxResourceDescriptorBufferRange_json=json["maxResourceDescriptorBufferRange"];
[&](){uint64_t temp_rwAFlnv;[&](){temp_rwAFlnv=static_cast<uint64_t>(value_to<int>(maxResourceDescriptorBufferRange_json));}();member.maxResourceDescriptorBufferRange=(VkDeviceSize)temp_rwAFlnv;}();
auto& samplerDescriptorBufferAddressSpaceSize_json=json["samplerDescriptorBufferAddressSpaceSize"];
[&](){uint64_t temp_kQfHzEE;[&](){temp_kQfHzEE=static_cast<uint64_t>(value_to<int>(samplerDescriptorBufferAddressSpaceSize_json));}();member.samplerDescriptorBufferAddressSpaceSize=(VkDeviceSize)temp_kQfHzEE;}();
auto& resourceDescriptorBufferAddressSpaceSize_json=json["resourceDescriptorBufferAddressSpaceSize"];
[&](){uint64_t temp_UZVtlyg;[&](){temp_UZVtlyg=static_cast<uint64_t>(value_to<int>(resourceDescriptorBufferAddressSpaceSize_json));}();member.resourceDescriptorBufferAddressSpaceSize=(VkDeviceSize)temp_UZVtlyg;}();
auto& descriptorBufferAddressSpaceSize_json=json["descriptorBufferAddressSpaceSize"];
[&](){uint64_t temp_faItxbH;[&](){temp_faItxbH=static_cast<uint64_t>(value_to<int>(descriptorBufferAddressSpaceSize_json));}();member.descriptorBufferAddressSpaceSize=(VkDeviceSize)temp_faItxbH;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& combinedImageSamplerDensityMapDescriptorSize_json=json["combinedImageSamplerDensityMapDescriptorSize"];
[&](){combinedImageSamplerDensityMapDescriptorSize_json=member.combinedImageSamplerDensityMapDescriptorSize;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& combinedImageSamplerDensityMapDescriptorSize_json=json["combinedImageSamplerDensityMapDescriptorSize"];
[&](){member.combinedImageSamplerDensityMapDescriptorSize=static_cast<size_t>(value_to<int>(combinedImageSamplerDensityMapDescriptorSize_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorAddressInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& address_json=json["address"];
[&](){[&](){address_json=member.address;}();}();
auto& range_json=json["range"];
[&](){[&](){range_json=member.range;}();}();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorAddressInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& address_json=json["address"];
[&](){uint64_t temp_CULVsIJ;[&](){temp_CULVsIJ=static_cast<uint64_t>(value_to<int>(address_json));}();member.address=(VkDeviceAddress)temp_CULVsIJ;}();
auto& range_json=json["range"];
[&](){uint64_t temp_UVnzFRl;[&](){temp_UVnzFRl=static_cast<uint64_t>(value_to<int>(range_json));}();member.range=(VkDeviceSize)temp_UVnzFRl;}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorBufferBindingInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& address_json=json["address"];
[&](){[&](){address_json=member.address;}();}();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorBufferBindingInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& address_json=json["address"];
[&](){uint64_t temp_CULVsIJ;[&](){temp_CULVsIJ=static_cast<uint64_t>(value_to<int>(address_json));}();member.address=(VkDeviceAddress)temp_CULVsIJ;}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_xMTCOae;[&](){temp_xMTCOae=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkBufferUsageFlags)temp_xMTCOae;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorBufferBindingPushDescriptorBufferHandleEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorDataEXT& member){
        
    
auto& pSampler_json=json["pSampler"];
[&](){
            if (member.pSampler==NULL){
                pSampler_json=boost::json::array();
            return; }pSampler_json=boost::json::array(1);
        auto& arr_dMQqpIL=pSampler_json.as_array();
        for(int eHUyqdO=0; eHUyqdO < 1; eHUyqdO++){
            [&](){serialize_VkSampler(arr_dMQqpIL[eHUyqdO],member.pSampler[eHUyqdO]);}();
        }
        }();
auto& pCombinedImageSampler_json=json["pCombinedImageSampler"];
[&](){
            if (member.pCombinedImageSampler==NULL){
                pCombinedImageSampler_json=boost::json::array();
            return; }pCombinedImageSampler_json=boost::json::array(1);
        auto& arr_SFaLpUw=pCombinedImageSampler_json.as_array();
        for(int PCbwOXN=0; PCbwOXN < 1; PCbwOXN++){
            [&](){
            auto& temp=arr_SFaLpUw[PCbwOXN].emplace_object();
            return serialize_struct(temp, member.pCombinedImageSampler[PCbwOXN]);
            }();
        }
        }();
auto& pInputAttachmentImage_json=json["pInputAttachmentImage"];
[&](){
            if (member.pInputAttachmentImage==NULL){
                pInputAttachmentImage_json=boost::json::array();
            return; }pInputAttachmentImage_json=boost::json::array(1);
        auto& arr_JmELAzk=pInputAttachmentImage_json.as_array();
        for(int UtkaHCy=0; UtkaHCy < 1; UtkaHCy++){
            [&](){
            auto& temp=arr_JmELAzk[UtkaHCy].emplace_object();
            return serialize_struct(temp, member.pInputAttachmentImage[UtkaHCy]);
            }();
        }
        }();
auto& pSampledImage_json=json["pSampledImage"];
[&](){
            if (member.pSampledImage==NULL){
                pSampledImage_json=boost::json::array();
            return; }pSampledImage_json=boost::json::array(1);
        auto& arr_qOHCftC=pSampledImage_json.as_array();
        for(int oasCmla=0; oasCmla < 1; oasCmla++){
            [&](){
            auto& temp=arr_qOHCftC[oasCmla].emplace_object();
            return serialize_struct(temp, member.pSampledImage[oasCmla]);
            }();
        }
        }();
auto& pStorageImage_json=json["pStorageImage"];
[&](){
            if (member.pStorageImage==NULL){
                pStorageImage_json=boost::json::array();
            return; }pStorageImage_json=boost::json::array(1);
        auto& arr_pmyozer=pStorageImage_json.as_array();
        for(int cYaYUCx=0; cYaYUCx < 1; cYaYUCx++){
            [&](){
            auto& temp=arr_pmyozer[cYaYUCx].emplace_object();
            return serialize_struct(temp, member.pStorageImage[cYaYUCx]);
            }();
        }
        }();
auto& pUniformTexelBuffer_json=json["pUniformTexelBuffer"];
[&](){
            if (member.pUniformTexelBuffer==NULL){
                pUniformTexelBuffer_json=boost::json::array();
            return; }pUniformTexelBuffer_json=boost::json::array(1);
        auto& arr_OIDlzqo=pUniformTexelBuffer_json.as_array();
        for(int pkFuwJH=0; pkFuwJH < 1; pkFuwJH++){
            [&](){
            auto& temp=arr_OIDlzqo[pkFuwJH].emplace_object();
            return serialize_struct(temp, member.pUniformTexelBuffer[pkFuwJH]);
            }();
        }
        }();
auto& pStorageTexelBuffer_json=json["pStorageTexelBuffer"];
[&](){
            if (member.pStorageTexelBuffer==NULL){
                pStorageTexelBuffer_json=boost::json::array();
            return; }pStorageTexelBuffer_json=boost::json::array(1);
        auto& arr_xtbpyML=pStorageTexelBuffer_json.as_array();
        for(int hVYviCs=0; hVYviCs < 1; hVYviCs++){
            [&](){
            auto& temp=arr_xtbpyML[hVYviCs].emplace_object();
            return serialize_struct(temp, member.pStorageTexelBuffer[hVYviCs]);
            }();
        }
        }();
auto& pUniformBuffer_json=json["pUniformBuffer"];
[&](){
            if (member.pUniformBuffer==NULL){
                pUniformBuffer_json=boost::json::array();
            return; }pUniformBuffer_json=boost::json::array(1);
        auto& arr_kxqZNdO=pUniformBuffer_json.as_array();
        for(int UnVRNnp=0; UnVRNnp < 1; UnVRNnp++){
            [&](){
            auto& temp=arr_kxqZNdO[UnVRNnp].emplace_object();
            return serialize_struct(temp, member.pUniformBuffer[UnVRNnp]);
            }();
        }
        }();
auto& pStorageBuffer_json=json["pStorageBuffer"];
[&](){
            if (member.pStorageBuffer==NULL){
                pStorageBuffer_json=boost::json::array();
            return; }pStorageBuffer_json=boost::json::array(1);
        auto& arr_UxtFGfq=pStorageBuffer_json.as_array();
        for(int dBYVCtY=0; dBYVCtY < 1; dBYVCtY++){
            [&](){
            auto& temp=arr_UxtFGfq[dBYVCtY].emplace_object();
            return serialize_struct(temp, member.pStorageBuffer[dBYVCtY]);
            }();
        }
        }();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){[&](){accelerationStructure_json=member.accelerationStructure;}();}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorDataEXT& member){
auto& pSampler_json=json["pSampler"];
[&](){ VkSampler* temp_QdVroVP;;[&](){
            if (pSampler_json.as_array().size()==0){
                temp_QdVroVP=NULL;
            return; }temp_QdVroVP=(VkSampler*)malloc(1*sizeof(VkSampler));
        auto& arr_EXEGLAG=pSampler_json.as_array();
        for(int bSeTpQc=0; bSeTpQc < 1; bSeTpQc++){
            [&](){deserialize_VkSampler(arr_EXEGLAG[bSeTpQc], temp_QdVroVP[bSeTpQc]);}();
        }
        }();member.pSampler=temp_QdVroVP;}();
auto& pCombinedImageSampler_json=json["pCombinedImageSampler"];
[&](){ VkDescriptorImageInfo* temp_tnowtMF;;[&](){
            if (pCombinedImageSampler_json.as_array().size()==0){
                temp_tnowtMF=NULL;
            return; }temp_tnowtMF=(VkDescriptorImageInfo*)malloc(1*sizeof(VkDescriptorImageInfo));
        auto& arr_JmmIyYp=pCombinedImageSampler_json.as_array();
        for(int PRjnWxB=0; PRjnWxB < 1; PRjnWxB++){
            [&](){
            auto& temp=arr_JmmIyYp[PRjnWxB].as_object();
            deserialize_struct(temp,temp_tnowtMF[PRjnWxB]);
            }();
        }
        }();member.pCombinedImageSampler=temp_tnowtMF;}();
auto& pInputAttachmentImage_json=json["pInputAttachmentImage"];
[&](){ VkDescriptorImageInfo* temp_WYjoOnC;;[&](){
            if (pInputAttachmentImage_json.as_array().size()==0){
                temp_WYjoOnC=NULL;
            return; }temp_WYjoOnC=(VkDescriptorImageInfo*)malloc(1*sizeof(VkDescriptorImageInfo));
        auto& arr_vTPChUU=pInputAttachmentImage_json.as_array();
        for(int UjIDGAR=0; UjIDGAR < 1; UjIDGAR++){
            [&](){
            auto& temp=arr_vTPChUU[UjIDGAR].as_object();
            deserialize_struct(temp,temp_WYjoOnC[UjIDGAR]);
            }();
        }
        }();member.pInputAttachmentImage=temp_WYjoOnC;}();
auto& pSampledImage_json=json["pSampledImage"];
[&](){ VkDescriptorImageInfo* temp_WbYUTqr;;[&](){
            if (pSampledImage_json.as_array().size()==0){
                temp_WbYUTqr=NULL;
            return; }temp_WbYUTqr=(VkDescriptorImageInfo*)malloc(1*sizeof(VkDescriptorImageInfo));
        auto& arr_JgbmhnK=pSampledImage_json.as_array();
        for(int xjGgAYh=0; xjGgAYh < 1; xjGgAYh++){
            [&](){
            auto& temp=arr_JgbmhnK[xjGgAYh].as_object();
            deserialize_struct(temp,temp_WbYUTqr[xjGgAYh]);
            }();
        }
        }();member.pSampledImage=temp_WbYUTqr;}();
auto& pStorageImage_json=json["pStorageImage"];
[&](){ VkDescriptorImageInfo* temp_WmpxPXT;;[&](){
            if (pStorageImage_json.as_array().size()==0){
                temp_WmpxPXT=NULL;
            return; }temp_WmpxPXT=(VkDescriptorImageInfo*)malloc(1*sizeof(VkDescriptorImageInfo));
        auto& arr_OxxDeug=pStorageImage_json.as_array();
        for(int DrSqgtn=0; DrSqgtn < 1; DrSqgtn++){
            [&](){
            auto& temp=arr_OxxDeug[DrSqgtn].as_object();
            deserialize_struct(temp,temp_WmpxPXT[DrSqgtn]);
            }();
        }
        }();member.pStorageImage=temp_WmpxPXT;}();
auto& pUniformTexelBuffer_json=json["pUniformTexelBuffer"];
[&](){ VkDescriptorAddressInfoEXT* temp_eLkxjrJ;;[&](){
            if (pUniformTexelBuffer_json.as_array().size()==0){
                temp_eLkxjrJ=NULL;
            return; }temp_eLkxjrJ=(VkDescriptorAddressInfoEXT*)malloc(1*sizeof(VkDescriptorAddressInfoEXT));
        auto& arr_WnIyiWq=pUniformTexelBuffer_json.as_array();
        for(int gHgWevM=0; gHgWevM < 1; gHgWevM++){
            [&](){
            auto& temp=arr_WnIyiWq[gHgWevM].as_object();
            deserialize_struct(temp,temp_eLkxjrJ[gHgWevM]);
            }();
        }
        }();member.pUniformTexelBuffer=temp_eLkxjrJ;}();
auto& pStorageTexelBuffer_json=json["pStorageTexelBuffer"];
[&](){ VkDescriptorAddressInfoEXT* temp_DRehIiE;;[&](){
            if (pStorageTexelBuffer_json.as_array().size()==0){
                temp_DRehIiE=NULL;
            return; }temp_DRehIiE=(VkDescriptorAddressInfoEXT*)malloc(1*sizeof(VkDescriptorAddressInfoEXT));
        auto& arr_XzcmCdN=pStorageTexelBuffer_json.as_array();
        for(int LkldXNJ=0; LkldXNJ < 1; LkldXNJ++){
            [&](){
            auto& temp=arr_XzcmCdN[LkldXNJ].as_object();
            deserialize_struct(temp,temp_DRehIiE[LkldXNJ]);
            }();
        }
        }();member.pStorageTexelBuffer=temp_DRehIiE;}();
auto& pUniformBuffer_json=json["pUniformBuffer"];
[&](){ VkDescriptorAddressInfoEXT* temp_JTaYVrT;;[&](){
            if (pUniformBuffer_json.as_array().size()==0){
                temp_JTaYVrT=NULL;
            return; }temp_JTaYVrT=(VkDescriptorAddressInfoEXT*)malloc(1*sizeof(VkDescriptorAddressInfoEXT));
        auto& arr_gXebRdt=pUniformBuffer_json.as_array();
        for(int RKNmAqU=0; RKNmAqU < 1; RKNmAqU++){
            [&](){
            auto& temp=arr_gXebRdt[RKNmAqU].as_object();
            deserialize_struct(temp,temp_JTaYVrT[RKNmAqU]);
            }();
        }
        }();member.pUniformBuffer=temp_JTaYVrT;}();
auto& pStorageBuffer_json=json["pStorageBuffer"];
[&](){ VkDescriptorAddressInfoEXT* temp_mvFeUBM;;[&](){
            if (pStorageBuffer_json.as_array().size()==0){
                temp_mvFeUBM=NULL;
            return; }temp_mvFeUBM=(VkDescriptorAddressInfoEXT*)malloc(1*sizeof(VkDescriptorAddressInfoEXT));
        auto& arr_CHPlVox=pStorageBuffer_json.as_array();
        for(int RShyduA=0; RShyduA < 1; RShyduA++){
            [&](){
            auto& temp=arr_CHPlVox[RShyduA].as_object();
            deserialize_struct(temp,temp_mvFeUBM[RShyduA]);
            }();
        }
        }();member.pStorageBuffer=temp_mvFeUBM;}();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){uint64_t temp_QHFtbZQ;[&](){temp_QHFtbZQ=static_cast<uint64_t>(value_to<int>(accelerationStructure_json));}();member.accelerationStructure=(VkDeviceAddress)temp_QHFtbZQ;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorGetInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.emplace_object();
            return serialize_struct(temp, member.data);
            }();
}
void deserialize_struct(boost::json::object& json, VkDescriptorGetInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& type_json=json["type"];
[&](){[&](){int temp_FkFybSO;[&](){temp_FkFybSO=static_cast<int>(value_to<int>(type_json));}();member.type=(VkDescriptorType)temp_FkFybSO;}();}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.as_object();
            deserialize_struct(temp,member.data);
            }();
}

    void serialize_struct(boost::json::object& json, const VkBufferCaptureDescriptorDataInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
}
void deserialize_struct(boost::json::object& json, VkBufferCaptureDescriptorDataInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
}

    void serialize_struct(boost::json::object& json, const VkImageCaptureDescriptorDataInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& image_json=json["image"];
[&](){serialize_VkImage(image_json,member.image);}();
}
void deserialize_struct(boost::json::object& json, VkImageCaptureDescriptorDataInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& image_json=json["image"];
[&](){deserialize_VkImage(image_json, member.image);}();
}

    void serialize_struct(boost::json::object& json, const VkImageViewCaptureDescriptorDataInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageView_json=json["imageView"];
[&](){serialize_VkImageView(imageView_json,member.imageView);}();
}
void deserialize_struct(boost::json::object& json, VkImageViewCaptureDescriptorDataInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& imageView_json=json["imageView"];
[&](){deserialize_VkImageView(imageView_json, member.imageView);}();
}

    void serialize_struct(boost::json::object& json, const VkSamplerCaptureDescriptorDataInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& sampler_json=json["sampler"];
[&](){serialize_VkSampler(sampler_json,member.sampler);}();
}
void deserialize_struct(boost::json::object& json, VkSamplerCaptureDescriptorDataInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& sampler_json=json["sampler"];
[&](){deserialize_VkSampler(sampler_json, member.sampler);}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureCaptureDescriptorDataInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){serialize_VkAccelerationStructureKHR(accelerationStructure_json,member.accelerationStructure);}();
auto& accelerationStructureNV_json=json["accelerationStructureNV"];
[&](){serialize_VkAccelerationStructureNV(accelerationStructureNV_json,member.accelerationStructureNV);}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureCaptureDescriptorDataInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& accelerationStructure_json=json["accelerationStructure"];
[&](){deserialize_VkAccelerationStructureKHR(accelerationStructure_json, member.accelerationStructure);}();
auto& accelerationStructureNV_json=json["accelerationStructureNV"];
[&](){deserialize_VkAccelerationStructureNV(accelerationStructureNV_json, member.accelerationStructureNV);}();
}

    void serialize_struct(boost::json::object& json, const VkOpaqueCaptureDescriptorDataCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& opaqueCaptureDescriptorData_json=json["opaqueCaptureDescriptorData"];
[&](){
            if (member.opaqueCaptureDescriptorData==NULL){
                opaqueCaptureDescriptorData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.opaqueCaptureDescriptorData))==NULL){
                opaqueCaptureDescriptorData_json=boost::json::array();
            return; }opaqueCaptureDescriptorData_json=boost::json::array(strlen(((char*)(member.opaqueCaptureDescriptorData)))+1);
        auto& arr_rVjycpg=opaqueCaptureDescriptorData_json.as_array();
        for(int HRdcEte=0; HRdcEte < strlen(((char*)(member.opaqueCaptureDescriptorData)))+1; HRdcEte++){
            [&](){arr_rVjycpg[HRdcEte]=((char*)(member.opaqueCaptureDescriptorData))[HRdcEte];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkOpaqueCaptureDescriptorDataCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& opaqueCaptureDescriptorData_json=json["opaqueCaptureDescriptorData"];
[&](){ void* temp_DKgMqmE;;[&](){
            if (opaqueCaptureDescriptorData_json.as_array().size()==0){
                temp_DKgMqmE=NULL;
            return; }char* temp_oilqpwP;[&](){
            if (opaqueCaptureDescriptorData_json.as_array().size()==0){
                temp_oilqpwP=NULL;
            return; }temp_oilqpwP=(char*)malloc(opaqueCaptureDescriptorData_json.as_array().size()*sizeof(char));
        auto& arr_sEKzMyF=opaqueCaptureDescriptorData_json.as_array();
        for(int GdODMOR=0; GdODMOR < opaqueCaptureDescriptorData_json.as_array().size(); GdODMOR++){
            [&](){temp_oilqpwP[GdODMOR]=static_cast<char>(value_to<int>(arr_sEKzMyF[GdODMOR]));}();
        }
        }();temp_DKgMqmE=temp_oilqpwP;}();member.opaqueCaptureDescriptorData=temp_DKgMqmE;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderIntegerDotProductFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderIntegerDotProduct_json=json["shaderIntegerDotProduct"];
[&](){[&](){shaderIntegerDotProduct_json=member.shaderIntegerDotProduct;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderIntegerDotProductFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderIntegerDotProduct_json=json["shaderIntegerDotProduct"];
[&](){uint32_t temp_eNUMtoL;[&](){temp_eNUMtoL=static_cast<uint32_t>(value_to<int>(shaderIntegerDotProduct_json));}();member.shaderIntegerDotProduct=(VkBool32)temp_eNUMtoL;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderIntegerDotProductProperties& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& integerDotProduct8BitUnsignedAccelerated_json=json["integerDotProduct8BitUnsignedAccelerated"];
[&](){[&](){integerDotProduct8BitUnsignedAccelerated_json=member.integerDotProduct8BitUnsignedAccelerated;}();}();
auto& integerDotProduct8BitSignedAccelerated_json=json["integerDotProduct8BitSignedAccelerated"];
[&](){[&](){integerDotProduct8BitSignedAccelerated_json=member.integerDotProduct8BitSignedAccelerated;}();}();
auto& integerDotProduct8BitMixedSignednessAccelerated_json=json["integerDotProduct8BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct8BitMixedSignednessAccelerated_json=member.integerDotProduct8BitMixedSignednessAccelerated;}();}();
auto& integerDotProduct4x8BitPackedUnsignedAccelerated_json=json["integerDotProduct4x8BitPackedUnsignedAccelerated"];
[&](){[&](){integerDotProduct4x8BitPackedUnsignedAccelerated_json=member.integerDotProduct4x8BitPackedUnsignedAccelerated;}();}();
auto& integerDotProduct4x8BitPackedSignedAccelerated_json=json["integerDotProduct4x8BitPackedSignedAccelerated"];
[&](){[&](){integerDotProduct4x8BitPackedSignedAccelerated_json=member.integerDotProduct4x8BitPackedSignedAccelerated;}();}();
auto& integerDotProduct4x8BitPackedMixedSignednessAccelerated_json=json["integerDotProduct4x8BitPackedMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct4x8BitPackedMixedSignednessAccelerated_json=member.integerDotProduct4x8BitPackedMixedSignednessAccelerated;}();}();
auto& integerDotProduct16BitUnsignedAccelerated_json=json["integerDotProduct16BitUnsignedAccelerated"];
[&](){[&](){integerDotProduct16BitUnsignedAccelerated_json=member.integerDotProduct16BitUnsignedAccelerated;}();}();
auto& integerDotProduct16BitSignedAccelerated_json=json["integerDotProduct16BitSignedAccelerated"];
[&](){[&](){integerDotProduct16BitSignedAccelerated_json=member.integerDotProduct16BitSignedAccelerated;}();}();
auto& integerDotProduct16BitMixedSignednessAccelerated_json=json["integerDotProduct16BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct16BitMixedSignednessAccelerated_json=member.integerDotProduct16BitMixedSignednessAccelerated;}();}();
auto& integerDotProduct32BitUnsignedAccelerated_json=json["integerDotProduct32BitUnsignedAccelerated"];
[&](){[&](){integerDotProduct32BitUnsignedAccelerated_json=member.integerDotProduct32BitUnsignedAccelerated;}();}();
auto& integerDotProduct32BitSignedAccelerated_json=json["integerDotProduct32BitSignedAccelerated"];
[&](){[&](){integerDotProduct32BitSignedAccelerated_json=member.integerDotProduct32BitSignedAccelerated;}();}();
auto& integerDotProduct32BitMixedSignednessAccelerated_json=json["integerDotProduct32BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct32BitMixedSignednessAccelerated_json=member.integerDotProduct32BitMixedSignednessAccelerated;}();}();
auto& integerDotProduct64BitUnsignedAccelerated_json=json["integerDotProduct64BitUnsignedAccelerated"];
[&](){[&](){integerDotProduct64BitUnsignedAccelerated_json=member.integerDotProduct64BitUnsignedAccelerated;}();}();
auto& integerDotProduct64BitSignedAccelerated_json=json["integerDotProduct64BitSignedAccelerated"];
[&](){[&](){integerDotProduct64BitSignedAccelerated_json=member.integerDotProduct64BitSignedAccelerated;}();}();
auto& integerDotProduct64BitMixedSignednessAccelerated_json=json["integerDotProduct64BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProduct64BitMixedSignednessAccelerated_json=member.integerDotProduct64BitMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating8BitUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating8BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating8BitSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating8BitSignedAccelerated_json=member.integerDotProductAccumulatingSaturating8BitSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_json=member.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating16BitUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating16BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating16BitSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating16BitSignedAccelerated_json=member.integerDotProductAccumulatingSaturating16BitSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating32BitUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating32BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating32BitSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating32BitSignedAccelerated_json=member.integerDotProductAccumulatingSaturating32BitSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating64BitUnsignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_json=member.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating64BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating64BitSignedAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating64BitSignedAccelerated_json=member.integerDotProductAccumulatingSaturating64BitSignedAccelerated;}();}();
auto& integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated"];
[&](){[&](){integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_json=member.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderIntegerDotProductProperties& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& integerDotProduct8BitUnsignedAccelerated_json=json["integerDotProduct8BitUnsignedAccelerated"];
[&](){uint32_t temp_fDqbRQt;[&](){temp_fDqbRQt=static_cast<uint32_t>(value_to<int>(integerDotProduct8BitUnsignedAccelerated_json));}();member.integerDotProduct8BitUnsignedAccelerated=(VkBool32)temp_fDqbRQt;}();
auto& integerDotProduct8BitSignedAccelerated_json=json["integerDotProduct8BitSignedAccelerated"];
[&](){uint32_t temp_OVVZAzm;[&](){temp_OVVZAzm=static_cast<uint32_t>(value_to<int>(integerDotProduct8BitSignedAccelerated_json));}();member.integerDotProduct8BitSignedAccelerated=(VkBool32)temp_OVVZAzm;}();
auto& integerDotProduct8BitMixedSignednessAccelerated_json=json["integerDotProduct8BitMixedSignednessAccelerated"];
[&](){uint32_t temp_ZPpCkIW;[&](){temp_ZPpCkIW=static_cast<uint32_t>(value_to<int>(integerDotProduct8BitMixedSignednessAccelerated_json));}();member.integerDotProduct8BitMixedSignednessAccelerated=(VkBool32)temp_ZPpCkIW;}();
auto& integerDotProduct4x8BitPackedUnsignedAccelerated_json=json["integerDotProduct4x8BitPackedUnsignedAccelerated"];
[&](){uint32_t temp_QQSXkLc;[&](){temp_QQSXkLc=static_cast<uint32_t>(value_to<int>(integerDotProduct4x8BitPackedUnsignedAccelerated_json));}();member.integerDotProduct4x8BitPackedUnsignedAccelerated=(VkBool32)temp_QQSXkLc;}();
auto& integerDotProduct4x8BitPackedSignedAccelerated_json=json["integerDotProduct4x8BitPackedSignedAccelerated"];
[&](){uint32_t temp_hjLzHHu;[&](){temp_hjLzHHu=static_cast<uint32_t>(value_to<int>(integerDotProduct4x8BitPackedSignedAccelerated_json));}();member.integerDotProduct4x8BitPackedSignedAccelerated=(VkBool32)temp_hjLzHHu;}();
auto& integerDotProduct4x8BitPackedMixedSignednessAccelerated_json=json["integerDotProduct4x8BitPackedMixedSignednessAccelerated"];
[&](){uint32_t temp_iTsrloW;[&](){temp_iTsrloW=static_cast<uint32_t>(value_to<int>(integerDotProduct4x8BitPackedMixedSignednessAccelerated_json));}();member.integerDotProduct4x8BitPackedMixedSignednessAccelerated=(VkBool32)temp_iTsrloW;}();
auto& integerDotProduct16BitUnsignedAccelerated_json=json["integerDotProduct16BitUnsignedAccelerated"];
[&](){uint32_t temp_RlYaNQJ;[&](){temp_RlYaNQJ=static_cast<uint32_t>(value_to<int>(integerDotProduct16BitUnsignedAccelerated_json));}();member.integerDotProduct16BitUnsignedAccelerated=(VkBool32)temp_RlYaNQJ;}();
auto& integerDotProduct16BitSignedAccelerated_json=json["integerDotProduct16BitSignedAccelerated"];
[&](){uint32_t temp_oazBVOM;[&](){temp_oazBVOM=static_cast<uint32_t>(value_to<int>(integerDotProduct16BitSignedAccelerated_json));}();member.integerDotProduct16BitSignedAccelerated=(VkBool32)temp_oazBVOM;}();
auto& integerDotProduct16BitMixedSignednessAccelerated_json=json["integerDotProduct16BitMixedSignednessAccelerated"];
[&](){uint32_t temp_VtDSaBh;[&](){temp_VtDSaBh=static_cast<uint32_t>(value_to<int>(integerDotProduct16BitMixedSignednessAccelerated_json));}();member.integerDotProduct16BitMixedSignednessAccelerated=(VkBool32)temp_VtDSaBh;}();
auto& integerDotProduct32BitUnsignedAccelerated_json=json["integerDotProduct32BitUnsignedAccelerated"];
[&](){uint32_t temp_mQdwEcH;[&](){temp_mQdwEcH=static_cast<uint32_t>(value_to<int>(integerDotProduct32BitUnsignedAccelerated_json));}();member.integerDotProduct32BitUnsignedAccelerated=(VkBool32)temp_mQdwEcH;}();
auto& integerDotProduct32BitSignedAccelerated_json=json["integerDotProduct32BitSignedAccelerated"];
[&](){uint32_t temp_fZyGLve;[&](){temp_fZyGLve=static_cast<uint32_t>(value_to<int>(integerDotProduct32BitSignedAccelerated_json));}();member.integerDotProduct32BitSignedAccelerated=(VkBool32)temp_fZyGLve;}();
auto& integerDotProduct32BitMixedSignednessAccelerated_json=json["integerDotProduct32BitMixedSignednessAccelerated"];
[&](){uint32_t temp_rOzQkzt;[&](){temp_rOzQkzt=static_cast<uint32_t>(value_to<int>(integerDotProduct32BitMixedSignednessAccelerated_json));}();member.integerDotProduct32BitMixedSignednessAccelerated=(VkBool32)temp_rOzQkzt;}();
auto& integerDotProduct64BitUnsignedAccelerated_json=json["integerDotProduct64BitUnsignedAccelerated"];
[&](){uint32_t temp_cibSbVP;[&](){temp_cibSbVP=static_cast<uint32_t>(value_to<int>(integerDotProduct64BitUnsignedAccelerated_json));}();member.integerDotProduct64BitUnsignedAccelerated=(VkBool32)temp_cibSbVP;}();
auto& integerDotProduct64BitSignedAccelerated_json=json["integerDotProduct64BitSignedAccelerated"];
[&](){uint32_t temp_wxUhdFT;[&](){temp_wxUhdFT=static_cast<uint32_t>(value_to<int>(integerDotProduct64BitSignedAccelerated_json));}();member.integerDotProduct64BitSignedAccelerated=(VkBool32)temp_wxUhdFT;}();
auto& integerDotProduct64BitMixedSignednessAccelerated_json=json["integerDotProduct64BitMixedSignednessAccelerated"];
[&](){uint32_t temp_gyfEcYC;[&](){temp_gyfEcYC=static_cast<uint32_t>(value_to<int>(integerDotProduct64BitMixedSignednessAccelerated_json));}();member.integerDotProduct64BitMixedSignednessAccelerated=(VkBool32)temp_gyfEcYC;}();
auto& integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating8BitUnsignedAccelerated"];
[&](){uint32_t temp_TMcyhrX;[&](){temp_TMcyhrX=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating8BitUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated=(VkBool32)temp_TMcyhrX;}();
auto& integerDotProductAccumulatingSaturating8BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating8BitSignedAccelerated"];
[&](){uint32_t temp_LeRvzBX;[&](){temp_LeRvzBX=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating8BitSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating8BitSignedAccelerated=(VkBool32)temp_LeRvzBX;}();
auto& integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated"];
[&](){uint32_t temp_jHhlRkW;[&](){temp_jHhlRkW=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated=(VkBool32)temp_jHhlRkW;}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated"];
[&](){uint32_t temp_FndoQSL;[&](){temp_FndoQSL=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated=(VkBool32)temp_FndoQSL;}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated"];
[&](){uint32_t temp_thuQCSE;[&](){temp_thuQCSE=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated=(VkBool32)temp_thuQCSE;}();
auto& integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated"];
[&](){uint32_t temp_VHhaQJU;[&](){temp_VHhaQJU=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated=(VkBool32)temp_VHhaQJU;}();
auto& integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating16BitUnsignedAccelerated"];
[&](){uint32_t temp_acIgfMM;[&](){temp_acIgfMM=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating16BitUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated=(VkBool32)temp_acIgfMM;}();
auto& integerDotProductAccumulatingSaturating16BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating16BitSignedAccelerated"];
[&](){uint32_t temp_HuYqlMi;[&](){temp_HuYqlMi=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating16BitSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating16BitSignedAccelerated=(VkBool32)temp_HuYqlMi;}();
auto& integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated"];
[&](){uint32_t temp_EWNFIGo;[&](){temp_EWNFIGo=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated=(VkBool32)temp_EWNFIGo;}();
auto& integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating32BitUnsignedAccelerated"];
[&](){uint32_t temp_eNRVwFh;[&](){temp_eNRVwFh=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating32BitUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated=(VkBool32)temp_eNRVwFh;}();
auto& integerDotProductAccumulatingSaturating32BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating32BitSignedAccelerated"];
[&](){uint32_t temp_GYmnmmW;[&](){temp_GYmnmmW=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating32BitSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating32BitSignedAccelerated=(VkBool32)temp_GYmnmmW;}();
auto& integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated"];
[&](){uint32_t temp_ejWvqPb;[&](){temp_ejWvqPb=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated=(VkBool32)temp_ejWvqPb;}();
auto& integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_json=json["integerDotProductAccumulatingSaturating64BitUnsignedAccelerated"];
[&](){uint32_t temp_KxIXIXe;[&](){temp_KxIXIXe=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating64BitUnsignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated=(VkBool32)temp_KxIXIXe;}();
auto& integerDotProductAccumulatingSaturating64BitSignedAccelerated_json=json["integerDotProductAccumulatingSaturating64BitSignedAccelerated"];
[&](){uint32_t temp_gmviEte;[&](){temp_gmviEte=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating64BitSignedAccelerated_json));}();member.integerDotProductAccumulatingSaturating64BitSignedAccelerated=(VkBool32)temp_gmviEte;}();
auto& integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_json=json["integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated"];
[&](){uint32_t temp_fOGFkYs;[&](){temp_fOGFkYs=static_cast<uint32_t>(value_to<int>(integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated_json));}();member.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated=(VkBool32)temp_fOGFkYs;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDrmPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& hasPrimary_json=json["hasPrimary"];
[&](){[&](){hasPrimary_json=member.hasPrimary;}();}();
auto& hasRender_json=json["hasRender"];
[&](){[&](){hasRender_json=member.hasRender;}();}();
auto& primaryMajor_json=json["primaryMajor"];
[&](){primaryMajor_json=member.primaryMajor;}();
auto& primaryMinor_json=json["primaryMinor"];
[&](){primaryMinor_json=member.primaryMinor;}();
auto& renderMajor_json=json["renderMajor"];
[&](){renderMajor_json=member.renderMajor;}();
auto& renderMinor_json=json["renderMinor"];
[&](){renderMinor_json=member.renderMinor;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDrmPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& hasPrimary_json=json["hasPrimary"];
[&](){uint32_t temp_QPxQZmD;[&](){temp_QPxQZmD=static_cast<uint32_t>(value_to<int>(hasPrimary_json));}();member.hasPrimary=(VkBool32)temp_QPxQZmD;}();
auto& hasRender_json=json["hasRender"];
[&](){uint32_t temp_MCdmIuA;[&](){temp_MCdmIuA=static_cast<uint32_t>(value_to<int>(hasRender_json));}();member.hasRender=(VkBool32)temp_MCdmIuA;}();
auto& primaryMajor_json=json["primaryMajor"];
[&](){member.primaryMajor=static_cast<int64_t>(value_to<int>(primaryMajor_json));}();
auto& primaryMinor_json=json["primaryMinor"];
[&](){member.primaryMinor=static_cast<int64_t>(value_to<int>(primaryMinor_json));}();
auto& renderMajor_json=json["renderMajor"];
[&](){member.renderMajor=static_cast<int64_t>(value_to<int>(renderMajor_json));}();
auto& renderMinor_json=json["renderMinor"];
[&](){member.renderMinor=static_cast<int64_t>(value_to<int>(renderMinor_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& fragmentShaderBarycentric_json=json["fragmentShaderBarycentric"];
[&](){[&](){fragmentShaderBarycentric_json=member.fragmentShaderBarycentric;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& fragmentShaderBarycentric_json=json["fragmentShaderBarycentric"];
[&](){uint32_t temp_bFHQLPo;[&](){temp_bFHQLPo=static_cast<uint32_t>(value_to<int>(fragmentShaderBarycentric_json));}();member.fragmentShaderBarycentric=(VkBool32)temp_bFHQLPo;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& triStripVertexOrderIndependentOfProvokingVertex_json=json["triStripVertexOrderIndependentOfProvokingVertex"];
[&](){[&](){triStripVertexOrderIndependentOfProvokingVertex_json=member.triStripVertexOrderIndependentOfProvokingVertex;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& triStripVertexOrderIndependentOfProvokingVertex_json=json["triStripVertexOrderIndependentOfProvokingVertex"];
[&](){uint32_t temp_ufcntQu;[&](){temp_ufcntQu=static_cast<uint32_t>(value_to<int>(triStripVertexOrderIndependentOfProvokingVertex_json));}();member.triStripVertexOrderIndependentOfProvokingVertex=(VkBool32)temp_ufcntQu;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rayTracingMotionBlur_json=json["rayTracingMotionBlur"];
[&](){[&](){rayTracingMotionBlur_json=member.rayTracingMotionBlur;}();}();
auto& rayTracingMotionBlurPipelineTraceRaysIndirect_json=json["rayTracingMotionBlurPipelineTraceRaysIndirect"];
[&](){[&](){rayTracingMotionBlurPipelineTraceRaysIndirect_json=member.rayTracingMotionBlurPipelineTraceRaysIndirect;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& rayTracingMotionBlur_json=json["rayTracingMotionBlur"];
[&](){uint32_t temp_hisUNZW;[&](){temp_hisUNZW=static_cast<uint32_t>(value_to<int>(rayTracingMotionBlur_json));}();member.rayTracingMotionBlur=(VkBool32)temp_hisUNZW;}();
auto& rayTracingMotionBlurPipelineTraceRaysIndirect_json=json["rayTracingMotionBlurPipelineTraceRaysIndirect"];
[&](){uint32_t temp_ztudyfh;[&](){temp_ztudyfh=static_cast<uint32_t>(value_to<int>(rayTracingMotionBlurPipelineTraceRaysIndirect_json));}();member.rayTracingMotionBlurPipelineTraceRaysIndirect=(VkBool32)temp_ztudyfh;}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureGeometryMotionTrianglesDataNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& vertexData_json=json["vertexData"];
[&](){
            auto& temp=vertexData_json.emplace_object();
            return serialize_struct(temp, member.vertexData);
            }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureGeometryMotionTrianglesDataNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& vertexData_json=json["vertexData"];
[&](){
            auto& temp=vertexData_json.as_object();
            deserialize_struct(temp,member.vertexData);
            }();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureMotionInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxInstances_json=json["maxInstances"];
[&](){maxInstances_json=member.maxInstances;}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureMotionInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& maxInstances_json=json["maxInstances"];
[&](){member.maxInstances=static_cast<uint32_t>(value_to<int>(maxInstances_json));}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_HfCnMtd;[&](){temp_HfCnMtd=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkAccelerationStructureMotionInfoFlagsNV)temp_HfCnMtd;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSRTDataNV& member){
        
    
auto& sx_json=json["sx"];
[&](){sx_json=member.sx;}();
auto& a_json=json["a"];
[&](){a_json=member.a;}();
auto& b_json=json["b"];
[&](){b_json=member.b;}();
auto& pvx_json=json["pvx"];
[&](){pvx_json=member.pvx;}();
auto& sy_json=json["sy"];
[&](){sy_json=member.sy;}();
auto& c_json=json["c"];
[&](){c_json=member.c;}();
auto& pvy_json=json["pvy"];
[&](){pvy_json=member.pvy;}();
auto& sz_json=json["sz"];
[&](){sz_json=member.sz;}();
auto& pvz_json=json["pvz"];
[&](){pvz_json=member.pvz;}();
auto& qx_json=json["qx"];
[&](){qx_json=member.qx;}();
auto& qy_json=json["qy"];
[&](){qy_json=member.qy;}();
auto& qz_json=json["qz"];
[&](){qz_json=member.qz;}();
auto& qw_json=json["qw"];
[&](){qw_json=member.qw;}();
auto& tx_json=json["tx"];
[&](){tx_json=member.tx;}();
auto& ty_json=json["ty"];
[&](){ty_json=member.ty;}();
auto& tz_json=json["tz"];
[&](){tz_json=member.tz;}();
}
void deserialize_struct(boost::json::object& json, VkSRTDataNV& member){
auto& sx_json=json["sx"];
[&](){member.sx=static_cast<float>(value_to<int>(sx_json));}();
auto& a_json=json["a"];
[&](){member.a=static_cast<float>(value_to<int>(a_json));}();
auto& b_json=json["b"];
[&](){member.b=static_cast<float>(value_to<int>(b_json));}();
auto& pvx_json=json["pvx"];
[&](){member.pvx=static_cast<float>(value_to<int>(pvx_json));}();
auto& sy_json=json["sy"];
[&](){member.sy=static_cast<float>(value_to<int>(sy_json));}();
auto& c_json=json["c"];
[&](){member.c=static_cast<float>(value_to<int>(c_json));}();
auto& pvy_json=json["pvy"];
[&](){member.pvy=static_cast<float>(value_to<int>(pvy_json));}();
auto& sz_json=json["sz"];
[&](){member.sz=static_cast<float>(value_to<int>(sz_json));}();
auto& pvz_json=json["pvz"];
[&](){member.pvz=static_cast<float>(value_to<int>(pvz_json));}();
auto& qx_json=json["qx"];
[&](){member.qx=static_cast<float>(value_to<int>(qx_json));}();
auto& qy_json=json["qy"];
[&](){member.qy=static_cast<float>(value_to<int>(qy_json));}();
auto& qz_json=json["qz"];
[&](){member.qz=static_cast<float>(value_to<int>(qz_json));}();
auto& qw_json=json["qw"];
[&](){member.qw=static_cast<float>(value_to<int>(qw_json));}();
auto& tx_json=json["tx"];
[&](){member.tx=static_cast<float>(value_to<int>(tx_json));}();
auto& ty_json=json["ty"];
[&](){member.ty=static_cast<float>(value_to<int>(ty_json));}();
auto& tz_json=json["tz"];
[&](){member.tz=static_cast<float>(value_to<int>(tz_json));}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureSRTMotionInstanceNV& member){
        
    
auto& transformT0_json=json["transformT0"];
[&](){
            auto& temp=transformT0_json.emplace_object();
            return serialize_struct(temp, member.transformT0);
            }();
auto& transformT1_json=json["transformT1"];
[&](){
            auto& temp=transformT1_json.emplace_object();
            return serialize_struct(temp, member.transformT1);
            }();
auto& instanceCustomIndex_json=json["instanceCustomIndex"];
[&](){instanceCustomIndex_json=member.instanceCustomIndex;}();
auto& mask_json=json["mask"];
[&](){mask_json=member.mask;}();
auto& instanceShaderBindingTableRecordOffset_json=json["instanceShaderBindingTableRecordOffset"];
[&](){instanceShaderBindingTableRecordOffset_json=member.instanceShaderBindingTableRecordOffset;}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& accelerationStructureReference_json=json["accelerationStructureReference"];
[&](){accelerationStructureReference_json=member.accelerationStructureReference;}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureSRTMotionInstanceNV& member){
auto& transformT0_json=json["transformT0"];
[&](){
            auto& temp=transformT0_json.as_object();
            deserialize_struct(temp,member.transformT0);
            }();
auto& transformT1_json=json["transformT1"];
[&](){
            auto& temp=transformT1_json.as_object();
            deserialize_struct(temp,member.transformT1);
            }();
auto& instanceCustomIndex_json=json["instanceCustomIndex"];
[&](){member.instanceCustomIndex=static_cast<uint32_t>(value_to<int>(instanceCustomIndex_json));}();
auto& mask_json=json["mask"];
[&](){member.mask=static_cast<uint32_t>(value_to<int>(mask_json));}();
auto& instanceShaderBindingTableRecordOffset_json=json["instanceShaderBindingTableRecordOffset"];
[&](){member.instanceShaderBindingTableRecordOffset=static_cast<uint32_t>(value_to<int>(instanceShaderBindingTableRecordOffset_json));}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_PyNGaXN;[&](){temp_PyNGaXN=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkGeometryInstanceFlagsKHR)temp_PyNGaXN;}();}();
auto& accelerationStructureReference_json=json["accelerationStructureReference"];
[&](){member.accelerationStructureReference=static_cast<uint64_t>(value_to<int>(accelerationStructureReference_json));}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureMatrixMotionInstanceNV& member){
        
    
auto& transformT0_json=json["transformT0"];
[&](){
            auto& temp=transformT0_json.emplace_object();
            return serialize_struct(temp, member.transformT0);
            }();
auto& transformT1_json=json["transformT1"];
[&](){
            auto& temp=transformT1_json.emplace_object();
            return serialize_struct(temp, member.transformT1);
            }();
auto& instanceCustomIndex_json=json["instanceCustomIndex"];
[&](){instanceCustomIndex_json=member.instanceCustomIndex;}();
auto& mask_json=json["mask"];
[&](){mask_json=member.mask;}();
auto& instanceShaderBindingTableRecordOffset_json=json["instanceShaderBindingTableRecordOffset"];
[&](){instanceShaderBindingTableRecordOffset_json=member.instanceShaderBindingTableRecordOffset;}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& accelerationStructureReference_json=json["accelerationStructureReference"];
[&](){accelerationStructureReference_json=member.accelerationStructureReference;}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureMatrixMotionInstanceNV& member){
auto& transformT0_json=json["transformT0"];
[&](){
            auto& temp=transformT0_json.as_object();
            deserialize_struct(temp,member.transformT0);
            }();
auto& transformT1_json=json["transformT1"];
[&](){
            auto& temp=transformT1_json.as_object();
            deserialize_struct(temp,member.transformT1);
            }();
auto& instanceCustomIndex_json=json["instanceCustomIndex"];
[&](){member.instanceCustomIndex=static_cast<uint32_t>(value_to<int>(instanceCustomIndex_json));}();
auto& mask_json=json["mask"];
[&](){member.mask=static_cast<uint32_t>(value_to<int>(mask_json));}();
auto& instanceShaderBindingTableRecordOffset_json=json["instanceShaderBindingTableRecordOffset"];
[&](){member.instanceShaderBindingTableRecordOffset=static_cast<uint32_t>(value_to<int>(instanceShaderBindingTableRecordOffset_json));}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_PyNGaXN;[&](){temp_PyNGaXN=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkGeometryInstanceFlagsKHR)temp_PyNGaXN;}();}();
auto& accelerationStructureReference_json=json["accelerationStructureReference"];
[&](){member.accelerationStructureReference=static_cast<uint64_t>(value_to<int>(accelerationStructureReference_json));}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureMotionInstanceDataNV& member){
        
    
auto& staticInstance_json=json["staticInstance"];
[&](){
            auto& temp=staticInstance_json.emplace_object();
            return serialize_struct(temp, member.staticInstance);
            }();
auto& matrixMotionInstance_json=json["matrixMotionInstance"];
[&](){
            auto& temp=matrixMotionInstance_json.emplace_object();
            return serialize_struct(temp, member.matrixMotionInstance);
            }();
auto& srtMotionInstance_json=json["srtMotionInstance"];
[&](){
            auto& temp=srtMotionInstance_json.emplace_object();
            return serialize_struct(temp, member.srtMotionInstance);
            }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureMotionInstanceDataNV& member){
auto& staticInstance_json=json["staticInstance"];
[&](){
            auto& temp=staticInstance_json.as_object();
            deserialize_struct(temp,member.staticInstance);
            }();
auto& matrixMotionInstance_json=json["matrixMotionInstance"];
[&](){
            auto& temp=matrixMotionInstance_json.as_object();
            deserialize_struct(temp,member.matrixMotionInstance);
            }();
auto& srtMotionInstance_json=json["srtMotionInstance"];
[&](){
            auto& temp=srtMotionInstance_json.as_object();
            deserialize_struct(temp,member.srtMotionInstance);
            }();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureMotionInstanceNV& member){
        
    
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.emplace_object();
            return serialize_struct(temp, member.data);
            }();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureMotionInstanceNV& member){
auto& type_json=json["type"];
[&](){[&](){int temp_ZtWFRep;[&](){temp_ZtWFRep=static_cast<int>(value_to<int>(type_json));}();member.type=(VkAccelerationStructureMotionInstanceTypeNV)temp_ZtWFRep;}();}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_sncnARe;[&](){temp_sncnARe=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkAccelerationStructureMotionInstanceFlagsNV)temp_sncnARe;}();}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.as_object();
            deserialize_struct(temp,member.data);
            }();
}

    void serialize_struct(boost::json::object& json, const VkMemoryGetRemoteAddressInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& handleType_json=json["handleType"];
[&](){[&](){[&](){handleType_json=member.handleType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkMemoryGetRemoteAddressInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& handleType_json=json["handleType"];
[&](){[&](){int temp_eyKBrDS;[&](){temp_eyKBrDS=static_cast<int>(value_to<int>(handleType_json));}();member.handleType=(VkExternalMemoryHandleTypeFlagBits)temp_eyKBrDS;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& formatRgba10x6WithoutYCbCrSampler_json=json["formatRgba10x6WithoutYCbCrSampler"];
[&](){[&](){formatRgba10x6WithoutYCbCrSampler_json=member.formatRgba10x6WithoutYCbCrSampler;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& formatRgba10x6WithoutYCbCrSampler_json=json["formatRgba10x6WithoutYCbCrSampler"];
[&](){uint32_t temp_XiusMYj;[&](){temp_XiusMYj=static_cast<uint32_t>(value_to<int>(formatRgba10x6WithoutYCbCrSampler_json));}();member.formatRgba10x6WithoutYCbCrSampler=(VkBool32)temp_XiusMYj;}();
}

    void serialize_struct(boost::json::object& json, const VkFormatProperties3& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& linearTilingFeatures_json=json["linearTilingFeatures"];
[&](){[&](){[&](){linearTilingFeatures_json=member.linearTilingFeatures;}();}();}();
auto& optimalTilingFeatures_json=json["optimalTilingFeatures"];
[&](){[&](){[&](){optimalTilingFeatures_json=member.optimalTilingFeatures;}();}();}();
auto& bufferFeatures_json=json["bufferFeatures"];
[&](){[&](){[&](){bufferFeatures_json=member.bufferFeatures;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkFormatProperties3& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& linearTilingFeatures_json=json["linearTilingFeatures"];
[&](){[&](){int temp_Qxdrffs;[&](){temp_Qxdrffs=static_cast<int>(value_to<int>(linearTilingFeatures_json));}();member.linearTilingFeatures=(VkFormatFeatureFlags2)temp_Qxdrffs;}();}();
auto& optimalTilingFeatures_json=json["optimalTilingFeatures"];
[&](){[&](){int temp_JJLpDEP;[&](){temp_JJLpDEP=static_cast<int>(value_to<int>(optimalTilingFeatures_json));}();member.optimalTilingFeatures=(VkFormatFeatureFlags2)temp_JJLpDEP;}();}();
auto& bufferFeatures_json=json["bufferFeatures"];
[&](){[&](){int temp_sOWcKLJ;[&](){temp_sOWcKLJ=static_cast<int>(value_to<int>(bufferFeatures_json));}();member.bufferFeatures=(VkFormatFeatureFlags2)temp_sOWcKLJ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDrmFormatModifierPropertiesList2EXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& drmFormatModifierCount_json=json["drmFormatModifierCount"];
[&](){drmFormatModifierCount_json=member.drmFormatModifierCount;}();
auto& pDrmFormatModifierProperties_json=json["pDrmFormatModifierProperties"];
[&](){
            if (member.pDrmFormatModifierProperties==NULL){
                pDrmFormatModifierProperties_json=boost::json::array();
            return; }pDrmFormatModifierProperties_json=boost::json::array(member.drmFormatModifierCount);
        auto& arr_IlDDRWk=pDrmFormatModifierProperties_json.as_array();
        for(int fYwCOAr=0; fYwCOAr < member.drmFormatModifierCount; fYwCOAr++){
            [&](){
            auto& temp=arr_IlDDRWk[fYwCOAr].emplace_object();
            return serialize_struct(temp, member.pDrmFormatModifierProperties[fYwCOAr]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDrmFormatModifierPropertiesList2EXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& drmFormatModifierCount_json=json["drmFormatModifierCount"];
[&](){member.drmFormatModifierCount=static_cast<uint32_t>(value_to<int>(drmFormatModifierCount_json));}();
auto& pDrmFormatModifierProperties_json=json["pDrmFormatModifierProperties"];
[&](){
            if (pDrmFormatModifierProperties_json.as_array().size()==0){
                member.pDrmFormatModifierProperties=NULL;
            return; }member.pDrmFormatModifierProperties=(VkDrmFormatModifierProperties2EXT*)malloc(member.drmFormatModifierCount*sizeof(VkDrmFormatModifierProperties2EXT));
        auto& arr_IlDDRWk=pDrmFormatModifierProperties_json.as_array();
        for(int fYwCOAr=0; fYwCOAr < member.drmFormatModifierCount; fYwCOAr++){
            [&](){
            auto& temp=arr_IlDDRWk[fYwCOAr].as_object();
            deserialize_struct(temp,member.pDrmFormatModifierProperties[fYwCOAr]);
            }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkDrmFormatModifierProperties2EXT& member){
        
    
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){drmFormatModifier_json=member.drmFormatModifier;}();
auto& drmFormatModifierPlaneCount_json=json["drmFormatModifierPlaneCount"];
[&](){drmFormatModifierPlaneCount_json=member.drmFormatModifierPlaneCount;}();
auto& drmFormatModifierTilingFeatures_json=json["drmFormatModifierTilingFeatures"];
[&](){[&](){[&](){drmFormatModifierTilingFeatures_json=member.drmFormatModifierTilingFeatures;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDrmFormatModifierProperties2EXT& member){
auto& drmFormatModifier_json=json["drmFormatModifier"];
[&](){member.drmFormatModifier=static_cast<uint64_t>(value_to<int>(drmFormatModifier_json));}();
auto& drmFormatModifierPlaneCount_json=json["drmFormatModifierPlaneCount"];
[&](){member.drmFormatModifierPlaneCount=static_cast<uint32_t>(value_to<int>(drmFormatModifierPlaneCount_json));}();
auto& drmFormatModifierTilingFeatures_json=json["drmFormatModifierTilingFeatures"];
[&](){[&](){int temp_mQGVQdL;[&](){temp_mQGVQdL=static_cast<int>(value_to<int>(drmFormatModifierTilingFeatures_json));}();member.drmFormatModifierTilingFeatures=(VkFormatFeatureFlags2)temp_mQGVQdL;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRenderingCreateInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& viewMask_json=json["viewMask"];
[&](){viewMask_json=member.viewMask;}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){colorAttachmentCount_json=member.colorAttachmentCount;}();
auto& pColorAttachmentFormats_json=json["pColorAttachmentFormats"];
[&](){
            if (member.pColorAttachmentFormats==NULL){
                pColorAttachmentFormats_json=boost::json::array();
            return; }pColorAttachmentFormats_json=boost::json::array(member.colorAttachmentCount);
        auto& arr_rhmCrPX=pColorAttachmentFormats_json.as_array();
        for(int yamBoue=0; yamBoue < member.colorAttachmentCount; yamBoue++){
            [&](){[&](){[&](){arr_rhmCrPX[yamBoue]=member.pColorAttachmentFormats[yamBoue];}();}();}();
        }
        }();
auto& depthAttachmentFormat_json=json["depthAttachmentFormat"];
[&](){[&](){[&](){depthAttachmentFormat_json=member.depthAttachmentFormat;}();}();}();
auto& stencilAttachmentFormat_json=json["stencilAttachmentFormat"];
[&](){[&](){[&](){stencilAttachmentFormat_json=member.stencilAttachmentFormat;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRenderingCreateInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& viewMask_json=json["viewMask"];
[&](){member.viewMask=static_cast<uint32_t>(value_to<int>(viewMask_json));}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){member.colorAttachmentCount=static_cast<uint32_t>(value_to<int>(colorAttachmentCount_json));}();
auto& pColorAttachmentFormats_json=json["pColorAttachmentFormats"];
[&](){ VkFormat* temp_GSTTjFs;;[&](){
            if (pColorAttachmentFormats_json.as_array().size()==0){
                temp_GSTTjFs=NULL;
            return; }temp_GSTTjFs=(VkFormat*)malloc(member.colorAttachmentCount*sizeof(VkFormat));
        auto& arr_ysBTEbK=pColorAttachmentFormats_json.as_array();
        for(int kpUTDXF=0; kpUTDXF < member.colorAttachmentCount; kpUTDXF++){
            [&](){[&](){int temp_KScoGUe;[&](){temp_KScoGUe=static_cast<int>(value_to<int>(arr_ysBTEbK[kpUTDXF]));}();temp_GSTTjFs[kpUTDXF]=(VkFormat)temp_KScoGUe;}();}();
        }
        }();member.pColorAttachmentFormats=temp_GSTTjFs;}();
auto& depthAttachmentFormat_json=json["depthAttachmentFormat"];
[&](){[&](){int temp_MlsQvpU;[&](){temp_MlsQvpU=static_cast<int>(value_to<int>(depthAttachmentFormat_json));}();member.depthAttachmentFormat=(VkFormat)temp_MlsQvpU;}();}();
auto& stencilAttachmentFormat_json=json["stencilAttachmentFormat"];
[&](){[&](){int temp_XITlXNi;[&](){temp_XITlXNi=static_cast<int>(value_to<int>(stencilAttachmentFormat_json));}();member.stencilAttachmentFormat=(VkFormat)temp_XITlXNi;}();}();
}

    void serialize_struct(boost::json::object& json, const VkRenderingInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& renderArea_json=json["renderArea"];
[&](){
            auto& temp=renderArea_json.emplace_object();
            return serialize_struct(temp, member.renderArea);
            }();
auto& layerCount_json=json["layerCount"];
[&](){layerCount_json=member.layerCount;}();
auto& viewMask_json=json["viewMask"];
[&](){viewMask_json=member.viewMask;}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){colorAttachmentCount_json=member.colorAttachmentCount;}();
auto& pColorAttachments_json=json["pColorAttachments"];
[&](){
            if (member.pColorAttachments==NULL){
                pColorAttachments_json=boost::json::array();
            return; }pColorAttachments_json=boost::json::array(member.colorAttachmentCount);
        auto& arr_zOjumrr=pColorAttachments_json.as_array();
        for(int MqTvXsu=0; MqTvXsu < member.colorAttachmentCount; MqTvXsu++){
            [&](){
            auto& temp=arr_zOjumrr[MqTvXsu].emplace_object();
            return serialize_struct(temp, member.pColorAttachments[MqTvXsu]);
            }();
        }
        }();
auto& pDepthAttachment_json=json["pDepthAttachment"];
[&](){
            if (member.pDepthAttachment==NULL){
                pDepthAttachment_json=boost::json::array();
            return; }pDepthAttachment_json=boost::json::array(1);
        auto& arr_zCcjFNg=pDepthAttachment_json.as_array();
        for(int DKeqxaZ=0; DKeqxaZ < 1; DKeqxaZ++){
            [&](){
            auto& temp=arr_zCcjFNg[DKeqxaZ].emplace_object();
            return serialize_struct(temp, member.pDepthAttachment[DKeqxaZ]);
            }();
        }
        }();
auto& pStencilAttachment_json=json["pStencilAttachment"];
[&](){
            if (member.pStencilAttachment==NULL){
                pStencilAttachment_json=boost::json::array();
            return; }pStencilAttachment_json=boost::json::array(1);
        auto& arr_NEEZdlG=pStencilAttachment_json.as_array();
        for(int JyQYSGl=0; JyQYSGl < 1; JyQYSGl++){
            [&](){
            auto& temp=arr_NEEZdlG[JyQYSGl].emplace_object();
            return serialize_struct(temp, member.pStencilAttachment[JyQYSGl]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderingInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_pyAikpY;[&](){temp_pyAikpY=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkRenderingFlags)temp_pyAikpY;}();}();
auto& renderArea_json=json["renderArea"];
[&](){
            auto& temp=renderArea_json.as_object();
            deserialize_struct(temp,member.renderArea);
            }();
auto& layerCount_json=json["layerCount"];
[&](){member.layerCount=static_cast<uint32_t>(value_to<int>(layerCount_json));}();
auto& viewMask_json=json["viewMask"];
[&](){member.viewMask=static_cast<uint32_t>(value_to<int>(viewMask_json));}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){member.colorAttachmentCount=static_cast<uint32_t>(value_to<int>(colorAttachmentCount_json));}();
auto& pColorAttachments_json=json["pColorAttachments"];
[&](){ VkRenderingAttachmentInfo* temp_uqrKiVo;;[&](){
            if (pColorAttachments_json.as_array().size()==0){
                temp_uqrKiVo=NULL;
            return; }temp_uqrKiVo=(VkRenderingAttachmentInfo*)malloc(member.colorAttachmentCount*sizeof(VkRenderingAttachmentInfo));
        auto& arr_tsLklfi=pColorAttachments_json.as_array();
        for(int VSeTfhd=0; VSeTfhd < member.colorAttachmentCount; VSeTfhd++){
            [&](){
            auto& temp=arr_tsLklfi[VSeTfhd].as_object();
            deserialize_struct(temp,temp_uqrKiVo[VSeTfhd]);
            }();
        }
        }();member.pColorAttachments=temp_uqrKiVo;}();
auto& pDepthAttachment_json=json["pDepthAttachment"];
[&](){ VkRenderingAttachmentInfo* temp_AfxJESk;;[&](){
            if (pDepthAttachment_json.as_array().size()==0){
                temp_AfxJESk=NULL;
            return; }temp_AfxJESk=(VkRenderingAttachmentInfo*)malloc(1*sizeof(VkRenderingAttachmentInfo));
        auto& arr_CQbSgDI=pDepthAttachment_json.as_array();
        for(int eWxHKcZ=0; eWxHKcZ < 1; eWxHKcZ++){
            [&](){
            auto& temp=arr_CQbSgDI[eWxHKcZ].as_object();
            deserialize_struct(temp,temp_AfxJESk[eWxHKcZ]);
            }();
        }
        }();member.pDepthAttachment=temp_AfxJESk;}();
auto& pStencilAttachment_json=json["pStencilAttachment"];
[&](){ VkRenderingAttachmentInfo* temp_DdtfxNr;;[&](){
            if (pStencilAttachment_json.as_array().size()==0){
                temp_DdtfxNr=NULL;
            return; }temp_DdtfxNr=(VkRenderingAttachmentInfo*)malloc(1*sizeof(VkRenderingAttachmentInfo));
        auto& arr_wXuDkKR=pStencilAttachment_json.as_array();
        for(int dJdpJiC=0; dJdpJiC < 1; dJdpJiC++){
            [&](){
            auto& temp=arr_wXuDkKR[dJdpJiC].as_object();
            deserialize_struct(temp,temp_DdtfxNr[dJdpJiC]);
            }();
        }
        }();member.pStencilAttachment=temp_DdtfxNr;}();
}

    void serialize_struct(boost::json::object& json, const VkRenderingAttachmentInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageView_json=json["imageView"];
[&](){serialize_VkImageView(imageView_json,member.imageView);}();
auto& imageLayout_json=json["imageLayout"];
[&](){[&](){[&](){imageLayout_json=member.imageLayout;}();}();}();
auto& resolveMode_json=json["resolveMode"];
[&](){[&](){[&](){resolveMode_json=member.resolveMode;}();}();}();
auto& resolveImageView_json=json["resolveImageView"];
[&](){serialize_VkImageView(resolveImageView_json,member.resolveImageView);}();
auto& resolveImageLayout_json=json["resolveImageLayout"];
[&](){[&](){[&](){resolveImageLayout_json=member.resolveImageLayout;}();}();}();
auto& loadOp_json=json["loadOp"];
[&](){[&](){[&](){loadOp_json=member.loadOp;}();}();}();
auto& storeOp_json=json["storeOp"];
[&](){[&](){[&](){storeOp_json=member.storeOp;}();}();}();
auto& clearValue_json=json["clearValue"];
[&](){
            auto& temp=clearValue_json.emplace_object();
            return serialize_struct(temp, member.clearValue);
            }();
}
void deserialize_struct(boost::json::object& json, VkRenderingAttachmentInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& imageView_json=json["imageView"];
[&](){deserialize_VkImageView(imageView_json, member.imageView);}();
auto& imageLayout_json=json["imageLayout"];
[&](){[&](){int temp_FajwjgZ;[&](){temp_FajwjgZ=static_cast<int>(value_to<int>(imageLayout_json));}();member.imageLayout=(VkImageLayout)temp_FajwjgZ;}();}();
auto& resolveMode_json=json["resolveMode"];
[&](){[&](){int temp_WTlluoN;[&](){temp_WTlluoN=static_cast<int>(value_to<int>(resolveMode_json));}();member.resolveMode=(VkResolveModeFlagBits)temp_WTlluoN;}();}();
auto& resolveImageView_json=json["resolveImageView"];
[&](){deserialize_VkImageView(resolveImageView_json, member.resolveImageView);}();
auto& resolveImageLayout_json=json["resolveImageLayout"];
[&](){[&](){int temp_JOTjGjh;[&](){temp_JOTjGjh=static_cast<int>(value_to<int>(resolveImageLayout_json));}();member.resolveImageLayout=(VkImageLayout)temp_JOTjGjh;}();}();
auto& loadOp_json=json["loadOp"];
[&](){[&](){int temp_FWnxBHJ;[&](){temp_FWnxBHJ=static_cast<int>(value_to<int>(loadOp_json));}();member.loadOp=(VkAttachmentLoadOp)temp_FWnxBHJ;}();}();
auto& storeOp_json=json["storeOp"];
[&](){[&](){int temp_fIASqxv;[&](){temp_fIASqxv=static_cast<int>(value_to<int>(storeOp_json));}();member.storeOp=(VkAttachmentStoreOp)temp_fIASqxv;}();}();
auto& clearValue_json=json["clearValue"];
[&](){
            auto& temp=clearValue_json.as_object();
            deserialize_struct(temp,member.clearValue);
            }();
}

    void serialize_struct(boost::json::object& json, const VkRenderingFragmentShadingRateAttachmentInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageView_json=json["imageView"];
[&](){serialize_VkImageView(imageView_json,member.imageView);}();
auto& imageLayout_json=json["imageLayout"];
[&](){[&](){[&](){imageLayout_json=member.imageLayout;}();}();}();
auto& shadingRateAttachmentTexelSize_json=json["shadingRateAttachmentTexelSize"];
[&](){
            auto& temp=shadingRateAttachmentTexelSize_json.emplace_object();
            return serialize_struct(temp, member.shadingRateAttachmentTexelSize);
            }();
}
void deserialize_struct(boost::json::object& json, VkRenderingFragmentShadingRateAttachmentInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& imageView_json=json["imageView"];
[&](){deserialize_VkImageView(imageView_json, member.imageView);}();
auto& imageLayout_json=json["imageLayout"];
[&](){[&](){int temp_FajwjgZ;[&](){temp_FajwjgZ=static_cast<int>(value_to<int>(imageLayout_json));}();member.imageLayout=(VkImageLayout)temp_FajwjgZ;}();}();
auto& shadingRateAttachmentTexelSize_json=json["shadingRateAttachmentTexelSize"];
[&](){
            auto& temp=shadingRateAttachmentTexelSize_json.as_object();
            deserialize_struct(temp,member.shadingRateAttachmentTexelSize);
            }();
}

    void serialize_struct(boost::json::object& json, const VkRenderingFragmentDensityMapAttachmentInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageView_json=json["imageView"];
[&](){serialize_VkImageView(imageView_json,member.imageView);}();
auto& imageLayout_json=json["imageLayout"];
[&](){[&](){[&](){imageLayout_json=member.imageLayout;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkRenderingFragmentDensityMapAttachmentInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& imageView_json=json["imageView"];
[&](){deserialize_VkImageView(imageView_json, member.imageView);}();
auto& imageLayout_json=json["imageLayout"];
[&](){[&](){int temp_FajwjgZ;[&](){temp_FajwjgZ=static_cast<int>(value_to<int>(imageLayout_json));}();member.imageLayout=(VkImageLayout)temp_FajwjgZ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDynamicRenderingFeatures& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dynamicRendering_json=json["dynamicRendering"];
[&](){[&](){dynamicRendering_json=member.dynamicRendering;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDynamicRenderingFeatures& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& dynamicRendering_json=json["dynamicRendering"];
[&](){uint32_t temp_sIAWlvy;[&](){temp_sIAWlvy=static_cast<uint32_t>(value_to<int>(dynamicRendering_json));}();member.dynamicRendering=(VkBool32)temp_sIAWlvy;}();
}

    void serialize_struct(boost::json::object& json, const VkCommandBufferInheritanceRenderingInfo& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& viewMask_json=json["viewMask"];
[&](){viewMask_json=member.viewMask;}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){colorAttachmentCount_json=member.colorAttachmentCount;}();
auto& pColorAttachmentFormats_json=json["pColorAttachmentFormats"];
[&](){
            if (member.pColorAttachmentFormats==NULL){
                pColorAttachmentFormats_json=boost::json::array();
            return; }pColorAttachmentFormats_json=boost::json::array(member.colorAttachmentCount);
        auto& arr_rhmCrPX=pColorAttachmentFormats_json.as_array();
        for(int yamBoue=0; yamBoue < member.colorAttachmentCount; yamBoue++){
            [&](){[&](){[&](){arr_rhmCrPX[yamBoue]=member.pColorAttachmentFormats[yamBoue];}();}();}();
        }
        }();
auto& depthAttachmentFormat_json=json["depthAttachmentFormat"];
[&](){[&](){[&](){depthAttachmentFormat_json=member.depthAttachmentFormat;}();}();}();
auto& stencilAttachmentFormat_json=json["stencilAttachmentFormat"];
[&](){[&](){[&](){stencilAttachmentFormat_json=member.stencilAttachmentFormat;}();}();}();
auto& rasterizationSamples_json=json["rasterizationSamples"];
[&](){[&](){[&](){rasterizationSamples_json=member.rasterizationSamples;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCommandBufferInheritanceRenderingInfo& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_pyAikpY;[&](){temp_pyAikpY=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkRenderingFlags)temp_pyAikpY;}();}();
auto& viewMask_json=json["viewMask"];
[&](){member.viewMask=static_cast<uint32_t>(value_to<int>(viewMask_json));}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){member.colorAttachmentCount=static_cast<uint32_t>(value_to<int>(colorAttachmentCount_json));}();
auto& pColorAttachmentFormats_json=json["pColorAttachmentFormats"];
[&](){ VkFormat* temp_GSTTjFs;;[&](){
            if (pColorAttachmentFormats_json.as_array().size()==0){
                temp_GSTTjFs=NULL;
            return; }temp_GSTTjFs=(VkFormat*)malloc(member.colorAttachmentCount*sizeof(VkFormat));
        auto& arr_ysBTEbK=pColorAttachmentFormats_json.as_array();
        for(int kpUTDXF=0; kpUTDXF < member.colorAttachmentCount; kpUTDXF++){
            [&](){[&](){int temp_KScoGUe;[&](){temp_KScoGUe=static_cast<int>(value_to<int>(arr_ysBTEbK[kpUTDXF]));}();temp_GSTTjFs[kpUTDXF]=(VkFormat)temp_KScoGUe;}();}();
        }
        }();member.pColorAttachmentFormats=temp_GSTTjFs;}();
auto& depthAttachmentFormat_json=json["depthAttachmentFormat"];
[&](){[&](){int temp_MlsQvpU;[&](){temp_MlsQvpU=static_cast<int>(value_to<int>(depthAttachmentFormat_json));}();member.depthAttachmentFormat=(VkFormat)temp_MlsQvpU;}();}();
auto& stencilAttachmentFormat_json=json["stencilAttachmentFormat"];
[&](){[&](){int temp_XITlXNi;[&](){temp_XITlXNi=static_cast<int>(value_to<int>(stencilAttachmentFormat_json));}();member.stencilAttachmentFormat=(VkFormat)temp_XITlXNi;}();}();
auto& rasterizationSamples_json=json["rasterizationSamples"];
[&](){[&](){int temp_cDVWodo;[&](){temp_cDVWodo=static_cast<int>(value_to<int>(rasterizationSamples_json));}();member.rasterizationSamples=(VkSampleCountFlagBits)temp_cDVWodo;}();}();
}

    void serialize_struct(boost::json::object& json, const VkAttachmentSampleCountInfoAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){colorAttachmentCount_json=member.colorAttachmentCount;}();
auto& pColorAttachmentSamples_json=json["pColorAttachmentSamples"];
[&](){
            if (member.pColorAttachmentSamples==NULL){
                pColorAttachmentSamples_json=boost::json::array();
            return; }pColorAttachmentSamples_json=boost::json::array(member.colorAttachmentCount);
        auto& arr_AUDfvvW=pColorAttachmentSamples_json.as_array();
        for(int Gkuhwbx=0; Gkuhwbx < member.colorAttachmentCount; Gkuhwbx++){
            [&](){[&](){[&](){arr_AUDfvvW[Gkuhwbx]=member.pColorAttachmentSamples[Gkuhwbx];}();}();}();
        }
        }();
auto& depthStencilAttachmentSamples_json=json["depthStencilAttachmentSamples"];
[&](){[&](){[&](){depthStencilAttachmentSamples_json=member.depthStencilAttachmentSamples;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkAttachmentSampleCountInfoAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& colorAttachmentCount_json=json["colorAttachmentCount"];
[&](){member.colorAttachmentCount=static_cast<uint32_t>(value_to<int>(colorAttachmentCount_json));}();
auto& pColorAttachmentSamples_json=json["pColorAttachmentSamples"];
[&](){ VkSampleCountFlagBits* temp_QdeYsec;;[&](){
            if (pColorAttachmentSamples_json.as_array().size()==0){
                temp_QdeYsec=NULL;
            return; }temp_QdeYsec=(VkSampleCountFlagBits*)malloc(member.colorAttachmentCount*sizeof(VkSampleCountFlagBits));
        auto& arr_AkCdTaG=pColorAttachmentSamples_json.as_array();
        for(int CAllvnD=0; CAllvnD < member.colorAttachmentCount; CAllvnD++){
            [&](){[&](){int temp_MwVVbSw;[&](){temp_MwVVbSw=static_cast<int>(value_to<int>(arr_AkCdTaG[CAllvnD]));}();temp_QdeYsec[CAllvnD]=(VkSampleCountFlagBits)temp_MwVVbSw;}();}();
        }
        }();member.pColorAttachmentSamples=temp_QdeYsec;}();
auto& depthStencilAttachmentSamples_json=json["depthStencilAttachmentSamples"];
[&](){[&](){int temp_IOaLFIb;[&](){temp_IOaLFIb=static_cast<int>(value_to<int>(depthStencilAttachmentSamples_json));}();member.depthStencilAttachmentSamples=(VkSampleCountFlagBits)temp_IOaLFIb;}();}();
}

    void serialize_struct(boost::json::object& json, const VkMultiviewPerViewAttributesInfoNVX& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& perViewAttributes_json=json["perViewAttributes"];
[&](){[&](){perViewAttributes_json=member.perViewAttributes;}();}();
auto& perViewAttributesPositionXOnly_json=json["perViewAttributesPositionXOnly"];
[&](){[&](){perViewAttributesPositionXOnly_json=member.perViewAttributesPositionXOnly;}();}();
}
void deserialize_struct(boost::json::object& json, VkMultiviewPerViewAttributesInfoNVX& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& perViewAttributes_json=json["perViewAttributes"];
[&](){uint32_t temp_HrxEnag;[&](){temp_HrxEnag=static_cast<uint32_t>(value_to<int>(perViewAttributes_json));}();member.perViewAttributes=(VkBool32)temp_HrxEnag;}();
auto& perViewAttributesPositionXOnly_json=json["perViewAttributesPositionXOnly"];
[&](){uint32_t temp_SVqRiiZ;[&](){temp_SVqRiiZ=static_cast<uint32_t>(value_to<int>(perViewAttributesPositionXOnly_json));}();member.perViewAttributesPositionXOnly=(VkBool32)temp_SVqRiiZ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageViewMinLodFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& minLod_json=json["minLod"];
[&](){[&](){minLod_json=member.minLod;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageViewMinLodFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& minLod_json=json["minLod"];
[&](){uint32_t temp_NksibAl;[&](){temp_NksibAl=static_cast<uint32_t>(value_to<int>(minLod_json));}();member.minLod=(VkBool32)temp_NksibAl;}();
}

    void serialize_struct(boost::json::object& json, const VkImageViewMinLodCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& minLod_json=json["minLod"];
[&](){minLod_json=member.minLod;}();
}
void deserialize_struct(boost::json::object& json, VkImageViewMinLodCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& minLod_json=json["minLod"];
[&](){member.minLod=static_cast<float>(value_to<int>(minLod_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rasterizationOrderColorAttachmentAccess_json=json["rasterizationOrderColorAttachmentAccess"];
[&](){[&](){rasterizationOrderColorAttachmentAccess_json=member.rasterizationOrderColorAttachmentAccess;}();}();
auto& rasterizationOrderDepthAttachmentAccess_json=json["rasterizationOrderDepthAttachmentAccess"];
[&](){[&](){rasterizationOrderDepthAttachmentAccess_json=member.rasterizationOrderDepthAttachmentAccess;}();}();
auto& rasterizationOrderStencilAttachmentAccess_json=json["rasterizationOrderStencilAttachmentAccess"];
[&](){[&](){rasterizationOrderStencilAttachmentAccess_json=member.rasterizationOrderStencilAttachmentAccess;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& rasterizationOrderColorAttachmentAccess_json=json["rasterizationOrderColorAttachmentAccess"];
[&](){uint32_t temp_eandYVh;[&](){temp_eandYVh=static_cast<uint32_t>(value_to<int>(rasterizationOrderColorAttachmentAccess_json));}();member.rasterizationOrderColorAttachmentAccess=(VkBool32)temp_eandYVh;}();
auto& rasterizationOrderDepthAttachmentAccess_json=json["rasterizationOrderDepthAttachmentAccess"];
[&](){uint32_t temp_DTAPpvo;[&](){temp_DTAPpvo=static_cast<uint32_t>(value_to<int>(rasterizationOrderDepthAttachmentAccess_json));}();member.rasterizationOrderDepthAttachmentAccess=(VkBool32)temp_DTAPpvo;}();
auto& rasterizationOrderStencilAttachmentAccess_json=json["rasterizationOrderStencilAttachmentAccess"];
[&](){uint32_t temp_KNYMkkd;[&](){temp_KNYMkkd=static_cast<uint32_t>(value_to<int>(rasterizationOrderStencilAttachmentAccess_json));}();member.rasterizationOrderStencilAttachmentAccess=(VkBool32)temp_KNYMkkd;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceLinearColorAttachmentFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& linearColorAttachment_json=json["linearColorAttachment"];
[&](){[&](){linearColorAttachment_json=member.linearColorAttachment;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceLinearColorAttachmentFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& linearColorAttachment_json=json["linearColorAttachment"];
[&](){uint32_t temp_IIahyml;[&](){temp_IIahyml=static_cast<uint32_t>(value_to<int>(linearColorAttachment_json));}();member.linearColorAttachment=(VkBool32)temp_IIahyml;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& graphicsPipelineLibrary_json=json["graphicsPipelineLibrary"];
[&](){[&](){graphicsPipelineLibrary_json=member.graphicsPipelineLibrary;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& graphicsPipelineLibrary_json=json["graphicsPipelineLibrary"];
[&](){uint32_t temp_YoxVIOt;[&](){temp_YoxVIOt=static_cast<uint32_t>(value_to<int>(graphicsPipelineLibrary_json));}();member.graphicsPipelineLibrary=(VkBool32)temp_YoxVIOt;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& graphicsPipelineLibraryFastLinking_json=json["graphicsPipelineLibraryFastLinking"];
[&](){[&](){graphicsPipelineLibraryFastLinking_json=member.graphicsPipelineLibraryFastLinking;}();}();
auto& graphicsPipelineLibraryIndependentInterpolationDecoration_json=json["graphicsPipelineLibraryIndependentInterpolationDecoration"];
[&](){[&](){graphicsPipelineLibraryIndependentInterpolationDecoration_json=member.graphicsPipelineLibraryIndependentInterpolationDecoration;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& graphicsPipelineLibraryFastLinking_json=json["graphicsPipelineLibraryFastLinking"];
[&](){uint32_t temp_YMoLPGU;[&](){temp_YMoLPGU=static_cast<uint32_t>(value_to<int>(graphicsPipelineLibraryFastLinking_json));}();member.graphicsPipelineLibraryFastLinking=(VkBool32)temp_YMoLPGU;}();
auto& graphicsPipelineLibraryIndependentInterpolationDecoration_json=json["graphicsPipelineLibraryIndependentInterpolationDecoration"];
[&](){uint32_t temp_LXsBMrk;[&](){temp_LXsBMrk=static_cast<uint32_t>(value_to<int>(graphicsPipelineLibraryIndependentInterpolationDecoration_json));}();member.graphicsPipelineLibraryIndependentInterpolationDecoration=(VkBool32)temp_LXsBMrk;}();
}

    void serialize_struct(boost::json::object& json, const VkGraphicsPipelineLibraryCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkGraphicsPipelineLibraryCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_VJlrVqt;[&](){temp_VJlrVqt=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkGraphicsPipelineLibraryFlagsEXT)temp_VJlrVqt;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& descriptorSetHostMapping_json=json["descriptorSetHostMapping"];
[&](){[&](){descriptorSetHostMapping_json=member.descriptorSetHostMapping;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& descriptorSetHostMapping_json=json["descriptorSetHostMapping"];
[&](){uint32_t temp_tekIhrn;[&](){temp_tekIhrn=static_cast<uint32_t>(value_to<int>(descriptorSetHostMapping_json));}();member.descriptorSetHostMapping=(VkBool32)temp_tekIhrn;}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorSetBindingReferenceVALVE& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& descriptorSetLayout_json=json["descriptorSetLayout"];
[&](){serialize_VkDescriptorSetLayout(descriptorSetLayout_json,member.descriptorSetLayout);}();
auto& binding_json=json["binding"];
[&](){binding_json=member.binding;}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorSetBindingReferenceVALVE& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& descriptorSetLayout_json=json["descriptorSetLayout"];
[&](){deserialize_VkDescriptorSetLayout(descriptorSetLayout_json, member.descriptorSetLayout);}();
auto& binding_json=json["binding"];
[&](){member.binding=static_cast<uint32_t>(value_to<int>(binding_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDescriptorSetLayoutHostMappingInfoVALVE& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& descriptorOffset_json=json["descriptorOffset"];
[&](){descriptorOffset_json=member.descriptorOffset;}();
auto& descriptorSize_json=json["descriptorSize"];
[&](){descriptorSize_json=member.descriptorSize;}();
}
void deserialize_struct(boost::json::object& json, VkDescriptorSetLayoutHostMappingInfoVALVE& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& descriptorOffset_json=json["descriptorOffset"];
[&](){member.descriptorOffset=static_cast<size_t>(value_to<int>(descriptorOffset_json));}();
auto& descriptorSize_json=json["descriptorSize"];
[&](){member.descriptorSize=static_cast<uint32_t>(value_to<int>(descriptorSize_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderModuleIdentifier_json=json["shaderModuleIdentifier"];
[&](){[&](){shaderModuleIdentifier_json=member.shaderModuleIdentifier;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderModuleIdentifier_json=json["shaderModuleIdentifier"];
[&](){uint32_t temp_ZqYsGET;[&](){temp_ZqYsGET=static_cast<uint32_t>(value_to<int>(shaderModuleIdentifier_json));}();member.shaderModuleIdentifier=(VkBool32)temp_ZqYsGET;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderModuleIdentifierAlgorithmUUID_json=json["shaderModuleIdentifierAlgorithmUUID"];
[&](){shaderModuleIdentifierAlgorithmUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_axGGHAu=shaderModuleIdentifierAlgorithmUUID_json.as_array();
        for(int IpgXIaE=0; IpgXIaE < VK_UUID_SIZE; IpgXIaE++){
            [&](){arr_axGGHAu[IpgXIaE]=member.shaderModuleIdentifierAlgorithmUUID[IpgXIaE];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderModuleIdentifierAlgorithmUUID_json=json["shaderModuleIdentifierAlgorithmUUID"];
[&](){
        auto& arr_axGGHAu=shaderModuleIdentifierAlgorithmUUID_json.as_array();
        for(int IpgXIaE=0; IpgXIaE < VK_UUID_SIZE; IpgXIaE++){
            [&](){member.shaderModuleIdentifierAlgorithmUUID[IpgXIaE]=static_cast<uint8_t>(value_to<int>(arr_axGGHAu[IpgXIaE]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPipelineShaderStageModuleIdentifierCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& identifierSize_json=json["identifierSize"];
[&](){identifierSize_json=member.identifierSize;}();
auto& pIdentifier_json=json["pIdentifier"];
[&](){
            if (member.pIdentifier==NULL){
                pIdentifier_json=boost::json::array();
            return; }pIdentifier_json=boost::json::array(member.identifierSize);
        auto& arr_XGuhhpo=pIdentifier_json.as_array();
        for(int NhNyQSA=0; NhNyQSA < member.identifierSize; NhNyQSA++){
            [&](){arr_XGuhhpo[NhNyQSA]=member.pIdentifier[NhNyQSA];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelineShaderStageModuleIdentifierCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& identifierSize_json=json["identifierSize"];
[&](){member.identifierSize=static_cast<uint32_t>(value_to<int>(identifierSize_json));}();
auto& pIdentifier_json=json["pIdentifier"];
[&](){ uint8_t* temp_BXJpQGX;;[&](){
            if (pIdentifier_json.as_array().size()==0){
                temp_BXJpQGX=NULL;
            return; }temp_BXJpQGX=(uint8_t*)malloc(member.identifierSize*sizeof(uint8_t));
        auto& arr_AgvdLje=pIdentifier_json.as_array();
        for(int HLcdsde=0; HLcdsde < member.identifierSize; HLcdsde++){
            [&](){temp_BXJpQGX[HLcdsde]=static_cast<uint8_t>(value_to<int>(arr_AgvdLje[HLcdsde]));}();
        }
        }();member.pIdentifier=temp_BXJpQGX;}();
}

    void serialize_struct(boost::json::object& json, const VkShaderModuleIdentifierEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& identifierSize_json=json["identifierSize"];
[&](){identifierSize_json=member.identifierSize;}();
auto& identifier_json=json["identifier"];
[&](){identifier_json=boost::json::array(VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT);
        auto& arr_MCaDwLp=identifier_json.as_array();
        for(int nIDmbeH=0; nIDmbeH < VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT; nIDmbeH++){
            [&](){arr_MCaDwLp[nIDmbeH]=member.identifier[nIDmbeH];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkShaderModuleIdentifierEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& identifierSize_json=json["identifierSize"];
[&](){member.identifierSize=static_cast<uint32_t>(value_to<int>(identifierSize_json));}();
auto& identifier_json=json["identifier"];
[&](){
        auto& arr_MCaDwLp=identifier_json.as_array();
        for(int nIDmbeH=0; nIDmbeH < VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT; nIDmbeH++){
            [&](){member.identifier[nIDmbeH]=static_cast<uint8_t>(value_to<int>(arr_MCaDwLp[nIDmbeH]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkImageCompressionControlEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& compressionControlPlaneCount_json=json["compressionControlPlaneCount"];
[&](){compressionControlPlaneCount_json=member.compressionControlPlaneCount;}();
auto& pFixedRateFlags_json=json["pFixedRateFlags"];
[&](){
            if (member.pFixedRateFlags==NULL){
                pFixedRateFlags_json=boost::json::array();
            return; }pFixedRateFlags_json=boost::json::array(member.compressionControlPlaneCount);
        auto& arr_cfXnXYF=pFixedRateFlags_json.as_array();
        for(int cnyOeKC=0; cnyOeKC < member.compressionControlPlaneCount; cnyOeKC++){
            [&](){[&](){[&](){arr_cfXnXYF[cnyOeKC]=member.pFixedRateFlags[cnyOeKC];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkImageCompressionControlEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_LfCUpvM;[&](){temp_LfCUpvM=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkImageCompressionFlagsEXT)temp_LfCUpvM;}();}();
auto& compressionControlPlaneCount_json=json["compressionControlPlaneCount"];
[&](){member.compressionControlPlaneCount=static_cast<uint32_t>(value_to<int>(compressionControlPlaneCount_json));}();
auto& pFixedRateFlags_json=json["pFixedRateFlags"];
[&](){
            if (pFixedRateFlags_json.as_array().size()==0){
                member.pFixedRateFlags=NULL;
            return; }member.pFixedRateFlags=(VkImageCompressionFixedRateFlagsEXT*)malloc(member.compressionControlPlaneCount*sizeof(VkImageCompressionFixedRateFlagsEXT));
        auto& arr_cfXnXYF=pFixedRateFlags_json.as_array();
        for(int cnyOeKC=0; cnyOeKC < member.compressionControlPlaneCount; cnyOeKC++){
            [&](){[&](){int temp_APZVuRE;[&](){temp_APZVuRE=static_cast<int>(value_to<int>(arr_cfXnXYF[cnyOeKC]));}();member.pFixedRateFlags[cnyOeKC]=(VkImageCompressionFixedRateFlagsEXT)temp_APZVuRE;}();}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageCompressionControlFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageCompressionControl_json=json["imageCompressionControl"];
[&](){[&](){imageCompressionControl_json=member.imageCompressionControl;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageCompressionControlFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& imageCompressionControl_json=json["imageCompressionControl"];
[&](){uint32_t temp_HOvJtns;[&](){temp_HOvJtns=static_cast<uint32_t>(value_to<int>(imageCompressionControl_json));}();member.imageCompressionControl=(VkBool32)temp_HOvJtns;}();
}

    void serialize_struct(boost::json::object& json, const VkImageCompressionPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageCompressionFlags_json=json["imageCompressionFlags"];
[&](){[&](){[&](){imageCompressionFlags_json=member.imageCompressionFlags;}();}();}();
auto& imageCompressionFixedRateFlags_json=json["imageCompressionFixedRateFlags"];
[&](){[&](){[&](){imageCompressionFixedRateFlags_json=member.imageCompressionFixedRateFlags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkImageCompressionPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& imageCompressionFlags_json=json["imageCompressionFlags"];
[&](){[&](){int temp_fedmwqI;[&](){temp_fedmwqI=static_cast<int>(value_to<int>(imageCompressionFlags_json));}();member.imageCompressionFlags=(VkImageCompressionFlagsEXT)temp_fedmwqI;}();}();
auto& imageCompressionFixedRateFlags_json=json["imageCompressionFixedRateFlags"];
[&](){[&](){int temp_qVLUzId;[&](){temp_qVLUzId=static_cast<int>(value_to<int>(imageCompressionFixedRateFlags_json));}();member.imageCompressionFixedRateFlags=(VkImageCompressionFixedRateFlagsEXT)temp_qVLUzId;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageCompressionControlSwapchain_json=json["imageCompressionControlSwapchain"];
[&](){[&](){imageCompressionControlSwapchain_json=member.imageCompressionControlSwapchain;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& imageCompressionControlSwapchain_json=json["imageCompressionControlSwapchain"];
[&](){uint32_t temp_GOcKJyE;[&](){temp_GOcKJyE=static_cast<uint32_t>(value_to<int>(imageCompressionControlSwapchain_json));}();member.imageCompressionControlSwapchain=(VkBool32)temp_GOcKJyE;}();
}

    void serialize_struct(boost::json::object& json, const VkImageSubresource2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.emplace_object();
            return serialize_struct(temp, member.imageSubresource);
            }();
}
void deserialize_struct(boost::json::object& json, VkImageSubresource2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& imageSubresource_json=json["imageSubresource"];
[&](){
            auto& temp=imageSubresource_json.as_object();
            deserialize_struct(temp,member.imageSubresource);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSubresourceLayout2KHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& subresourceLayout_json=json["subresourceLayout"];
[&](){
            auto& temp=subresourceLayout_json.emplace_object();
            return serialize_struct(temp, member.subresourceLayout);
            }();
}
void deserialize_struct(boost::json::object& json, VkSubresourceLayout2KHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& subresourceLayout_json=json["subresourceLayout"];
[&](){
            auto& temp=subresourceLayout_json.as_object();
            deserialize_struct(temp,member.subresourceLayout);
            }();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassCreationControlEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& disallowMerging_json=json["disallowMerging"];
[&](){[&](){disallowMerging_json=member.disallowMerging;}();}();
}
void deserialize_struct(boost::json::object& json, VkRenderPassCreationControlEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& disallowMerging_json=json["disallowMerging"];
[&](){uint32_t temp_IZreZmN;[&](){temp_IZreZmN=static_cast<uint32_t>(value_to<int>(disallowMerging_json));}();member.disallowMerging=(VkBool32)temp_IZreZmN;}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassCreationFeedbackInfoEXT& member){
        
    
auto& postMergeSubpassCount_json=json["postMergeSubpassCount"];
[&](){postMergeSubpassCount_json=member.postMergeSubpassCount;}();
}
void deserialize_struct(boost::json::object& json, VkRenderPassCreationFeedbackInfoEXT& member){
auto& postMergeSubpassCount_json=json["postMergeSubpassCount"];
[&](){member.postMergeSubpassCount=static_cast<uint32_t>(value_to<int>(postMergeSubpassCount_json));}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassCreationFeedbackCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pRenderPassFeedback_json=json["pRenderPassFeedback"];
[&](){
            if (member.pRenderPassFeedback==NULL){
                pRenderPassFeedback_json=boost::json::array();
            return; }pRenderPassFeedback_json=boost::json::array(1);
        auto& arr_JjvUXSK=pRenderPassFeedback_json.as_array();
        for(int nNbsIPU=0; nNbsIPU < 1; nNbsIPU++){
            [&](){
            auto& temp=arr_JjvUXSK[nNbsIPU].emplace_object();
            return serialize_struct(temp, member.pRenderPassFeedback[nNbsIPU]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassCreationFeedbackCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pRenderPassFeedback_json=json["pRenderPassFeedback"];
[&](){
            if (pRenderPassFeedback_json.as_array().size()==0){
                member.pRenderPassFeedback=NULL;
            return; }member.pRenderPassFeedback=(VkRenderPassCreationFeedbackInfoEXT*)malloc(1*sizeof(VkRenderPassCreationFeedbackInfoEXT));
        auto& arr_JjvUXSK=pRenderPassFeedback_json.as_array();
        for(int nNbsIPU=0; nNbsIPU < 1; nNbsIPU++){
            [&](){
            auto& temp=arr_JjvUXSK[nNbsIPU].as_object();
            deserialize_struct(temp,member.pRenderPassFeedback[nNbsIPU]);
            }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassSubpassFeedbackInfoEXT& member){
        
    
auto& subpassMergeStatus_json=json["subpassMergeStatus"];
[&](){[&](){[&](){subpassMergeStatus_json=member.subpassMergeStatus;}();}();}();
auto& description_json=json["description"];
[&](){description_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){arr_XKStCoi[xOHuflK]=member.description[xOHuflK];}();
        }
        }();
auto& postMergeIndex_json=json["postMergeIndex"];
[&](){postMergeIndex_json=member.postMergeIndex;}();
}
void deserialize_struct(boost::json::object& json, VkRenderPassSubpassFeedbackInfoEXT& member){
auto& subpassMergeStatus_json=json["subpassMergeStatus"];
[&](){[&](){int temp_ZDUzHCn;[&](){temp_ZDUzHCn=static_cast<int>(value_to<int>(subpassMergeStatus_json));}();member.subpassMergeStatus=(VkSubpassMergeStatusEXT)temp_ZDUzHCn;}();}();
auto& description_json=json["description"];
[&](){
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){member.description[xOHuflK]=static_cast<char>(value_to<int>(arr_XKStCoi[xOHuflK]));}();
        }
        }();
auto& postMergeIndex_json=json["postMergeIndex"];
[&](){member.postMergeIndex=static_cast<uint32_t>(value_to<int>(postMergeIndex_json));}();
}

    void serialize_struct(boost::json::object& json, const VkRenderPassSubpassFeedbackCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pSubpassFeedback_json=json["pSubpassFeedback"];
[&](){
            if (member.pSubpassFeedback==NULL){
                pSubpassFeedback_json=boost::json::array();
            return; }pSubpassFeedback_json=boost::json::array(1);
        auto& arr_TraKUUQ=pSubpassFeedback_json.as_array();
        for(int ETwKPnx=0; ETwKPnx < 1; ETwKPnx++){
            [&](){
            auto& temp=arr_TraKUUQ[ETwKPnx].emplace_object();
            return serialize_struct(temp, member.pSubpassFeedback[ETwKPnx]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkRenderPassSubpassFeedbackCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pSubpassFeedback_json=json["pSubpassFeedback"];
[&](){
            if (pSubpassFeedback_json.as_array().size()==0){
                member.pSubpassFeedback=NULL;
            return; }member.pSubpassFeedback=(VkRenderPassSubpassFeedbackInfoEXT*)malloc(1*sizeof(VkRenderPassSubpassFeedbackInfoEXT));
        auto& arr_TraKUUQ=pSubpassFeedback_json.as_array();
        for(int ETwKPnx=0; ETwKPnx < 1; ETwKPnx++){
            [&](){
            auto& temp=arr_TraKUUQ[ETwKPnx].as_object();
            deserialize_struct(temp,member.pSubpassFeedback[ETwKPnx]);
            }();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& subpassMergeFeedback_json=json["subpassMergeFeedback"];
[&](){[&](){subpassMergeFeedback_json=member.subpassMergeFeedback;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& subpassMergeFeedback_json=json["subpassMergeFeedback"];
[&](){uint32_t temp_iOURYqG;[&](){temp_iOURYqG=static_cast<uint32_t>(value_to<int>(subpassMergeFeedback_json));}();member.subpassMergeFeedback=(VkBool32)temp_iOURYqG;}();
}

    void serialize_struct(boost::json::object& json, const VkMicromapBuildInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
auto& dstMicromap_json=json["dstMicromap"];
[&](){serialize_VkMicromapEXT(dstMicromap_json,member.dstMicromap);}();
auto& usageCountsCount_json=json["usageCountsCount"];
[&](){usageCountsCount_json=member.usageCountsCount;}();
auto& pUsageCounts_json=json["pUsageCounts"];
[&](){
            if (member.pUsageCounts==NULL){
                pUsageCounts_json=boost::json::array();
            return; }pUsageCounts_json=boost::json::array(member.usageCountsCount);
        auto& arr_ISbbbyT=pUsageCounts_json.as_array();
        for(int fcbtTBG=0; fcbtTBG < member.usageCountsCount; fcbtTBG++){
            [&](){
            auto& temp=arr_ISbbbyT[fcbtTBG].emplace_object();
            return serialize_struct(temp, member.pUsageCounts[fcbtTBG]);
            }();
        }
        }();
auto& ppUsageCounts_json=json["ppUsageCounts"];
[&](){
            if (member.ppUsageCounts==NULL){
                ppUsageCounts_json=boost::json::array();
            return; }ppUsageCounts_json=boost::json::array(member.usageCountsCount);
        auto& arr_tKtvYXX=ppUsageCounts_json.as_array();
        for(int kPEvNon=0; kPEvNon < member.usageCountsCount; kPEvNon++){
            [&](){
            if (member.ppUsageCounts[kPEvNon]==NULL){
                arr_tKtvYXX[kPEvNon]=boost::json::array();
            return; }arr_tKtvYXX[kPEvNon]=boost::json::array(1);
        auto& arr_epKIoAu=arr_tKtvYXX[kPEvNon].as_array();
        for(int bFKrJKe=0; bFKrJKe < 1; bFKrJKe++){
            [&](){
            auto& temp=arr_epKIoAu[bFKrJKe].emplace_object();
            return serialize_struct(temp, member.ppUsageCounts[kPEvNon][bFKrJKe]);
            }();
        }
        }();
        }
        }();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.emplace_object();
            return serialize_struct(temp, member.data);
            }();
auto& scratchData_json=json["scratchData"];
[&](){
            auto& temp=scratchData_json.emplace_object();
            return serialize_struct(temp, member.scratchData);
            }();
auto& triangleArray_json=json["triangleArray"];
[&](){
            auto& temp=triangleArray_json.emplace_object();
            return serialize_struct(temp, member.triangleArray);
            }();
auto& triangleArrayStride_json=json["triangleArrayStride"];
[&](){[&](){triangleArrayStride_json=member.triangleArrayStride;}();}();
}
void deserialize_struct(boost::json::object& json, VkMicromapBuildInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& type_json=json["type"];
[&](){[&](){int temp_QJxTbAh;[&](){temp_QJxTbAh=static_cast<int>(value_to<int>(type_json));}();member.type=(VkMicromapTypeEXT)temp_QJxTbAh;}();}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_qYnldEx;[&](){temp_qYnldEx=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkBuildMicromapFlagsEXT)temp_qYnldEx;}();}();
auto& mode_json=json["mode"];
[&](){[&](){int temp_yesVPNy;[&](){temp_yesVPNy=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkBuildMicromapModeEXT)temp_yesVPNy;}();}();
auto& dstMicromap_json=json["dstMicromap"];
[&](){deserialize_VkMicromapEXT(dstMicromap_json, member.dstMicromap);}();
auto& usageCountsCount_json=json["usageCountsCount"];
[&](){member.usageCountsCount=static_cast<uint32_t>(value_to<int>(usageCountsCount_json));}();
auto& pUsageCounts_json=json["pUsageCounts"];
[&](){ VkMicromapUsageEXT* temp_PnhGAGz;;[&](){
            if (pUsageCounts_json.as_array().size()==0){
                temp_PnhGAGz=NULL;
            return; }temp_PnhGAGz=(VkMicromapUsageEXT*)malloc(member.usageCountsCount*sizeof(VkMicromapUsageEXT));
        auto& arr_cxGBOGi=pUsageCounts_json.as_array();
        for(int uiTzGnC=0; uiTzGnC < member.usageCountsCount; uiTzGnC++){
            [&](){
            auto& temp=arr_cxGBOGi[uiTzGnC].as_object();
            deserialize_struct(temp,temp_PnhGAGz[uiTzGnC]);
            }();
        }
        }();member.pUsageCounts=temp_PnhGAGz;}();
auto& ppUsageCounts_json=json["ppUsageCounts"];
[&](){ VkMicromapUsageEXT* * temp_pfcHTud;;[&](){
            if (ppUsageCounts_json.as_array().size()==0){
                temp_pfcHTud=NULL;
            return; }temp_pfcHTud=(VkMicromapUsageEXT**)malloc(member.usageCountsCount*sizeof(VkMicromapUsageEXT*));
        auto& arr_xilHauq=ppUsageCounts_json.as_array();
        for(int XoJSEEr=0; XoJSEEr < member.usageCountsCount; XoJSEEr++){
            [&](){
            if (arr_xilHauq[XoJSEEr].as_array().size()==0){
                temp_pfcHTud[XoJSEEr]=NULL;
            return; }temp_pfcHTud[XoJSEEr]=(VkMicromapUsageEXT*)malloc(1*sizeof(VkMicromapUsageEXT));
        auto& arr_pcsocwp=arr_xilHauq[XoJSEEr].as_array();
        for(int Zbsxegm=0; Zbsxegm < 1; Zbsxegm++){
            [&](){
            auto& temp=arr_pcsocwp[Zbsxegm].as_object();
            deserialize_struct(temp,temp_pfcHTud[XoJSEEr][Zbsxegm]);
            }();
        }
        }();
        }
        }();member.ppUsageCounts=temp_pfcHTud;}();
auto& data_json=json["data"];
[&](){
            auto& temp=data_json.as_object();
            deserialize_struct(temp,member.data);
            }();
auto& scratchData_json=json["scratchData"];
[&](){
            auto& temp=scratchData_json.as_object();
            deserialize_struct(temp,member.scratchData);
            }();
auto& triangleArray_json=json["triangleArray"];
[&](){
            auto& temp=triangleArray_json.as_object();
            deserialize_struct(temp,member.triangleArray);
            }();
auto& triangleArrayStride_json=json["triangleArrayStride"];
[&](){uint64_t temp_tjMaJxB;[&](){temp_tjMaJxB=static_cast<uint64_t>(value_to<int>(triangleArrayStride_json));}();member.triangleArrayStride=(VkDeviceSize)temp_tjMaJxB;}();
}

    void serialize_struct(boost::json::object& json, const VkMicromapCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& createFlags_json=json["createFlags"];
[&](){[&](){[&](){createFlags_json=member.createFlags;}();}();}();
auto& buffer_json=json["buffer"];
[&](){serialize_VkBuffer(buffer_json,member.buffer);}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& type_json=json["type"];
[&](){[&](){[&](){type_json=member.type;}();}();}();
auto& deviceAddress_json=json["deviceAddress"];
[&](){[&](){deviceAddress_json=member.deviceAddress;}();}();
}
void deserialize_struct(boost::json::object& json, VkMicromapCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& createFlags_json=json["createFlags"];
[&](){[&](){int temp_iblPBrt;[&](){temp_iblPBrt=static_cast<int>(value_to<int>(createFlags_json));}();member.createFlags=(VkMicromapCreateFlagsEXT)temp_iblPBrt;}();}();
auto& buffer_json=json["buffer"];
[&](){deserialize_VkBuffer(buffer_json, member.buffer);}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& type_json=json["type"];
[&](){[&](){int temp_QJxTbAh;[&](){temp_QJxTbAh=static_cast<int>(value_to<int>(type_json));}();member.type=(VkMicromapTypeEXT)temp_QJxTbAh;}();}();
auto& deviceAddress_json=json["deviceAddress"];
[&](){uint64_t temp_JcebElc;[&](){temp_JcebElc=static_cast<uint64_t>(value_to<int>(deviceAddress_json));}();member.deviceAddress=(VkDeviceAddress)temp_JcebElc;}();
}

    void serialize_struct(boost::json::object& json, const VkMicromapVersionInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pVersionData_json=json["pVersionData"];
[&](){
            if (member.pVersionData==NULL){
                pVersionData_json=boost::json::array();
            return; }pVersionData_json=boost::json::array(2*VK_UUID_SIZE);
        auto& arr_RuHqWQz=pVersionData_json.as_array();
        for(int EDvhmfD=0; EDvhmfD < 2*VK_UUID_SIZE; EDvhmfD++){
            [&](){arr_RuHqWQz[EDvhmfD]=member.pVersionData[EDvhmfD];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkMicromapVersionInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pVersionData_json=json["pVersionData"];
[&](){ uint8_t* temp_djnalGl;;[&](){
            if (pVersionData_json.as_array().size()==0){
                temp_djnalGl=NULL;
            return; }temp_djnalGl=(uint8_t*)malloc(2*VK_UUID_SIZE*sizeof(uint8_t));
        auto& arr_LkXRmLG=pVersionData_json.as_array();
        for(int NHzWVtx=0; NHzWVtx < 2*VK_UUID_SIZE; NHzWVtx++){
            [&](){temp_djnalGl[NHzWVtx]=static_cast<uint8_t>(value_to<int>(arr_LkXRmLG[NHzWVtx]));}();
        }
        }();member.pVersionData=temp_djnalGl;}();
}

    void serialize_struct(boost::json::object& json, const VkCopyMicromapInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& src_json=json["src"];
[&](){serialize_VkMicromapEXT(src_json,member.src);}();
auto& dst_json=json["dst"];
[&](){serialize_VkMicromapEXT(dst_json,member.dst);}();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCopyMicromapInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& src_json=json["src"];
[&](){deserialize_VkMicromapEXT(src_json, member.src);}();
auto& dst_json=json["dst"];
[&](){deserialize_VkMicromapEXT(dst_json, member.dst);}();
auto& mode_json=json["mode"];
[&](){[&](){int temp_YandjQd;[&](){temp_YandjQd=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkCopyMicromapModeEXT)temp_YandjQd;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCopyMicromapToMemoryInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& src_json=json["src"];
[&](){serialize_VkMicromapEXT(src_json,member.src);}();
auto& dst_json=json["dst"];
[&](){
            auto& temp=dst_json.emplace_object();
            return serialize_struct(temp, member.dst);
            }();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCopyMicromapToMemoryInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& src_json=json["src"];
[&](){deserialize_VkMicromapEXT(src_json, member.src);}();
auto& dst_json=json["dst"];
[&](){
            auto& temp=dst_json.as_object();
            deserialize_struct(temp,member.dst);
            }();
auto& mode_json=json["mode"];
[&](){[&](){int temp_YandjQd;[&](){temp_YandjQd=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkCopyMicromapModeEXT)temp_YandjQd;}();}();
}

    void serialize_struct(boost::json::object& json, const VkCopyMemoryToMicromapInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& src_json=json["src"];
[&](){
            auto& temp=src_json.emplace_object();
            return serialize_struct(temp, member.src);
            }();
auto& dst_json=json["dst"];
[&](){serialize_VkMicromapEXT(dst_json,member.dst);}();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCopyMemoryToMicromapInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& src_json=json["src"];
[&](){
            auto& temp=src_json.as_object();
            deserialize_struct(temp,member.src);
            }();
auto& dst_json=json["dst"];
[&](){deserialize_VkMicromapEXT(dst_json, member.dst);}();
auto& mode_json=json["mode"];
[&](){[&](){int temp_YandjQd;[&](){temp_YandjQd=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkCopyMicromapModeEXT)temp_YandjQd;}();}();
}

    void serialize_struct(boost::json::object& json, const VkMicromapBuildSizesInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& micromapSize_json=json["micromapSize"];
[&](){[&](){micromapSize_json=member.micromapSize;}();}();
auto& buildScratchSize_json=json["buildScratchSize"];
[&](){[&](){buildScratchSize_json=member.buildScratchSize;}();}();
auto& discardable_json=json["discardable"];
[&](){[&](){discardable_json=member.discardable;}();}();
}
void deserialize_struct(boost::json::object& json, VkMicromapBuildSizesInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& micromapSize_json=json["micromapSize"];
[&](){uint64_t temp_oERVvNH;[&](){temp_oERVvNH=static_cast<uint64_t>(value_to<int>(micromapSize_json));}();member.micromapSize=(VkDeviceSize)temp_oERVvNH;}();
auto& buildScratchSize_json=json["buildScratchSize"];
[&](){uint64_t temp_MMSKrnN;[&](){temp_MMSKrnN=static_cast<uint64_t>(value_to<int>(buildScratchSize_json));}();member.buildScratchSize=(VkDeviceSize)temp_MMSKrnN;}();
auto& discardable_json=json["discardable"];
[&](){uint32_t temp_AsBHJnI;[&](){temp_AsBHJnI=static_cast<uint32_t>(value_to<int>(discardable_json));}();member.discardable=(VkBool32)temp_AsBHJnI;}();
}

    void serialize_struct(boost::json::object& json, const VkMicromapUsageEXT& member){
        
    
auto& count_json=json["count"];
[&](){count_json=member.count;}();
auto& subdivisionLevel_json=json["subdivisionLevel"];
[&](){subdivisionLevel_json=member.subdivisionLevel;}();
auto& format_json=json["format"];
[&](){format_json=member.format;}();
}
void deserialize_struct(boost::json::object& json, VkMicromapUsageEXT& member){
auto& count_json=json["count"];
[&](){member.count=static_cast<uint32_t>(value_to<int>(count_json));}();
auto& subdivisionLevel_json=json["subdivisionLevel"];
[&](){member.subdivisionLevel=static_cast<uint32_t>(value_to<int>(subdivisionLevel_json));}();
auto& format_json=json["format"];
[&](){member.format=static_cast<uint32_t>(value_to<int>(format_json));}();
}

    void serialize_struct(boost::json::object& json, const VkMicromapTriangleEXT& member){
        
    
auto& dataOffset_json=json["dataOffset"];
[&](){dataOffset_json=member.dataOffset;}();
auto& subdivisionLevel_json=json["subdivisionLevel"];
[&](){subdivisionLevel_json=member.subdivisionLevel;}();
auto& format_json=json["format"];
[&](){format_json=member.format;}();
}
void deserialize_struct(boost::json::object& json, VkMicromapTriangleEXT& member){
auto& dataOffset_json=json["dataOffset"];
[&](){member.dataOffset=static_cast<uint32_t>(value_to<int>(dataOffset_json));}();
auto& subdivisionLevel_json=json["subdivisionLevel"];
[&](){member.subdivisionLevel=static_cast<uint16_t>(value_to<int>(subdivisionLevel_json));}();
auto& format_json=json["format"];
[&](){member.format=static_cast<uint16_t>(value_to<int>(format_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceOpacityMicromapFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& micromap_json=json["micromap"];
[&](){[&](){micromap_json=member.micromap;}();}();
auto& micromapCaptureReplay_json=json["micromapCaptureReplay"];
[&](){[&](){micromapCaptureReplay_json=member.micromapCaptureReplay;}();}();
auto& micromapHostCommands_json=json["micromapHostCommands"];
[&](){[&](){micromapHostCommands_json=member.micromapHostCommands;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceOpacityMicromapFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& micromap_json=json["micromap"];
[&](){uint32_t temp_Kptsjdd;[&](){temp_Kptsjdd=static_cast<uint32_t>(value_to<int>(micromap_json));}();member.micromap=(VkBool32)temp_Kptsjdd;}();
auto& micromapCaptureReplay_json=json["micromapCaptureReplay"];
[&](){uint32_t temp_lHkyhgQ;[&](){temp_lHkyhgQ=static_cast<uint32_t>(value_to<int>(micromapCaptureReplay_json));}();member.micromapCaptureReplay=(VkBool32)temp_lHkyhgQ;}();
auto& micromapHostCommands_json=json["micromapHostCommands"];
[&](){uint32_t temp_fNUBasJ;[&](){temp_fNUBasJ=static_cast<uint32_t>(value_to<int>(micromapHostCommands_json));}();member.micromapHostCommands=(VkBool32)temp_fNUBasJ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceOpacityMicromapPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxOpacity2StateSubdivisionLevel_json=json["maxOpacity2StateSubdivisionLevel"];
[&](){maxOpacity2StateSubdivisionLevel_json=member.maxOpacity2StateSubdivisionLevel;}();
auto& maxOpacity4StateSubdivisionLevel_json=json["maxOpacity4StateSubdivisionLevel"];
[&](){maxOpacity4StateSubdivisionLevel_json=member.maxOpacity4StateSubdivisionLevel;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceOpacityMicromapPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxOpacity2StateSubdivisionLevel_json=json["maxOpacity2StateSubdivisionLevel"];
[&](){member.maxOpacity2StateSubdivisionLevel=static_cast<uint32_t>(value_to<int>(maxOpacity2StateSubdivisionLevel_json));}();
auto& maxOpacity4StateSubdivisionLevel_json=json["maxOpacity4StateSubdivisionLevel"];
[&](){member.maxOpacity4StateSubdivisionLevel=static_cast<uint32_t>(value_to<int>(maxOpacity4StateSubdivisionLevel_json));}();
}

    void serialize_struct(boost::json::object& json, const VkAccelerationStructureTrianglesOpacityMicromapEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& indexType_json=json["indexType"];
[&](){[&](){[&](){indexType_json=member.indexType;}();}();}();
auto& indexBuffer_json=json["indexBuffer"];
[&](){
            auto& temp=indexBuffer_json.emplace_object();
            return serialize_struct(temp, member.indexBuffer);
            }();
auto& indexStride_json=json["indexStride"];
[&](){[&](){indexStride_json=member.indexStride;}();}();
auto& baseTriangle_json=json["baseTriangle"];
[&](){baseTriangle_json=member.baseTriangle;}();
auto& usageCountsCount_json=json["usageCountsCount"];
[&](){usageCountsCount_json=member.usageCountsCount;}();
auto& pUsageCounts_json=json["pUsageCounts"];
[&](){
            if (member.pUsageCounts==NULL){
                pUsageCounts_json=boost::json::array();
            return; }pUsageCounts_json=boost::json::array(member.usageCountsCount);
        auto& arr_ISbbbyT=pUsageCounts_json.as_array();
        for(int fcbtTBG=0; fcbtTBG < member.usageCountsCount; fcbtTBG++){
            [&](){
            auto& temp=arr_ISbbbyT[fcbtTBG].emplace_object();
            return serialize_struct(temp, member.pUsageCounts[fcbtTBG]);
            }();
        }
        }();
auto& ppUsageCounts_json=json["ppUsageCounts"];
[&](){
            if (member.ppUsageCounts==NULL){
                ppUsageCounts_json=boost::json::array();
            return; }ppUsageCounts_json=boost::json::array(member.usageCountsCount);
        auto& arr_tKtvYXX=ppUsageCounts_json.as_array();
        for(int kPEvNon=0; kPEvNon < member.usageCountsCount; kPEvNon++){
            [&](){
            if (member.ppUsageCounts[kPEvNon]==NULL){
                arr_tKtvYXX[kPEvNon]=boost::json::array();
            return; }arr_tKtvYXX[kPEvNon]=boost::json::array(1);
        auto& arr_epKIoAu=arr_tKtvYXX[kPEvNon].as_array();
        for(int bFKrJKe=0; bFKrJKe < 1; bFKrJKe++){
            [&](){
            auto& temp=arr_epKIoAu[bFKrJKe].emplace_object();
            return serialize_struct(temp, member.ppUsageCounts[kPEvNon][bFKrJKe]);
            }();
        }
        }();
        }
        }();
auto& micromap_json=json["micromap"];
[&](){serialize_VkMicromapEXT(micromap_json,member.micromap);}();
}
void deserialize_struct(boost::json::object& json, VkAccelerationStructureTrianglesOpacityMicromapEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& indexType_json=json["indexType"];
[&](){[&](){int temp_sCUtzFY;[&](){temp_sCUtzFY=static_cast<int>(value_to<int>(indexType_json));}();member.indexType=(VkIndexType)temp_sCUtzFY;}();}();
auto& indexBuffer_json=json["indexBuffer"];
[&](){
            auto& temp=indexBuffer_json.as_object();
            deserialize_struct(temp,member.indexBuffer);
            }();
auto& indexStride_json=json["indexStride"];
[&](){uint64_t temp_DmwELfS;[&](){temp_DmwELfS=static_cast<uint64_t>(value_to<int>(indexStride_json));}();member.indexStride=(VkDeviceSize)temp_DmwELfS;}();
auto& baseTriangle_json=json["baseTriangle"];
[&](){member.baseTriangle=static_cast<uint32_t>(value_to<int>(baseTriangle_json));}();
auto& usageCountsCount_json=json["usageCountsCount"];
[&](){member.usageCountsCount=static_cast<uint32_t>(value_to<int>(usageCountsCount_json));}();
auto& pUsageCounts_json=json["pUsageCounts"];
[&](){ VkMicromapUsageEXT* temp_PnhGAGz;;[&](){
            if (pUsageCounts_json.as_array().size()==0){
                temp_PnhGAGz=NULL;
            return; }temp_PnhGAGz=(VkMicromapUsageEXT*)malloc(member.usageCountsCount*sizeof(VkMicromapUsageEXT));
        auto& arr_cxGBOGi=pUsageCounts_json.as_array();
        for(int uiTzGnC=0; uiTzGnC < member.usageCountsCount; uiTzGnC++){
            [&](){
            auto& temp=arr_cxGBOGi[uiTzGnC].as_object();
            deserialize_struct(temp,temp_PnhGAGz[uiTzGnC]);
            }();
        }
        }();member.pUsageCounts=temp_PnhGAGz;}();
auto& ppUsageCounts_json=json["ppUsageCounts"];
[&](){ VkMicromapUsageEXT* * temp_pfcHTud;;[&](){
            if (ppUsageCounts_json.as_array().size()==0){
                temp_pfcHTud=NULL;
            return; }temp_pfcHTud=(VkMicromapUsageEXT**)malloc(member.usageCountsCount*sizeof(VkMicromapUsageEXT*));
        auto& arr_xilHauq=ppUsageCounts_json.as_array();
        for(int XoJSEEr=0; XoJSEEr < member.usageCountsCount; XoJSEEr++){
            [&](){
            if (arr_xilHauq[XoJSEEr].as_array().size()==0){
                temp_pfcHTud[XoJSEEr]=NULL;
            return; }temp_pfcHTud[XoJSEEr]=(VkMicromapUsageEXT*)malloc(1*sizeof(VkMicromapUsageEXT));
        auto& arr_pcsocwp=arr_xilHauq[XoJSEEr].as_array();
        for(int Zbsxegm=0; Zbsxegm < 1; Zbsxegm++){
            [&](){
            auto& temp=arr_pcsocwp[Zbsxegm].as_object();
            deserialize_struct(temp,temp_pfcHTud[XoJSEEr][Zbsxegm]);
            }();
        }
        }();
        }
        }();member.ppUsageCounts=temp_pfcHTud;}();
auto& micromap_json=json["micromap"];
[&](){deserialize_VkMicromapEXT(micromap_json, member.micromap);}();
}

    void serialize_struct(boost::json::object& json, const VkPipelinePropertiesIdentifierEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineIdentifier_json=json["pipelineIdentifier"];
[&](){pipelineIdentifier_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_hBnQYQy=pipelineIdentifier_json.as_array();
        for(int ODNvRcX=0; ODNvRcX < VK_UUID_SIZE; ODNvRcX++){
            [&](){arr_hBnQYQy[ODNvRcX]=member.pipelineIdentifier[ODNvRcX];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkPipelinePropertiesIdentifierEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pipelineIdentifier_json=json["pipelineIdentifier"];
[&](){
        auto& arr_hBnQYQy=pipelineIdentifier_json.as_array();
        for(int ODNvRcX=0; ODNvRcX < VK_UUID_SIZE; ODNvRcX++){
            [&](){member.pipelineIdentifier[ODNvRcX]=static_cast<uint8_t>(value_to<int>(arr_hBnQYQy[ODNvRcX]));}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePipelinePropertiesFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelinePropertiesIdentifier_json=json["pipelinePropertiesIdentifier"];
[&](){[&](){pipelinePropertiesIdentifier_json=member.pipelinePropertiesIdentifier;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePipelinePropertiesFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pipelinePropertiesIdentifier_json=json["pipelinePropertiesIdentifier"];
[&](){uint32_t temp_UKMRJBt;[&](){temp_UKMRJBt=static_cast<uint32_t>(value_to<int>(pipelinePropertiesIdentifier_json));}();member.pipelinePropertiesIdentifier=(VkBool32)temp_UKMRJBt;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderEarlyAndLateFragmentTests_json=json["shaderEarlyAndLateFragmentTests"];
[&](){[&](){shaderEarlyAndLateFragmentTests_json=member.shaderEarlyAndLateFragmentTests;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderEarlyAndLateFragmentTests_json=json["shaderEarlyAndLateFragmentTests"];
[&](){uint32_t temp_AasExMA;[&](){temp_AasExMA=static_cast<uint32_t>(value_to<int>(shaderEarlyAndLateFragmentTests_json));}();member.shaderEarlyAndLateFragmentTests=(VkBool32)temp_AasExMA;}();
}

    void serialize_struct(boost::json::object& json, const VkExternalMemoryAcquireUnmodifiedEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& acquireUnmodifiedMemory_json=json["acquireUnmodifiedMemory"];
[&](){[&](){acquireUnmodifiedMemory_json=member.acquireUnmodifiedMemory;}();}();
}
void deserialize_struct(boost::json::object& json, VkExternalMemoryAcquireUnmodifiedEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& acquireUnmodifiedMemory_json=json["acquireUnmodifiedMemory"];
[&](){uint32_t temp_YBFlBlk;[&](){temp_YBFlBlk=static_cast<uint32_t>(value_to<int>(acquireUnmodifiedMemory_json));}();member.acquireUnmodifiedMemory=(VkBool32)temp_YBFlBlk;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& nonSeamlessCubeMap_json=json["nonSeamlessCubeMap"];
[&](){[&](){nonSeamlessCubeMap_json=member.nonSeamlessCubeMap;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& nonSeamlessCubeMap_json=json["nonSeamlessCubeMap"];
[&](){uint32_t temp_jBtkwVz;[&](){temp_jBtkwVz=static_cast<uint32_t>(value_to<int>(nonSeamlessCubeMap_json));}();member.nonSeamlessCubeMap=(VkBool32)temp_jBtkwVz;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePipelineRobustnessFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineRobustness_json=json["pipelineRobustness"];
[&](){[&](){pipelineRobustness_json=member.pipelineRobustness;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePipelineRobustnessFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pipelineRobustness_json=json["pipelineRobustness"];
[&](){uint32_t temp_GfDoxpL;[&](){temp_GfDoxpL=static_cast<uint32_t>(value_to<int>(pipelineRobustness_json));}();member.pipelineRobustness=(VkBool32)temp_GfDoxpL;}();
}

    void serialize_struct(boost::json::object& json, const VkPipelineRobustnessCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& storageBuffers_json=json["storageBuffers"];
[&](){[&](){[&](){storageBuffers_json=member.storageBuffers;}();}();}();
auto& uniformBuffers_json=json["uniformBuffers"];
[&](){[&](){[&](){uniformBuffers_json=member.uniformBuffers;}();}();}();
auto& vertexInputs_json=json["vertexInputs"];
[&](){[&](){[&](){vertexInputs_json=member.vertexInputs;}();}();}();
auto& images_json=json["images"];
[&](){[&](){[&](){images_json=member.images;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPipelineRobustnessCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& storageBuffers_json=json["storageBuffers"];
[&](){[&](){int temp_gMScghT;[&](){temp_gMScghT=static_cast<int>(value_to<int>(storageBuffers_json));}();member.storageBuffers=(VkPipelineRobustnessBufferBehaviorEXT)temp_gMScghT;}();}();
auto& uniformBuffers_json=json["uniformBuffers"];
[&](){[&](){int temp_RxGulQo;[&](){temp_RxGulQo=static_cast<int>(value_to<int>(uniformBuffers_json));}();member.uniformBuffers=(VkPipelineRobustnessBufferBehaviorEXT)temp_RxGulQo;}();}();
auto& vertexInputs_json=json["vertexInputs"];
[&](){[&](){int temp_qGdTFNc;[&](){temp_qGdTFNc=static_cast<int>(value_to<int>(vertexInputs_json));}();member.vertexInputs=(VkPipelineRobustnessBufferBehaviorEXT)temp_qGdTFNc;}();}();
auto& images_json=json["images"];
[&](){[&](){int temp_JXyzcTD;[&](){temp_JXyzcTD=static_cast<int>(value_to<int>(images_json));}();member.images=(VkPipelineRobustnessImageBehaviorEXT)temp_JXyzcTD;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePipelineRobustnessPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& defaultRobustnessStorageBuffers_json=json["defaultRobustnessStorageBuffers"];
[&](){[&](){[&](){defaultRobustnessStorageBuffers_json=member.defaultRobustnessStorageBuffers;}();}();}();
auto& defaultRobustnessUniformBuffers_json=json["defaultRobustnessUniformBuffers"];
[&](){[&](){[&](){defaultRobustnessUniformBuffers_json=member.defaultRobustnessUniformBuffers;}();}();}();
auto& defaultRobustnessVertexInputs_json=json["defaultRobustnessVertexInputs"];
[&](){[&](){[&](){defaultRobustnessVertexInputs_json=member.defaultRobustnessVertexInputs;}();}();}();
auto& defaultRobustnessImages_json=json["defaultRobustnessImages"];
[&](){[&](){[&](){defaultRobustnessImages_json=member.defaultRobustnessImages;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePipelineRobustnessPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& defaultRobustnessStorageBuffers_json=json["defaultRobustnessStorageBuffers"];
[&](){[&](){int temp_zQYvxNY;[&](){temp_zQYvxNY=static_cast<int>(value_to<int>(defaultRobustnessStorageBuffers_json));}();member.defaultRobustnessStorageBuffers=(VkPipelineRobustnessBufferBehaviorEXT)temp_zQYvxNY;}();}();
auto& defaultRobustnessUniformBuffers_json=json["defaultRobustnessUniformBuffers"];
[&](){[&](){int temp_btoZzll;[&](){temp_btoZzll=static_cast<int>(value_to<int>(defaultRobustnessUniformBuffers_json));}();member.defaultRobustnessUniformBuffers=(VkPipelineRobustnessBufferBehaviorEXT)temp_btoZzll;}();}();
auto& defaultRobustnessVertexInputs_json=json["defaultRobustnessVertexInputs"];
[&](){[&](){int temp_XFwRlkV;[&](){temp_XFwRlkV=static_cast<int>(value_to<int>(defaultRobustnessVertexInputs_json));}();member.defaultRobustnessVertexInputs=(VkPipelineRobustnessBufferBehaviorEXT)temp_XFwRlkV;}();}();
auto& defaultRobustnessImages_json=json["defaultRobustnessImages"];
[&](){[&](){int temp_lOLEqZZ;[&](){temp_lOLEqZZ=static_cast<int>(value_to<int>(defaultRobustnessImages_json));}();member.defaultRobustnessImages=(VkPipelineRobustnessImageBehaviorEXT)temp_lOLEqZZ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkImageViewSampleWeightCreateInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& filterCenter_json=json["filterCenter"];
[&](){
            auto& temp=filterCenter_json.emplace_object();
            return serialize_struct(temp, member.filterCenter);
            }();
auto& filterSize_json=json["filterSize"];
[&](){
            auto& temp=filterSize_json.emplace_object();
            return serialize_struct(temp, member.filterSize);
            }();
auto& numPhases_json=json["numPhases"];
[&](){numPhases_json=member.numPhases;}();
}
void deserialize_struct(boost::json::object& json, VkImageViewSampleWeightCreateInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& filterCenter_json=json["filterCenter"];
[&](){
            auto& temp=filterCenter_json.as_object();
            deserialize_struct(temp,member.filterCenter);
            }();
auto& filterSize_json=json["filterSize"];
[&](){
            auto& temp=filterSize_json.as_object();
            deserialize_struct(temp,member.filterSize);
            }();
auto& numPhases_json=json["numPhases"];
[&](){member.numPhases=static_cast<uint32_t>(value_to<int>(numPhases_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageProcessingFeaturesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& textureSampleWeighted_json=json["textureSampleWeighted"];
[&](){[&](){textureSampleWeighted_json=member.textureSampleWeighted;}();}();
auto& textureBoxFilter_json=json["textureBoxFilter"];
[&](){[&](){textureBoxFilter_json=member.textureBoxFilter;}();}();
auto& textureBlockMatch_json=json["textureBlockMatch"];
[&](){[&](){textureBlockMatch_json=member.textureBlockMatch;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageProcessingFeaturesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& textureSampleWeighted_json=json["textureSampleWeighted"];
[&](){uint32_t temp_IiRCUZB;[&](){temp_IiRCUZB=static_cast<uint32_t>(value_to<int>(textureSampleWeighted_json));}();member.textureSampleWeighted=(VkBool32)temp_IiRCUZB;}();
auto& textureBoxFilter_json=json["textureBoxFilter"];
[&](){uint32_t temp_iYwWerA;[&](){temp_iYwWerA=static_cast<uint32_t>(value_to<int>(textureBoxFilter_json));}();member.textureBoxFilter=(VkBool32)temp_iYwWerA;}();
auto& textureBlockMatch_json=json["textureBlockMatch"];
[&](){uint32_t temp_nruQmGI;[&](){temp_nruQmGI=static_cast<uint32_t>(value_to<int>(textureBlockMatch_json));}();member.textureBlockMatch=(VkBool32)temp_nruQmGI;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageProcessingPropertiesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxWeightFilterPhases_json=json["maxWeightFilterPhases"];
[&](){maxWeightFilterPhases_json=member.maxWeightFilterPhases;}();
auto& maxWeightFilterDimension_json=json["maxWeightFilterDimension"];
[&](){
            auto& temp=maxWeightFilterDimension_json.emplace_object();
            return serialize_struct(temp, member.maxWeightFilterDimension);
            }();
auto& maxBlockMatchRegion_json=json["maxBlockMatchRegion"];
[&](){
            auto& temp=maxBlockMatchRegion_json.emplace_object();
            return serialize_struct(temp, member.maxBlockMatchRegion);
            }();
auto& maxBoxFilterBlockSize_json=json["maxBoxFilterBlockSize"];
[&](){
            auto& temp=maxBoxFilterBlockSize_json.emplace_object();
            return serialize_struct(temp, member.maxBoxFilterBlockSize);
            }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageProcessingPropertiesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxWeightFilterPhases_json=json["maxWeightFilterPhases"];
[&](){member.maxWeightFilterPhases=static_cast<uint32_t>(value_to<int>(maxWeightFilterPhases_json));}();
auto& maxWeightFilterDimension_json=json["maxWeightFilterDimension"];
[&](){
            auto& temp=maxWeightFilterDimension_json.as_object();
            deserialize_struct(temp,member.maxWeightFilterDimension);
            }();
auto& maxBlockMatchRegion_json=json["maxBlockMatchRegion"];
[&](){
            auto& temp=maxBlockMatchRegion_json.as_object();
            deserialize_struct(temp,member.maxBlockMatchRegion);
            }();
auto& maxBoxFilterBlockSize_json=json["maxBoxFilterBlockSize"];
[&](){
            auto& temp=maxBoxFilterBlockSize_json.as_object();
            deserialize_struct(temp,member.maxBoxFilterBlockSize);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceTilePropertiesFeaturesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& tileProperties_json=json["tileProperties"];
[&](){[&](){tileProperties_json=member.tileProperties;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceTilePropertiesFeaturesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& tileProperties_json=json["tileProperties"];
[&](){uint32_t temp_YNcqiDM;[&](){temp_YNcqiDM=static_cast<uint32_t>(value_to<int>(tileProperties_json));}();member.tileProperties=(VkBool32)temp_YNcqiDM;}();
}

    void serialize_struct(boost::json::object& json, const VkTilePropertiesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& tileSize_json=json["tileSize"];
[&](){
            auto& temp=tileSize_json.emplace_object();
            return serialize_struct(temp, member.tileSize);
            }();
auto& apronSize_json=json["apronSize"];
[&](){
            auto& temp=apronSize_json.emplace_object();
            return serialize_struct(temp, member.apronSize);
            }();
auto& origin_json=json["origin"];
[&](){
            auto& temp=origin_json.emplace_object();
            return serialize_struct(temp, member.origin);
            }();
}
void deserialize_struct(boost::json::object& json, VkTilePropertiesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& tileSize_json=json["tileSize"];
[&](){
            auto& temp=tileSize_json.as_object();
            deserialize_struct(temp,member.tileSize);
            }();
auto& apronSize_json=json["apronSize"];
[&](){
            auto& temp=apronSize_json.as_object();
            deserialize_struct(temp,member.apronSize);
            }();
auto& origin_json=json["origin"];
[&](){
            auto& temp=origin_json.as_object();
            deserialize_struct(temp,member.origin);
            }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceAmigoProfilingFeaturesSEC& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& amigoProfiling_json=json["amigoProfiling"];
[&](){[&](){amigoProfiling_json=member.amigoProfiling;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceAmigoProfilingFeaturesSEC& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& amigoProfiling_json=json["amigoProfiling"];
[&](){uint32_t temp_blaVfYh;[&](){temp_blaVfYh=static_cast<uint32_t>(value_to<int>(amigoProfiling_json));}();member.amigoProfiling=(VkBool32)temp_blaVfYh;}();
}

    void serialize_struct(boost::json::object& json, const VkAmigoProfilingSubmitInfoSEC& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& firstDrawTimestamp_json=json["firstDrawTimestamp"];
[&](){firstDrawTimestamp_json=member.firstDrawTimestamp;}();
auto& swapBufferTimestamp_json=json["swapBufferTimestamp"];
[&](){swapBufferTimestamp_json=member.swapBufferTimestamp;}();
}
void deserialize_struct(boost::json::object& json, VkAmigoProfilingSubmitInfoSEC& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& firstDrawTimestamp_json=json["firstDrawTimestamp"];
[&](){member.firstDrawTimestamp=static_cast<uint64_t>(value_to<int>(firstDrawTimestamp_json));}();
auto& swapBufferTimestamp_json=json["swapBufferTimestamp"];
[&](){member.swapBufferTimestamp=static_cast<uint64_t>(value_to<int>(swapBufferTimestamp_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& attachmentFeedbackLoopLayout_json=json["attachmentFeedbackLoopLayout"];
[&](){[&](){attachmentFeedbackLoopLayout_json=member.attachmentFeedbackLoopLayout;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& attachmentFeedbackLoopLayout_json=json["attachmentFeedbackLoopLayout"];
[&](){uint32_t temp_HoMeRxa;[&](){temp_HoMeRxa=static_cast<uint32_t>(value_to<int>(attachmentFeedbackLoopLayout_json));}();member.attachmentFeedbackLoopLayout=(VkBool32)temp_HoMeRxa;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& depthClampZeroOne_json=json["depthClampZeroOne"];
[&](){[&](){depthClampZeroOne_json=member.depthClampZeroOne;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDepthClampZeroOneFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& depthClampZeroOne_json=json["depthClampZeroOne"];
[&](){uint32_t temp_XdNlTVA;[&](){temp_XdNlTVA=static_cast<uint32_t>(value_to<int>(depthClampZeroOne_json));}();member.depthClampZeroOne=(VkBool32)temp_XdNlTVA;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceAddressBindingReportFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& reportAddressBinding_json=json["reportAddressBinding"];
[&](){[&](){reportAddressBinding_json=member.reportAddressBinding;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceAddressBindingReportFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& reportAddressBinding_json=json["reportAddressBinding"];
[&](){uint32_t temp_HHOcSzt;[&](){temp_HHOcSzt=static_cast<uint32_t>(value_to<int>(reportAddressBinding_json));}();member.reportAddressBinding=(VkBool32)temp_HHOcSzt;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceAddressBindingCallbackDataEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& baseAddress_json=json["baseAddress"];
[&](){[&](){baseAddress_json=member.baseAddress;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
auto& bindingType_json=json["bindingType"];
[&](){[&](){[&](){bindingType_json=member.bindingType;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceAddressBindingCallbackDataEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_mZulDvJ;[&](){temp_mZulDvJ=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDeviceAddressBindingFlagsEXT)temp_mZulDvJ;}();}();
auto& baseAddress_json=json["baseAddress"];
[&](){uint64_t temp_fQReIVP;[&](){temp_fQReIVP=static_cast<uint64_t>(value_to<int>(baseAddress_json));}();member.baseAddress=(VkDeviceAddress)temp_fQReIVP;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
auto& bindingType_json=json["bindingType"];
[&](){[&](){int temp_JzkgRkZ;[&](){temp_JzkgRkZ=static_cast<int>(value_to<int>(bindingType_json));}();member.bindingType=(VkDeviceAddressBindingTypeEXT)temp_JzkgRkZ;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceOpticalFlowFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& opticalFlow_json=json["opticalFlow"];
[&](){[&](){opticalFlow_json=member.opticalFlow;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceOpticalFlowFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& opticalFlow_json=json["opticalFlow"];
[&](){uint32_t temp_NiGBcPV;[&](){temp_NiGBcPV=static_cast<uint32_t>(value_to<int>(opticalFlow_json));}();member.opticalFlow=(VkBool32)temp_NiGBcPV;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceOpticalFlowPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& supportedOutputGridSizes_json=json["supportedOutputGridSizes"];
[&](){[&](){[&](){supportedOutputGridSizes_json=member.supportedOutputGridSizes;}();}();}();
auto& supportedHintGridSizes_json=json["supportedHintGridSizes"];
[&](){[&](){[&](){supportedHintGridSizes_json=member.supportedHintGridSizes;}();}();}();
auto& hintSupported_json=json["hintSupported"];
[&](){[&](){hintSupported_json=member.hintSupported;}();}();
auto& costSupported_json=json["costSupported"];
[&](){[&](){costSupported_json=member.costSupported;}();}();
auto& bidirectionalFlowSupported_json=json["bidirectionalFlowSupported"];
[&](){[&](){bidirectionalFlowSupported_json=member.bidirectionalFlowSupported;}();}();
auto& globalFlowSupported_json=json["globalFlowSupported"];
[&](){[&](){globalFlowSupported_json=member.globalFlowSupported;}();}();
auto& minWidth_json=json["minWidth"];
[&](){minWidth_json=member.minWidth;}();
auto& minHeight_json=json["minHeight"];
[&](){minHeight_json=member.minHeight;}();
auto& maxWidth_json=json["maxWidth"];
[&](){maxWidth_json=member.maxWidth;}();
auto& maxHeight_json=json["maxHeight"];
[&](){maxHeight_json=member.maxHeight;}();
auto& maxNumRegionsOfInterest_json=json["maxNumRegionsOfInterest"];
[&](){maxNumRegionsOfInterest_json=member.maxNumRegionsOfInterest;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceOpticalFlowPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& supportedOutputGridSizes_json=json["supportedOutputGridSizes"];
[&](){[&](){int temp_TLSyVZr;[&](){temp_TLSyVZr=static_cast<int>(value_to<int>(supportedOutputGridSizes_json));}();member.supportedOutputGridSizes=(VkOpticalFlowGridSizeFlagsNV)temp_TLSyVZr;}();}();
auto& supportedHintGridSizes_json=json["supportedHintGridSizes"];
[&](){[&](){int temp_WfvpXZP;[&](){temp_WfvpXZP=static_cast<int>(value_to<int>(supportedHintGridSizes_json));}();member.supportedHintGridSizes=(VkOpticalFlowGridSizeFlagsNV)temp_WfvpXZP;}();}();
auto& hintSupported_json=json["hintSupported"];
[&](){uint32_t temp_PAMZkxh;[&](){temp_PAMZkxh=static_cast<uint32_t>(value_to<int>(hintSupported_json));}();member.hintSupported=(VkBool32)temp_PAMZkxh;}();
auto& costSupported_json=json["costSupported"];
[&](){uint32_t temp_QQRliMy;[&](){temp_QQRliMy=static_cast<uint32_t>(value_to<int>(costSupported_json));}();member.costSupported=(VkBool32)temp_QQRliMy;}();
auto& bidirectionalFlowSupported_json=json["bidirectionalFlowSupported"];
[&](){uint32_t temp_ukcXMTD;[&](){temp_ukcXMTD=static_cast<uint32_t>(value_to<int>(bidirectionalFlowSupported_json));}();member.bidirectionalFlowSupported=(VkBool32)temp_ukcXMTD;}();
auto& globalFlowSupported_json=json["globalFlowSupported"];
[&](){uint32_t temp_kgQyXxq;[&](){temp_kgQyXxq=static_cast<uint32_t>(value_to<int>(globalFlowSupported_json));}();member.globalFlowSupported=(VkBool32)temp_kgQyXxq;}();
auto& minWidth_json=json["minWidth"];
[&](){member.minWidth=static_cast<uint32_t>(value_to<int>(minWidth_json));}();
auto& minHeight_json=json["minHeight"];
[&](){member.minHeight=static_cast<uint32_t>(value_to<int>(minHeight_json));}();
auto& maxWidth_json=json["maxWidth"];
[&](){member.maxWidth=static_cast<uint32_t>(value_to<int>(maxWidth_json));}();
auto& maxHeight_json=json["maxHeight"];
[&](){member.maxHeight=static_cast<uint32_t>(value_to<int>(maxHeight_json));}();
auto& maxNumRegionsOfInterest_json=json["maxNumRegionsOfInterest"];
[&](){member.maxNumRegionsOfInterest=static_cast<uint32_t>(value_to<int>(maxNumRegionsOfInterest_json));}();
}

    void serialize_struct(boost::json::object& json, const VkOpticalFlowImageFormatInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& usage_json=json["usage"];
[&](){[&](){[&](){usage_json=member.usage;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkOpticalFlowImageFormatInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& usage_json=json["usage"];
[&](){[&](){int temp_PoacDYx;[&](){temp_PoacDYx=static_cast<int>(value_to<int>(usage_json));}();member.usage=(VkOpticalFlowUsageFlagsNV)temp_PoacDYx;}();}();
}

    void serialize_struct(boost::json::object& json, const VkOpticalFlowImageFormatPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& format_json=json["format"];
[&](){[&](){[&](){format_json=member.format;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkOpticalFlowImageFormatPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& format_json=json["format"];
[&](){[&](){int temp_vIzYkNH;[&](){temp_vIzYkNH=static_cast<int>(value_to<int>(format_json));}();member.format=(VkFormat)temp_vIzYkNH;}();}();
}

    void serialize_struct(boost::json::object& json, const VkOpticalFlowSessionCreateInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& width_json=json["width"];
[&](){width_json=member.width;}();
auto& height_json=json["height"];
[&](){height_json=member.height;}();
auto& imageFormat_json=json["imageFormat"];
[&](){[&](){[&](){imageFormat_json=member.imageFormat;}();}();}();
auto& flowVectorFormat_json=json["flowVectorFormat"];
[&](){[&](){[&](){flowVectorFormat_json=member.flowVectorFormat;}();}();}();
auto& costFormat_json=json["costFormat"];
[&](){[&](){[&](){costFormat_json=member.costFormat;}();}();}();
auto& outputGridSize_json=json["outputGridSize"];
[&](){[&](){[&](){outputGridSize_json=member.outputGridSize;}();}();}();
auto& hintGridSize_json=json["hintGridSize"];
[&](){[&](){[&](){hintGridSize_json=member.hintGridSize;}();}();}();
auto& performanceLevel_json=json["performanceLevel"];
[&](){[&](){[&](){performanceLevel_json=member.performanceLevel;}();}();}();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkOpticalFlowSessionCreateInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& width_json=json["width"];
[&](){member.width=static_cast<uint32_t>(value_to<int>(width_json));}();
auto& height_json=json["height"];
[&](){member.height=static_cast<uint32_t>(value_to<int>(height_json));}();
auto& imageFormat_json=json["imageFormat"];
[&](){[&](){int temp_BOhPhdB;[&](){temp_BOhPhdB=static_cast<int>(value_to<int>(imageFormat_json));}();member.imageFormat=(VkFormat)temp_BOhPhdB;}();}();
auto& flowVectorFormat_json=json["flowVectorFormat"];
[&](){[&](){int temp_pYmEMhk;[&](){temp_pYmEMhk=static_cast<int>(value_to<int>(flowVectorFormat_json));}();member.flowVectorFormat=(VkFormat)temp_pYmEMhk;}();}();
auto& costFormat_json=json["costFormat"];
[&](){[&](){int temp_aQKtMXP;[&](){temp_aQKtMXP=static_cast<int>(value_to<int>(costFormat_json));}();member.costFormat=(VkFormat)temp_aQKtMXP;}();}();
auto& outputGridSize_json=json["outputGridSize"];
[&](){[&](){int temp_gIJDfmT;[&](){temp_gIJDfmT=static_cast<int>(value_to<int>(outputGridSize_json));}();member.outputGridSize=(VkOpticalFlowGridSizeFlagsNV)temp_gIJDfmT;}();}();
auto& hintGridSize_json=json["hintGridSize"];
[&](){[&](){int temp_SPzQrXh;[&](){temp_SPzQrXh=static_cast<int>(value_to<int>(hintGridSize_json));}();member.hintGridSize=(VkOpticalFlowGridSizeFlagsNV)temp_SPzQrXh;}();}();
auto& performanceLevel_json=json["performanceLevel"];
[&](){[&](){int temp_lcGZbPE;[&](){temp_lcGZbPE=static_cast<int>(value_to<int>(performanceLevel_json));}();member.performanceLevel=(VkOpticalFlowPerformanceLevelNV)temp_lcGZbPE;}();}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_gPJRaVp;[&](){temp_gPJRaVp=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkOpticalFlowSessionCreateFlagsNV)temp_gPJRaVp;}();}();
}

    void serialize_struct(boost::json::object& json, const VkOpticalFlowSessionCreatePrivateDataInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& id_json=json["id"];
[&](){id_json=member.id;}();
auto& size_json=json["size"];
[&](){size_json=member.size;}();
auto& pPrivateData_json=json["pPrivateData"];
[&](){
            if (member.pPrivateData==NULL){
                pPrivateData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pPrivateData))==NULL){
                pPrivateData_json=boost::json::array();
            return; }pPrivateData_json=boost::json::array(strlen(((char*)(member.pPrivateData)))+1);
        auto& arr_jSPWUwe=pPrivateData_json.as_array();
        for(int IsTGaYP=0; IsTGaYP < strlen(((char*)(member.pPrivateData)))+1; IsTGaYP++){
            [&](){arr_jSPWUwe[IsTGaYP]=((char*)(member.pPrivateData))[IsTGaYP];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkOpticalFlowSessionCreatePrivateDataInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& id_json=json["id"];
[&](){member.id=static_cast<uint32_t>(value_to<int>(id_json));}();
auto& size_json=json["size"];
[&](){member.size=static_cast<uint32_t>(value_to<int>(size_json));}();
auto& pPrivateData_json=json["pPrivateData"];
[&](){ void* temp_XOIvhnK;;[&](){
            if (pPrivateData_json.as_array().size()==0){
                temp_XOIvhnK=NULL;
            return; }char* temp_BmEmXzz;[&](){
            if (pPrivateData_json.as_array().size()==0){
                temp_BmEmXzz=NULL;
            return; }temp_BmEmXzz=(char*)malloc(pPrivateData_json.as_array().size()*sizeof(char));
        auto& arr_bmJmfhQ=pPrivateData_json.as_array();
        for(int nmMljYJ=0; nmMljYJ < pPrivateData_json.as_array().size(); nmMljYJ++){
            [&](){temp_BmEmXzz[nmMljYJ]=static_cast<char>(value_to<int>(arr_bmJmfhQ[nmMljYJ]));}();
        }
        }();temp_XOIvhnK=temp_BmEmXzz;}();member.pPrivateData=temp_XOIvhnK;}();
}

    void serialize_struct(boost::json::object& json, const VkOpticalFlowExecuteInfoNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& regionCount_json=json["regionCount"];
[&](){regionCount_json=member.regionCount;}();
auto& pRegions_json=json["pRegions"];
[&](){
            if (member.pRegions==NULL){
                pRegions_json=boost::json::array();
            return; }pRegions_json=boost::json::array(member.regionCount);
        auto& arr_xyUxORq=pRegions_json.as_array();
        for(int tsobRzD=0; tsobRzD < member.regionCount; tsobRzD++){
            [&](){
            auto& temp=arr_xyUxORq[tsobRzD].emplace_object();
            return serialize_struct(temp, member.pRegions[tsobRzD]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkOpticalFlowExecuteInfoNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_tfCvJZA;[&](){temp_tfCvJZA=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkOpticalFlowExecuteFlagsNV)temp_tfCvJZA;}();}();
auto& regionCount_json=json["regionCount"];
[&](){member.regionCount=static_cast<uint32_t>(value_to<int>(regionCount_json));}();
auto& pRegions_json=json["pRegions"];
[&](){ VkRect2D* temp_GwCWjHO;;[&](){
            if (pRegions_json.as_array().size()==0){
                temp_GwCWjHO=NULL;
            return; }temp_GwCWjHO=(VkRect2D*)malloc(member.regionCount*sizeof(VkRect2D));
        auto& arr_AUAmgpH=pRegions_json.as_array();
        for(int TIDWZvK=0; TIDWZvK < member.regionCount; TIDWZvK++){
            [&](){
            auto& temp=arr_AUAmgpH[TIDWZvK].as_object();
            deserialize_struct(temp,temp_GwCWjHO[TIDWZvK]);
            }();
        }
        }();member.pRegions=temp_GwCWjHO;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFaultFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& deviceFault_json=json["deviceFault"];
[&](){[&](){deviceFault_json=member.deviceFault;}();}();
auto& deviceFaultVendorBinary_json=json["deviceFaultVendorBinary"];
[&](){[&](){deviceFaultVendorBinary_json=member.deviceFaultVendorBinary;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFaultFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& deviceFault_json=json["deviceFault"];
[&](){uint32_t temp_wiRQBWg;[&](){temp_wiRQBWg=static_cast<uint32_t>(value_to<int>(deviceFault_json));}();member.deviceFault=(VkBool32)temp_wiRQBWg;}();
auto& deviceFaultVendorBinary_json=json["deviceFaultVendorBinary"];
[&](){uint32_t temp_sgwfeGh;[&](){temp_sgwfeGh=static_cast<uint32_t>(value_to<int>(deviceFaultVendorBinary_json));}();member.deviceFaultVendorBinary=(VkBool32)temp_sgwfeGh;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceFaultAddressInfoEXT& member){
        
    
auto& addressType_json=json["addressType"];
[&](){[&](){[&](){addressType_json=member.addressType;}();}();}();
auto& reportedAddress_json=json["reportedAddress"];
[&](){[&](){reportedAddress_json=member.reportedAddress;}();}();
auto& addressPrecision_json=json["addressPrecision"];
[&](){[&](){addressPrecision_json=member.addressPrecision;}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceFaultAddressInfoEXT& member){
auto& addressType_json=json["addressType"];
[&](){[&](){int temp_XeiEXbz;[&](){temp_XeiEXbz=static_cast<int>(value_to<int>(addressType_json));}();member.addressType=(VkDeviceFaultAddressTypeEXT)temp_XeiEXbz;}();}();
auto& reportedAddress_json=json["reportedAddress"];
[&](){uint64_t temp_PCDLLVd;[&](){temp_PCDLLVd=static_cast<uint64_t>(value_to<int>(reportedAddress_json));}();member.reportedAddress=(VkDeviceAddress)temp_PCDLLVd;}();
auto& addressPrecision_json=json["addressPrecision"];
[&](){uint64_t temp_TAtIoKS;[&](){temp_TAtIoKS=static_cast<uint64_t>(value_to<int>(addressPrecision_json));}();member.addressPrecision=(VkDeviceSize)temp_TAtIoKS;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceFaultVendorInfoEXT& member){
        
    
auto& description_json=json["description"];
[&](){description_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){arr_XKStCoi[xOHuflK]=member.description[xOHuflK];}();
        }
        }();
auto& vendorFaultCode_json=json["vendorFaultCode"];
[&](){vendorFaultCode_json=member.vendorFaultCode;}();
auto& vendorFaultData_json=json["vendorFaultData"];
[&](){vendorFaultData_json=member.vendorFaultData;}();
}
void deserialize_struct(boost::json::object& json, VkDeviceFaultVendorInfoEXT& member){
auto& description_json=json["description"];
[&](){
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){member.description[xOHuflK]=static_cast<char>(value_to<int>(arr_XKStCoi[xOHuflK]));}();
        }
        }();
auto& vendorFaultCode_json=json["vendorFaultCode"];
[&](){member.vendorFaultCode=static_cast<uint64_t>(value_to<int>(vendorFaultCode_json));}();
auto& vendorFaultData_json=json["vendorFaultData"];
[&](){member.vendorFaultData=static_cast<uint64_t>(value_to<int>(vendorFaultData_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceFaultCountsEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& addressInfoCount_json=json["addressInfoCount"];
[&](){addressInfoCount_json=member.addressInfoCount;}();
auto& vendorInfoCount_json=json["vendorInfoCount"];
[&](){vendorInfoCount_json=member.vendorInfoCount;}();
auto& vendorBinarySize_json=json["vendorBinarySize"];
[&](){[&](){vendorBinarySize_json=member.vendorBinarySize;}();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceFaultCountsEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& addressInfoCount_json=json["addressInfoCount"];
[&](){member.addressInfoCount=static_cast<uint32_t>(value_to<int>(addressInfoCount_json));}();
auto& vendorInfoCount_json=json["vendorInfoCount"];
[&](){member.vendorInfoCount=static_cast<uint32_t>(value_to<int>(vendorInfoCount_json));}();
auto& vendorBinarySize_json=json["vendorBinarySize"];
[&](){uint64_t temp_WXkXrQe;[&](){temp_WXkXrQe=static_cast<uint64_t>(value_to<int>(vendorBinarySize_json));}();member.vendorBinarySize=(VkDeviceSize)temp_WXkXrQe;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceFaultInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& description_json=json["description"];
[&](){description_json=boost::json::array(VK_MAX_DESCRIPTION_SIZE);
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){arr_XKStCoi[xOHuflK]=member.description[xOHuflK];}();
        }
        }();
auto& pAddressInfos_json=json["pAddressInfos"];
[&](){
            if (member.pAddressInfos==NULL){
                pAddressInfos_json=boost::json::array();
            return; }pAddressInfos_json=boost::json::array(1);
        auto& arr_UnNfNMF=pAddressInfos_json.as_array();
        for(int ypOCYMK=0; ypOCYMK < 1; ypOCYMK++){
            [&](){
            auto& temp=arr_UnNfNMF[ypOCYMK].emplace_object();
            return serialize_struct(temp, member.pAddressInfos[ypOCYMK]);
            }();
        }
        }();
auto& pVendorInfos_json=json["pVendorInfos"];
[&](){
            if (member.pVendorInfos==NULL){
                pVendorInfos_json=boost::json::array();
            return; }pVendorInfos_json=boost::json::array(1);
        auto& arr_wWSNRSk=pVendorInfos_json.as_array();
        for(int GvWjMmU=0; GvWjMmU < 1; GvWjMmU++){
            [&](){
            auto& temp=arr_wWSNRSk[GvWjMmU].emplace_object();
            return serialize_struct(temp, member.pVendorInfos[GvWjMmU]);
            }();
        }
        }();
auto& pVendorBinaryData_json=json["pVendorBinaryData"];
[&](){
            if (member.pVendorBinaryData==NULL){
                pVendorBinaryData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pVendorBinaryData))==NULL){
                pVendorBinaryData_json=boost::json::array();
            return; }pVendorBinaryData_json=boost::json::array(strlen(((char*)(member.pVendorBinaryData)))+1);
        auto& arr_UjtduAY=pVendorBinaryData_json.as_array();
        for(int svQUInl=0; svQUInl < strlen(((char*)(member.pVendorBinaryData)))+1; svQUInl++){
            [&](){arr_UjtduAY[svQUInl]=((char*)(member.pVendorBinaryData))[svQUInl];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkDeviceFaultInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& description_json=json["description"];
[&](){
        auto& arr_XKStCoi=description_json.as_array();
        for(int xOHuflK=0; xOHuflK < VK_MAX_DESCRIPTION_SIZE; xOHuflK++){
            [&](){member.description[xOHuflK]=static_cast<char>(value_to<int>(arr_XKStCoi[xOHuflK]));}();
        }
        }();
auto& pAddressInfos_json=json["pAddressInfos"];
[&](){
            if (pAddressInfos_json.as_array().size()==0){
                member.pAddressInfos=NULL;
            return; }member.pAddressInfos=(VkDeviceFaultAddressInfoEXT*)malloc(1*sizeof(VkDeviceFaultAddressInfoEXT));
        auto& arr_UnNfNMF=pAddressInfos_json.as_array();
        for(int ypOCYMK=0; ypOCYMK < 1; ypOCYMK++){
            [&](){
            auto& temp=arr_UnNfNMF[ypOCYMK].as_object();
            deserialize_struct(temp,member.pAddressInfos[ypOCYMK]);
            }();
        }
        }();
auto& pVendorInfos_json=json["pVendorInfos"];
[&](){
            if (pVendorInfos_json.as_array().size()==0){
                member.pVendorInfos=NULL;
            return; }member.pVendorInfos=(VkDeviceFaultVendorInfoEXT*)malloc(1*sizeof(VkDeviceFaultVendorInfoEXT));
        auto& arr_wWSNRSk=pVendorInfos_json.as_array();
        for(int GvWjMmU=0; GvWjMmU < 1; GvWjMmU++){
            [&](){
            auto& temp=arr_wWSNRSk[GvWjMmU].as_object();
            deserialize_struct(temp,member.pVendorInfos[GvWjMmU]);
            }();
        }
        }();
auto& pVendorBinaryData_json=json["pVendorBinaryData"];
[&](){
            if (pVendorBinaryData_json.as_array().size()==0){
                member.pVendorBinaryData=NULL;
            return; }char* temp_qkBFJQZ;[&](){
            if (pVendorBinaryData_json.as_array().size()==0){
                temp_qkBFJQZ=NULL;
            return; }temp_qkBFJQZ=(char*)malloc(pVendorBinaryData_json.as_array().size()*sizeof(char));
        auto& arr_UjtduAY=pVendorBinaryData_json.as_array();
        for(int svQUInl=0; svQUInl < pVendorBinaryData_json.as_array().size(); svQUInl++){
            [&](){temp_qkBFJQZ[svQUInl]=static_cast<char>(value_to<int>(arr_UjtduAY[svQUInl]));}();
        }
        }();member.pVendorBinaryData=temp_qkBFJQZ;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceFaultVendorBinaryHeaderVersionOneEXT& member){
        
    
auto& headerSize_json=json["headerSize"];
[&](){headerSize_json=member.headerSize;}();
auto& headerVersion_json=json["headerVersion"];
[&](){[&](){[&](){headerVersion_json=member.headerVersion;}();}();}();
auto& vendorID_json=json["vendorID"];
[&](){vendorID_json=member.vendorID;}();
auto& deviceID_json=json["deviceID"];
[&](){deviceID_json=member.deviceID;}();
auto& driverVersion_json=json["driverVersion"];
[&](){driverVersion_json=member.driverVersion;}();
auto& pipelineCacheUUID_json=json["pipelineCacheUUID"];
[&](){pipelineCacheUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_nLZmyOs=pipelineCacheUUID_json.as_array();
        for(int tnNOYvF=0; tnNOYvF < VK_UUID_SIZE; tnNOYvF++){
            [&](){arr_nLZmyOs[tnNOYvF]=member.pipelineCacheUUID[tnNOYvF];}();
        }
        }();
auto& applicationNameOffset_json=json["applicationNameOffset"];
[&](){applicationNameOffset_json=member.applicationNameOffset;}();
auto& applicationVersion_json=json["applicationVersion"];
[&](){applicationVersion_json=member.applicationVersion;}();
auto& engineNameOffset_json=json["engineNameOffset"];
[&](){engineNameOffset_json=member.engineNameOffset;}();
auto& engineVersion_json=json["engineVersion"];
[&](){engineVersion_json=member.engineVersion;}();
auto& apiVersion_json=json["apiVersion"];
[&](){apiVersion_json=member.apiVersion;}();
}
void deserialize_struct(boost::json::object& json, VkDeviceFaultVendorBinaryHeaderVersionOneEXT& member){
auto& headerSize_json=json["headerSize"];
[&](){member.headerSize=static_cast<uint32_t>(value_to<int>(headerSize_json));}();
auto& headerVersion_json=json["headerVersion"];
[&](){[&](){int temp_mbxkYQP;[&](){temp_mbxkYQP=static_cast<int>(value_to<int>(headerVersion_json));}();member.headerVersion=(VkDeviceFaultVendorBinaryHeaderVersionEXT)temp_mbxkYQP;}();}();
auto& vendorID_json=json["vendorID"];
[&](){member.vendorID=static_cast<uint32_t>(value_to<int>(vendorID_json));}();
auto& deviceID_json=json["deviceID"];
[&](){member.deviceID=static_cast<uint32_t>(value_to<int>(deviceID_json));}();
auto& driverVersion_json=json["driverVersion"];
[&](){member.driverVersion=static_cast<uint32_t>(value_to<int>(driverVersion_json));}();
auto& pipelineCacheUUID_json=json["pipelineCacheUUID"];
[&](){
        auto& arr_nLZmyOs=pipelineCacheUUID_json.as_array();
        for(int tnNOYvF=0; tnNOYvF < VK_UUID_SIZE; tnNOYvF++){
            [&](){member.pipelineCacheUUID[tnNOYvF]=static_cast<uint8_t>(value_to<int>(arr_nLZmyOs[tnNOYvF]));}();
        }
        }();
auto& applicationNameOffset_json=json["applicationNameOffset"];
[&](){member.applicationNameOffset=static_cast<uint32_t>(value_to<int>(applicationNameOffset_json));}();
auto& applicationVersion_json=json["applicationVersion"];
[&](){member.applicationVersion=static_cast<uint32_t>(value_to<int>(applicationVersion_json));}();
auto& engineNameOffset_json=json["engineNameOffset"];
[&](){member.engineNameOffset=static_cast<uint32_t>(value_to<int>(engineNameOffset_json));}();
auto& engineVersion_json=json["engineVersion"];
[&](){member.engineVersion=static_cast<uint32_t>(value_to<int>(engineVersion_json));}();
auto& apiVersion_json=json["apiVersion"];
[&](){member.apiVersion=static_cast<uint32_t>(value_to<int>(apiVersion_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pipelineLibraryGroupHandles_json=json["pipelineLibraryGroupHandles"];
[&](){[&](){pipelineLibraryGroupHandles_json=member.pipelineLibraryGroupHandles;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pipelineLibraryGroupHandles_json=json["pipelineLibraryGroupHandles"];
[&](){uint32_t temp_eCLxtth;[&](){temp_eCLxtth=static_cast<uint32_t>(value_to<int>(pipelineLibraryGroupHandles_json));}();member.pipelineLibraryGroupHandles=(VkBool32)temp_eCLxtth;}();
}

    void serialize_struct(boost::json::object& json, const VkDepthBiasInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& depthBiasConstantFactor_json=json["depthBiasConstantFactor"];
[&](){depthBiasConstantFactor_json=member.depthBiasConstantFactor;}();
auto& depthBiasClamp_json=json["depthBiasClamp"];
[&](){depthBiasClamp_json=member.depthBiasClamp;}();
auto& depthBiasSlopeFactor_json=json["depthBiasSlopeFactor"];
[&](){depthBiasSlopeFactor_json=member.depthBiasSlopeFactor;}();
}
void deserialize_struct(boost::json::object& json, VkDepthBiasInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& depthBiasConstantFactor_json=json["depthBiasConstantFactor"];
[&](){member.depthBiasConstantFactor=static_cast<float>(value_to<int>(depthBiasConstantFactor_json));}();
auto& depthBiasClamp_json=json["depthBiasClamp"];
[&](){member.depthBiasClamp=static_cast<float>(value_to<int>(depthBiasClamp_json));}();
auto& depthBiasSlopeFactor_json=json["depthBiasSlopeFactor"];
[&](){member.depthBiasSlopeFactor=static_cast<float>(value_to<int>(depthBiasSlopeFactor_json));}();
}

    void serialize_struct(boost::json::object& json, const VkDepthBiasRepresentationInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& depthBiasRepresentation_json=json["depthBiasRepresentation"];
[&](){[&](){[&](){depthBiasRepresentation_json=member.depthBiasRepresentation;}();}();}();
auto& depthBiasExact_json=json["depthBiasExact"];
[&](){[&](){depthBiasExact_json=member.depthBiasExact;}();}();
}
void deserialize_struct(boost::json::object& json, VkDepthBiasRepresentationInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& depthBiasRepresentation_json=json["depthBiasRepresentation"];
[&](){[&](){int temp_hPnHfFn;[&](){temp_hPnHfFn=static_cast<int>(value_to<int>(depthBiasRepresentation_json));}();member.depthBiasRepresentation=(VkDepthBiasRepresentationEXT)temp_hPnHfFn;}();}();
auto& depthBiasExact_json=json["depthBiasExact"];
[&](){uint32_t temp_MUBYmRi;[&](){temp_MUBYmRi=static_cast<uint32_t>(value_to<int>(depthBiasExact_json));}();member.depthBiasExact=(VkBool32)temp_MUBYmRi;}();
}

    void serialize_struct(boost::json::object& json, const VkDecompressMemoryRegionNV& member){
        
    
auto& srcAddress_json=json["srcAddress"];
[&](){[&](){srcAddress_json=member.srcAddress;}();}();
auto& dstAddress_json=json["dstAddress"];
[&](){[&](){dstAddress_json=member.dstAddress;}();}();
auto& compressedSize_json=json["compressedSize"];
[&](){[&](){compressedSize_json=member.compressedSize;}();}();
auto& decompressedSize_json=json["decompressedSize"];
[&](){[&](){decompressedSize_json=member.decompressedSize;}();}();
auto& decompressionMethod_json=json["decompressionMethod"];
[&](){[&](){[&](){decompressionMethod_json=member.decompressionMethod;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkDecompressMemoryRegionNV& member){
auto& srcAddress_json=json["srcAddress"];
[&](){uint64_t temp_qCbCSnK;[&](){temp_qCbCSnK=static_cast<uint64_t>(value_to<int>(srcAddress_json));}();member.srcAddress=(VkDeviceAddress)temp_qCbCSnK;}();
auto& dstAddress_json=json["dstAddress"];
[&](){uint64_t temp_ownHFoz;[&](){temp_ownHFoz=static_cast<uint64_t>(value_to<int>(dstAddress_json));}();member.dstAddress=(VkDeviceAddress)temp_ownHFoz;}();
auto& compressedSize_json=json["compressedSize"];
[&](){uint64_t temp_ZyiznvB;[&](){temp_ZyiznvB=static_cast<uint64_t>(value_to<int>(compressedSize_json));}();member.compressedSize=(VkDeviceSize)temp_ZyiznvB;}();
auto& decompressedSize_json=json["decompressedSize"];
[&](){uint64_t temp_tPSTsiS;[&](){temp_tPSTsiS=static_cast<uint64_t>(value_to<int>(decompressedSize_json));}();member.decompressedSize=(VkDeviceSize)temp_tPSTsiS;}();
auto& decompressionMethod_json=json["decompressionMethod"];
[&](){[&](){int temp_KdfpWgn;[&](){temp_KdfpWgn=static_cast<int>(value_to<int>(decompressionMethod_json));}();member.decompressionMethod=(VkMemoryDecompressionMethodFlagsNV)temp_KdfpWgn;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderCoreMask_json=json["shaderCoreMask"];
[&](){shaderCoreMask_json=member.shaderCoreMask;}();
auto& shaderCoreCount_json=json["shaderCoreCount"];
[&](){shaderCoreCount_json=member.shaderCoreCount;}();
auto& shaderWarpsPerCore_json=json["shaderWarpsPerCore"];
[&](){shaderWarpsPerCore_json=member.shaderWarpsPerCore;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderCoreMask_json=json["shaderCoreMask"];
[&](){member.shaderCoreMask=static_cast<uint64_t>(value_to<int>(shaderCoreMask_json));}();
auto& shaderCoreCount_json=json["shaderCoreCount"];
[&](){member.shaderCoreCount=static_cast<uint32_t>(value_to<int>(shaderCoreCount_json));}();
auto& shaderWarpsPerCore_json=json["shaderWarpsPerCore"];
[&](){member.shaderWarpsPerCore=static_cast<uint32_t>(value_to<int>(shaderWarpsPerCore_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderCoreBuiltins_json=json["shaderCoreBuiltins"];
[&](){[&](){shaderCoreBuiltins_json=member.shaderCoreBuiltins;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderCoreBuiltins_json=json["shaderCoreBuiltins"];
[&](){uint32_t temp_uerwBMg;[&](){temp_uerwBMg=static_cast<uint32_t>(value_to<int>(shaderCoreBuiltins_json));}();member.shaderCoreBuiltins=(VkBool32)temp_uerwBMg;}();
}

    void serialize_struct(boost::json::object& json, const VkFrameBoundaryEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& frameID_json=json["frameID"];
[&](){frameID_json=member.frameID;}();
auto& imageCount_json=json["imageCount"];
[&](){imageCount_json=member.imageCount;}();
auto& pImages_json=json["pImages"];
[&](){
            if (member.pImages==NULL){
                pImages_json=boost::json::array();
            return; }pImages_json=boost::json::array(member.imageCount);
        auto& arr_bOJLRee=pImages_json.as_array();
        for(int SkZrgZX=0; SkZrgZX < member.imageCount; SkZrgZX++){
            [&](){serialize_VkImage(arr_bOJLRee[SkZrgZX],member.pImages[SkZrgZX]);}();
        }
        }();
auto& bufferCount_json=json["bufferCount"];
[&](){bufferCount_json=member.bufferCount;}();
auto& pBuffers_json=json["pBuffers"];
[&](){
            if (member.pBuffers==NULL){
                pBuffers_json=boost::json::array();
            return; }pBuffers_json=boost::json::array(member.bufferCount);
        auto& arr_IcGwYwf=pBuffers_json.as_array();
        for(int eyXGVyQ=0; eyXGVyQ < member.bufferCount; eyXGVyQ++){
            [&](){serialize_VkBuffer(arr_IcGwYwf[eyXGVyQ],member.pBuffers[eyXGVyQ]);}();
        }
        }();
auto& tagName_json=json["tagName"];
[&](){tagName_json=member.tagName;}();
auto& tagSize_json=json["tagSize"];
[&](){tagSize_json=member.tagSize;}();
auto& pTag_json=json["pTag"];
[&](){
            if (member.pTag==NULL){
                pTag_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pTag))==NULL){
                pTag_json=boost::json::array();
            return; }pTag_json=boost::json::array(strlen(((char*)(member.pTag)))+1);
        auto& arr_FJzNXuD=pTag_json.as_array();
        for(int LCdjkoW=0; LCdjkoW < strlen(((char*)(member.pTag)))+1; LCdjkoW++){
            [&](){arr_FJzNXuD[LCdjkoW]=((char*)(member.pTag))[LCdjkoW];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkFrameBoundaryEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_FnFWvBF;[&](){temp_FnFWvBF=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkFrameBoundaryFlagsEXT)temp_FnFWvBF;}();}();
auto& frameID_json=json["frameID"];
[&](){member.frameID=static_cast<uint64_t>(value_to<int>(frameID_json));}();
auto& imageCount_json=json["imageCount"];
[&](){member.imageCount=static_cast<uint32_t>(value_to<int>(imageCount_json));}();
auto& pImages_json=json["pImages"];
[&](){ VkImage* temp_pdDejft;;[&](){
            if (pImages_json.as_array().size()==0){
                temp_pdDejft=NULL;
            return; }temp_pdDejft=(VkImage*)malloc(member.imageCount*sizeof(VkImage));
        auto& arr_gVOAPkD=pImages_json.as_array();
        for(int Kmmcikz=0; Kmmcikz < member.imageCount; Kmmcikz++){
            [&](){deserialize_VkImage(arr_gVOAPkD[Kmmcikz], temp_pdDejft[Kmmcikz]);}();
        }
        }();member.pImages=temp_pdDejft;}();
auto& bufferCount_json=json["bufferCount"];
[&](){member.bufferCount=static_cast<uint32_t>(value_to<int>(bufferCount_json));}();
auto& pBuffers_json=json["pBuffers"];
[&](){ VkBuffer* temp_LLXcbqM;;[&](){
            if (pBuffers_json.as_array().size()==0){
                temp_LLXcbqM=NULL;
            return; }temp_LLXcbqM=(VkBuffer*)malloc(member.bufferCount*sizeof(VkBuffer));
        auto& arr_ltYiOSI=pBuffers_json.as_array();
        for(int EdcHGAo=0; EdcHGAo < member.bufferCount; EdcHGAo++){
            [&](){deserialize_VkBuffer(arr_ltYiOSI[EdcHGAo], temp_LLXcbqM[EdcHGAo]);}();
        }
        }();member.pBuffers=temp_LLXcbqM;}();
auto& tagName_json=json["tagName"];
[&](){member.tagName=static_cast<uint64_t>(value_to<int>(tagName_json));}();
auto& tagSize_json=json["tagSize"];
[&](){member.tagSize=static_cast<size_t>(value_to<int>(tagSize_json));}();
auto& pTag_json=json["pTag"];
[&](){ void* temp_PSkTDjB;;[&](){
            if (pTag_json.as_array().size()==0){
                temp_PSkTDjB=NULL;
            return; }char* temp_ggwGDbs;[&](){
            if (pTag_json.as_array().size()==0){
                temp_ggwGDbs=NULL;
            return; }temp_ggwGDbs=(char*)malloc(pTag_json.as_array().size()*sizeof(char));
        auto& arr_ewjwcVs=pTag_json.as_array();
        for(int uOzVzVX=0; uOzVzVX < pTag_json.as_array().size(); uOzVzVX++){
            [&](){temp_ggwGDbs[uOzVzVX]=static_cast<char>(value_to<int>(arr_ewjwcVs[uOzVzVX]));}();
        }
        }();temp_PSkTDjB=temp_ggwGDbs;}();member.pTag=temp_PSkTDjB;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceFrameBoundaryFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& frameBoundary_json=json["frameBoundary"];
[&](){[&](){frameBoundary_json=member.frameBoundary;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceFrameBoundaryFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& frameBoundary_json=json["frameBoundary"];
[&](){uint32_t temp_qbCWGGZ;[&](){temp_qbCWGGZ=static_cast<uint32_t>(value_to<int>(frameBoundary_json));}();member.frameBoundary=(VkBool32)temp_qbCWGGZ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& dynamicRenderingUnusedAttachments_json=json["dynamicRenderingUnusedAttachments"];
[&](){[&](){dynamicRenderingUnusedAttachments_json=member.dynamicRenderingUnusedAttachments;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& dynamicRenderingUnusedAttachments_json=json["dynamicRenderingUnusedAttachments"];
[&](){uint32_t temp_NLdceFl;[&](){temp_NLdceFl=static_cast<uint32_t>(value_to<int>(dynamicRenderingUnusedAttachments_json));}();member.dynamicRenderingUnusedAttachments=(VkBool32)temp_NLdceFl;}();
}

    void serialize_struct(boost::json::object& json, const VkSurfacePresentModeEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& presentMode_json=json["presentMode"];
[&](){[&](){[&](){presentMode_json=member.presentMode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSurfacePresentModeEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& presentMode_json=json["presentMode"];
[&](){[&](){int temp_iaJAWxo;[&](){temp_iaJAWxo=static_cast<int>(value_to<int>(presentMode_json));}();member.presentMode=(VkPresentModeKHR)temp_iaJAWxo;}();}();
}

    void serialize_struct(boost::json::object& json, const VkSurfacePresentScalingCapabilitiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& supportedPresentScaling_json=json["supportedPresentScaling"];
[&](){[&](){[&](){supportedPresentScaling_json=member.supportedPresentScaling;}();}();}();
auto& supportedPresentGravityX_json=json["supportedPresentGravityX"];
[&](){[&](){[&](){supportedPresentGravityX_json=member.supportedPresentGravityX;}();}();}();
auto& supportedPresentGravityY_json=json["supportedPresentGravityY"];
[&](){[&](){[&](){supportedPresentGravityY_json=member.supportedPresentGravityY;}();}();}();
auto& minScaledImageExtent_json=json["minScaledImageExtent"];
[&](){
            auto& temp=minScaledImageExtent_json.emplace_object();
            return serialize_struct(temp, member.minScaledImageExtent);
            }();
auto& maxScaledImageExtent_json=json["maxScaledImageExtent"];
[&](){
            auto& temp=maxScaledImageExtent_json.emplace_object();
            return serialize_struct(temp, member.maxScaledImageExtent);
            }();
}
void deserialize_struct(boost::json::object& json, VkSurfacePresentScalingCapabilitiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& supportedPresentScaling_json=json["supportedPresentScaling"];
[&](){[&](){int temp_eKvCRwo;[&](){temp_eKvCRwo=static_cast<int>(value_to<int>(supportedPresentScaling_json));}();member.supportedPresentScaling=(VkPresentScalingFlagsEXT)temp_eKvCRwo;}();}();
auto& supportedPresentGravityX_json=json["supportedPresentGravityX"];
[&](){[&](){int temp_VUjExYb;[&](){temp_VUjExYb=static_cast<int>(value_to<int>(supportedPresentGravityX_json));}();member.supportedPresentGravityX=(VkPresentGravityFlagsEXT)temp_VUjExYb;}();}();
auto& supportedPresentGravityY_json=json["supportedPresentGravityY"];
[&](){[&](){int temp_ZVimFpz;[&](){temp_ZVimFpz=static_cast<int>(value_to<int>(supportedPresentGravityY_json));}();member.supportedPresentGravityY=(VkPresentGravityFlagsEXT)temp_ZVimFpz;}();}();
auto& minScaledImageExtent_json=json["minScaledImageExtent"];
[&](){
            auto& temp=minScaledImageExtent_json.as_object();
            deserialize_struct(temp,member.minScaledImageExtent);
            }();
auto& maxScaledImageExtent_json=json["maxScaledImageExtent"];
[&](){
            auto& temp=maxScaledImageExtent_json.as_object();
            deserialize_struct(temp,member.maxScaledImageExtent);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSurfacePresentModeCompatibilityEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& presentModeCount_json=json["presentModeCount"];
[&](){presentModeCount_json=member.presentModeCount;}();
auto& pPresentModes_json=json["pPresentModes"];
[&](){
            if (member.pPresentModes==NULL){
                pPresentModes_json=boost::json::array();
            return; }pPresentModes_json=boost::json::array(member.presentModeCount);
        auto& arr_wwXJJnL=pPresentModes_json.as_array();
        for(int FIcDtVl=0; FIcDtVl < member.presentModeCount; FIcDtVl++){
            [&](){[&](){[&](){arr_wwXJJnL[FIcDtVl]=member.pPresentModes[FIcDtVl];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSurfacePresentModeCompatibilityEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& presentModeCount_json=json["presentModeCount"];
[&](){member.presentModeCount=static_cast<uint32_t>(value_to<int>(presentModeCount_json));}();
auto& pPresentModes_json=json["pPresentModes"];
[&](){
            if (pPresentModes_json.as_array().size()==0){
                member.pPresentModes=NULL;
            return; }member.pPresentModes=(VkPresentModeKHR*)malloc(member.presentModeCount*sizeof(VkPresentModeKHR));
        auto& arr_wwXJJnL=pPresentModes_json.as_array();
        for(int FIcDtVl=0; FIcDtVl < member.presentModeCount; FIcDtVl++){
            [&](){[&](){int temp_unsgDfz;[&](){temp_unsgDfz=static_cast<int>(value_to<int>(arr_wwXJJnL[FIcDtVl]));}();member.pPresentModes[FIcDtVl]=(VkPresentModeKHR)temp_unsgDfz;}();}();
        }
        }();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchainMaintenance1_json=json["swapchainMaintenance1"];
[&](){[&](){swapchainMaintenance1_json=member.swapchainMaintenance1;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& swapchainMaintenance1_json=json["swapchainMaintenance1"];
[&](){uint32_t temp_ZVIDrUR;[&](){temp_ZVIDrUR=static_cast<uint32_t>(value_to<int>(swapchainMaintenance1_json));}();member.swapchainMaintenance1=(VkBool32)temp_ZVIDrUR;}();
}

    void serialize_struct(boost::json::object& json, const VkSwapchainPresentFenceInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchainCount_json=json["swapchainCount"];
[&](){swapchainCount_json=member.swapchainCount;}();
auto& pFences_json=json["pFences"];
[&](){
            if (member.pFences==NULL){
                pFences_json=boost::json::array();
            return; }pFences_json=boost::json::array(member.swapchainCount);
        auto& arr_EzapEnY=pFences_json.as_array();
        for(int XxcVHDd=0; XxcVHDd < member.swapchainCount; XxcVHDd++){
            [&](){serialize_VkFence(arr_EzapEnY[XxcVHDd],member.pFences[XxcVHDd]);}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSwapchainPresentFenceInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchainCount_json=json["swapchainCount"];
[&](){member.swapchainCount=static_cast<uint32_t>(value_to<int>(swapchainCount_json));}();
auto& pFences_json=json["pFences"];
[&](){ VkFence* temp_JOcgSsr;;[&](){
            if (pFences_json.as_array().size()==0){
                temp_JOcgSsr=NULL;
            return; }temp_JOcgSsr=(VkFence*)malloc(member.swapchainCount*sizeof(VkFence));
        auto& arr_gpoylyV=pFences_json.as_array();
        for(int dsNzNJH=0; dsNzNJH < member.swapchainCount; dsNzNJH++){
            [&](){deserialize_VkFence(arr_gpoylyV[dsNzNJH], temp_JOcgSsr[dsNzNJH]);}();
        }
        }();member.pFences=temp_JOcgSsr;}();
}

    void serialize_struct(boost::json::object& json, const VkSwapchainPresentModesCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& presentModeCount_json=json["presentModeCount"];
[&](){presentModeCount_json=member.presentModeCount;}();
auto& pPresentModes_json=json["pPresentModes"];
[&](){
            if (member.pPresentModes==NULL){
                pPresentModes_json=boost::json::array();
            return; }pPresentModes_json=boost::json::array(member.presentModeCount);
        auto& arr_cRacBhu=pPresentModes_json.as_array();
        for(int wkhrNzv=0; wkhrNzv < member.presentModeCount; wkhrNzv++){
            [&](){[&](){[&](){arr_cRacBhu[wkhrNzv]=member.pPresentModes[wkhrNzv];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSwapchainPresentModesCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& presentModeCount_json=json["presentModeCount"];
[&](){member.presentModeCount=static_cast<uint32_t>(value_to<int>(presentModeCount_json));}();
auto& pPresentModes_json=json["pPresentModes"];
[&](){ VkPresentModeKHR* temp_KDEZkEe;;[&](){
            if (pPresentModes_json.as_array().size()==0){
                temp_KDEZkEe=NULL;
            return; }temp_KDEZkEe=(VkPresentModeKHR*)malloc(member.presentModeCount*sizeof(VkPresentModeKHR));
        auto& arr_RUloPkq=pPresentModes_json.as_array();
        for(int euyNrPT=0; euyNrPT < member.presentModeCount; euyNrPT++){
            [&](){[&](){int temp_UuFOJTZ;[&](){temp_UuFOJTZ=static_cast<int>(value_to<int>(arr_RUloPkq[euyNrPT]));}();temp_KDEZkEe[euyNrPT]=(VkPresentModeKHR)temp_UuFOJTZ;}();}();
        }
        }();member.pPresentModes=temp_KDEZkEe;}();
}

    void serialize_struct(boost::json::object& json, const VkSwapchainPresentModeInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchainCount_json=json["swapchainCount"];
[&](){swapchainCount_json=member.swapchainCount;}();
auto& pPresentModes_json=json["pPresentModes"];
[&](){
            if (member.pPresentModes==NULL){
                pPresentModes_json=boost::json::array();
            return; }pPresentModes_json=boost::json::array(member.swapchainCount);
        auto& arr_cRacBhu=pPresentModes_json.as_array();
        for(int wkhrNzv=0; wkhrNzv < member.swapchainCount; wkhrNzv++){
            [&](){[&](){[&](){arr_cRacBhu[wkhrNzv]=member.pPresentModes[wkhrNzv];}();}();}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkSwapchainPresentModeInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchainCount_json=json["swapchainCount"];
[&](){member.swapchainCount=static_cast<uint32_t>(value_to<int>(swapchainCount_json));}();
auto& pPresentModes_json=json["pPresentModes"];
[&](){ VkPresentModeKHR* temp_vgFkoBT;;[&](){
            if (pPresentModes_json.as_array().size()==0){
                temp_vgFkoBT=NULL;
            return; }temp_vgFkoBT=(VkPresentModeKHR*)malloc(member.swapchainCount*sizeof(VkPresentModeKHR));
        auto& arr_RUloPkq=pPresentModes_json.as_array();
        for(int euyNrPT=0; euyNrPT < member.swapchainCount; euyNrPT++){
            [&](){[&](){int temp_UuFOJTZ;[&](){temp_UuFOJTZ=static_cast<int>(value_to<int>(arr_RUloPkq[euyNrPT]));}();temp_vgFkoBT[euyNrPT]=(VkPresentModeKHR)temp_UuFOJTZ;}();}();
        }
        }();member.pPresentModes=temp_vgFkoBT;}();
}

    void serialize_struct(boost::json::object& json, const VkSwapchainPresentScalingCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& scalingBehavior_json=json["scalingBehavior"];
[&](){[&](){[&](){scalingBehavior_json=member.scalingBehavior;}();}();}();
auto& presentGravityX_json=json["presentGravityX"];
[&](){[&](){[&](){presentGravityX_json=member.presentGravityX;}();}();}();
auto& presentGravityY_json=json["presentGravityY"];
[&](){[&](){[&](){presentGravityY_json=member.presentGravityY;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSwapchainPresentScalingCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& scalingBehavior_json=json["scalingBehavior"];
[&](){[&](){int temp_EpQfKnn;[&](){temp_EpQfKnn=static_cast<int>(value_to<int>(scalingBehavior_json));}();member.scalingBehavior=(VkPresentScalingFlagsEXT)temp_EpQfKnn;}();}();
auto& presentGravityX_json=json["presentGravityX"];
[&](){[&](){int temp_mJZjdXH;[&](){temp_mJZjdXH=static_cast<int>(value_to<int>(presentGravityX_json));}();member.presentGravityX=(VkPresentGravityFlagsEXT)temp_mJZjdXH;}();}();
auto& presentGravityY_json=json["presentGravityY"];
[&](){[&](){int temp_TfqgLnq;[&](){temp_TfqgLnq=static_cast<int>(value_to<int>(presentGravityY_json));}();member.presentGravityY=(VkPresentGravityFlagsEXT)temp_TfqgLnq;}();}();
}

    void serialize_struct(boost::json::object& json, const VkReleaseSwapchainImagesInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& swapchain_json=json["swapchain"];
[&](){serialize_VkSwapchainKHR(swapchain_json,member.swapchain);}();
auto& imageIndexCount_json=json["imageIndexCount"];
[&](){imageIndexCount_json=member.imageIndexCount;}();
auto& pImageIndices_json=json["pImageIndices"];
[&](){
            if (member.pImageIndices==NULL){
                pImageIndices_json=boost::json::array();
            return; }pImageIndices_json=boost::json::array(member.imageIndexCount);
        auto& arr_fmPZCwp=pImageIndices_json.as_array();
        for(int lfPeqDF=0; lfPeqDF < member.imageIndexCount; lfPeqDF++){
            [&](){arr_fmPZCwp[lfPeqDF]=member.pImageIndices[lfPeqDF];}();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkReleaseSwapchainImagesInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& swapchain_json=json["swapchain"];
[&](){deserialize_VkSwapchainKHR(swapchain_json, member.swapchain);}();
auto& imageIndexCount_json=json["imageIndexCount"];
[&](){member.imageIndexCount=static_cast<uint32_t>(value_to<int>(imageIndexCount_json));}();
auto& pImageIndices_json=json["pImageIndices"];
[&](){ uint32_t* temp_ELTaXUF;;[&](){
            if (pImageIndices_json.as_array().size()==0){
                temp_ELTaXUF=NULL;
            return; }temp_ELTaXUF=(uint32_t*)malloc(member.imageIndexCount*sizeof(uint32_t));
        auto& arr_wIgefjv=pImageIndices_json.as_array();
        for(int MuunZXi=0; MuunZXi < member.imageIndexCount; MuunZXi++){
            [&](){temp_ELTaXUF[MuunZXi]=static_cast<uint32_t>(value_to<int>(arr_wIgefjv[MuunZXi]));}();
        }
        }();member.pImageIndices=temp_ELTaXUF;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDepthBiasControlFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& depthBiasControl_json=json["depthBiasControl"];
[&](){[&](){depthBiasControl_json=member.depthBiasControl;}();}();
auto& leastRepresentableValueForceUnormRepresentation_json=json["leastRepresentableValueForceUnormRepresentation"];
[&](){[&](){leastRepresentableValueForceUnormRepresentation_json=member.leastRepresentableValueForceUnormRepresentation;}();}();
auto& floatRepresentation_json=json["floatRepresentation"];
[&](){[&](){floatRepresentation_json=member.floatRepresentation;}();}();
auto& depthBiasExact_json=json["depthBiasExact"];
[&](){[&](){depthBiasExact_json=member.depthBiasExact;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDepthBiasControlFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& depthBiasControl_json=json["depthBiasControl"];
[&](){uint32_t temp_DJfFPnJ;[&](){temp_DJfFPnJ=static_cast<uint32_t>(value_to<int>(depthBiasControl_json));}();member.depthBiasControl=(VkBool32)temp_DJfFPnJ;}();
auto& leastRepresentableValueForceUnormRepresentation_json=json["leastRepresentableValueForceUnormRepresentation"];
[&](){uint32_t temp_tjrXmBV;[&](){temp_tjrXmBV=static_cast<uint32_t>(value_to<int>(leastRepresentableValueForceUnormRepresentation_json));}();member.leastRepresentableValueForceUnormRepresentation=(VkBool32)temp_tjrXmBV;}();
auto& floatRepresentation_json=json["floatRepresentation"];
[&](){uint32_t temp_qycCdHe;[&](){temp_qycCdHe=static_cast<uint32_t>(value_to<int>(floatRepresentation_json));}();member.floatRepresentation=(VkBool32)temp_qycCdHe;}();
auto& depthBiasExact_json=json["depthBiasExact"];
[&](){uint32_t temp_MUBYmRi;[&](){temp_MUBYmRi=static_cast<uint32_t>(value_to<int>(depthBiasExact_json));}();member.depthBiasExact=(VkBool32)temp_MUBYmRi;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rayTracingInvocationReorder_json=json["rayTracingInvocationReorder"];
[&](){[&](){rayTracingInvocationReorder_json=member.rayTracingInvocationReorder;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& rayTracingInvocationReorder_json=json["rayTracingInvocationReorder"];
[&](){uint32_t temp_nVQfTXH;[&](){temp_nVQfTXH=static_cast<uint32_t>(value_to<int>(rayTracingInvocationReorder_json));}();member.rayTracingInvocationReorder=(VkBool32)temp_nVQfTXH;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rayTracingInvocationReorderReorderingHint_json=json["rayTracingInvocationReorderReorderingHint"];
[&](){[&](){[&](){rayTracingInvocationReorderReorderingHint_json=member.rayTracingInvocationReorderReorderingHint;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& rayTracingInvocationReorderReorderingHint_json=json["rayTracingInvocationReorderReorderingHint"];
[&](){[&](){int temp_qYPTQhv;[&](){temp_qYPTQhv=static_cast<int>(value_to<int>(rayTracingInvocationReorderReorderingHint_json));}();member.rayTracingInvocationReorderReorderingHint=(VkRayTracingInvocationReorderModeNV)temp_qYPTQhv;}();}();
}

    void serialize_struct(boost::json::object& json, const VkDirectDriverLoadingInfoLUNARG& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& pfnGetInstanceProcAddr_json=json["pfnGetInstanceProcAddr"];
[&](){
            auto& temp=pfnGetInstanceProcAddr_json.emplace_object();
            return serialize_PFN_vkGetInstanceProcAddrLUNARG(temp, member.pfnGetInstanceProcAddr);
            }();
}
void deserialize_struct(boost::json::object& json, VkDirectDriverLoadingInfoLUNARG& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){int temp_rqUTqOr;[&](){temp_rqUTqOr=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkDirectDriverLoadingFlagsLUNARG)temp_rqUTqOr;}();}();
auto& pfnGetInstanceProcAddr_json=json["pfnGetInstanceProcAddr"];
[&](){
            auto& temp=pfnGetInstanceProcAddr_json.as_object();
            deserialize_PFN_vkGetInstanceProcAddrLUNARG(temp,member.pfnGetInstanceProcAddr);
            }();
}

    void serialize_struct(boost::json::object& json, const VkDirectDriverLoadingListLUNARG& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& mode_json=json["mode"];
[&](){[&](){[&](){mode_json=member.mode;}();}();}();
auto& driverCount_json=json["driverCount"];
[&](){driverCount_json=member.driverCount;}();
auto& pDrivers_json=json["pDrivers"];
[&](){
            if (member.pDrivers==NULL){
                pDrivers_json=boost::json::array();
            return; }pDrivers_json=boost::json::array(member.driverCount);
        auto& arr_buhBPRp=pDrivers_json.as_array();
        for(int pnnfRRV=0; pnnfRRV < member.driverCount; pnnfRRV++){
            [&](){
            auto& temp=arr_buhBPRp[pnnfRRV].emplace_object();
            return serialize_struct(temp, member.pDrivers[pnnfRRV]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDirectDriverLoadingListLUNARG& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& mode_json=json["mode"];
[&](){[&](){int temp_NVZRHGN;[&](){temp_NVZRHGN=static_cast<int>(value_to<int>(mode_json));}();member.mode=(VkDirectDriverLoadingModeLUNARG)temp_NVZRHGN;}();}();
auto& driverCount_json=json["driverCount"];
[&](){member.driverCount=static_cast<uint32_t>(value_to<int>(driverCount_json));}();
auto& pDrivers_json=json["pDrivers"];
[&](){ VkDirectDriverLoadingInfoLUNARG* temp_KGfbmgR;;[&](){
            if (pDrivers_json.as_array().size()==0){
                temp_KGfbmgR=NULL;
            return; }temp_KGfbmgR=(VkDirectDriverLoadingInfoLUNARG*)malloc(member.driverCount*sizeof(VkDirectDriverLoadingInfoLUNARG));
        auto& arr_kBttnVM=pDrivers_json.as_array();
        for(int LDhsTkL=0; LDhsTkL < member.driverCount; LDhsTkL++){
            [&](){
            auto& temp=arr_kBttnVM[LDhsTkL].as_object();
            deserialize_struct(temp,temp_KGfbmgR[LDhsTkL]);
            }();
        }
        }();member.pDrivers=temp_KGfbmgR;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& multiviewPerViewViewports_json=json["multiviewPerViewViewports"];
[&](){[&](){multiviewPerViewViewports_json=member.multiviewPerViewViewports;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& multiviewPerViewViewports_json=json["multiviewPerViewViewports"];
[&](){uint32_t temp_SNsmOcJ;[&](){temp_SNsmOcJ=static_cast<uint32_t>(value_to<int>(multiviewPerViewViewports_json));}();member.multiviewPerViewViewports=(VkBool32)temp_SNsmOcJ;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& rayTracingPositionFetch_json=json["rayTracingPositionFetch"];
[&](){[&](){rayTracingPositionFetch_json=member.rayTracingPositionFetch;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& rayTracingPositionFetch_json=json["rayTracingPositionFetch"];
[&](){uint32_t temp_vDYgLFc;[&](){temp_vDYgLFc=static_cast<uint32_t>(value_to<int>(rayTracingPositionFetch_json));}();member.rayTracingPositionFetch=(VkBool32)temp_vDYgLFc;}();
}

    void serialize_struct(boost::json::object& json, const VkDeviceImageSubresourceInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pCreateInfo_json=json["pCreateInfo"];
[&](){
            if (member.pCreateInfo==NULL){
                pCreateInfo_json=boost::json::array();
            return; }pCreateInfo_json=boost::json::array(1);
        auto& arr_ZehFYFR=pCreateInfo_json.as_array();
        for(int WlalFpx=0; WlalFpx < 1; WlalFpx++){
            [&](){
            auto& temp=arr_ZehFYFR[WlalFpx].emplace_object();
            return serialize_struct(temp, member.pCreateInfo[WlalFpx]);
            }();
        }
        }();
auto& pSubresource_json=json["pSubresource"];
[&](){
            if (member.pSubresource==NULL){
                pSubresource_json=boost::json::array();
            return; }pSubresource_json=boost::json::array(1);
        auto& arr_zPrqsJG=pSubresource_json.as_array();
        for(int qYYdFsm=0; qYYdFsm < 1; qYYdFsm++){
            [&](){
            auto& temp=arr_zPrqsJG[qYYdFsm].emplace_object();
            return serialize_struct(temp, member.pSubresource[qYYdFsm]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkDeviceImageSubresourceInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pCreateInfo_json=json["pCreateInfo"];
[&](){ VkImageCreateInfo* temp_qYyheZw;;[&](){
            if (pCreateInfo_json.as_array().size()==0){
                temp_qYyheZw=NULL;
            return; }temp_qYyheZw=(VkImageCreateInfo*)malloc(1*sizeof(VkImageCreateInfo));
        auto& arr_okKoGgS=pCreateInfo_json.as_array();
        for(int jLxWavY=0; jLxWavY < 1; jLxWavY++){
            [&](){
            auto& temp=arr_okKoGgS[jLxWavY].as_object();
            deserialize_struct(temp,temp_qYyheZw[jLxWavY]);
            }();
        }
        }();member.pCreateInfo=temp_qYyheZw;}();
auto& pSubresource_json=json["pSubresource"];
[&](){ VkImageSubresource2KHR* temp_UIJYocy;;[&](){
            if (pSubresource_json.as_array().size()==0){
                temp_UIJYocy=NULL;
            return; }temp_UIJYocy=(VkImageSubresource2KHR*)malloc(1*sizeof(VkImageSubresource2KHR));
        auto& arr_PNYvKGf=pSubresource_json.as_array();
        for(int zdORIYi=0; zdORIYi < 1; zdORIYi++){
            [&](){
            auto& temp=arr_PNYvKGf[zdORIYi].as_object();
            deserialize_struct(temp,temp_UIJYocy[zdORIYi]);
            }();
        }
        }();member.pSubresource=temp_UIJYocy;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderCorePropertiesARM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pixelRate_json=json["pixelRate"];
[&](){pixelRate_json=member.pixelRate;}();
auto& texelRate_json=json["texelRate"];
[&](){texelRate_json=member.texelRate;}();
auto& fmaRate_json=json["fmaRate"];
[&](){fmaRate_json=member.fmaRate;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderCorePropertiesARM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& pixelRate_json=json["pixelRate"];
[&](){member.pixelRate=static_cast<uint32_t>(value_to<int>(pixelRate_json));}();
auto& texelRate_json=json["texelRate"];
[&](){member.texelRate=static_cast<uint32_t>(value_to<int>(texelRate_json));}();
auto& fmaRate_json=json["fmaRate"];
[&](){member.fmaRate=static_cast<uint32_t>(value_to<int>(fmaRate_json));}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& multiviewPerViewRenderAreas_json=json["multiviewPerViewRenderAreas"];
[&](){[&](){multiviewPerViewRenderAreas_json=member.multiviewPerViewRenderAreas;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& multiviewPerViewRenderAreas_json=json["multiviewPerViewRenderAreas"];
[&](){uint32_t temp_leePXSK;[&](){temp_leePXSK=static_cast<uint32_t>(value_to<int>(multiviewPerViewRenderAreas_json));}();member.multiviewPerViewRenderAreas=(VkBool32)temp_leePXSK;}();
}

    void serialize_struct(boost::json::object& json, const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& perViewRenderAreaCount_json=json["perViewRenderAreaCount"];
[&](){perViewRenderAreaCount_json=member.perViewRenderAreaCount;}();
auto& pPerViewRenderAreas_json=json["pPerViewRenderAreas"];
[&](){
            if (member.pPerViewRenderAreas==NULL){
                pPerViewRenderAreas_json=boost::json::array();
            return; }pPerViewRenderAreas_json=boost::json::array(member.perViewRenderAreaCount);
        auto& arr_YFtcppG=pPerViewRenderAreas_json.as_array();
        for(int KBPTIPg=0; KBPTIPg < member.perViewRenderAreaCount; KBPTIPg++){
            [&](){
            auto& temp=arr_YFtcppG[KBPTIPg].emplace_object();
            return serialize_struct(temp, member.pPerViewRenderAreas[KBPTIPg]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& perViewRenderAreaCount_json=json["perViewRenderAreaCount"];
[&](){member.perViewRenderAreaCount=static_cast<uint32_t>(value_to<int>(perViewRenderAreaCount_json));}();
auto& pPerViewRenderAreas_json=json["pPerViewRenderAreas"];
[&](){ VkRect2D* temp_RJRJdiz;;[&](){
            if (pPerViewRenderAreas_json.as_array().size()==0){
                temp_RJRJdiz=NULL;
            return; }temp_RJRJdiz=(VkRect2D*)malloc(member.perViewRenderAreaCount*sizeof(VkRect2D));
        auto& arr_PJONVTm=pPerViewRenderAreas_json.as_array();
        for(int UuKpHuR=0; UuKpHuR < member.perViewRenderAreaCount; UuKpHuR++){
            [&](){
            auto& temp=arr_PJONVTm[UuKpHuR].as_object();
            deserialize_struct(temp,temp_RJRJdiz[UuKpHuR]);
            }();
        }
        }();member.pPerViewRenderAreas=temp_RJRJdiz;}();
}

    void serialize_struct(boost::json::object& json, const VkQueryLowLatencySupportNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& pQueriedLowLatencyData_json=json["pQueriedLowLatencyData"];
[&](){
            if (member.pQueriedLowLatencyData==NULL){
                pQueriedLowLatencyData_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pQueriedLowLatencyData))==NULL){
                pQueriedLowLatencyData_json=boost::json::array();
            return; }pQueriedLowLatencyData_json=boost::json::array(strlen(((char*)(member.pQueriedLowLatencyData)))+1);
        auto& arr_TaYZcsf=pQueriedLowLatencyData_json.as_array();
        for(int KKwdYza=0; KKwdYza < strlen(((char*)(member.pQueriedLowLatencyData)))+1; KKwdYza++){
            [&](){arr_TaYZcsf[KKwdYza]=((char*)(member.pQueriedLowLatencyData))[KKwdYza];}();
        }
        }();}();
}
void deserialize_struct(boost::json::object& json, VkQueryLowLatencySupportNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& pQueriedLowLatencyData_json=json["pQueriedLowLatencyData"];
[&](){
            if (pQueriedLowLatencyData_json.as_array().size()==0){
                member.pQueriedLowLatencyData=NULL;
            return; }char* temp_TDNanoF;[&](){
            if (pQueriedLowLatencyData_json.as_array().size()==0){
                temp_TDNanoF=NULL;
            return; }temp_TDNanoF=(char*)malloc(pQueriedLowLatencyData_json.as_array().size()*sizeof(char));
        auto& arr_TaYZcsf=pQueriedLowLatencyData_json.as_array();
        for(int KKwdYza=0; KKwdYza < pQueriedLowLatencyData_json.as_array().size(); KKwdYza++){
            [&](){temp_TDNanoF[KKwdYza]=static_cast<char>(value_to<int>(arr_TaYZcsf[KKwdYza]));}();
        }
        }();member.pQueriedLowLatencyData=temp_TDNanoF;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryMapInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
auto& offset_json=json["offset"];
[&](){[&](){offset_json=member.offset;}();}();
auto& size_json=json["size"];
[&](){[&](){size_json=member.size;}();}();
}
void deserialize_struct(boost::json::object& json, VkMemoryMapInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_qgNDnEv;[&](){temp_qgNDnEv=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkMemoryMapFlags)temp_qgNDnEv;}();}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
auto& offset_json=json["offset"];
[&](){uint64_t temp_EwrXfgl;[&](){temp_EwrXfgl=static_cast<uint64_t>(value_to<int>(offset_json));}();member.offset=(VkDeviceSize)temp_EwrXfgl;}();
auto& size_json=json["size"];
[&](){uint64_t temp_AdFSvGi;[&](){temp_AdFSvGi=static_cast<uint64_t>(value_to<int>(size_json));}();member.size=(VkDeviceSize)temp_AdFSvGi;}();
}

    void serialize_struct(boost::json::object& json, const VkMemoryUnmapInfoKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& memory_json=json["memory"];
[&](){serialize_VkDeviceMemory(memory_json,member.memory);}();
}
void deserialize_struct(boost::json::object& json, VkMemoryUnmapInfoKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_KJqVlGe;[&](){temp_KJqVlGe=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkMemoryUnmapFlagsKHR)temp_KJqVlGe;}();}();
auto& memory_json=json["memory"];
[&](){deserialize_VkDeviceMemory(memory_json, member.memory);}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderObjectFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderObject_json=json["shaderObject"];
[&](){[&](){shaderObject_json=member.shaderObject;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderObjectFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderObject_json=json["shaderObject"];
[&](){uint32_t temp_VwylZcL;[&](){temp_VwylZcL=static_cast<uint32_t>(value_to<int>(shaderObject_json));}();member.shaderObject=(VkBool32)temp_VwylZcL;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderObjectPropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderBinaryUUID_json=json["shaderBinaryUUID"];
[&](){shaderBinaryUUID_json=boost::json::array(VK_UUID_SIZE);
        auto& arr_yVRZKUN=shaderBinaryUUID_json.as_array();
        for(int jdiUEzK=0; jdiUEzK < VK_UUID_SIZE; jdiUEzK++){
            [&](){arr_yVRZKUN[jdiUEzK]=member.shaderBinaryUUID[jdiUEzK];}();
        }
        }();
auto& shaderBinaryVersion_json=json["shaderBinaryVersion"];
[&](){shaderBinaryVersion_json=member.shaderBinaryVersion;}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderObjectPropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderBinaryUUID_json=json["shaderBinaryUUID"];
[&](){
        auto& arr_yVRZKUN=shaderBinaryUUID_json.as_array();
        for(int jdiUEzK=0; jdiUEzK < VK_UUID_SIZE; jdiUEzK++){
            [&](){member.shaderBinaryUUID[jdiUEzK]=static_cast<uint8_t>(value_to<int>(arr_yVRZKUN[jdiUEzK]));}();
        }
        }();
auto& shaderBinaryVersion_json=json["shaderBinaryVersion"];
[&](){member.shaderBinaryVersion=static_cast<uint32_t>(value_to<int>(shaderBinaryVersion_json));}();
}

    void serialize_struct(boost::json::object& json, const VkShaderCreateInfoEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& flags_json=json["flags"];
[&](){[&](){[&](){flags_json=member.flags;}();}();}();
auto& stage_json=json["stage"];
[&](){[&](){[&](){stage_json=member.stage;}();}();}();
auto& nextStage_json=json["nextStage"];
[&](){[&](){[&](){nextStage_json=member.nextStage;}();}();}();
auto& codeType_json=json["codeType"];
[&](){[&](){[&](){codeType_json=member.codeType;}();}();}();
auto& codeSize_json=json["codeSize"];
[&](){codeSize_json=member.codeSize;}();
auto& pCode_json=json["pCode"];
[&](){
            if (member.pCode==NULL){
                pCode_json=boost::json::array();
            return; }[&](){
            if (((char*)(member.pCode))==NULL){
                pCode_json=boost::json::array();
            return; }pCode_json=boost::json::array(member.codeSize);
        auto& arr_IFfhMkY=pCode_json.as_array();
        for(int OYFIRtg=0; OYFIRtg < member.codeSize; OYFIRtg++){
            [&](){arr_IFfhMkY[OYFIRtg]=((char*)(member.pCode))[OYFIRtg];}();
        }
        }();}();
auto& pName_json=json["pName"];
[&](){
            if (member.pName==NULL){
                pName_json=boost::json::array();
            return; }pName_json=boost::json::array(strlen(member.pName)+1);
        auto& arr_RNtEgHa=pName_json.as_array();
        for(int JRJzPhN=0; JRJzPhN < strlen(member.pName)+1; JRJzPhN++){
            [&](){arr_RNtEgHa[JRJzPhN]=member.pName[JRJzPhN];}();
        }
        }();
auto& setLayoutCount_json=json["setLayoutCount"];
[&](){setLayoutCount_json=member.setLayoutCount;}();
auto& pSetLayouts_json=json["pSetLayouts"];
[&](){
            if (member.pSetLayouts==NULL){
                pSetLayouts_json=boost::json::array();
            return; }pSetLayouts_json=boost::json::array(member.setLayoutCount);
        auto& arr_zVMtIaT=pSetLayouts_json.as_array();
        for(int uklMdkt=0; uklMdkt < member.setLayoutCount; uklMdkt++){
            [&](){serialize_VkDescriptorSetLayout(arr_zVMtIaT[uklMdkt],member.pSetLayouts[uklMdkt]);}();
        }
        }();
auto& pushConstantRangeCount_json=json["pushConstantRangeCount"];
[&](){pushConstantRangeCount_json=member.pushConstantRangeCount;}();
auto& pPushConstantRanges_json=json["pPushConstantRanges"];
[&](){
            if (member.pPushConstantRanges==NULL){
                pPushConstantRanges_json=boost::json::array();
            return; }pPushConstantRanges_json=boost::json::array(member.pushConstantRangeCount);
        auto& arr_doTQoKZ=pPushConstantRanges_json.as_array();
        for(int IhaFWFv=0; IhaFWFv < member.pushConstantRangeCount; IhaFWFv++){
            [&](){
            auto& temp=arr_doTQoKZ[IhaFWFv].emplace_object();
            return serialize_struct(temp, member.pPushConstantRanges[IhaFWFv]);
            }();
        }
        }();
auto& pSpecializationInfo_json=json["pSpecializationInfo"];
[&](){
            if (member.pSpecializationInfo==NULL){
                pSpecializationInfo_json=boost::json::array();
            return; }pSpecializationInfo_json=boost::json::array(1);
        auto& arr_AfbichW=pSpecializationInfo_json.as_array();
        for(int lSuLhWh=0; lSuLhWh < 1; lSuLhWh++){
            [&](){
            auto& temp=arr_AfbichW[lSuLhWh].emplace_object();
            return serialize_struct(temp, member.pSpecializationInfo[lSuLhWh]);
            }();
        }
        }();
}
void deserialize_struct(boost::json::object& json, VkShaderCreateInfoEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& flags_json=json["flags"];
[&](){[&](){int temp_aglisDB;[&](){temp_aglisDB=static_cast<int>(value_to<int>(flags_json));}();member.flags=(VkShaderCreateFlagsEXT)temp_aglisDB;}();}();
auto& stage_json=json["stage"];
[&](){[&](){int temp_IHUgemq;[&](){temp_IHUgemq=static_cast<int>(value_to<int>(stage_json));}();member.stage=(VkShaderStageFlagBits)temp_IHUgemq;}();}();
auto& nextStage_json=json["nextStage"];
[&](){[&](){int temp_AXVDxXz;[&](){temp_AXVDxXz=static_cast<int>(value_to<int>(nextStage_json));}();member.nextStage=(VkShaderStageFlags)temp_AXVDxXz;}();}();
auto& codeType_json=json["codeType"];
[&](){[&](){int temp_itoWcLv;[&](){temp_itoWcLv=static_cast<int>(value_to<int>(codeType_json));}();member.codeType=(VkShaderCodeTypeEXT)temp_itoWcLv;}();}();
auto& codeSize_json=json["codeSize"];
[&](){member.codeSize=static_cast<size_t>(value_to<int>(codeSize_json));}();
auto& pCode_json=json["pCode"];
[&](){ void* temp_QXiYhLC;;[&](){
            if (pCode_json.as_array().size()==0){
                temp_QXiYhLC=NULL;
            return; }char* temp_dSsBPnc;[&](){
            if (pCode_json.as_array().size()==0){
                temp_dSsBPnc=NULL;
            return; }temp_dSsBPnc=(char*)malloc(member.codeSize*sizeof(char));
        auto& arr_TlXMCuz=pCode_json.as_array();
        for(int FNdEBir=0; FNdEBir < member.codeSize; FNdEBir++){
            [&](){temp_dSsBPnc[FNdEBir]=static_cast<char>(value_to<int>(arr_TlXMCuz[FNdEBir]));}();
        }
        }();temp_QXiYhLC=temp_dSsBPnc;}();member.pCode=temp_QXiYhLC;}();
auto& pName_json=json["pName"];
[&](){ char* temp_AzKgJNk;;[&](){
            if (pName_json.as_array().size()==0){
                temp_AzKgJNk=NULL;
            return; }temp_AzKgJNk=(char*)malloc(pName_json.as_array().size()*sizeof(char));
        auto& arr_SFTpFTT=pName_json.as_array();
        for(int zYvyZlQ=0; zYvyZlQ < pName_json.as_array().size(); zYvyZlQ++){
            [&](){temp_AzKgJNk[zYvyZlQ]=static_cast<char>(value_to<int>(arr_SFTpFTT[zYvyZlQ]));}();
        }
        }();member.pName=temp_AzKgJNk;}();
auto& setLayoutCount_json=json["setLayoutCount"];
[&](){member.setLayoutCount=static_cast<uint32_t>(value_to<int>(setLayoutCount_json));}();
auto& pSetLayouts_json=json["pSetLayouts"];
[&](){ VkDescriptorSetLayout* temp_bpLPvjG;;[&](){
            if (pSetLayouts_json.as_array().size()==0){
                temp_bpLPvjG=NULL;
            return; }temp_bpLPvjG=(VkDescriptorSetLayout*)malloc(member.setLayoutCount*sizeof(VkDescriptorSetLayout));
        auto& arr_KfikEjZ=pSetLayouts_json.as_array();
        for(int nDMuHRP=0; nDMuHRP < member.setLayoutCount; nDMuHRP++){
            [&](){deserialize_VkDescriptorSetLayout(arr_KfikEjZ[nDMuHRP], temp_bpLPvjG[nDMuHRP]);}();
        }
        }();member.pSetLayouts=temp_bpLPvjG;}();
auto& pushConstantRangeCount_json=json["pushConstantRangeCount"];
[&](){member.pushConstantRangeCount=static_cast<uint32_t>(value_to<int>(pushConstantRangeCount_json));}();
auto& pPushConstantRanges_json=json["pPushConstantRanges"];
[&](){ VkPushConstantRange* temp_VHwwNeL;;[&](){
            if (pPushConstantRanges_json.as_array().size()==0){
                temp_VHwwNeL=NULL;
            return; }temp_VHwwNeL=(VkPushConstantRange*)malloc(member.pushConstantRangeCount*sizeof(VkPushConstantRange));
        auto& arr_ezithAb=pPushConstantRanges_json.as_array();
        for(int RRqDZWS=0; RRqDZWS < member.pushConstantRangeCount; RRqDZWS++){
            [&](){
            auto& temp=arr_ezithAb[RRqDZWS].as_object();
            deserialize_struct(temp,temp_VHwwNeL[RRqDZWS]);
            }();
        }
        }();member.pPushConstantRanges=temp_VHwwNeL;}();
auto& pSpecializationInfo_json=json["pSpecializationInfo"];
[&](){ VkSpecializationInfo* temp_vphocRa;;[&](){
            if (pSpecializationInfo_json.as_array().size()==0){
                temp_vphocRa=NULL;
            return; }temp_vphocRa=(VkSpecializationInfo*)malloc(1*sizeof(VkSpecializationInfo));
        auto& arr_byhNwxk=pSpecializationInfo_json.as_array();
        for(int zWKlFhs=0; zWKlFhs < 1; zWKlFhs++){
            [&](){
            auto& temp=arr_byhNwxk[zWKlFhs].as_object();
            deserialize_struct(temp,temp_vphocRa[zWKlFhs]);
            }();
        }
        }();member.pSpecializationInfo=temp_vphocRa;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderTileImageFeaturesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderTileImageColorReadAccess_json=json["shaderTileImageColorReadAccess"];
[&](){[&](){shaderTileImageColorReadAccess_json=member.shaderTileImageColorReadAccess;}();}();
auto& shaderTileImageDepthReadAccess_json=json["shaderTileImageDepthReadAccess"];
[&](){[&](){shaderTileImageDepthReadAccess_json=member.shaderTileImageDepthReadAccess;}();}();
auto& shaderTileImageStencilReadAccess_json=json["shaderTileImageStencilReadAccess"];
[&](){[&](){shaderTileImageStencilReadAccess_json=member.shaderTileImageStencilReadAccess;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderTileImageFeaturesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderTileImageColorReadAccess_json=json["shaderTileImageColorReadAccess"];
[&](){uint32_t temp_YRyMhpN;[&](){temp_YRyMhpN=static_cast<uint32_t>(value_to<int>(shaderTileImageColorReadAccess_json));}();member.shaderTileImageColorReadAccess=(VkBool32)temp_YRyMhpN;}();
auto& shaderTileImageDepthReadAccess_json=json["shaderTileImageDepthReadAccess"];
[&](){uint32_t temp_sZeggUG;[&](){temp_sZeggUG=static_cast<uint32_t>(value_to<int>(shaderTileImageDepthReadAccess_json));}();member.shaderTileImageDepthReadAccess=(VkBool32)temp_sZeggUG;}();
auto& shaderTileImageStencilReadAccess_json=json["shaderTileImageStencilReadAccess"];
[&](){uint32_t temp_wcqIOzq;[&](){temp_wcqIOzq=static_cast<uint32_t>(value_to<int>(shaderTileImageStencilReadAccess_json));}();member.shaderTileImageStencilReadAccess=(VkBool32)temp_wcqIOzq;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceShaderTileImagePropertiesEXT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& shaderTileImageCoherentReadAccelerated_json=json["shaderTileImageCoherentReadAccelerated"];
[&](){[&](){shaderTileImageCoherentReadAccelerated_json=member.shaderTileImageCoherentReadAccelerated;}();}();
auto& shaderTileImageReadSampleFromPixelRateInvocation_json=json["shaderTileImageReadSampleFromPixelRateInvocation"];
[&](){[&](){shaderTileImageReadSampleFromPixelRateInvocation_json=member.shaderTileImageReadSampleFromPixelRateInvocation;}();}();
auto& shaderTileImageReadFromHelperInvocation_json=json["shaderTileImageReadFromHelperInvocation"];
[&](){[&](){shaderTileImageReadFromHelperInvocation_json=member.shaderTileImageReadFromHelperInvocation;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceShaderTileImagePropertiesEXT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& shaderTileImageCoherentReadAccelerated_json=json["shaderTileImageCoherentReadAccelerated"];
[&](){uint32_t temp_mRgSurO;[&](){temp_mRgSurO=static_cast<uint32_t>(value_to<int>(shaderTileImageCoherentReadAccelerated_json));}();member.shaderTileImageCoherentReadAccelerated=(VkBool32)temp_mRgSurO;}();
auto& shaderTileImageReadSampleFromPixelRateInvocation_json=json["shaderTileImageReadSampleFromPixelRateInvocation"];
[&](){uint32_t temp_kNmKQnV;[&](){temp_kNmKQnV=static_cast<uint32_t>(value_to<int>(shaderTileImageReadSampleFromPixelRateInvocation_json));}();member.shaderTileImageReadSampleFromPixelRateInvocation=(VkBool32)temp_kNmKQnV;}();
auto& shaderTileImageReadFromHelperInvocation_json=json["shaderTileImageReadFromHelperInvocation"];
[&](){uint32_t temp_rfkdnZp;[&](){temp_rfkdnZp=static_cast<uint32_t>(value_to<int>(shaderTileImageReadFromHelperInvocation_json));}();member.shaderTileImageReadFromHelperInvocation=(VkBool32)temp_rfkdnZp;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCooperativeMatrixFeaturesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& cooperativeMatrix_json=json["cooperativeMatrix"];
[&](){[&](){cooperativeMatrix_json=member.cooperativeMatrix;}();}();
auto& cooperativeMatrixRobustBufferAccess_json=json["cooperativeMatrixRobustBufferAccess"];
[&](){[&](){cooperativeMatrixRobustBufferAccess_json=member.cooperativeMatrixRobustBufferAccess;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCooperativeMatrixFeaturesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& cooperativeMatrix_json=json["cooperativeMatrix"];
[&](){uint32_t temp_qiHCmYX;[&](){temp_qiHCmYX=static_cast<uint32_t>(value_to<int>(cooperativeMatrix_json));}();member.cooperativeMatrix=(VkBool32)temp_qiHCmYX;}();
auto& cooperativeMatrixRobustBufferAccess_json=json["cooperativeMatrixRobustBufferAccess"];
[&](){uint32_t temp_bJZwwLn;[&](){temp_bJZwwLn=static_cast<uint32_t>(value_to<int>(cooperativeMatrixRobustBufferAccess_json));}();member.cooperativeMatrixRobustBufferAccess=(VkBool32)temp_bJZwwLn;}();
}

    void serialize_struct(boost::json::object& json, const VkCooperativeMatrixPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& MSize_json=json["MSize"];
[&](){MSize_json=member.MSize;}();
auto& NSize_json=json["NSize"];
[&](){NSize_json=member.NSize;}();
auto& KSize_json=json["KSize"];
[&](){KSize_json=member.KSize;}();
auto& AType_json=json["AType"];
[&](){[&](){[&](){AType_json=member.AType;}();}();}();
auto& BType_json=json["BType"];
[&](){[&](){[&](){BType_json=member.BType;}();}();}();
auto& CType_json=json["CType"];
[&](){[&](){[&](){CType_json=member.CType;}();}();}();
auto& ResultType_json=json["ResultType"];
[&](){[&](){[&](){ResultType_json=member.ResultType;}();}();}();
auto& saturatingAccumulation_json=json["saturatingAccumulation"];
[&](){[&](){saturatingAccumulation_json=member.saturatingAccumulation;}();}();
auto& scope_json=json["scope"];
[&](){[&](){[&](){scope_json=member.scope;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkCooperativeMatrixPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& MSize_json=json["MSize"];
[&](){member.MSize=static_cast<uint32_t>(value_to<int>(MSize_json));}();
auto& NSize_json=json["NSize"];
[&](){member.NSize=static_cast<uint32_t>(value_to<int>(NSize_json));}();
auto& KSize_json=json["KSize"];
[&](){member.KSize=static_cast<uint32_t>(value_to<int>(KSize_json));}();
auto& AType_json=json["AType"];
[&](){[&](){int temp_gnidCmY;[&](){temp_gnidCmY=static_cast<int>(value_to<int>(AType_json));}();member.AType=(VkComponentTypeKHR)temp_gnidCmY;}();}();
auto& BType_json=json["BType"];
[&](){[&](){int temp_qxWVrQw;[&](){temp_qxWVrQw=static_cast<int>(value_to<int>(BType_json));}();member.BType=(VkComponentTypeKHR)temp_qxWVrQw;}();}();
auto& CType_json=json["CType"];
[&](){[&](){int temp_sfLXPnx;[&](){temp_sfLXPnx=static_cast<int>(value_to<int>(CType_json));}();member.CType=(VkComponentTypeKHR)temp_sfLXPnx;}();}();
auto& ResultType_json=json["ResultType"];
[&](){[&](){int temp_fOXlgoM;[&](){temp_fOXlgoM=static_cast<int>(value_to<int>(ResultType_json));}();member.ResultType=(VkComponentTypeKHR)temp_fOXlgoM;}();}();
auto& saturatingAccumulation_json=json["saturatingAccumulation"];
[&](){uint32_t temp_veQMDUf;[&](){temp_veQMDUf=static_cast<uint32_t>(value_to<int>(saturatingAccumulation_json));}();member.saturatingAccumulation=(VkBool32)temp_veQMDUf;}();
auto& scope_json=json["scope"];
[&](){[&](){int temp_GjXxyyO;[&](){temp_GjXxyyO=static_cast<int>(value_to<int>(scope_json));}();member.scope=(VkScopeKHR)temp_GjXxyyO;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCooperativeMatrixPropertiesKHR& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& cooperativeMatrixSupportedStages_json=json["cooperativeMatrixSupportedStages"];
[&](){[&](){[&](){cooperativeMatrixSupportedStages_json=member.cooperativeMatrixSupportedStages;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCooperativeMatrixPropertiesKHR& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& cooperativeMatrixSupportedStages_json=json["cooperativeMatrixSupportedStages"];
[&](){[&](){int temp_viFKXIW;[&](){temp_viFKXIW=static_cast<int>(value_to<int>(cooperativeMatrixSupportedStages_json));}();member.cooperativeMatrixSupportedStages=(VkShaderStageFlags)temp_viFKXIW;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCubicClampFeaturesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& cubicRangeClamp_json=json["cubicRangeClamp"];
[&](){[&](){cubicRangeClamp_json=member.cubicRangeClamp;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCubicClampFeaturesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& cubicRangeClamp_json=json["cubicRangeClamp"];
[&](){uint32_t temp_edXtUDs;[&](){temp_edXtUDs=static_cast<uint32_t>(value_to<int>(cubicRangeClamp_json));}();member.cubicRangeClamp=(VkBool32)temp_edXtUDs;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& ycbcrDegamma_json=json["ycbcrDegamma"];
[&](){[&](){ycbcrDegamma_json=member.ycbcrDegamma;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceYcbcrDegammaFeaturesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& ycbcrDegamma_json=json["ycbcrDegamma"];
[&](){uint32_t temp_NaZdCNP;[&](){temp_NaZdCNP=static_cast<uint32_t>(value_to<int>(ycbcrDegamma_json));}();member.ycbcrDegamma=(VkBool32)temp_NaZdCNP;}();
}

    void serialize_struct(boost::json::object& json, const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& enableYDegamma_json=json["enableYDegamma"];
[&](){[&](){enableYDegamma_json=member.enableYDegamma;}();}();
auto& enableCbCrDegamma_json=json["enableCbCrDegamma"];
[&](){[&](){enableCbCrDegamma_json=member.enableCbCrDegamma;}();}();
}
void deserialize_struct(boost::json::object& json, VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& enableYDegamma_json=json["enableYDegamma"];
[&](){uint32_t temp_DoExhqG;[&](){temp_DoExhqG=static_cast<uint32_t>(value_to<int>(enableYDegamma_json));}();member.enableYDegamma=(VkBool32)temp_DoExhqG;}();
auto& enableCbCrDegamma_json=json["enableCbCrDegamma"];
[&](){uint32_t temp_VAfMLSS;[&](){temp_VAfMLSS=static_cast<uint32_t>(value_to<int>(enableCbCrDegamma_json));}();member.enableCbCrDegamma=(VkBool32)temp_VAfMLSS;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceCubicWeightsFeaturesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& selectableCubicWeights_json=json["selectableCubicWeights"];
[&](){[&](){selectableCubicWeights_json=member.selectableCubicWeights;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceCubicWeightsFeaturesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& selectableCubicWeights_json=json["selectableCubicWeights"];
[&](){uint32_t temp_FnsTMDF;[&](){temp_FnsTMDF=static_cast<uint32_t>(value_to<int>(selectableCubicWeights_json));}();member.selectableCubicWeights=(VkBool32)temp_FnsTMDF;}();
}

    void serialize_struct(boost::json::object& json, const VkSamplerCubicWeightsCreateInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& cubicWeights_json=json["cubicWeights"];
[&](){[&](){[&](){cubicWeights_json=member.cubicWeights;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSamplerCubicWeightsCreateInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& cubicWeights_json=json["cubicWeights"];
[&](){[&](){int temp_pUsjObg;[&](){temp_pUsjObg=static_cast<int>(value_to<int>(cubicWeights_json));}();member.cubicWeights=(VkCubicFilterWeightsQCOM)temp_pUsjObg;}();}();
}

    void serialize_struct(boost::json::object& json, const VkBlitImageCubicWeightsInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& cubicWeights_json=json["cubicWeights"];
[&](){[&](){[&](){cubicWeights_json=member.cubicWeights;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkBlitImageCubicWeightsInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& cubicWeights_json=json["cubicWeights"];
[&](){[&](){int temp_pUsjObg;[&](){temp_pUsjObg=static_cast<int>(value_to<int>(cubicWeights_json));}();member.cubicWeights=(VkCubicFilterWeightsQCOM)temp_pUsjObg;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageProcessing2FeaturesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& textureBlockMatch2_json=json["textureBlockMatch2"];
[&](){[&](){textureBlockMatch2_json=member.textureBlockMatch2;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageProcessing2FeaturesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& textureBlockMatch2_json=json["textureBlockMatch2"];
[&](){uint32_t temp_YnQYSzc;[&](){temp_YnQYSzc=static_cast<uint32_t>(value_to<int>(textureBlockMatch2_json));}();member.textureBlockMatch2=(VkBool32)temp_YnQYSzc;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceImageProcessing2PropertiesQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& maxBlockMatchWindow_json=json["maxBlockMatchWindow"];
[&](){
            auto& temp=maxBlockMatchWindow_json.emplace_object();
            return serialize_struct(temp, member.maxBlockMatchWindow);
            }();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceImageProcessing2PropertiesQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& maxBlockMatchWindow_json=json["maxBlockMatchWindow"];
[&](){
            auto& temp=maxBlockMatchWindow_json.as_object();
            deserialize_struct(temp,member.maxBlockMatchWindow);
            }();
}

    void serialize_struct(boost::json::object& json, const VkSamplerBlockMatchWindowCreateInfoQCOM& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& windowExtent_json=json["windowExtent"];
[&](){
            auto& temp=windowExtent_json.emplace_object();
            return serialize_struct(temp, member.windowExtent);
            }();
auto& windowCompareMode_json=json["windowCompareMode"];
[&](){[&](){[&](){windowCompareMode_json=member.windowCompareMode;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkSamplerBlockMatchWindowCreateInfoQCOM& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){ void* temp_nBBafEa;;[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,temp_nBBafEa);
            }();member.pNext=temp_nBBafEa;}();
auto& windowExtent_json=json["windowExtent"];
[&](){
            auto& temp=windowExtent_json.as_object();
            deserialize_struct(temp,member.windowExtent);
            }();
auto& windowCompareMode_json=json["windowCompareMode"];
[&](){[&](){int temp_SWWOYHT;[&](){temp_SWWOYHT=static_cast<int>(value_to<int>(windowCompareMode_json));}();member.windowCompareMode=(VkBlockMatchWindowCompareModeQCOM)temp_SWWOYHT;}();}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& descriptorPoolOverallocation_json=json["descriptorPoolOverallocation"];
[&](){[&](){descriptorPoolOverallocation_json=member.descriptorPoolOverallocation;}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& descriptorPoolOverallocation_json=json["descriptorPoolOverallocation"];
[&](){uint32_t temp_lRzVxht;[&](){temp_lRzVxht=static_cast<uint32_t>(value_to<int>(descriptorPoolOverallocation_json));}();member.descriptorPoolOverallocation=(VkBool32)temp_lRzVxht;}();
}

    void serialize_struct(boost::json::object& json, const VkPhysicalDeviceLayeredDriverPropertiesMSFT& member){
        
    
auto& sType_json=json["sType"];
[&](){[&](){[&](){sType_json=member.sType;}();}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.emplace_object();
            return serialize_pNext(temp, member.pNext);
            }();
auto& underlyingAPI_json=json["underlyingAPI"];
[&](){[&](){[&](){underlyingAPI_json=member.underlyingAPI;}();}();}();
}
void deserialize_struct(boost::json::object& json, VkPhysicalDeviceLayeredDriverPropertiesMSFT& member){
auto& sType_json=json["sType"];
[&](){[&](){int temp_BblWyAR;[&](){temp_BblWyAR=static_cast<int>(value_to<int>(sType_json));}();member.sType=(VkStructureType)temp_BblWyAR;}();}();
auto& pNext_json=json["pNext"];
[&](){
            auto& temp=pNext_json.as_object();
            deserialize_pNext(temp,member.pNext);
            }();
auto& underlyingAPI_json=json["underlyingAPI"];
[&](){[&](){int temp_EgQvhBH;[&](){temp_EgQvhBH=static_cast<int>(value_to<int>(underlyingAPI_json));}();member.underlyingAPI=(VkLayeredDriverUnderlyingApiMSFT)temp_EgQvhBH;}();}();
}
std::map<uintptr_t,PFN_vkInternalAllocationNotification> id_to_PFN_vkInternalAllocationNotification;

    void serialize_PFN_vkInternalAllocationNotification(boost::json::object&, const PFN_vkInternalAllocationNotification&){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkInternalAllocationNotification_wrapper( void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope){
        //Will only be called by the server
        
        boost::json::object json;
        json["type"]=PFN_VKINTERNALALLOCATIONNOTIFICATION;
        
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){json["size"]=size;}();
[&](){[&](){[&](){json["allocationType"]=allocationType;}();}();}();
[&](){[&](){[&](){json["allocationScope"]=allocationScope;}();}();}();

        json["id"]=((pUserData_struct*)pUserData)->PFN_vkInternalAllocationNotification;
        
        writeToConn(json); //Send request
        json=readFromConn(); //Recieve response
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
[&](){size=static_cast<size_t>(value_to<int>(json["size"]));}();
[&](){[&](){int temp_eIybqdS;[&](){temp_eIybqdS=static_cast<int>(value_to<int>(json["allocationType"]));}();allocationType=(VkInternalAllocationType)temp_eIybqdS;}();}();
[&](){[&](){int temp_tAAgjfM;[&](){temp_tAAgjfM=static_cast<int>(value_to<int>(json["allocationScope"]));}();allocationScope=(VkSystemAllocationScope)temp_tAAgjfM;}();}();
json.clear();
json.erase("mem");

        writeToConn(json); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return;
}

            void handle_PFN_vkInternalAllocationNotification(boost::json::object& json){
            //Will only be called by the client
            
            // Recieved data from server's PFN_vkInternalAllocationNotification wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkInternalAllocationNotification[value_to<uintptr_t>(json["id"])];
        
void* pUserData;;
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }temp_PunOKTH=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
size_t size;;
[&](){size=static_cast<size_t>(value_to<int>(json["size"]));}();
VkInternalAllocationType allocationType;;
[&](){[&](){int temp_eIybqdS;[&](){temp_eIybqdS=static_cast<int>(value_to<int>(json["allocationType"]));}();allocationType=(VkInternalAllocationType)temp_eIybqdS;}();}();
VkSystemAllocationScope allocationScope;;
[&](){[&](){int temp_tAAgjfM;[&](){temp_tAAgjfM=static_cast<int>(value_to<int>(json["allocationScope"]));}();allocationScope=(VkSystemAllocationScope)temp_tAAgjfM;}();}();
funcpointer(pUserData,size,allocationType,allocationScope);
json.clear();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){json["size"]=size;}();
[&](){[&](){[&](){json["allocationType"]=allocationType;}();}();}();
[&](){[&](){[&](){json["allocationScope"]=allocationScope;}();}();}();

writeToConn(json);
};

        void deserialize_PFN_vkInternalAllocationNotification(boost::json::object& json, PFN_vkInternalAllocationNotification& member){
            //Will only be called by the server
            
            member=PFN_vkInternalAllocationNotification_wrapper;
            };
        
std::map<uintptr_t,PFN_vkInternalFreeNotification> id_to_PFN_vkInternalFreeNotification;

    void serialize_PFN_vkInternalFreeNotification(boost::json::object&, const PFN_vkInternalFreeNotification&){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkInternalFreeNotification_wrapper( void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope){
        //Will only be called by the server
        
        boost::json::object json;
        json["type"]=PFN_VKINTERNALFREENOTIFICATION;
        
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){json["size"]=size;}();
[&](){[&](){[&](){json["allocationType"]=allocationType;}();}();}();
[&](){[&](){[&](){json["allocationScope"]=allocationScope;}();}();}();

        json["id"]=((pUserData_struct*)pUserData)->PFN_vkInternalFreeNotification;
        
        writeToConn(json); //Send request
        json=readFromConn(); //Recieve response
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
[&](){size=static_cast<size_t>(value_to<int>(json["size"]));}();
[&](){[&](){int temp_eIybqdS;[&](){temp_eIybqdS=static_cast<int>(value_to<int>(json["allocationType"]));}();allocationType=(VkInternalAllocationType)temp_eIybqdS;}();}();
[&](){[&](){int temp_tAAgjfM;[&](){temp_tAAgjfM=static_cast<int>(value_to<int>(json["allocationScope"]));}();allocationScope=(VkSystemAllocationScope)temp_tAAgjfM;}();}();
json.clear();
json.erase("mem");

        writeToConn(json); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return;
}

            void handle_PFN_vkInternalFreeNotification(boost::json::object& json){
            //Will only be called by the client
            
            // Recieved data from server's PFN_vkInternalFreeNotification wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkInternalFreeNotification[value_to<uintptr_t>(json["id"])];
        
void* pUserData;;
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }temp_PunOKTH=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
size_t size;;
[&](){size=static_cast<size_t>(value_to<int>(json["size"]));}();
VkInternalAllocationType allocationType;;
[&](){[&](){int temp_eIybqdS;[&](){temp_eIybqdS=static_cast<int>(value_to<int>(json["allocationType"]));}();allocationType=(VkInternalAllocationType)temp_eIybqdS;}();}();
VkSystemAllocationScope allocationScope;;
[&](){[&](){int temp_tAAgjfM;[&](){temp_tAAgjfM=static_cast<int>(value_to<int>(json["allocationScope"]));}();allocationScope=(VkSystemAllocationScope)temp_tAAgjfM;}();}();
funcpointer(pUserData,size,allocationType,allocationScope);
json.clear();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){json["size"]=size;}();
[&](){[&](){[&](){json["allocationType"]=allocationType;}();}();}();
[&](){[&](){[&](){json["allocationScope"]=allocationScope;}();}();}();

writeToConn(json);
};

        void deserialize_PFN_vkInternalFreeNotification(boost::json::object& json, PFN_vkInternalFreeNotification& member){
            //Will only be called by the server
            
            member=PFN_vkInternalFreeNotification_wrapper;
            };
        
std::map<uintptr_t,PFN_vkReallocationFunction> id_to_PFN_vkReallocationFunction;

    void serialize_PFN_vkReallocationFunction(boost::json::object&, const PFN_vkReallocationFunction&){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkReallocationFunction_wrapper( void* pUserData, void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope allocationScope){
        //Will only be called by the server
        
        boost::json::object json;
        json["type"]=PFN_VKREALLOCATIONFUNCTION;
        
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){
            if (pOriginal==NULL){
                json["pOriginal"]=boost::json::array();
            return; }[&](){
            if (((char*)(pOriginal))==NULL){
                json["pOriginal"]=boost::json::array();
            return; }json["pOriginal"]=boost::json::array(strlen(((char*)(pOriginal)))+1);
        auto& arr_rITHcbq=json["pOriginal"].as_array();
        for(int oHRYLxY=0; oHRYLxY < strlen(((char*)(pOriginal)))+1; oHRYLxY++){
            [&](){arr_rITHcbq[oHRYLxY]=((char*)(pOriginal))[oHRYLxY];}();
        }
        }();}();
[&](){json["size"]=size;}();
[&](){json["alignment"]=alignment;}();
[&](){[&](){[&](){json["allocationScope"]=allocationScope;}();}();}();

        json["id"]=((pUserData_struct*)pUserData)->PFN_vkReallocationFunction;
        
        writeToConn(json); //Send request
        json=readFromConn(); //Recieve response
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
[&](){
            if (json["pOriginal"].as_array().size()==0){
                pOriginal=NULL;
            return; }char* temp_SZtjdWN;[&](){
            if (json["pOriginal"].as_array().size()==0){
                temp_SZtjdWN=NULL;
            return; }
        auto& arr_rITHcbq=json["pOriginal"].as_array();
        for(int oHRYLxY=0; oHRYLxY < json["pOriginal"].as_array().size(); oHRYLxY++){
            [&](){temp_SZtjdWN[oHRYLxY]=static_cast<char>(value_to<int>(arr_rITHcbq[oHRYLxY]));}();
        }
        }();pOriginal=temp_SZtjdWN;}();
[&](){size=static_cast<size_t>(value_to<int>(json["size"]));}();
[&](){alignment=static_cast<size_t>(value_to<int>(json["alignment"]));}();
[&](){[&](){int temp_tAAgjfM;[&](){temp_tAAgjfM=static_cast<int>(value_to<int>(json["allocationScope"]));}();allocationScope=(VkSystemAllocationScope)temp_tAAgjfM;}();}();
void* result;
[&](){
            if (json["result"].as_array().size()==0){
                result=NULL;
            return; }char* temp_IcIzwPV;[&](){
            if (json["result"].as_array().size()==0){
                temp_IcIzwPV=NULL;
            return; }temp_IcIzwPV=(char*)malloc(json["result"].as_array().size()*sizeof(char));
        auto& arr_LiwXrkM=json["result"].as_array();
        for(int CrRTcID=0; CrRTcID < json["result"].as_array().size(); CrRTcID++){
            [&](){temp_IcIzwPV[CrRTcID]=static_cast<char>(value_to<int>(arr_LiwXrkM[CrRTcID]));}();
        }
        }();result=temp_IcIzwPV;}();
json.clear();
registerAllocatedMem(result,size);
json["mem"]=(uintptr_t)result;

        writeToConn(json); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return result;
}

            void handle_PFN_vkReallocationFunction(boost::json::object& json){
            //Will only be called by the client
            
            // Recieved data from server's PFN_vkReallocationFunction wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkReallocationFunction[value_to<uintptr_t>(json["id"])];
        
void* pUserData;;
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }temp_PunOKTH=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
void* pOriginal;;
[&](){
            if (json["pOriginal"].as_array().size()==0){
                pOriginal=NULL;
            return; }char* temp_SZtjdWN;[&](){
            if (json["pOriginal"].as_array().size()==0){
                temp_SZtjdWN=NULL;
            return; }temp_SZtjdWN=(char*)malloc(json["pOriginal"].as_array().size()*sizeof(char));
        auto& arr_rITHcbq=json["pOriginal"].as_array();
        for(int oHRYLxY=0; oHRYLxY < json["pOriginal"].as_array().size(); oHRYLxY++){
            [&](){temp_SZtjdWN[oHRYLxY]=static_cast<char>(value_to<int>(arr_rITHcbq[oHRYLxY]));}();
        }
        }();pOriginal=temp_SZtjdWN;}();
size_t size;;
[&](){size=static_cast<size_t>(value_to<int>(json["size"]));}();
size_t alignment;;
[&](){alignment=static_cast<size_t>(value_to<int>(json["alignment"]));}();
VkSystemAllocationScope allocationScope;;
[&](){[&](){int temp_tAAgjfM;[&](){temp_tAAgjfM=static_cast<int>(value_to<int>(json["allocationScope"]));}();allocationScope=(VkSystemAllocationScope)temp_tAAgjfM;}();}();
auto result=funcpointer(pUserData,pOriginal,size,alignment,allocationScope);
json.clear();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){
            if (pOriginal==NULL){
                json["pOriginal"]=boost::json::array();
            return; }[&](){
            if (((char*)(pOriginal))==NULL){
                json["pOriginal"]=boost::json::array();
            return; }json["pOriginal"]=boost::json::array(strlen(((char*)(pOriginal)))+1);
        auto& arr_rITHcbq=json["pOriginal"].as_array();
        for(int oHRYLxY=0; oHRYLxY < strlen(((char*)(pOriginal)))+1; oHRYLxY++){
            [&](){arr_rITHcbq[oHRYLxY]=((char*)(pOriginal))[oHRYLxY];}();
        }
        }();}();
[&](){json["size"]=size;}();
[&](){json["alignment"]=alignment;}();
[&](){[&](){[&](){json["allocationScope"]=allocationScope;}();}();}();
[&](){
            if (result==NULL){
                json["result"]=boost::json::array();
            return; }[&](){
            if (((char*)(result))==NULL){
                json["result"]=boost::json::array();
            return; }json["result"]=boost::json::array(strlen(((char*)(result)))+1);
        auto& arr_fKfzVOD=json["result"].as_array();
        for(int rfEQqjG=0; rfEQqjG < strlen(((char*)(result)))+1; rfEQqjG++){
            [&](){arr_fKfzVOD[rfEQqjG]=((char*)(result))[rfEQqjG];}();
        }
        }();}();
writeToConn(json);

            json=readFromConn();
            registerClientServerMemoryMapping((uintptr_t)result, value_to<uintptr_t>(json["mem"]) );
            
            json.clear();
            writeToConn(json); //Send empty message to signal to the server the mapping is done.
            
};

        void deserialize_PFN_vkReallocationFunction(boost::json::object& json, PFN_vkReallocationFunction& member){
            //Will only be called by the server
            
            member=PFN_vkReallocationFunction_wrapper;
            };
        
std::map<uintptr_t,PFN_vkAllocationFunction> id_to_PFN_vkAllocationFunction;

    void serialize_PFN_vkAllocationFunction(boost::json::object&, const PFN_vkAllocationFunction&){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkAllocationFunction_wrapper( void* pUserData, size_t size, size_t alignment, VkSystemAllocationScope allocationScope){
        //Will only be called by the server
        
        boost::json::object json;
        json["type"]=PFN_VKALLOCATIONFUNCTION;
        
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){json["size"]=size;}();
[&](){json["alignment"]=alignment;}();
[&](){[&](){[&](){json["allocationScope"]=allocationScope;}();}();}();

        json["id"]=((pUserData_struct*)pUserData)->PFN_vkAllocationFunction;
        
        writeToConn(json); //Send request
        json=readFromConn(); //Recieve response
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
[&](){size=static_cast<size_t>(value_to<int>(json["size"]));}();
[&](){alignment=static_cast<size_t>(value_to<int>(json["alignment"]));}();
[&](){[&](){int temp_tAAgjfM;[&](){temp_tAAgjfM=static_cast<int>(value_to<int>(json["allocationScope"]));}();allocationScope=(VkSystemAllocationScope)temp_tAAgjfM;}();}();
void* result;
[&](){
            if (json["result"].as_array().size()==0){
                result=NULL;
            return; }char* temp_vIskEJn;[&](){
            if (json["result"].as_array().size()==0){
                temp_vIskEJn=NULL;
            return; }temp_vIskEJn=(char*)malloc(size*sizeof(char));
        auto& arr_hfmlfUi=json["result"].as_array();
        for(int irXenxH=0; irXenxH < size; irXenxH++){
            [&](){temp_vIskEJn[irXenxH]=static_cast<char>(value_to<int>(arr_hfmlfUi[irXenxH]));}();
        }
        }();result=temp_vIskEJn;}();
json.clear();
registerAllocatedMem(result,size);
json["mem"]=(uintptr_t)result;

        writeToConn(json); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return result;
}

            void handle_PFN_vkAllocationFunction(boost::json::object& json){
            //Will only be called by the client
            
            // Recieved data from server's PFN_vkAllocationFunction wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkAllocationFunction[value_to<uintptr_t>(json["id"])];
        
void* pUserData;;
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }temp_PunOKTH=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
size_t size;;
[&](){size=static_cast<size_t>(value_to<int>(json["size"]));}();
size_t alignment;;
[&](){alignment=static_cast<size_t>(value_to<int>(json["alignment"]));}();
VkSystemAllocationScope allocationScope;;
[&](){[&](){int temp_tAAgjfM;[&](){temp_tAAgjfM=static_cast<int>(value_to<int>(json["allocationScope"]));}();allocationScope=(VkSystemAllocationScope)temp_tAAgjfM;}();}();
auto result=funcpointer(pUserData,size,alignment,allocationScope);
json.clear();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){json["size"]=size;}();
[&](){json["alignment"]=alignment;}();
[&](){[&](){[&](){json["allocationScope"]=allocationScope;}();}();}();
[&](){
            if (result==NULL){
                json["result"]=boost::json::array();
            return; }[&](){
            if (((char*)(result))==NULL){
                json["result"]=boost::json::array();
            return; }json["result"]=boost::json::array(size);
        auto& arr_xtFOIbA=json["result"].as_array();
        for(int CcKxMXg=0; CcKxMXg < size; CcKxMXg++){
            [&](){arr_xtFOIbA[CcKxMXg]=((char*)(result))[CcKxMXg];}();
        }
        }();}();
writeToConn(json);

            json=readFromConn();
            registerClientServerMemoryMapping((uintptr_t)result, value_to<uintptr_t>(json["mem"]) );
            
            json.clear();
            writeToConn(json); //Send empty message to signal to the server the mapping is done.
            
};

        void deserialize_PFN_vkAllocationFunction(boost::json::object& json, PFN_vkAllocationFunction& member){
            //Will only be called by the server
            
            member=PFN_vkAllocationFunction_wrapper;
            };
        
std::map<uintptr_t,PFN_vkFreeFunction> id_to_PFN_vkFreeFunction;

    void serialize_PFN_vkFreeFunction(boost::json::object&, const PFN_vkFreeFunction&){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkFreeFunction_wrapper( void* pUserData, void* pMemory){
        //Will only be called by the server
        
        boost::json::object json;
        json["type"]=PFN_VKFREEFUNCTION;
        
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){
            if (pMemory==NULL){
                json["pMemory"]=boost::json::array();
            return; }[&](){
            if (((char*)(pMemory))==NULL){
                json["pMemory"]=boost::json::array();
            return; }json["pMemory"]=boost::json::array(strlen(((char*)(pMemory)))+1);
        auto& arr_qKvWVRO=json["pMemory"].as_array();
        for(int LkSrwrv=0; LkSrwrv < strlen(((char*)(pMemory)))+1; LkSrwrv++){
            [&](){arr_qKvWVRO[LkSrwrv]=((char*)(pMemory))[LkSrwrv];}();
        }
        }();}();

        json["id"]=((pUserData_struct*)pUserData)->PFN_vkFreeFunction;
        
        writeToConn(json); //Send request
        json=readFromConn(); //Recieve response
        
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
[&](){
            if (json["pMemory"].as_array().size()==0){
                pMemory=NULL;
            return; }char* temp_TQlreEU;[&](){
            if (json["pMemory"].as_array().size()==0){
                temp_TQlreEU=NULL;
            return; }
        auto& arr_qKvWVRO=json["pMemory"].as_array();
        for(int LkSrwrv=0; LkSrwrv < json["pMemory"].as_array().size(); LkSrwrv++){
            [&](){temp_TQlreEU[LkSrwrv]=static_cast<char>(value_to<int>(arr_qKvWVRO[LkSrwrv]));}();
        }
        }();pMemory=temp_TQlreEU;}();
json.clear();
json.erase("mem");

        writeToConn(json); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return;
}

            void handle_PFN_vkFreeFunction(boost::json::object& json){
            //Will only be called by the client
            
            // Recieved data from server's PFN_vkFreeFunction wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkFreeFunction[value_to<uintptr_t>(json["id"])];
        
void* pUserData;;
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }temp_PunOKTH=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
void* pMemory;;
[&](){
            if (json["pMemory"].as_array().size()==0){
                pMemory=NULL;
            return; }char* temp_TQlreEU;[&](){
            if (json["pMemory"].as_array().size()==0){
                temp_TQlreEU=NULL;
            return; }temp_TQlreEU=(char*)malloc(json["pMemory"].as_array().size()*sizeof(char));
        auto& arr_qKvWVRO=json["pMemory"].as_array();
        for(int LkSrwrv=0; LkSrwrv < json["pMemory"].as_array().size(); LkSrwrv++){
            [&](){temp_TQlreEU[LkSrwrv]=static_cast<char>(value_to<int>(arr_qKvWVRO[LkSrwrv]));}();
        }
        }();pMemory=temp_TQlreEU;}();
funcpointer(pUserData,pMemory);
json.clear();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){
            if (pMemory==NULL){
                json["pMemory"]=boost::json::array();
            return; }[&](){
            if (((char*)(pMemory))==NULL){
                json["pMemory"]=boost::json::array();
            return; }json["pMemory"]=boost::json::array(strlen(((char*)(pMemory)))+1);
        auto& arr_qKvWVRO=json["pMemory"].as_array();
        for(int LkSrwrv=0; LkSrwrv < strlen(((char*)(pMemory)))+1; LkSrwrv++){
            [&](){arr_qKvWVRO[LkSrwrv]=((char*)(pMemory))[LkSrwrv];}();
        }
        }();}();

writeToConn(json);
};

        void deserialize_PFN_vkFreeFunction(boost::json::object& json, PFN_vkFreeFunction& member){
            //Will only be called by the server
            
            member=PFN_vkFreeFunction_wrapper;
            };
        
std::map<uintptr_t,PFN_vkDebugReportCallbackEXT> id_to_PFN_vkDebugReportCallbackEXT;

    void serialize_PFN_vkDebugReportCallbackEXT(boost::json::object&, const PFN_vkDebugReportCallbackEXT&){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkDebugReportCallbackEXT_wrapper( VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage, void* pUserData){
        //Will only be called by the server
        
        boost::json::object json;
        json["type"]=PFN_VKDEBUGREPORTCALLBACKEXT;
        
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["object"]=object;}();
[&](){json["location"]=location;}();
[&](){json["messageCode"]=messageCode;}();
[&](){
            if (pLayerPrefix==NULL){
                json["pLayerPrefix"]=boost::json::array();
            return; }json["pLayerPrefix"]=boost::json::array(strlen(pLayerPrefix)+1);
        auto& arr_VtlqskV=json["pLayerPrefix"].as_array();
        for(int wbPKFFy=0; wbPKFFy < strlen(pLayerPrefix)+1; wbPKFFy++){
            [&](){arr_VtlqskV[wbPKFFy]=pLayerPrefix[wbPKFFy];}();
        }
        }();
[&](){
            if (pMessage==NULL){
                json["pMessage"]=boost::json::array();
            return; }json["pMessage"]=boost::json::array(strlen(pMessage)+1);
        auto& arr_WrGZAPa=json["pMessage"].as_array();
        for(int YtftAYM=0; YtftAYM < strlen(pMessage)+1; YtftAYM++){
            [&](){arr_WrGZAPa[YtftAYM]=pMessage[YtftAYM];}();
        }
        }();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();

        json["id"]=((pUserData_struct*)pUserData)->PFN_vkDebugReportCallbackEXT;
        
        writeToConn(json); //Send request
        json=readFromConn(); //Recieve response
        
[&](){[&](){int temp_OepEvDd;[&](){temp_OepEvDd=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkDebugReportFlagsEXT)temp_OepEvDd;}();}();
[&](){[&](){int temp_fBSsGOe;[&](){temp_fBSsGOe=static_cast<int>(value_to<int>(json["objectType"]));}();objectType=(VkDebugReportObjectTypeEXT)temp_fBSsGOe;}();}();
[&](){object=static_cast<uint64_t>(value_to<int>(json["object"]));}();
[&](){location=static_cast<size_t>(value_to<int>(json["location"]));}();
[&](){messageCode=static_cast<int32_t>(value_to<int>(json["messageCode"]));}();


[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
VkBool32 result;
[&](){uint32_t temp_WFCRZTD;[&](){temp_WFCRZTD=static_cast<uint32_t>(value_to<int>(json["result"]));}();result=(VkBool32)temp_WFCRZTD;}();
json.clear();
json.erase("mem");

        writeToConn(json); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return result;
}

            void handle_PFN_vkDebugReportCallbackEXT(boost::json::object& json){
            //Will only be called by the client
            
            // Recieved data from server's PFN_vkDebugReportCallbackEXT wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkDebugReportCallbackEXT[value_to<uintptr_t>(json["id"])];
        
VkDebugReportFlagsEXT flags;;
[&](){[&](){int temp_OepEvDd;[&](){temp_OepEvDd=static_cast<int>(value_to<int>(json["flags"]));}();flags=(VkDebugReportFlagsEXT)temp_OepEvDd;}();}();
VkDebugReportObjectTypeEXT objectType;;
[&](){[&](){int temp_fBSsGOe;[&](){temp_fBSsGOe=static_cast<int>(value_to<int>(json["objectType"]));}();objectType=(VkDebugReportObjectTypeEXT)temp_fBSsGOe;}();}();
uint64_t object;;
[&](){object=static_cast<uint64_t>(value_to<int>(json["object"]));}();
size_t location;;
[&](){location=static_cast<size_t>(value_to<int>(json["location"]));}();
int32_t messageCode;;
[&](){messageCode=static_cast<int32_t>(value_to<int>(json["messageCode"]));}();
const char* pLayerPrefix;;
[&](){ char* temp_Dtlcvim;;[&](){
            if (json["pLayerPrefix"].as_array().size()==0){
                temp_Dtlcvim=NULL;
            return; }temp_Dtlcvim=(char*)malloc(json["pLayerPrefix"].as_array().size()*sizeof(char));
        auto& arr_JkVyQXV=json["pLayerPrefix"].as_array();
        for(int LQVmgjI=0; LQVmgjI < json["pLayerPrefix"].as_array().size(); LQVmgjI++){
            [&](){temp_Dtlcvim[LQVmgjI]=static_cast<char>(value_to<int>(arr_JkVyQXV[LQVmgjI]));}();
        }
        }();pLayerPrefix=temp_Dtlcvim;}();
const char* pMessage;;
[&](){ char* temp_pLvWxeM;;[&](){
            if (json["pMessage"].as_array().size()==0){
                temp_pLvWxeM=NULL;
            return; }temp_pLvWxeM=(char*)malloc(json["pMessage"].as_array().size()*sizeof(char));
        auto& arr_ReBKgcF=json["pMessage"].as_array();
        for(int agWVGCe=0; agWVGCe < json["pMessage"].as_array().size(); agWVGCe++){
            [&](){temp_pLvWxeM[agWVGCe]=static_cast<char>(value_to<int>(arr_ReBKgcF[agWVGCe]));}();
        }
        }();pMessage=temp_pLvWxeM;}();
void* pUserData;;
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }temp_PunOKTH=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
auto result=funcpointer(flags,objectType,object,location,messageCode,pLayerPrefix,pMessage,pUserData);
json.clear();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["object"]=object;}();
[&](){json["location"]=location;}();
[&](){json["messageCode"]=messageCode;}();
[&](){
            if (pLayerPrefix==NULL){
                json["pLayerPrefix"]=boost::json::array();
            return; }json["pLayerPrefix"]=boost::json::array(strlen(pLayerPrefix)+1);
        auto& arr_VtlqskV=json["pLayerPrefix"].as_array();
        for(int wbPKFFy=0; wbPKFFy < strlen(pLayerPrefix)+1; wbPKFFy++){
            [&](){arr_VtlqskV[wbPKFFy]=pLayerPrefix[wbPKFFy];}();
        }
        }();
[&](){
            if (pMessage==NULL){
                json["pMessage"]=boost::json::array();
            return; }json["pMessage"]=boost::json::array(strlen(pMessage)+1);
        auto& arr_WrGZAPa=json["pMessage"].as_array();
        for(int YtftAYM=0; YtftAYM < strlen(pMessage)+1; YtftAYM++){
            [&](){arr_WrGZAPa[YtftAYM]=pMessage[YtftAYM];}();
        }
        }();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){[&](){json["result"]=result;}();}();
writeToConn(json);
};

        void deserialize_PFN_vkDebugReportCallbackEXT(boost::json::object& json, PFN_vkDebugReportCallbackEXT& member){
            //Will only be called by the server
            
            member=PFN_vkDebugReportCallbackEXT_wrapper;
            };
        
std::map<uintptr_t,PFN_vkDebugUtilsMessengerCallbackEXT> id_to_PFN_vkDebugUtilsMessengerCallbackEXT;

    void serialize_PFN_vkDebugUtilsMessengerCallbackEXT(boost::json::object&, const PFN_vkDebugUtilsMessengerCallbackEXT&){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkDebugUtilsMessengerCallbackEXT_wrapper( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData){
        //Will only be called by the server
        
        boost::json::object json;
        json["type"]=PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT;
        
[&](){[&](){[&](){json["messageSeverity"]=messageSeverity;}();}();}();
[&](){[&](){[&](){json["messageTypes"]=messageTypes;}();}();}();
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=boost::json::array();
            return; }json["pCallbackData"]=boost::json::array(1);
        auto& arr_ELbGsuC=json["pCallbackData"].as_array();
        for(int cgqXeou=0; cgqXeou < 1; cgqXeou++){
            [&](){
            auto& temp=arr_ELbGsuC[cgqXeou].emplace_object();
            return serialize_struct(temp, pCallbackData[cgqXeou]);
            }();
        }
        }();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();

        json["id"]=((pUserData_struct*)pUserData)->PFN_vkDebugUtilsMessengerCallbackEXT;
        
        writeToConn(json); //Send request
        json=readFromConn(); //Recieve response
        
[&](){[&](){int temp_WJEqtsJ;[&](){temp_WJEqtsJ=static_cast<int>(value_to<int>(json["messageSeverity"]));}();messageSeverity=(VkDebugUtilsMessageSeverityFlagBitsEXT)temp_WJEqtsJ;}();}();
[&](){[&](){int temp_gfwPHsR;[&](){temp_gfwPHsR=static_cast<int>(value_to<int>(json["messageTypes"]));}();messageTypes=(VkDebugUtilsMessageTypeFlagsEXT)temp_gfwPHsR;}();}();

[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
VkBool32 result;
[&](){uint32_t temp_PEAhYzx;[&](){temp_PEAhYzx=static_cast<uint32_t>(value_to<int>(json["result"]));}();result=(VkBool32)temp_PEAhYzx;}();
json.clear();
json.erase("mem");

        writeToConn(json); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return result;
}

            void handle_PFN_vkDebugUtilsMessengerCallbackEXT(boost::json::object& json){
            //Will only be called by the client
            
            // Recieved data from server's PFN_vkDebugUtilsMessengerCallbackEXT wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkDebugUtilsMessengerCallbackEXT[value_to<uintptr_t>(json["id"])];
        
VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;;
[&](){[&](){int temp_WJEqtsJ;[&](){temp_WJEqtsJ=static_cast<int>(value_to<int>(json["messageSeverity"]));}();messageSeverity=(VkDebugUtilsMessageSeverityFlagBitsEXT)temp_WJEqtsJ;}();}();
VkDebugUtilsMessageTypeFlagsEXT messageTypes;;
[&](){[&](){int temp_gfwPHsR;[&](){temp_gfwPHsR=static_cast<int>(value_to<int>(json["messageTypes"]));}();messageTypes=(VkDebugUtilsMessageTypeFlagsEXT)temp_gfwPHsR;}();}();
const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;;
[&](){ VkDebugUtilsMessengerCallbackDataEXT* temp_vjIQYMp;;[&](){
            if (json["pCallbackData"].as_array().size()==0){
                temp_vjIQYMp=NULL;
            return; }temp_vjIQYMp=(VkDebugUtilsMessengerCallbackDataEXT*)malloc(1*sizeof(VkDebugUtilsMessengerCallbackDataEXT));
        auto& arr_qDxNjBm=json["pCallbackData"].as_array();
        for(int HNKHCHi=0; HNKHCHi < 1; HNKHCHi++){
            [&](){
            auto& temp=arr_qDxNjBm[HNKHCHi].as_object();
            deserialize_struct(temp,temp_vjIQYMp[HNKHCHi]);
            }();
        }
        }();pCallbackData=temp_vjIQYMp;}();
void* pUserData;;
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }temp_PunOKTH=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
auto result=funcpointer(messageSeverity,messageTypes,pCallbackData,pUserData);
json.clear();
[&](){[&](){[&](){json["messageSeverity"]=messageSeverity;}();}();}();
[&](){[&](){[&](){json["messageTypes"]=messageTypes;}();}();}();
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=boost::json::array();
            return; }json["pCallbackData"]=boost::json::array(1);
        auto& arr_ELbGsuC=json["pCallbackData"].as_array();
        for(int cgqXeou=0; cgqXeou < 1; cgqXeou++){
            [&](){
            auto& temp=arr_ELbGsuC[cgqXeou].emplace_object();
            return serialize_struct(temp, pCallbackData[cgqXeou]);
            }();
        }
        }();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();
[&](){[&](){json["result"]=result;}();}();
writeToConn(json);
};

        void deserialize_PFN_vkDebugUtilsMessengerCallbackEXT(boost::json::object& json, PFN_vkDebugUtilsMessengerCallbackEXT& member){
            //Will only be called by the server
            
            member=PFN_vkDebugUtilsMessengerCallbackEXT_wrapper;
            };
        
std::map<uintptr_t,PFN_vkDeviceMemoryReportCallbackEXT> id_to_PFN_vkDeviceMemoryReportCallbackEXT;

    void serialize_PFN_vkDeviceMemoryReportCallbackEXT(boost::json::object&, const PFN_vkDeviceMemoryReportCallbackEXT&){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkDeviceMemoryReportCallbackEXT_wrapper( const VkDeviceMemoryReportCallbackDataEXT* pCallbackData, void* pUserData){
        //Will only be called by the server
        
        boost::json::object json;
        json["type"]=PFN_VKDEVICEMEMORYREPORTCALLBACKEXT;
        
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=boost::json::array();
            return; }json["pCallbackData"]=boost::json::array(1);
        auto& arr_dvgiwmM=json["pCallbackData"].as_array();
        for(int QJmpCRq=0; QJmpCRq < 1; QJmpCRq++){
            [&](){
            auto& temp=arr_dvgiwmM[QJmpCRq].emplace_object();
            return serialize_struct(temp, pCallbackData[QJmpCRq]);
            }();
        }
        }();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();

        json["id"]=((pUserData_struct*)pUserData)->PFN_vkDeviceMemoryReportCallbackEXT;
        
        writeToConn(json); //Send request
        json=readFromConn(); //Recieve response
        

[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
json.clear();
json.erase("mem");

        writeToConn(json); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return;
}

            void handle_PFN_vkDeviceMemoryReportCallbackEXT(boost::json::object& json){
            //Will only be called by the client
            
            // Recieved data from server's PFN_vkDeviceMemoryReportCallbackEXT wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkDeviceMemoryReportCallbackEXT[value_to<uintptr_t>(json["id"])];
        
const VkDeviceMemoryReportCallbackDataEXT* pCallbackData;;
[&](){ VkDeviceMemoryReportCallbackDataEXT* temp_JtQUiIC;;[&](){
            if (json["pCallbackData"].as_array().size()==0){
                temp_JtQUiIC=NULL;
            return; }temp_JtQUiIC=(VkDeviceMemoryReportCallbackDataEXT*)malloc(1*sizeof(VkDeviceMemoryReportCallbackDataEXT));
        auto& arr_nuOXBbL=json["pCallbackData"].as_array();
        for(int PqRmPuO=0; PqRmPuO < 1; PqRmPuO++){
            [&](){
            auto& temp=arr_nuOXBbL[PqRmPuO].as_object();
            deserialize_struct(temp,temp_JtQUiIC[PqRmPuO]);
            }();
        }
        }();pCallbackData=temp_JtQUiIC;}();
void* pUserData;;
[&](){
            if (json["pUserData"].as_array().size()==0){
                pUserData=NULL;
            return; }char* temp_PunOKTH;[&](){
            if (json["pUserData"].as_array().size()==0){
                temp_PunOKTH=NULL;
            return; }temp_PunOKTH=(char*)malloc(json["pUserData"].as_array().size()*sizeof(char));
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < json["pUserData"].as_array().size(); EuMrPhh++){
            [&](){temp_PunOKTH[EuMrPhh]=static_cast<char>(value_to<int>(arr_wKsaVqw[EuMrPhh]));}();
        }
        }();pUserData=temp_PunOKTH;}();
funcpointer(pCallbackData,pUserData);
json.clear();
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=boost::json::array();
            return; }json["pCallbackData"]=boost::json::array(1);
        auto& arr_dvgiwmM=json["pCallbackData"].as_array();
        for(int QJmpCRq=0; QJmpCRq < 1; QJmpCRq++){
            [&](){
            auto& temp=arr_dvgiwmM[QJmpCRq].emplace_object();
            return serialize_struct(temp, pCallbackData[QJmpCRq]);
            }();
        }
        }();
[&](){
            if (pUserData==NULL){
                json["pUserData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pUserData))==NULL){
                json["pUserData"]=boost::json::array();
            return; }json["pUserData"]=boost::json::array(strlen(((char*)(pUserData)))+1);
        auto& arr_wKsaVqw=json["pUserData"].as_array();
        for(int EuMrPhh=0; EuMrPhh < strlen(((char*)(pUserData)))+1; EuMrPhh++){
            [&](){arr_wKsaVqw[EuMrPhh]=((char*)(pUserData))[EuMrPhh];}();
        }
        }();}();

writeToConn(json);
};

        void deserialize_PFN_vkDeviceMemoryReportCallbackEXT(boost::json::object& json, PFN_vkDeviceMemoryReportCallbackEXT& member){
            //Will only be called by the server
            
            member=PFN_vkDeviceMemoryReportCallbackEXT_wrapper;
            };
        
std::map<uintptr_t,PFN_vkGetInstanceProcAddrLUNARG> id_to_PFN_vkGetInstanceProcAddrLUNARG;

    void serialize_PFN_vkGetInstanceProcAddrLUNARG(boost::json::object&, const PFN_vkGetInstanceProcAddrLUNARG&){
        //Will only be called by the client
        return;
    }
    

            void deserialize_PFN_vkGetInstanceProcAddrLUNARG(boost::json::object& json, PFN_vkGetInstanceProcAddrLUNARG& member){
            //Will only be called by the server
            
            member=vkGetInstanceProcAddr;
            };
        

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkInstance_to_server_VkInstance;
            std::map<uintptr_t,uintptr_t> server_VkInstance_to_client_VkInstance;
            
        #endif
        

        void serialize_VkInstance(boost::json::value& json, const VkInstance& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkInstance_to_server_VkInstance.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkInstance %p not found!\n",data);
                    }
                     debug_printf("Serializing VkInstance %p...\n",(VkInstance)client_VkInstance_to_server_VkInstance[(uintptr_t)data]);
                    result=client_VkInstance_to_server_VkInstance[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkInstance(boost::json::value& json, VkInstance& member){
                VkInstance result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkInstance)data);
                    if (server_VkInstance_to_client_VkInstance.contains(data)){
                        result=(VkInstance)server_VkInstance_to_client_VkInstance[data];
                        debug_printf("Deserializing to VkInstance %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkInstance));
                        debug_printf("Mapping to VkInstance %p...\n",handle);
                        server_VkInstance_to_client_VkInstance[data]=(uintptr_t)handle;
                        client_VkInstance_to_server_VkInstance[(uintptr_t)handle]=data;
                        
                        result=(VkInstance)handle; //This is highly dangerous -- I'm basically casting VkInstance* to VkInstance. I should do *((VkInstance*)alloc_icd_object())
                    }
                #else
                    result=(VkInstance)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPhysicalDevice_to_server_VkPhysicalDevice;
            std::map<uintptr_t,uintptr_t> server_VkPhysicalDevice_to_client_VkPhysicalDevice;
            
        #endif
        

        void serialize_VkPhysicalDevice(boost::json::value& json, const VkPhysicalDevice& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPhysicalDevice_to_server_VkPhysicalDevice.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPhysicalDevice %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPhysicalDevice %p...\n",(VkPhysicalDevice)client_VkPhysicalDevice_to_server_VkPhysicalDevice[(uintptr_t)data]);
                    result=client_VkPhysicalDevice_to_server_VkPhysicalDevice[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkPhysicalDevice(boost::json::value& json, VkPhysicalDevice& member){
                VkPhysicalDevice result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPhysicalDevice)data);
                    if (server_VkPhysicalDevice_to_client_VkPhysicalDevice.contains(data)){
                        result=(VkPhysicalDevice)server_VkPhysicalDevice_to_client_VkPhysicalDevice[data];
                        debug_printf("Deserializing to VkPhysicalDevice %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPhysicalDevice));
                        debug_printf("Mapping to VkPhysicalDevice %p...\n",handle);
                        server_VkPhysicalDevice_to_client_VkPhysicalDevice[data]=(uintptr_t)handle;
                        client_VkPhysicalDevice_to_server_VkPhysicalDevice[(uintptr_t)handle]=data;
                        
                        result=(VkPhysicalDevice)handle; //This is highly dangerous -- I'm basically casting VkPhysicalDevice* to VkPhysicalDevice. I should do *((VkPhysicalDevice*)alloc_icd_object())
                    }
                #else
                    result=(VkPhysicalDevice)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDevice_to_server_VkDevice;
            std::map<uintptr_t,uintptr_t> server_VkDevice_to_client_VkDevice;
            
        #endif
        

        void serialize_VkDevice(boost::json::value& json, const VkDevice& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDevice_to_server_VkDevice.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDevice %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDevice %p...\n",(VkDevice)client_VkDevice_to_server_VkDevice[(uintptr_t)data]);
                    result=client_VkDevice_to_server_VkDevice[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDevice(boost::json::value& json, VkDevice& member){
                VkDevice result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDevice)data);
                    if (server_VkDevice_to_client_VkDevice.contains(data)){
                        result=(VkDevice)server_VkDevice_to_client_VkDevice[data];
                        debug_printf("Deserializing to VkDevice %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDevice));
                        debug_printf("Mapping to VkDevice %p...\n",handle);
                        server_VkDevice_to_client_VkDevice[data]=(uintptr_t)handle;
                        client_VkDevice_to_server_VkDevice[(uintptr_t)handle]=data;
                        
                        result=(VkDevice)handle; //This is highly dangerous -- I'm basically casting VkDevice* to VkDevice. I should do *((VkDevice*)alloc_icd_object())
                    }
                #else
                    result=(VkDevice)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkQueue_to_server_VkQueue;
            std::map<uintptr_t,uintptr_t> server_VkQueue_to_client_VkQueue;
            
        #endif
        

        void serialize_VkQueue(boost::json::value& json, const VkQueue& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkQueue_to_server_VkQueue.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkQueue %p not found!\n",data);
                    }
                     debug_printf("Serializing VkQueue %p...\n",(VkQueue)client_VkQueue_to_server_VkQueue[(uintptr_t)data]);
                    result=client_VkQueue_to_server_VkQueue[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkQueue(boost::json::value& json, VkQueue& member){
                VkQueue result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkQueue)data);
                    if (server_VkQueue_to_client_VkQueue.contains(data)){
                        result=(VkQueue)server_VkQueue_to_client_VkQueue[data];
                        debug_printf("Deserializing to VkQueue %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkQueue));
                        debug_printf("Mapping to VkQueue %p...\n",handle);
                        server_VkQueue_to_client_VkQueue[data]=(uintptr_t)handle;
                        client_VkQueue_to_server_VkQueue[(uintptr_t)handle]=data;
                        
                        result=(VkQueue)handle; //This is highly dangerous -- I'm basically casting VkQueue* to VkQueue. I should do *((VkQueue*)alloc_icd_object())
                    }
                #else
                    result=(VkQueue)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkCommandBuffer_to_server_VkCommandBuffer;
            std::map<uintptr_t,uintptr_t> server_VkCommandBuffer_to_client_VkCommandBuffer;
            
        #endif
        

        void serialize_VkCommandBuffer(boost::json::value& json, const VkCommandBuffer& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkCommandBuffer_to_server_VkCommandBuffer.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkCommandBuffer %p not found!\n",data);
                    }
                     debug_printf("Serializing VkCommandBuffer %p...\n",(VkCommandBuffer)client_VkCommandBuffer_to_server_VkCommandBuffer[(uintptr_t)data]);
                    result=client_VkCommandBuffer_to_server_VkCommandBuffer[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkCommandBuffer(boost::json::value& json, VkCommandBuffer& member){
                VkCommandBuffer result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkCommandBuffer)data);
                    if (server_VkCommandBuffer_to_client_VkCommandBuffer.contains(data)){
                        result=(VkCommandBuffer)server_VkCommandBuffer_to_client_VkCommandBuffer[data];
                        debug_printf("Deserializing to VkCommandBuffer %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkCommandBuffer));
                        debug_printf("Mapping to VkCommandBuffer %p...\n",handle);
                        server_VkCommandBuffer_to_client_VkCommandBuffer[data]=(uintptr_t)handle;
                        client_VkCommandBuffer_to_server_VkCommandBuffer[(uintptr_t)handle]=data;
                        
                        result=(VkCommandBuffer)handle; //This is highly dangerous -- I'm basically casting VkCommandBuffer* to VkCommandBuffer. I should do *((VkCommandBuffer*)alloc_icd_object())
                    }
                #else
                    result=(VkCommandBuffer)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDeviceMemory_to_server_VkDeviceMemory;
            std::map<uintptr_t,uintptr_t> server_VkDeviceMemory_to_client_VkDeviceMemory;
            
        #endif
        

        void serialize_VkDeviceMemory(boost::json::value& json, const VkDeviceMemory& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDeviceMemory_to_server_VkDeviceMemory.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDeviceMemory %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDeviceMemory %p...\n",(VkDeviceMemory)client_VkDeviceMemory_to_server_VkDeviceMemory[(uintptr_t)data]);
                    result=client_VkDeviceMemory_to_server_VkDeviceMemory[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDeviceMemory(boost::json::value& json, VkDeviceMemory& member){
                VkDeviceMemory result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDeviceMemory)data);
                    if (server_VkDeviceMemory_to_client_VkDeviceMemory.contains(data)){
                        result=(VkDeviceMemory)server_VkDeviceMemory_to_client_VkDeviceMemory[data];
                        debug_printf("Deserializing to VkDeviceMemory %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDeviceMemory));
                        debug_printf("Mapping to VkDeviceMemory %p...\n",handle);
                        server_VkDeviceMemory_to_client_VkDeviceMemory[data]=(uintptr_t)handle;
                        client_VkDeviceMemory_to_server_VkDeviceMemory[(uintptr_t)handle]=data;
                        
                        result=(VkDeviceMemory)handle; //This is highly dangerous -- I'm basically casting VkDeviceMemory* to VkDeviceMemory. I should do *((VkDeviceMemory*)alloc_icd_object())
                    }
                #else
                    result=(VkDeviceMemory)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkCommandPool_to_server_VkCommandPool;
            std::map<uintptr_t,uintptr_t> server_VkCommandPool_to_client_VkCommandPool;
            
        #endif
        

        void serialize_VkCommandPool(boost::json::value& json, const VkCommandPool& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkCommandPool_to_server_VkCommandPool.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkCommandPool %p not found!\n",data);
                    }
                     debug_printf("Serializing VkCommandPool %p...\n",(VkCommandPool)client_VkCommandPool_to_server_VkCommandPool[(uintptr_t)data]);
                    result=client_VkCommandPool_to_server_VkCommandPool[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkCommandPool(boost::json::value& json, VkCommandPool& member){
                VkCommandPool result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkCommandPool)data);
                    if (server_VkCommandPool_to_client_VkCommandPool.contains(data)){
                        result=(VkCommandPool)server_VkCommandPool_to_client_VkCommandPool[data];
                        debug_printf("Deserializing to VkCommandPool %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkCommandPool));
                        debug_printf("Mapping to VkCommandPool %p...\n",handle);
                        server_VkCommandPool_to_client_VkCommandPool[data]=(uintptr_t)handle;
                        client_VkCommandPool_to_server_VkCommandPool[(uintptr_t)handle]=data;
                        
                        result=(VkCommandPool)handle; //This is highly dangerous -- I'm basically casting VkCommandPool* to VkCommandPool. I should do *((VkCommandPool*)alloc_icd_object())
                    }
                #else
                    result=(VkCommandPool)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkBuffer_to_server_VkBuffer;
            std::map<uintptr_t,uintptr_t> server_VkBuffer_to_client_VkBuffer;
            
        #endif
        

        void serialize_VkBuffer(boost::json::value& json, const VkBuffer& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkBuffer_to_server_VkBuffer.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkBuffer %p not found!\n",data);
                    }
                     debug_printf("Serializing VkBuffer %p...\n",(VkBuffer)client_VkBuffer_to_server_VkBuffer[(uintptr_t)data]);
                    result=client_VkBuffer_to_server_VkBuffer[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkBuffer(boost::json::value& json, VkBuffer& member){
                VkBuffer result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkBuffer)data);
                    if (server_VkBuffer_to_client_VkBuffer.contains(data)){
                        result=(VkBuffer)server_VkBuffer_to_client_VkBuffer[data];
                        debug_printf("Deserializing to VkBuffer %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkBuffer));
                        debug_printf("Mapping to VkBuffer %p...\n",handle);
                        server_VkBuffer_to_client_VkBuffer[data]=(uintptr_t)handle;
                        client_VkBuffer_to_server_VkBuffer[(uintptr_t)handle]=data;
                        
                        result=(VkBuffer)handle; //This is highly dangerous -- I'm basically casting VkBuffer* to VkBuffer. I should do *((VkBuffer*)alloc_icd_object())
                    }
                #else
                    result=(VkBuffer)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkBufferView_to_server_VkBufferView;
            std::map<uintptr_t,uintptr_t> server_VkBufferView_to_client_VkBufferView;
            
        #endif
        

        void serialize_VkBufferView(boost::json::value& json, const VkBufferView& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkBufferView_to_server_VkBufferView.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkBufferView %p not found!\n",data);
                    }
                     debug_printf("Serializing VkBufferView %p...\n",(VkBufferView)client_VkBufferView_to_server_VkBufferView[(uintptr_t)data]);
                    result=client_VkBufferView_to_server_VkBufferView[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkBufferView(boost::json::value& json, VkBufferView& member){
                VkBufferView result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkBufferView)data);
                    if (server_VkBufferView_to_client_VkBufferView.contains(data)){
                        result=(VkBufferView)server_VkBufferView_to_client_VkBufferView[data];
                        debug_printf("Deserializing to VkBufferView %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkBufferView));
                        debug_printf("Mapping to VkBufferView %p...\n",handle);
                        server_VkBufferView_to_client_VkBufferView[data]=(uintptr_t)handle;
                        client_VkBufferView_to_server_VkBufferView[(uintptr_t)handle]=data;
                        
                        result=(VkBufferView)handle; //This is highly dangerous -- I'm basically casting VkBufferView* to VkBufferView. I should do *((VkBufferView*)alloc_icd_object())
                    }
                #else
                    result=(VkBufferView)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkImage_to_server_VkImage;
            std::map<uintptr_t,uintptr_t> server_VkImage_to_client_VkImage;
            
        #endif
        

        void serialize_VkImage(boost::json::value& json, const VkImage& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkImage_to_server_VkImage.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkImage %p not found!\n",data);
                    }
                     debug_printf("Serializing VkImage %p...\n",(VkImage)client_VkImage_to_server_VkImage[(uintptr_t)data]);
                    result=client_VkImage_to_server_VkImage[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkImage(boost::json::value& json, VkImage& member){
                VkImage result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkImage)data);
                    if (server_VkImage_to_client_VkImage.contains(data)){
                        result=(VkImage)server_VkImage_to_client_VkImage[data];
                        debug_printf("Deserializing to VkImage %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkImage));
                        debug_printf("Mapping to VkImage %p...\n",handle);
                        server_VkImage_to_client_VkImage[data]=(uintptr_t)handle;
                        client_VkImage_to_server_VkImage[(uintptr_t)handle]=data;
                        
                        result=(VkImage)handle; //This is highly dangerous -- I'm basically casting VkImage* to VkImage. I should do *((VkImage*)alloc_icd_object())
                    }
                #else
                    result=(VkImage)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkImageView_to_server_VkImageView;
            std::map<uintptr_t,uintptr_t> server_VkImageView_to_client_VkImageView;
            
        #endif
        

        void serialize_VkImageView(boost::json::value& json, const VkImageView& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkImageView_to_server_VkImageView.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkImageView %p not found!\n",data);
                    }
                     debug_printf("Serializing VkImageView %p...\n",(VkImageView)client_VkImageView_to_server_VkImageView[(uintptr_t)data]);
                    result=client_VkImageView_to_server_VkImageView[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkImageView(boost::json::value& json, VkImageView& member){
                VkImageView result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkImageView)data);
                    if (server_VkImageView_to_client_VkImageView.contains(data)){
                        result=(VkImageView)server_VkImageView_to_client_VkImageView[data];
                        debug_printf("Deserializing to VkImageView %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkImageView));
                        debug_printf("Mapping to VkImageView %p...\n",handle);
                        server_VkImageView_to_client_VkImageView[data]=(uintptr_t)handle;
                        client_VkImageView_to_server_VkImageView[(uintptr_t)handle]=data;
                        
                        result=(VkImageView)handle; //This is highly dangerous -- I'm basically casting VkImageView* to VkImageView. I should do *((VkImageView*)alloc_icd_object())
                    }
                #else
                    result=(VkImageView)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkShaderModule_to_server_VkShaderModule;
            std::map<uintptr_t,uintptr_t> server_VkShaderModule_to_client_VkShaderModule;
            
        #endif
        

        void serialize_VkShaderModule(boost::json::value& json, const VkShaderModule& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkShaderModule_to_server_VkShaderModule.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkShaderModule %p not found!\n",data);
                    }
                     debug_printf("Serializing VkShaderModule %p...\n",(VkShaderModule)client_VkShaderModule_to_server_VkShaderModule[(uintptr_t)data]);
                    result=client_VkShaderModule_to_server_VkShaderModule[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkShaderModule(boost::json::value& json, VkShaderModule& member){
                VkShaderModule result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkShaderModule)data);
                    if (server_VkShaderModule_to_client_VkShaderModule.contains(data)){
                        result=(VkShaderModule)server_VkShaderModule_to_client_VkShaderModule[data];
                        debug_printf("Deserializing to VkShaderModule %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkShaderModule));
                        debug_printf("Mapping to VkShaderModule %p...\n",handle);
                        server_VkShaderModule_to_client_VkShaderModule[data]=(uintptr_t)handle;
                        client_VkShaderModule_to_server_VkShaderModule[(uintptr_t)handle]=data;
                        
                        result=(VkShaderModule)handle; //This is highly dangerous -- I'm basically casting VkShaderModule* to VkShaderModule. I should do *((VkShaderModule*)alloc_icd_object())
                    }
                #else
                    result=(VkShaderModule)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPipeline_to_server_VkPipeline;
            std::map<uintptr_t,uintptr_t> server_VkPipeline_to_client_VkPipeline;
            
        #endif
        

        void serialize_VkPipeline(boost::json::value& json, const VkPipeline& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPipeline_to_server_VkPipeline.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPipeline %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPipeline %p...\n",(VkPipeline)client_VkPipeline_to_server_VkPipeline[(uintptr_t)data]);
                    result=client_VkPipeline_to_server_VkPipeline[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkPipeline(boost::json::value& json, VkPipeline& member){
                VkPipeline result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPipeline)data);
                    if (server_VkPipeline_to_client_VkPipeline.contains(data)){
                        result=(VkPipeline)server_VkPipeline_to_client_VkPipeline[data];
                        debug_printf("Deserializing to VkPipeline %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPipeline));
                        debug_printf("Mapping to VkPipeline %p...\n",handle);
                        server_VkPipeline_to_client_VkPipeline[data]=(uintptr_t)handle;
                        client_VkPipeline_to_server_VkPipeline[(uintptr_t)handle]=data;
                        
                        result=(VkPipeline)handle; //This is highly dangerous -- I'm basically casting VkPipeline* to VkPipeline. I should do *((VkPipeline*)alloc_icd_object())
                    }
                #else
                    result=(VkPipeline)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPipelineLayout_to_server_VkPipelineLayout;
            std::map<uintptr_t,uintptr_t> server_VkPipelineLayout_to_client_VkPipelineLayout;
            
        #endif
        

        void serialize_VkPipelineLayout(boost::json::value& json, const VkPipelineLayout& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPipelineLayout_to_server_VkPipelineLayout.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPipelineLayout %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPipelineLayout %p...\n",(VkPipelineLayout)client_VkPipelineLayout_to_server_VkPipelineLayout[(uintptr_t)data]);
                    result=client_VkPipelineLayout_to_server_VkPipelineLayout[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkPipelineLayout(boost::json::value& json, VkPipelineLayout& member){
                VkPipelineLayout result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPipelineLayout)data);
                    if (server_VkPipelineLayout_to_client_VkPipelineLayout.contains(data)){
                        result=(VkPipelineLayout)server_VkPipelineLayout_to_client_VkPipelineLayout[data];
                        debug_printf("Deserializing to VkPipelineLayout %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPipelineLayout));
                        debug_printf("Mapping to VkPipelineLayout %p...\n",handle);
                        server_VkPipelineLayout_to_client_VkPipelineLayout[data]=(uintptr_t)handle;
                        client_VkPipelineLayout_to_server_VkPipelineLayout[(uintptr_t)handle]=data;
                        
                        result=(VkPipelineLayout)handle; //This is highly dangerous -- I'm basically casting VkPipelineLayout* to VkPipelineLayout. I should do *((VkPipelineLayout*)alloc_icd_object())
                    }
                #else
                    result=(VkPipelineLayout)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSampler_to_server_VkSampler;
            std::map<uintptr_t,uintptr_t> server_VkSampler_to_client_VkSampler;
            
        #endif
        

        void serialize_VkSampler(boost::json::value& json, const VkSampler& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSampler_to_server_VkSampler.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSampler %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSampler %p...\n",(VkSampler)client_VkSampler_to_server_VkSampler[(uintptr_t)data]);
                    result=client_VkSampler_to_server_VkSampler[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkSampler(boost::json::value& json, VkSampler& member){
                VkSampler result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSampler)data);
                    if (server_VkSampler_to_client_VkSampler.contains(data)){
                        result=(VkSampler)server_VkSampler_to_client_VkSampler[data];
                        debug_printf("Deserializing to VkSampler %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSampler));
                        debug_printf("Mapping to VkSampler %p...\n",handle);
                        server_VkSampler_to_client_VkSampler[data]=(uintptr_t)handle;
                        client_VkSampler_to_server_VkSampler[(uintptr_t)handle]=data;
                        
                        result=(VkSampler)handle; //This is highly dangerous -- I'm basically casting VkSampler* to VkSampler. I should do *((VkSampler*)alloc_icd_object())
                    }
                #else
                    result=(VkSampler)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorSet_to_server_VkDescriptorSet;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorSet_to_client_VkDescriptorSet;
            
        #endif
        

        void serialize_VkDescriptorSet(boost::json::value& json, const VkDescriptorSet& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorSet_to_server_VkDescriptorSet.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorSet %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorSet %p...\n",(VkDescriptorSet)client_VkDescriptorSet_to_server_VkDescriptorSet[(uintptr_t)data]);
                    result=client_VkDescriptorSet_to_server_VkDescriptorSet[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDescriptorSet(boost::json::value& json, VkDescriptorSet& member){
                VkDescriptorSet result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorSet)data);
                    if (server_VkDescriptorSet_to_client_VkDescriptorSet.contains(data)){
                        result=(VkDescriptorSet)server_VkDescriptorSet_to_client_VkDescriptorSet[data];
                        debug_printf("Deserializing to VkDescriptorSet %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorSet));
                        debug_printf("Mapping to VkDescriptorSet %p...\n",handle);
                        server_VkDescriptorSet_to_client_VkDescriptorSet[data]=(uintptr_t)handle;
                        client_VkDescriptorSet_to_server_VkDescriptorSet[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorSet)handle; //This is highly dangerous -- I'm basically casting VkDescriptorSet* to VkDescriptorSet. I should do *((VkDescriptorSet*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorSet)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorSetLayout_to_client_VkDescriptorSetLayout;
            
        #endif
        

        void serialize_VkDescriptorSetLayout(boost::json::value& json, const VkDescriptorSetLayout& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorSetLayout %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorSetLayout %p...\n",(VkDescriptorSetLayout)client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout[(uintptr_t)data]);
                    result=client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDescriptorSetLayout(boost::json::value& json, VkDescriptorSetLayout& member){
                VkDescriptorSetLayout result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorSetLayout)data);
                    if (server_VkDescriptorSetLayout_to_client_VkDescriptorSetLayout.contains(data)){
                        result=(VkDescriptorSetLayout)server_VkDescriptorSetLayout_to_client_VkDescriptorSetLayout[data];
                        debug_printf("Deserializing to VkDescriptorSetLayout %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorSetLayout));
                        debug_printf("Mapping to VkDescriptorSetLayout %p...\n",handle);
                        server_VkDescriptorSetLayout_to_client_VkDescriptorSetLayout[data]=(uintptr_t)handle;
                        client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorSetLayout)handle; //This is highly dangerous -- I'm basically casting VkDescriptorSetLayout* to VkDescriptorSetLayout. I should do *((VkDescriptorSetLayout*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorSetLayout)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorPool_to_server_VkDescriptorPool;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorPool_to_client_VkDescriptorPool;
            
        #endif
        

        void serialize_VkDescriptorPool(boost::json::value& json, const VkDescriptorPool& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorPool_to_server_VkDescriptorPool.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorPool %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorPool %p...\n",(VkDescriptorPool)client_VkDescriptorPool_to_server_VkDescriptorPool[(uintptr_t)data]);
                    result=client_VkDescriptorPool_to_server_VkDescriptorPool[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDescriptorPool(boost::json::value& json, VkDescriptorPool& member){
                VkDescriptorPool result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorPool)data);
                    if (server_VkDescriptorPool_to_client_VkDescriptorPool.contains(data)){
                        result=(VkDescriptorPool)server_VkDescriptorPool_to_client_VkDescriptorPool[data];
                        debug_printf("Deserializing to VkDescriptorPool %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorPool));
                        debug_printf("Mapping to VkDescriptorPool %p...\n",handle);
                        server_VkDescriptorPool_to_client_VkDescriptorPool[data]=(uintptr_t)handle;
                        client_VkDescriptorPool_to_server_VkDescriptorPool[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorPool)handle; //This is highly dangerous -- I'm basically casting VkDescriptorPool* to VkDescriptorPool. I should do *((VkDescriptorPool*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorPool)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkFence_to_server_VkFence;
            std::map<uintptr_t,uintptr_t> server_VkFence_to_client_VkFence;
            
        #endif
        

        void serialize_VkFence(boost::json::value& json, const VkFence& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkFence_to_server_VkFence.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkFence %p not found!\n",data);
                    }
                     debug_printf("Serializing VkFence %p...\n",(VkFence)client_VkFence_to_server_VkFence[(uintptr_t)data]);
                    result=client_VkFence_to_server_VkFence[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkFence(boost::json::value& json, VkFence& member){
                VkFence result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkFence)data);
                    if (server_VkFence_to_client_VkFence.contains(data)){
                        result=(VkFence)server_VkFence_to_client_VkFence[data];
                        debug_printf("Deserializing to VkFence %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkFence));
                        debug_printf("Mapping to VkFence %p...\n",handle);
                        server_VkFence_to_client_VkFence[data]=(uintptr_t)handle;
                        client_VkFence_to_server_VkFence[(uintptr_t)handle]=data;
                        
                        result=(VkFence)handle; //This is highly dangerous -- I'm basically casting VkFence* to VkFence. I should do *((VkFence*)alloc_icd_object())
                    }
                #else
                    result=(VkFence)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSemaphore_to_server_VkSemaphore;
            std::map<uintptr_t,uintptr_t> server_VkSemaphore_to_client_VkSemaphore;
            
        #endif
        

        void serialize_VkSemaphore(boost::json::value& json, const VkSemaphore& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSemaphore_to_server_VkSemaphore.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSemaphore %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSemaphore %p...\n",(VkSemaphore)client_VkSemaphore_to_server_VkSemaphore[(uintptr_t)data]);
                    result=client_VkSemaphore_to_server_VkSemaphore[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkSemaphore(boost::json::value& json, VkSemaphore& member){
                VkSemaphore result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSemaphore)data);
                    if (server_VkSemaphore_to_client_VkSemaphore.contains(data)){
                        result=(VkSemaphore)server_VkSemaphore_to_client_VkSemaphore[data];
                        debug_printf("Deserializing to VkSemaphore %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSemaphore));
                        debug_printf("Mapping to VkSemaphore %p...\n",handle);
                        server_VkSemaphore_to_client_VkSemaphore[data]=(uintptr_t)handle;
                        client_VkSemaphore_to_server_VkSemaphore[(uintptr_t)handle]=data;
                        
                        result=(VkSemaphore)handle; //This is highly dangerous -- I'm basically casting VkSemaphore* to VkSemaphore. I should do *((VkSemaphore*)alloc_icd_object())
                    }
                #else
                    result=(VkSemaphore)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkEvent_to_server_VkEvent;
            std::map<uintptr_t,uintptr_t> server_VkEvent_to_client_VkEvent;
            
        #endif
        

        void serialize_VkEvent(boost::json::value& json, const VkEvent& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkEvent_to_server_VkEvent.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkEvent %p not found!\n",data);
                    }
                     debug_printf("Serializing VkEvent %p...\n",(VkEvent)client_VkEvent_to_server_VkEvent[(uintptr_t)data]);
                    result=client_VkEvent_to_server_VkEvent[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkEvent(boost::json::value& json, VkEvent& member){
                VkEvent result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkEvent)data);
                    if (server_VkEvent_to_client_VkEvent.contains(data)){
                        result=(VkEvent)server_VkEvent_to_client_VkEvent[data];
                        debug_printf("Deserializing to VkEvent %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkEvent));
                        debug_printf("Mapping to VkEvent %p...\n",handle);
                        server_VkEvent_to_client_VkEvent[data]=(uintptr_t)handle;
                        client_VkEvent_to_server_VkEvent[(uintptr_t)handle]=data;
                        
                        result=(VkEvent)handle; //This is highly dangerous -- I'm basically casting VkEvent* to VkEvent. I should do *((VkEvent*)alloc_icd_object())
                    }
                #else
                    result=(VkEvent)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkQueryPool_to_server_VkQueryPool;
            std::map<uintptr_t,uintptr_t> server_VkQueryPool_to_client_VkQueryPool;
            
        #endif
        

        void serialize_VkQueryPool(boost::json::value& json, const VkQueryPool& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkQueryPool_to_server_VkQueryPool.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkQueryPool %p not found!\n",data);
                    }
                     debug_printf("Serializing VkQueryPool %p...\n",(VkQueryPool)client_VkQueryPool_to_server_VkQueryPool[(uintptr_t)data]);
                    result=client_VkQueryPool_to_server_VkQueryPool[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkQueryPool(boost::json::value& json, VkQueryPool& member){
                VkQueryPool result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkQueryPool)data);
                    if (server_VkQueryPool_to_client_VkQueryPool.contains(data)){
                        result=(VkQueryPool)server_VkQueryPool_to_client_VkQueryPool[data];
                        debug_printf("Deserializing to VkQueryPool %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkQueryPool));
                        debug_printf("Mapping to VkQueryPool %p...\n",handle);
                        server_VkQueryPool_to_client_VkQueryPool[data]=(uintptr_t)handle;
                        client_VkQueryPool_to_server_VkQueryPool[(uintptr_t)handle]=data;
                        
                        result=(VkQueryPool)handle; //This is highly dangerous -- I'm basically casting VkQueryPool* to VkQueryPool. I should do *((VkQueryPool*)alloc_icd_object())
                    }
                #else
                    result=(VkQueryPool)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkFramebuffer_to_server_VkFramebuffer;
            std::map<uintptr_t,uintptr_t> server_VkFramebuffer_to_client_VkFramebuffer;
            
        #endif
        

        void serialize_VkFramebuffer(boost::json::value& json, const VkFramebuffer& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkFramebuffer_to_server_VkFramebuffer.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkFramebuffer %p not found!\n",data);
                    }
                     debug_printf("Serializing VkFramebuffer %p...\n",(VkFramebuffer)client_VkFramebuffer_to_server_VkFramebuffer[(uintptr_t)data]);
                    result=client_VkFramebuffer_to_server_VkFramebuffer[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkFramebuffer(boost::json::value& json, VkFramebuffer& member){
                VkFramebuffer result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkFramebuffer)data);
                    if (server_VkFramebuffer_to_client_VkFramebuffer.contains(data)){
                        result=(VkFramebuffer)server_VkFramebuffer_to_client_VkFramebuffer[data];
                        debug_printf("Deserializing to VkFramebuffer %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkFramebuffer));
                        debug_printf("Mapping to VkFramebuffer %p...\n",handle);
                        server_VkFramebuffer_to_client_VkFramebuffer[data]=(uintptr_t)handle;
                        client_VkFramebuffer_to_server_VkFramebuffer[(uintptr_t)handle]=data;
                        
                        result=(VkFramebuffer)handle; //This is highly dangerous -- I'm basically casting VkFramebuffer* to VkFramebuffer. I should do *((VkFramebuffer*)alloc_icd_object())
                    }
                #else
                    result=(VkFramebuffer)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkRenderPass_to_server_VkRenderPass;
            std::map<uintptr_t,uintptr_t> server_VkRenderPass_to_client_VkRenderPass;
            
        #endif
        

        void serialize_VkRenderPass(boost::json::value& json, const VkRenderPass& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkRenderPass_to_server_VkRenderPass.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkRenderPass %p not found!\n",data);
                    }
                     debug_printf("Serializing VkRenderPass %p...\n",(VkRenderPass)client_VkRenderPass_to_server_VkRenderPass[(uintptr_t)data]);
                    result=client_VkRenderPass_to_server_VkRenderPass[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkRenderPass(boost::json::value& json, VkRenderPass& member){
                VkRenderPass result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkRenderPass)data);
                    if (server_VkRenderPass_to_client_VkRenderPass.contains(data)){
                        result=(VkRenderPass)server_VkRenderPass_to_client_VkRenderPass[data];
                        debug_printf("Deserializing to VkRenderPass %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkRenderPass));
                        debug_printf("Mapping to VkRenderPass %p...\n",handle);
                        server_VkRenderPass_to_client_VkRenderPass[data]=(uintptr_t)handle;
                        client_VkRenderPass_to_server_VkRenderPass[(uintptr_t)handle]=data;
                        
                        result=(VkRenderPass)handle; //This is highly dangerous -- I'm basically casting VkRenderPass* to VkRenderPass. I should do *((VkRenderPass*)alloc_icd_object())
                    }
                #else
                    result=(VkRenderPass)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPipelineCache_to_server_VkPipelineCache;
            std::map<uintptr_t,uintptr_t> server_VkPipelineCache_to_client_VkPipelineCache;
            
        #endif
        

        void serialize_VkPipelineCache(boost::json::value& json, const VkPipelineCache& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPipelineCache_to_server_VkPipelineCache.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPipelineCache %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPipelineCache %p...\n",(VkPipelineCache)client_VkPipelineCache_to_server_VkPipelineCache[(uintptr_t)data]);
                    result=client_VkPipelineCache_to_server_VkPipelineCache[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkPipelineCache(boost::json::value& json, VkPipelineCache& member){
                VkPipelineCache result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPipelineCache)data);
                    if (server_VkPipelineCache_to_client_VkPipelineCache.contains(data)){
                        result=(VkPipelineCache)server_VkPipelineCache_to_client_VkPipelineCache[data];
                        debug_printf("Deserializing to VkPipelineCache %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPipelineCache));
                        debug_printf("Mapping to VkPipelineCache %p...\n",handle);
                        server_VkPipelineCache_to_client_VkPipelineCache[data]=(uintptr_t)handle;
                        client_VkPipelineCache_to_server_VkPipelineCache[(uintptr_t)handle]=data;
                        
                        result=(VkPipelineCache)handle; //This is highly dangerous -- I'm basically casting VkPipelineCache* to VkPipelineCache. I should do *((VkPipelineCache*)alloc_icd_object())
                    }
                #else
                    result=(VkPipelineCache)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV;
            std::map<uintptr_t,uintptr_t> server_VkIndirectCommandsLayoutNV_to_client_VkIndirectCommandsLayoutNV;
            
        #endif
        

        void serialize_VkIndirectCommandsLayoutNV(boost::json::value& json, const VkIndirectCommandsLayoutNV& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkIndirectCommandsLayoutNV %p not found!\n",data);
                    }
                     debug_printf("Serializing VkIndirectCommandsLayoutNV %p...\n",(VkIndirectCommandsLayoutNV)client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV[(uintptr_t)data]);
                    result=client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkIndirectCommandsLayoutNV(boost::json::value& json, VkIndirectCommandsLayoutNV& member){
                VkIndirectCommandsLayoutNV result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkIndirectCommandsLayoutNV)data);
                    if (server_VkIndirectCommandsLayoutNV_to_client_VkIndirectCommandsLayoutNV.contains(data)){
                        result=(VkIndirectCommandsLayoutNV)server_VkIndirectCommandsLayoutNV_to_client_VkIndirectCommandsLayoutNV[data];
                        debug_printf("Deserializing to VkIndirectCommandsLayoutNV %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkIndirectCommandsLayoutNV));
                        debug_printf("Mapping to VkIndirectCommandsLayoutNV %p...\n",handle);
                        server_VkIndirectCommandsLayoutNV_to_client_VkIndirectCommandsLayoutNV[data]=(uintptr_t)handle;
                        client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV[(uintptr_t)handle]=data;
                        
                        result=(VkIndirectCommandsLayoutNV)handle; //This is highly dangerous -- I'm basically casting VkIndirectCommandsLayoutNV* to VkIndirectCommandsLayoutNV. I should do *((VkIndirectCommandsLayoutNV*)alloc_icd_object())
                    }
                #else
                    result=(VkIndirectCommandsLayoutNV)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorUpdateTemplate_to_client_VkDescriptorUpdateTemplate;
            
        #endif
        

        void serialize_VkDescriptorUpdateTemplate(boost::json::value& json, const VkDescriptorUpdateTemplate& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorUpdateTemplate %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorUpdateTemplate %p...\n",(VkDescriptorUpdateTemplate)client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate[(uintptr_t)data]);
                    result=client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDescriptorUpdateTemplate(boost::json::value& json, VkDescriptorUpdateTemplate& member){
                VkDescriptorUpdateTemplate result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorUpdateTemplate)data);
                    if (server_VkDescriptorUpdateTemplate_to_client_VkDescriptorUpdateTemplate.contains(data)){
                        result=(VkDescriptorUpdateTemplate)server_VkDescriptorUpdateTemplate_to_client_VkDescriptorUpdateTemplate[data];
                        debug_printf("Deserializing to VkDescriptorUpdateTemplate %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorUpdateTemplate));
                        debug_printf("Mapping to VkDescriptorUpdateTemplate %p...\n",handle);
                        server_VkDescriptorUpdateTemplate_to_client_VkDescriptorUpdateTemplate[data]=(uintptr_t)handle;
                        client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorUpdateTemplate)handle; //This is highly dangerous -- I'm basically casting VkDescriptorUpdateTemplate* to VkDescriptorUpdateTemplate. I should do *((VkDescriptorUpdateTemplate*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorUpdateTemplate)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorUpdateTemplateKHR_to_client_VkDescriptorUpdateTemplateKHR;
            
        #endif
        

        void serialize_VkDescriptorUpdateTemplateKHR(boost::json::value& json, const VkDescriptorUpdateTemplateKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorUpdateTemplateKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorUpdateTemplateKHR %p...\n",(VkDescriptorUpdateTemplateKHR)client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR[(uintptr_t)data]);
                    result=client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDescriptorUpdateTemplateKHR(boost::json::value& json, VkDescriptorUpdateTemplateKHR& member){
                VkDescriptorUpdateTemplateKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorUpdateTemplateKHR)data);
                    if (server_VkDescriptorUpdateTemplateKHR_to_client_VkDescriptorUpdateTemplateKHR.contains(data)){
                        result=(VkDescriptorUpdateTemplateKHR)server_VkDescriptorUpdateTemplateKHR_to_client_VkDescriptorUpdateTemplateKHR[data];
                        debug_printf("Deserializing to VkDescriptorUpdateTemplateKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorUpdateTemplateKHR));
                        debug_printf("Mapping to VkDescriptorUpdateTemplateKHR %p...\n",handle);
                        server_VkDescriptorUpdateTemplateKHR_to_client_VkDescriptorUpdateTemplateKHR[data]=(uintptr_t)handle;
                        client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorUpdateTemplateKHR)handle; //This is highly dangerous -- I'm basically casting VkDescriptorUpdateTemplateKHR* to VkDescriptorUpdateTemplateKHR. I should do *((VkDescriptorUpdateTemplateKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorUpdateTemplateKHR)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion;
            std::map<uintptr_t,uintptr_t> server_VkSamplerYcbcrConversion_to_client_VkSamplerYcbcrConversion;
            
        #endif
        

        void serialize_VkSamplerYcbcrConversion(boost::json::value& json, const VkSamplerYcbcrConversion& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSamplerYcbcrConversion %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSamplerYcbcrConversion %p...\n",(VkSamplerYcbcrConversion)client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion[(uintptr_t)data]);
                    result=client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkSamplerYcbcrConversion(boost::json::value& json, VkSamplerYcbcrConversion& member){
                VkSamplerYcbcrConversion result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSamplerYcbcrConversion)data);
                    if (server_VkSamplerYcbcrConversion_to_client_VkSamplerYcbcrConversion.contains(data)){
                        result=(VkSamplerYcbcrConversion)server_VkSamplerYcbcrConversion_to_client_VkSamplerYcbcrConversion[data];
                        debug_printf("Deserializing to VkSamplerYcbcrConversion %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSamplerYcbcrConversion));
                        debug_printf("Mapping to VkSamplerYcbcrConversion %p...\n",handle);
                        server_VkSamplerYcbcrConversion_to_client_VkSamplerYcbcrConversion[data]=(uintptr_t)handle;
                        client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion[(uintptr_t)handle]=data;
                        
                        result=(VkSamplerYcbcrConversion)handle; //This is highly dangerous -- I'm basically casting VkSamplerYcbcrConversion* to VkSamplerYcbcrConversion. I should do *((VkSamplerYcbcrConversion*)alloc_icd_object())
                    }
                #else
                    result=(VkSamplerYcbcrConversion)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR;
            std::map<uintptr_t,uintptr_t> server_VkSamplerYcbcrConversionKHR_to_client_VkSamplerYcbcrConversionKHR;
            
        #endif
        

        void serialize_VkSamplerYcbcrConversionKHR(boost::json::value& json, const VkSamplerYcbcrConversionKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSamplerYcbcrConversionKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSamplerYcbcrConversionKHR %p...\n",(VkSamplerYcbcrConversionKHR)client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR[(uintptr_t)data]);
                    result=client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkSamplerYcbcrConversionKHR(boost::json::value& json, VkSamplerYcbcrConversionKHR& member){
                VkSamplerYcbcrConversionKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSamplerYcbcrConversionKHR)data);
                    if (server_VkSamplerYcbcrConversionKHR_to_client_VkSamplerYcbcrConversionKHR.contains(data)){
                        result=(VkSamplerYcbcrConversionKHR)server_VkSamplerYcbcrConversionKHR_to_client_VkSamplerYcbcrConversionKHR[data];
                        debug_printf("Deserializing to VkSamplerYcbcrConversionKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSamplerYcbcrConversionKHR));
                        debug_printf("Mapping to VkSamplerYcbcrConversionKHR %p...\n",handle);
                        server_VkSamplerYcbcrConversionKHR_to_client_VkSamplerYcbcrConversionKHR[data]=(uintptr_t)handle;
                        client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR[(uintptr_t)handle]=data;
                        
                        result=(VkSamplerYcbcrConversionKHR)handle; //This is highly dangerous -- I'm basically casting VkSamplerYcbcrConversionKHR* to VkSamplerYcbcrConversionKHR. I should do *((VkSamplerYcbcrConversionKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkSamplerYcbcrConversionKHR)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkValidationCacheEXT_to_server_VkValidationCacheEXT;
            std::map<uintptr_t,uintptr_t> server_VkValidationCacheEXT_to_client_VkValidationCacheEXT;
            
        #endif
        

        void serialize_VkValidationCacheEXT(boost::json::value& json, const VkValidationCacheEXT& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkValidationCacheEXT_to_server_VkValidationCacheEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkValidationCacheEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkValidationCacheEXT %p...\n",(VkValidationCacheEXT)client_VkValidationCacheEXT_to_server_VkValidationCacheEXT[(uintptr_t)data]);
                    result=client_VkValidationCacheEXT_to_server_VkValidationCacheEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkValidationCacheEXT(boost::json::value& json, VkValidationCacheEXT& member){
                VkValidationCacheEXT result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkValidationCacheEXT)data);
                    if (server_VkValidationCacheEXT_to_client_VkValidationCacheEXT.contains(data)){
                        result=(VkValidationCacheEXT)server_VkValidationCacheEXT_to_client_VkValidationCacheEXT[data];
                        debug_printf("Deserializing to VkValidationCacheEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkValidationCacheEXT));
                        debug_printf("Mapping to VkValidationCacheEXT %p...\n",handle);
                        server_VkValidationCacheEXT_to_client_VkValidationCacheEXT[data]=(uintptr_t)handle;
                        client_VkValidationCacheEXT_to_server_VkValidationCacheEXT[(uintptr_t)handle]=data;
                        
                        result=(VkValidationCacheEXT)handle; //This is highly dangerous -- I'm basically casting VkValidationCacheEXT* to VkValidationCacheEXT. I should do *((VkValidationCacheEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkValidationCacheEXT)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR;
            std::map<uintptr_t,uintptr_t> server_VkAccelerationStructureKHR_to_client_VkAccelerationStructureKHR;
            
        #endif
        

        void serialize_VkAccelerationStructureKHR(boost::json::value& json, const VkAccelerationStructureKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkAccelerationStructureKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkAccelerationStructureKHR %p...\n",(VkAccelerationStructureKHR)client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR[(uintptr_t)data]);
                    result=client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkAccelerationStructureKHR(boost::json::value& json, VkAccelerationStructureKHR& member){
                VkAccelerationStructureKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkAccelerationStructureKHR)data);
                    if (server_VkAccelerationStructureKHR_to_client_VkAccelerationStructureKHR.contains(data)){
                        result=(VkAccelerationStructureKHR)server_VkAccelerationStructureKHR_to_client_VkAccelerationStructureKHR[data];
                        debug_printf("Deserializing to VkAccelerationStructureKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkAccelerationStructureKHR));
                        debug_printf("Mapping to VkAccelerationStructureKHR %p...\n",handle);
                        server_VkAccelerationStructureKHR_to_client_VkAccelerationStructureKHR[data]=(uintptr_t)handle;
                        client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR[(uintptr_t)handle]=data;
                        
                        result=(VkAccelerationStructureKHR)handle; //This is highly dangerous -- I'm basically casting VkAccelerationStructureKHR* to VkAccelerationStructureKHR. I should do *((VkAccelerationStructureKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkAccelerationStructureKHR)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV;
            std::map<uintptr_t,uintptr_t> server_VkAccelerationStructureNV_to_client_VkAccelerationStructureNV;
            
        #endif
        

        void serialize_VkAccelerationStructureNV(boost::json::value& json, const VkAccelerationStructureNV& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkAccelerationStructureNV %p not found!\n",data);
                    }
                     debug_printf("Serializing VkAccelerationStructureNV %p...\n",(VkAccelerationStructureNV)client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV[(uintptr_t)data]);
                    result=client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkAccelerationStructureNV(boost::json::value& json, VkAccelerationStructureNV& member){
                VkAccelerationStructureNV result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkAccelerationStructureNV)data);
                    if (server_VkAccelerationStructureNV_to_client_VkAccelerationStructureNV.contains(data)){
                        result=(VkAccelerationStructureNV)server_VkAccelerationStructureNV_to_client_VkAccelerationStructureNV[data];
                        debug_printf("Deserializing to VkAccelerationStructureNV %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkAccelerationStructureNV));
                        debug_printf("Mapping to VkAccelerationStructureNV %p...\n",handle);
                        server_VkAccelerationStructureNV_to_client_VkAccelerationStructureNV[data]=(uintptr_t)handle;
                        client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV[(uintptr_t)handle]=data;
                        
                        result=(VkAccelerationStructureNV)handle; //This is highly dangerous -- I'm basically casting VkAccelerationStructureNV* to VkAccelerationStructureNV. I should do *((VkAccelerationStructureNV*)alloc_icd_object())
                    }
                #else
                    result=(VkAccelerationStructureNV)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL;
            std::map<uintptr_t,uintptr_t> server_VkPerformanceConfigurationINTEL_to_client_VkPerformanceConfigurationINTEL;
            
        #endif
        

        void serialize_VkPerformanceConfigurationINTEL(boost::json::value& json, const VkPerformanceConfigurationINTEL& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPerformanceConfigurationINTEL %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPerformanceConfigurationINTEL %p...\n",(VkPerformanceConfigurationINTEL)client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL[(uintptr_t)data]);
                    result=client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkPerformanceConfigurationINTEL(boost::json::value& json, VkPerformanceConfigurationINTEL& member){
                VkPerformanceConfigurationINTEL result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPerformanceConfigurationINTEL)data);
                    if (server_VkPerformanceConfigurationINTEL_to_client_VkPerformanceConfigurationINTEL.contains(data)){
                        result=(VkPerformanceConfigurationINTEL)server_VkPerformanceConfigurationINTEL_to_client_VkPerformanceConfigurationINTEL[data];
                        debug_printf("Deserializing to VkPerformanceConfigurationINTEL %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPerformanceConfigurationINTEL));
                        debug_printf("Mapping to VkPerformanceConfigurationINTEL %p...\n",handle);
                        server_VkPerformanceConfigurationINTEL_to_client_VkPerformanceConfigurationINTEL[data]=(uintptr_t)handle;
                        client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL[(uintptr_t)handle]=data;
                        
                        result=(VkPerformanceConfigurationINTEL)handle; //This is highly dangerous -- I'm basically casting VkPerformanceConfigurationINTEL* to VkPerformanceConfigurationINTEL. I should do *((VkPerformanceConfigurationINTEL*)alloc_icd_object())
                    }
                #else
                    result=(VkPerformanceConfigurationINTEL)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR;
            std::map<uintptr_t,uintptr_t> server_VkDeferredOperationKHR_to_client_VkDeferredOperationKHR;
            
        #endif
        

        void serialize_VkDeferredOperationKHR(boost::json::value& json, const VkDeferredOperationKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDeferredOperationKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDeferredOperationKHR %p...\n",(VkDeferredOperationKHR)client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR[(uintptr_t)data]);
                    result=client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDeferredOperationKHR(boost::json::value& json, VkDeferredOperationKHR& member){
                VkDeferredOperationKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDeferredOperationKHR)data);
                    if (server_VkDeferredOperationKHR_to_client_VkDeferredOperationKHR.contains(data)){
                        result=(VkDeferredOperationKHR)server_VkDeferredOperationKHR_to_client_VkDeferredOperationKHR[data];
                        debug_printf("Deserializing to VkDeferredOperationKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDeferredOperationKHR));
                        debug_printf("Mapping to VkDeferredOperationKHR %p...\n",handle);
                        server_VkDeferredOperationKHR_to_client_VkDeferredOperationKHR[data]=(uintptr_t)handle;
                        client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR[(uintptr_t)handle]=data;
                        
                        result=(VkDeferredOperationKHR)handle; //This is highly dangerous -- I'm basically casting VkDeferredOperationKHR* to VkDeferredOperationKHR. I should do *((VkDeferredOperationKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkDeferredOperationKHR)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPrivateDataSlot_to_server_VkPrivateDataSlot;
            std::map<uintptr_t,uintptr_t> server_VkPrivateDataSlot_to_client_VkPrivateDataSlot;
            
        #endif
        

        void serialize_VkPrivateDataSlot(boost::json::value& json, const VkPrivateDataSlot& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPrivateDataSlot_to_server_VkPrivateDataSlot.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPrivateDataSlot %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPrivateDataSlot %p...\n",(VkPrivateDataSlot)client_VkPrivateDataSlot_to_server_VkPrivateDataSlot[(uintptr_t)data]);
                    result=client_VkPrivateDataSlot_to_server_VkPrivateDataSlot[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkPrivateDataSlot(boost::json::value& json, VkPrivateDataSlot& member){
                VkPrivateDataSlot result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPrivateDataSlot)data);
                    if (server_VkPrivateDataSlot_to_client_VkPrivateDataSlot.contains(data)){
                        result=(VkPrivateDataSlot)server_VkPrivateDataSlot_to_client_VkPrivateDataSlot[data];
                        debug_printf("Deserializing to VkPrivateDataSlot %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPrivateDataSlot));
                        debug_printf("Mapping to VkPrivateDataSlot %p...\n",handle);
                        server_VkPrivateDataSlot_to_client_VkPrivateDataSlot[data]=(uintptr_t)handle;
                        client_VkPrivateDataSlot_to_server_VkPrivateDataSlot[(uintptr_t)handle]=data;
                        
                        result=(VkPrivateDataSlot)handle; //This is highly dangerous -- I'm basically casting VkPrivateDataSlot* to VkPrivateDataSlot. I should do *((VkPrivateDataSlot*)alloc_icd_object())
                    }
                #else
                    result=(VkPrivateDataSlot)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT;
            std::map<uintptr_t,uintptr_t> server_VkPrivateDataSlotEXT_to_client_VkPrivateDataSlotEXT;
            
        #endif
        

        void serialize_VkPrivateDataSlotEXT(boost::json::value& json, const VkPrivateDataSlotEXT& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPrivateDataSlotEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPrivateDataSlotEXT %p...\n",(VkPrivateDataSlotEXT)client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT[(uintptr_t)data]);
                    result=client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkPrivateDataSlotEXT(boost::json::value& json, VkPrivateDataSlotEXT& member){
                VkPrivateDataSlotEXT result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPrivateDataSlotEXT)data);
                    if (server_VkPrivateDataSlotEXT_to_client_VkPrivateDataSlotEXT.contains(data)){
                        result=(VkPrivateDataSlotEXT)server_VkPrivateDataSlotEXT_to_client_VkPrivateDataSlotEXT[data];
                        debug_printf("Deserializing to VkPrivateDataSlotEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPrivateDataSlotEXT));
                        debug_printf("Mapping to VkPrivateDataSlotEXT %p...\n",handle);
                        server_VkPrivateDataSlotEXT_to_client_VkPrivateDataSlotEXT[data]=(uintptr_t)handle;
                        client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT[(uintptr_t)handle]=data;
                        
                        result=(VkPrivateDataSlotEXT)handle; //This is highly dangerous -- I'm basically casting VkPrivateDataSlotEXT* to VkPrivateDataSlotEXT. I should do *((VkPrivateDataSlotEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkPrivateDataSlotEXT)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkCuModuleNVX_to_server_VkCuModuleNVX;
            std::map<uintptr_t,uintptr_t> server_VkCuModuleNVX_to_client_VkCuModuleNVX;
            
        #endif
        

        void serialize_VkCuModuleNVX(boost::json::value& json, const VkCuModuleNVX& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkCuModuleNVX_to_server_VkCuModuleNVX.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkCuModuleNVX %p not found!\n",data);
                    }
                     debug_printf("Serializing VkCuModuleNVX %p...\n",(VkCuModuleNVX)client_VkCuModuleNVX_to_server_VkCuModuleNVX[(uintptr_t)data]);
                    result=client_VkCuModuleNVX_to_server_VkCuModuleNVX[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkCuModuleNVX(boost::json::value& json, VkCuModuleNVX& member){
                VkCuModuleNVX result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkCuModuleNVX)data);
                    if (server_VkCuModuleNVX_to_client_VkCuModuleNVX.contains(data)){
                        result=(VkCuModuleNVX)server_VkCuModuleNVX_to_client_VkCuModuleNVX[data];
                        debug_printf("Deserializing to VkCuModuleNVX %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkCuModuleNVX));
                        debug_printf("Mapping to VkCuModuleNVX %p...\n",handle);
                        server_VkCuModuleNVX_to_client_VkCuModuleNVX[data]=(uintptr_t)handle;
                        client_VkCuModuleNVX_to_server_VkCuModuleNVX[(uintptr_t)handle]=data;
                        
                        result=(VkCuModuleNVX)handle; //This is highly dangerous -- I'm basically casting VkCuModuleNVX* to VkCuModuleNVX. I should do *((VkCuModuleNVX*)alloc_icd_object())
                    }
                #else
                    result=(VkCuModuleNVX)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkCuFunctionNVX_to_server_VkCuFunctionNVX;
            std::map<uintptr_t,uintptr_t> server_VkCuFunctionNVX_to_client_VkCuFunctionNVX;
            
        #endif
        

        void serialize_VkCuFunctionNVX(boost::json::value& json, const VkCuFunctionNVX& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkCuFunctionNVX_to_server_VkCuFunctionNVX.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkCuFunctionNVX %p not found!\n",data);
                    }
                     debug_printf("Serializing VkCuFunctionNVX %p...\n",(VkCuFunctionNVX)client_VkCuFunctionNVX_to_server_VkCuFunctionNVX[(uintptr_t)data]);
                    result=client_VkCuFunctionNVX_to_server_VkCuFunctionNVX[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkCuFunctionNVX(boost::json::value& json, VkCuFunctionNVX& member){
                VkCuFunctionNVX result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkCuFunctionNVX)data);
                    if (server_VkCuFunctionNVX_to_client_VkCuFunctionNVX.contains(data)){
                        result=(VkCuFunctionNVX)server_VkCuFunctionNVX_to_client_VkCuFunctionNVX[data];
                        debug_printf("Deserializing to VkCuFunctionNVX %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkCuFunctionNVX));
                        debug_printf("Mapping to VkCuFunctionNVX %p...\n",handle);
                        server_VkCuFunctionNVX_to_client_VkCuFunctionNVX[data]=(uintptr_t)handle;
                        client_VkCuFunctionNVX_to_server_VkCuFunctionNVX[(uintptr_t)handle]=data;
                        
                        result=(VkCuFunctionNVX)handle; //This is highly dangerous -- I'm basically casting VkCuFunctionNVX* to VkCuFunctionNVX. I should do *((VkCuFunctionNVX*)alloc_icd_object())
                    }
                #else
                    result=(VkCuFunctionNVX)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV;
            std::map<uintptr_t,uintptr_t> server_VkOpticalFlowSessionNV_to_client_VkOpticalFlowSessionNV;
            
        #endif
        

        void serialize_VkOpticalFlowSessionNV(boost::json::value& json, const VkOpticalFlowSessionNV& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkOpticalFlowSessionNV %p not found!\n",data);
                    }
                     debug_printf("Serializing VkOpticalFlowSessionNV %p...\n",(VkOpticalFlowSessionNV)client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV[(uintptr_t)data]);
                    result=client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkOpticalFlowSessionNV(boost::json::value& json, VkOpticalFlowSessionNV& member){
                VkOpticalFlowSessionNV result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkOpticalFlowSessionNV)data);
                    if (server_VkOpticalFlowSessionNV_to_client_VkOpticalFlowSessionNV.contains(data)){
                        result=(VkOpticalFlowSessionNV)server_VkOpticalFlowSessionNV_to_client_VkOpticalFlowSessionNV[data];
                        debug_printf("Deserializing to VkOpticalFlowSessionNV %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkOpticalFlowSessionNV));
                        debug_printf("Mapping to VkOpticalFlowSessionNV %p...\n",handle);
                        server_VkOpticalFlowSessionNV_to_client_VkOpticalFlowSessionNV[data]=(uintptr_t)handle;
                        client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV[(uintptr_t)handle]=data;
                        
                        result=(VkOpticalFlowSessionNV)handle; //This is highly dangerous -- I'm basically casting VkOpticalFlowSessionNV* to VkOpticalFlowSessionNV. I should do *((VkOpticalFlowSessionNV*)alloc_icd_object())
                    }
                #else
                    result=(VkOpticalFlowSessionNV)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkMicromapEXT_to_server_VkMicromapEXT;
            std::map<uintptr_t,uintptr_t> server_VkMicromapEXT_to_client_VkMicromapEXT;
            
        #endif
        

        void serialize_VkMicromapEXT(boost::json::value& json, const VkMicromapEXT& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkMicromapEXT_to_server_VkMicromapEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkMicromapEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkMicromapEXT %p...\n",(VkMicromapEXT)client_VkMicromapEXT_to_server_VkMicromapEXT[(uintptr_t)data]);
                    result=client_VkMicromapEXT_to_server_VkMicromapEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkMicromapEXT(boost::json::value& json, VkMicromapEXT& member){
                VkMicromapEXT result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkMicromapEXT)data);
                    if (server_VkMicromapEXT_to_client_VkMicromapEXT.contains(data)){
                        result=(VkMicromapEXT)server_VkMicromapEXT_to_client_VkMicromapEXT[data];
                        debug_printf("Deserializing to VkMicromapEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkMicromapEXT));
                        debug_printf("Mapping to VkMicromapEXT %p...\n",handle);
                        server_VkMicromapEXT_to_client_VkMicromapEXT[data]=(uintptr_t)handle;
                        client_VkMicromapEXT_to_server_VkMicromapEXT[(uintptr_t)handle]=data;
                        
                        result=(VkMicromapEXT)handle; //This is highly dangerous -- I'm basically casting VkMicromapEXT* to VkMicromapEXT. I should do *((VkMicromapEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkMicromapEXT)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkShaderEXT_to_server_VkShaderEXT;
            std::map<uintptr_t,uintptr_t> server_VkShaderEXT_to_client_VkShaderEXT;
            
        #endif
        

        void serialize_VkShaderEXT(boost::json::value& json, const VkShaderEXT& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkShaderEXT_to_server_VkShaderEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkShaderEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkShaderEXT %p...\n",(VkShaderEXT)client_VkShaderEXT_to_server_VkShaderEXT[(uintptr_t)data]);
                    result=client_VkShaderEXT_to_server_VkShaderEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkShaderEXT(boost::json::value& json, VkShaderEXT& member){
                VkShaderEXT result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkShaderEXT)data);
                    if (server_VkShaderEXT_to_client_VkShaderEXT.contains(data)){
                        result=(VkShaderEXT)server_VkShaderEXT_to_client_VkShaderEXT[data];
                        debug_printf("Deserializing to VkShaderEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkShaderEXT));
                        debug_printf("Mapping to VkShaderEXT %p...\n",handle);
                        server_VkShaderEXT_to_client_VkShaderEXT[data]=(uintptr_t)handle;
                        client_VkShaderEXT_to_server_VkShaderEXT[(uintptr_t)handle]=data;
                        
                        result=(VkShaderEXT)handle; //This is highly dangerous -- I'm basically casting VkShaderEXT* to VkShaderEXT. I should do *((VkShaderEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkShaderEXT)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDisplayKHR_to_server_VkDisplayKHR;
            std::map<uintptr_t,uintptr_t> server_VkDisplayKHR_to_client_VkDisplayKHR;
            
        #endif
        

        void serialize_VkDisplayKHR(boost::json::value& json, const VkDisplayKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDisplayKHR_to_server_VkDisplayKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDisplayKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDisplayKHR %p...\n",(VkDisplayKHR)client_VkDisplayKHR_to_server_VkDisplayKHR[(uintptr_t)data]);
                    result=client_VkDisplayKHR_to_server_VkDisplayKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDisplayKHR(boost::json::value& json, VkDisplayKHR& member){
                VkDisplayKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDisplayKHR)data);
                    if (server_VkDisplayKHR_to_client_VkDisplayKHR.contains(data)){
                        result=(VkDisplayKHR)server_VkDisplayKHR_to_client_VkDisplayKHR[data];
                        debug_printf("Deserializing to VkDisplayKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDisplayKHR));
                        debug_printf("Mapping to VkDisplayKHR %p...\n",handle);
                        server_VkDisplayKHR_to_client_VkDisplayKHR[data]=(uintptr_t)handle;
                        client_VkDisplayKHR_to_server_VkDisplayKHR[(uintptr_t)handle]=data;
                        
                        result=(VkDisplayKHR)handle; //This is highly dangerous -- I'm basically casting VkDisplayKHR* to VkDisplayKHR. I should do *((VkDisplayKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkDisplayKHR)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDisplayModeKHR_to_server_VkDisplayModeKHR;
            std::map<uintptr_t,uintptr_t> server_VkDisplayModeKHR_to_client_VkDisplayModeKHR;
            
        #endif
        

        void serialize_VkDisplayModeKHR(boost::json::value& json, const VkDisplayModeKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDisplayModeKHR_to_server_VkDisplayModeKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDisplayModeKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDisplayModeKHR %p...\n",(VkDisplayModeKHR)client_VkDisplayModeKHR_to_server_VkDisplayModeKHR[(uintptr_t)data]);
                    result=client_VkDisplayModeKHR_to_server_VkDisplayModeKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDisplayModeKHR(boost::json::value& json, VkDisplayModeKHR& member){
                VkDisplayModeKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDisplayModeKHR)data);
                    if (server_VkDisplayModeKHR_to_client_VkDisplayModeKHR.contains(data)){
                        result=(VkDisplayModeKHR)server_VkDisplayModeKHR_to_client_VkDisplayModeKHR[data];
                        debug_printf("Deserializing to VkDisplayModeKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDisplayModeKHR));
                        debug_printf("Mapping to VkDisplayModeKHR %p...\n",handle);
                        server_VkDisplayModeKHR_to_client_VkDisplayModeKHR[data]=(uintptr_t)handle;
                        client_VkDisplayModeKHR_to_server_VkDisplayModeKHR[(uintptr_t)handle]=data;
                        
                        result=(VkDisplayModeKHR)handle; //This is highly dangerous -- I'm basically casting VkDisplayModeKHR* to VkDisplayModeKHR. I should do *((VkDisplayModeKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkDisplayModeKHR)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSurfaceKHR_to_server_VkSurfaceKHR;
            std::map<uintptr_t,uintptr_t> server_VkSurfaceKHR_to_client_VkSurfaceKHR;
            
        #endif
        

        void serialize_VkSurfaceKHR(boost::json::value& json, const VkSurfaceKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSurfaceKHR_to_server_VkSurfaceKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSurfaceKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSurfaceKHR %p...\n",(VkSurfaceKHR)client_VkSurfaceKHR_to_server_VkSurfaceKHR[(uintptr_t)data]);
                    result=client_VkSurfaceKHR_to_server_VkSurfaceKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkSurfaceKHR(boost::json::value& json, VkSurfaceKHR& member){
                VkSurfaceKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSurfaceKHR)data);
                    if (server_VkSurfaceKHR_to_client_VkSurfaceKHR.contains(data)){
                        result=(VkSurfaceKHR)server_VkSurfaceKHR_to_client_VkSurfaceKHR[data];
                        debug_printf("Deserializing to VkSurfaceKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSurfaceKHR));
                        debug_printf("Mapping to VkSurfaceKHR %p...\n",handle);
                        server_VkSurfaceKHR_to_client_VkSurfaceKHR[data]=(uintptr_t)handle;
                        client_VkSurfaceKHR_to_server_VkSurfaceKHR[(uintptr_t)handle]=data;
                        
                        result=(VkSurfaceKHR)handle; //This is highly dangerous -- I'm basically casting VkSurfaceKHR* to VkSurfaceKHR. I should do *((VkSurfaceKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkSurfaceKHR)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSwapchainKHR_to_server_VkSwapchainKHR;
            std::map<uintptr_t,uintptr_t> server_VkSwapchainKHR_to_client_VkSwapchainKHR;
            
        #endif
        

        void serialize_VkSwapchainKHR(boost::json::value& json, const VkSwapchainKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSwapchainKHR_to_server_VkSwapchainKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSwapchainKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSwapchainKHR %p...\n",(VkSwapchainKHR)client_VkSwapchainKHR_to_server_VkSwapchainKHR[(uintptr_t)data]);
                    result=client_VkSwapchainKHR_to_server_VkSwapchainKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkSwapchainKHR(boost::json::value& json, VkSwapchainKHR& member){
                VkSwapchainKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSwapchainKHR)data);
                    if (server_VkSwapchainKHR_to_client_VkSwapchainKHR.contains(data)){
                        result=(VkSwapchainKHR)server_VkSwapchainKHR_to_client_VkSwapchainKHR[data];
                        debug_printf("Deserializing to VkSwapchainKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSwapchainKHR));
                        debug_printf("Mapping to VkSwapchainKHR %p...\n",handle);
                        server_VkSwapchainKHR_to_client_VkSwapchainKHR[data]=(uintptr_t)handle;
                        client_VkSwapchainKHR_to_server_VkSwapchainKHR[(uintptr_t)handle]=data;
                        
                        result=(VkSwapchainKHR)handle; //This is highly dangerous -- I'm basically casting VkSwapchainKHR* to VkSwapchainKHR. I should do *((VkSwapchainKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkSwapchainKHR)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT;
            std::map<uintptr_t,uintptr_t> server_VkDebugReportCallbackEXT_to_client_VkDebugReportCallbackEXT;
            
        #endif
        

        void serialize_VkDebugReportCallbackEXT(boost::json::value& json, const VkDebugReportCallbackEXT& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDebugReportCallbackEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDebugReportCallbackEXT %p...\n",(VkDebugReportCallbackEXT)client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT[(uintptr_t)data]);
                    result=client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDebugReportCallbackEXT(boost::json::value& json, VkDebugReportCallbackEXT& member){
                VkDebugReportCallbackEXT result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDebugReportCallbackEXT)data);
                    if (server_VkDebugReportCallbackEXT_to_client_VkDebugReportCallbackEXT.contains(data)){
                        result=(VkDebugReportCallbackEXT)server_VkDebugReportCallbackEXT_to_client_VkDebugReportCallbackEXT[data];
                        debug_printf("Deserializing to VkDebugReportCallbackEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDebugReportCallbackEXT));
                        debug_printf("Mapping to VkDebugReportCallbackEXT %p...\n",handle);
                        server_VkDebugReportCallbackEXT_to_client_VkDebugReportCallbackEXT[data]=(uintptr_t)handle;
                        client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT[(uintptr_t)handle]=data;
                        
                        result=(VkDebugReportCallbackEXT)handle; //This is highly dangerous -- I'm basically casting VkDebugReportCallbackEXT* to VkDebugReportCallbackEXT. I should do *((VkDebugReportCallbackEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkDebugReportCallbackEXT)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT;
            std::map<uintptr_t,uintptr_t> server_VkDebugUtilsMessengerEXT_to_client_VkDebugUtilsMessengerEXT;
            
        #endif
        

        void serialize_VkDebugUtilsMessengerEXT(boost::json::value& json, const VkDebugUtilsMessengerEXT& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDebugUtilsMessengerEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDebugUtilsMessengerEXT %p...\n",(VkDebugUtilsMessengerEXT)client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT[(uintptr_t)data]);
                    result=client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkDebugUtilsMessengerEXT(boost::json::value& json, VkDebugUtilsMessengerEXT& member){
                VkDebugUtilsMessengerEXT result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDebugUtilsMessengerEXT)data);
                    if (server_VkDebugUtilsMessengerEXT_to_client_VkDebugUtilsMessengerEXT.contains(data)){
                        result=(VkDebugUtilsMessengerEXT)server_VkDebugUtilsMessengerEXT_to_client_VkDebugUtilsMessengerEXT[data];
                        debug_printf("Deserializing to VkDebugUtilsMessengerEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDebugUtilsMessengerEXT));
                        debug_printf("Mapping to VkDebugUtilsMessengerEXT %p...\n",handle);
                        server_VkDebugUtilsMessengerEXT_to_client_VkDebugUtilsMessengerEXT[data]=(uintptr_t)handle;
                        client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT[(uintptr_t)handle]=data;
                        
                        result=(VkDebugUtilsMessengerEXT)handle; //This is highly dangerous -- I'm basically casting VkDebugUtilsMessengerEXT* to VkDebugUtilsMessengerEXT. I should do *((VkDebugUtilsMessengerEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkDebugUtilsMessengerEXT)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkVideoSessionKHR_to_server_VkVideoSessionKHR;
            std::map<uintptr_t,uintptr_t> server_VkVideoSessionKHR_to_client_VkVideoSessionKHR;
            
        #endif
        

        void serialize_VkVideoSessionKHR(boost::json::value& json, const VkVideoSessionKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkVideoSessionKHR_to_server_VkVideoSessionKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkVideoSessionKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkVideoSessionKHR %p...\n",(VkVideoSessionKHR)client_VkVideoSessionKHR_to_server_VkVideoSessionKHR[(uintptr_t)data]);
                    result=client_VkVideoSessionKHR_to_server_VkVideoSessionKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkVideoSessionKHR(boost::json::value& json, VkVideoSessionKHR& member){
                VkVideoSessionKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkVideoSessionKHR)data);
                    if (server_VkVideoSessionKHR_to_client_VkVideoSessionKHR.contains(data)){
                        result=(VkVideoSessionKHR)server_VkVideoSessionKHR_to_client_VkVideoSessionKHR[data];
                        debug_printf("Deserializing to VkVideoSessionKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkVideoSessionKHR));
                        debug_printf("Mapping to VkVideoSessionKHR %p...\n",handle);
                        server_VkVideoSessionKHR_to_client_VkVideoSessionKHR[data]=(uintptr_t)handle;
                        client_VkVideoSessionKHR_to_server_VkVideoSessionKHR[(uintptr_t)handle]=data;
                        
                        result=(VkVideoSessionKHR)handle; //This is highly dangerous -- I'm basically casting VkVideoSessionKHR* to VkVideoSessionKHR. I should do *((VkVideoSessionKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkVideoSessionKHR)data;
                #endif
                
                member=result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR;
            std::map<uintptr_t,uintptr_t> server_VkVideoSessionParametersKHR_to_client_VkVideoSessionParametersKHR;
            
        #endif
        

        void serialize_VkVideoSessionParametersKHR(boost::json::value& json, const VkVideoSessionParametersKHR& data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkVideoSessionParametersKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkVideoSessionParametersKHR %p...\n",(VkVideoSessionParametersKHR)client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR[(uintptr_t)data]);
                    result=client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            json=result;
        }
       

          void deserialize_VkVideoSessionParametersKHR(boost::json::value& json, VkVideoSessionParametersKHR& member){
                VkVideoSessionParametersKHR result;
                auto data=value_to<uintptr_t>(json);
                
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkVideoSessionParametersKHR)data);
                    if (server_VkVideoSessionParametersKHR_to_client_VkVideoSessionParametersKHR.contains(data)){
                        result=(VkVideoSessionParametersKHR)server_VkVideoSessionParametersKHR_to_client_VkVideoSessionParametersKHR[data];
                        debug_printf("Deserializing to VkVideoSessionParametersKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkVideoSessionParametersKHR));
                        debug_printf("Mapping to VkVideoSessionParametersKHR %p...\n",handle);
                        server_VkVideoSessionParametersKHR_to_client_VkVideoSessionParametersKHR[data]=(uintptr_t)handle;
                        client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR[(uintptr_t)handle]=data;
                        
                        result=(VkVideoSessionParametersKHR)handle; //This is highly dangerous -- I'm basically casting VkVideoSessionParametersKHR* to VkVideoSessionParametersKHR. I should do *((VkVideoSessionParametersKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkVideoSessionParametersKHR)data;
                #endif
                
                member=result;
       }
